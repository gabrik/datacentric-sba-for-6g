//! Main binary entry point for nsfm_pdusession implementation.

#![allow(missing_docs)]

use std::str::FromStr;

use clap::Parser;
use url::Url;

mod server;

#[derive(Parser)]
pub struct Opts {
    // public options
    #[clap(short = 'l', long, default_value = "http://127.0.0.1:8082")]
    pub listen: String,
    #[clap(short = 'n', long, default_value = "http://127.0.0.1:8080")]
    pub nrf: String,
    #[clap(short = 'u', long, default_value = "http://127.0.0.1:8081")]
    pub udm: String,
    #[clap(short = 'u', long, default_value = "http://127.0.0.1:8083")]
    pub amf: String,
}

/// Create custom server, wire it to the autogenerated router,
/// and pass it to the web server.
#[tokio::main]
async fn main() {
    env_logger::init();
    let opts = Opts::parse();

    let base_url = Url::parse(&opts.listen).unwrap();
    let is_https = if base_url.scheme() == "https" {
        true
    } else {
        false
    };

    server::create(
        &format!(
            "{}:{}",
            base_url.host_str().unwrap(),
            base_url.port().unwrap()
        ),
        is_https,
        url::Url::from_str(&opts.nrf).expect("unable to create url"),
        url::Url::from_str(&opts.udm).expect("unable to create url"),
        url::Url::from_str(&opts.amf).expect("unable to create url"),
    )
    .await;
}
