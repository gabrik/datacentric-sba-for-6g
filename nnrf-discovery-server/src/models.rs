#![allow(unused_qualifications)]

use derive_more::Display;
use std::str::FromStr;

#[cfg(any(feature = "client", feature = "server"))]
use crate::header;
use crate::models;

/// Represents the information relative to an AAnF NF Instance.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AanfInfo {
    #[serde(rename = "routingIndicators")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub routing_indicators: Option<Vec<String>>,
}

impl AanfInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AanfInfo {
        AanfInfo {
            routing_indicators: None,
        }
    }
}

/// Converts the AanfInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AanfInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> =
            vec![self.routing_indicators.as_ref().map(|routing_indicators| {
                vec![
                    "routingIndicators".to_string(),
                    routing_indicators
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            })];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AanfInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AanfInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub routing_indicators: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AanfInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "routingIndicators" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AanfInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AanfInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AanfInfo {
            routing_indicators: intermediate_rep.routing_indicators.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AanfInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AanfInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AanfInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AanfInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AanfInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AanfInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AanfInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Error returned in the access token response message
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AccessTokenErr {
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "error")]
    pub error: String,

    #[serde(rename = "error_description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_description: Option<String>,

    #[serde(rename = "error_uri")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_uri: Option<String>,
}

impl AccessTokenErr {
    #[allow(clippy::new_without_default)]
    pub fn new(error: String) -> AccessTokenErr {
        AccessTokenErr {
            error,
            error_description: None,
            error_uri: None,
        }
    }
}

/// Converts the AccessTokenErr value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AccessTokenErr {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("error".to_string()),
            Some(self.error.to_string()),
            self.error_description.as_ref().map(|error_description| {
                vec![
                    "error_description".to_string(),
                    error_description.to_string(),
                ]
                .join(",")
            }),
            self.error_uri
                .as_ref()
                .map(|error_uri| vec!["error_uri".to_string(), error_uri.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AccessTokenErr value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AccessTokenErr {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub error: Vec<String>,
            pub error_description: Vec<String>,
            pub error_uri: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AccessTokenErr".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "error" => intermediate_rep.error.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "error_description" => intermediate_rep.error_description.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "error_uri" => intermediate_rep.error_uri.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AccessTokenErr".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AccessTokenErr {
            error: intermediate_rep
                .error
                .into_iter()
                .next()
                .ok_or_else(|| "error missing in AccessTokenErr".to_string())?,
            error_description: intermediate_rep.error_description.into_iter().next(),
            error_uri: intermediate_rep.error_uri.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AccessTokenErr> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AccessTokenErr>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AccessTokenErr>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AccessTokenErr - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AccessTokenErr> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AccessTokenErr as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AccessTokenErr - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains information related to the access token request
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AccessTokenReq {
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "grant_type")]
    pub grant_type: String,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "nfInstanceId")]
    pub nf_instance_id: uuid::Uuid,

    #[serde(rename = "nfType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nf_type: Option<models::NfType>,

    #[serde(rename = "targetNfType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_nf_type: Option<models::NfType>,

    #[serde(rename = "scope")]
    pub scope: String,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "targetNfInstanceId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_nf_instance_id: Option<uuid::Uuid>,

    #[serde(rename = "requesterPlmn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requester_plmn: Option<models::PlmnId>,

    #[serde(rename = "requesterPlmnList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requester_plmn_list: Option<Vec<models::PlmnId>>,

    #[serde(rename = "requesterSnssaiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requester_snssai_list: Option<Vec<models::Snssai>>,

    /// Fully Qualified Domain Name
    #[serde(rename = "requesterFqdn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requester_fqdn: Option<String>,

    #[serde(rename = "requesterSnpnList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requester_snpn_list: Option<Vec<models::PlmnIdNid>>,

    #[serde(rename = "targetPlmn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_plmn: Option<models::PlmnId>,

    #[serde(rename = "targetSnpn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_snpn: Option<models::PlmnIdNid>,

    #[serde(rename = "targetSnssaiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_snssai_list: Option<Vec<models::Snssai>>,

    #[serde(rename = "targetNsiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_nsi_list: Option<Vec<String>>,

    /// NF Set Identifier (see clause 28.12 of 3GPP TS 23.003), formatted as the following string \"set<Set ID>.<nftype>set.5gc.mnc<MNC>.mcc<MCC>\", or  \"set<SetID>.<NFType>set.5gc.nid<NID>.mnc<MNC>.mcc<MCC>\" with  <MCC> encoded as defined in clause 5.4.2 (\"Mcc\" data type definition)  <MNC> encoding the Mobile Network Code part of the PLMN, comprising 3 digits.    If there are only 2 significant digits in the MNC, one \"0\" digit shall be inserted    at the left side to fill the 3 digits coding of MNC.  Pattern: '^[0-9]{3}$' <NFType> encoded as a value defined in Table 6.1.6.3.3-1 of 3GPP TS 29.510 but    with lower case characters <Set ID> encoded as a string of characters consisting of    alphabetic characters (A-Z and a-z), digits (0-9) and/or the hyphen (-) and that    shall end with either an alphabetic character or a digit.
    #[serde(rename = "targetNfSetId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_nf_set_id: Option<String>,

    /// NF Service Set Identifier (see clause 28.12 of 3GPP TS 23.003) formatted as the following  string \"set<Set ID>.sn<Service Name>.nfi<NF Instance ID>.5gc.mnc<MNC>.mcc<MCC>\", or  \"set<SetID>.sn<ServiceName>.nfi<NFInstanceID>.5gc.nid<NID>.mnc<MNC>.mcc<MCC>\" with  <MCC> encoded as defined in clause 5.4.2 (\"Mcc\" data type definition)   <MNC> encoding the Mobile Network Code part of the PLMN, comprising 3 digits.    If there are only 2 significant digits in the MNC, one \"0\" digit shall be inserted    at the left side to fill the 3 digits coding of MNC.  Pattern: '^[0-9]{3}$' <NID> encoded as defined in clauseÂ 5.4.2 (\"Nid\" data type definition)  <NFInstanceId> encoded as defined in clause 5.3.2  <ServiceName> encoded as defined in 3GPP TS 29.510  <Set ID> encoded as a string of characters consisting of alphabetic    characters (A-Z and a-z), digits (0-9) and/or the hyphen (-) and that shall end    with either an alphabetic character or a digit.
    #[serde(rename = "targetNfServiceSetId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_nf_service_set_id: Option<String>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "hnrfAccessTokenUri")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hnrf_access_token_uri: Option<String>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "sourceNfInstanceId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source_nf_instance_id: Option<uuid::Uuid>,
}

impl AccessTokenReq {
    #[allow(clippy::new_without_default)]
    pub fn new(grant_type: String, nf_instance_id: uuid::Uuid, scope: String) -> AccessTokenReq {
        AccessTokenReq {
            grant_type,
            nf_instance_id,
            nf_type: None,
            target_nf_type: None,
            scope,
            target_nf_instance_id: None,
            requester_plmn: None,
            requester_plmn_list: None,
            requester_snssai_list: None,
            requester_fqdn: None,
            requester_snpn_list: None,
            target_plmn: None,
            target_snpn: None,
            target_snssai_list: None,
            target_nsi_list: None,
            target_nf_set_id: None,
            target_nf_service_set_id: None,
            hnrf_access_token_uri: None,
            source_nf_instance_id: None,
        }
    }
}

/// Converts the AccessTokenReq value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AccessTokenReq {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("grant_type".to_string()),
            Some(self.grant_type.to_string()),
            // Skipping nfInstanceId in query parameter serialization

            // Skipping nfType in query parameter serialization

            // Skipping targetNfType in query parameter serialization
            Some("scope".to_string()),
            Some(self.scope.to_string()),
            // Skipping targetNfInstanceId in query parameter serialization

            // Skipping requesterPlmn in query parameter serialization

            // Skipping requesterPlmnList in query parameter serialization

            // Skipping requesterSnssaiList in query parameter serialization
            self.requester_fqdn.as_ref().map(|requester_fqdn| {
                vec!["requesterFqdn".to_string(), requester_fqdn.to_string()].join(",")
            }),
            // Skipping requesterSnpnList in query parameter serialization

            // Skipping targetPlmn in query parameter serialization

            // Skipping targetSnpn in query parameter serialization

            // Skipping targetSnssaiList in query parameter serialization
            self.target_nsi_list.as_ref().map(|target_nsi_list| {
                vec![
                    "targetNsiList".to_string(),
                    target_nsi_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.target_nf_set_id.as_ref().map(|target_nf_set_id| {
                vec!["targetNfSetId".to_string(), target_nf_set_id.to_string()].join(",")
            }),
            self.target_nf_service_set_id
                .as_ref()
                .map(|target_nf_service_set_id| {
                    vec![
                        "targetNfServiceSetId".to_string(),
                        target_nf_service_set_id.to_string(),
                    ]
                    .join(",")
                }),
            self.hnrf_access_token_uri
                .as_ref()
                .map(|hnrf_access_token_uri| {
                    vec![
                        "hnrfAccessTokenUri".to_string(),
                        hnrf_access_token_uri.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping sourceNfInstanceId in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AccessTokenReq value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AccessTokenReq {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub grant_type: Vec<String>,
            pub nf_instance_id: Vec<uuid::Uuid>,
            pub nf_type: Vec<models::NfType>,
            pub target_nf_type: Vec<models::NfType>,
            pub scope: Vec<String>,
            pub target_nf_instance_id: Vec<uuid::Uuid>,
            pub requester_plmn: Vec<models::PlmnId>,
            pub requester_plmn_list: Vec<Vec<models::PlmnId>>,
            pub requester_snssai_list: Vec<Vec<models::Snssai>>,
            pub requester_fqdn: Vec<String>,
            pub requester_snpn_list: Vec<Vec<models::PlmnIdNid>>,
            pub target_plmn: Vec<models::PlmnId>,
            pub target_snpn: Vec<models::PlmnIdNid>,
            pub target_snssai_list: Vec<Vec<models::Snssai>>,
            pub target_nsi_list: Vec<Vec<String>>,
            pub target_nf_set_id: Vec<String>,
            pub target_nf_service_set_id: Vec<String>,
            pub hnrf_access_token_uri: Vec<String>,
            pub source_nf_instance_id: Vec<uuid::Uuid>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AccessTokenReq".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "grant_type" => intermediate_rep.grant_type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nfInstanceId" => intermediate_rep.nf_instance_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nfType" => intermediate_rep.nf_type.push(
                        <models::NfType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "targetNfType" => intermediate_rep.target_nf_type.push(
                        <models::NfType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "scope" => intermediate_rep.scope.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "targetNfInstanceId" => intermediate_rep.target_nf_instance_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "requesterPlmn" => intermediate_rep.requester_plmn.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "requesterPlmnList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AccessTokenReq"
                                .to_string(),
                        )
                    }
                    "requesterSnssaiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AccessTokenReq"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "requesterFqdn" => intermediate_rep.requester_fqdn.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "requesterSnpnList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AccessTokenReq"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "targetPlmn" => intermediate_rep.target_plmn.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "targetSnpn" => intermediate_rep.target_snpn.push(
                        <models::PlmnIdNid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "targetSnssaiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AccessTokenReq"
                                .to_string(),
                        )
                    }
                    "targetNsiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AccessTokenReq"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "targetNfSetId" => intermediate_rep.target_nf_set_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "targetNfServiceSetId" => intermediate_rep.target_nf_service_set_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "hnrfAccessTokenUri" => intermediate_rep.hnrf_access_token_uri.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "sourceNfInstanceId" => intermediate_rep.source_nf_instance_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AccessTokenReq".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AccessTokenReq {
            grant_type: intermediate_rep
                .grant_type
                .into_iter()
                .next()
                .ok_or_else(|| "grant_type missing in AccessTokenReq".to_string())?,
            nf_instance_id: intermediate_rep
                .nf_instance_id
                .into_iter()
                .next()
                .ok_or_else(|| "nfInstanceId missing in AccessTokenReq".to_string())?,
            nf_type: intermediate_rep.nf_type.into_iter().next(),
            target_nf_type: intermediate_rep.target_nf_type.into_iter().next(),
            scope: intermediate_rep
                .scope
                .into_iter()
                .next()
                .ok_or_else(|| "scope missing in AccessTokenReq".to_string())?,
            target_nf_instance_id: intermediate_rep.target_nf_instance_id.into_iter().next(),
            requester_plmn: intermediate_rep.requester_plmn.into_iter().next(),
            requester_plmn_list: intermediate_rep.requester_plmn_list.into_iter().next(),
            requester_snssai_list: intermediate_rep.requester_snssai_list.into_iter().next(),
            requester_fqdn: intermediate_rep.requester_fqdn.into_iter().next(),
            requester_snpn_list: intermediate_rep.requester_snpn_list.into_iter().next(),
            target_plmn: intermediate_rep.target_plmn.into_iter().next(),
            target_snpn: intermediate_rep.target_snpn.into_iter().next(),
            target_snssai_list: intermediate_rep.target_snssai_list.into_iter().next(),
            target_nsi_list: intermediate_rep.target_nsi_list.into_iter().next(),
            target_nf_set_id: intermediate_rep.target_nf_set_id.into_iter().next(),
            target_nf_service_set_id: intermediate_rep.target_nf_service_set_id.into_iter().next(),
            hnrf_access_token_uri: intermediate_rep.hnrf_access_token_uri.into_iter().next(),
            source_nf_instance_id: intermediate_rep.source_nf_instance_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AccessTokenReq> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AccessTokenReq>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AccessTokenReq>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AccessTokenReq - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AccessTokenReq> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AccessTokenReq as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AccessTokenReq - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Indicates whether the access is  via 3GPP or via non-3GPP.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum AccessType {
    #[serde(rename = "3GPP_ACCESS")]
    Variant3GppAccess,
    #[serde(rename = "NON_3GPP_ACCESS")]
    Non3GppAccess,
}

impl std::fmt::Display for AccessType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            AccessType::Variant3GppAccess => write!(f, "3GPP_ACCESS"),
            AccessType::Non3GppAccess => write!(f, "NON_3GPP_ACCESS"),
        }
    }
}

impl std::str::FromStr for AccessType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "3GPP_ACCESS" => std::result::Result::Ok(AccessType::Variant3GppAccess),
            "NON_3GPP_ACCESS" => std::result::Result::Ok(AccessType::Non3GppAccess),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Represents Application Events.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AfEvent {}

impl AfEvent {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AfEvent {
        AfEvent {}
    }
}

/// Converts the AfEvent value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AfEvent {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AfEvent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AfEvent {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AfEvent".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AfEvent".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AfEvent {})
    }
}

// Methods for converting between header::IntoHeaderValue<AfEvent> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AfEvent>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AfEvent>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AfEvent - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AfEvent> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AfEvent as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AfEvent - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum AfEventAnyOf {
    #[serde(rename = "SVC_EXPERIENCE")]
    SvcExperience,
    #[serde(rename = "UE_MOBILITY")]
    UeMobility,
    #[serde(rename = "UE_COMM")]
    UeComm,
    #[serde(rename = "EXCEPTIONS")]
    Exceptions,
    #[serde(rename = "USER_DATA_CONGESTION")]
    UserDataCongestion,
    #[serde(rename = "PERF_DATA")]
    PerfData,
    #[serde(rename = "DISPERSION")]
    Dispersion,
    #[serde(rename = "COLLECTIVE_BEHAVIOUR")]
    CollectiveBehaviour,
    #[serde(rename = "MS_QOE_METRICS")]
    MsQoeMetrics,
    #[serde(rename = "MS_CONSUMPTION")]
    MsConsumption,
    #[serde(rename = "MS_NET_ASSIST_INVOCATION")]
    MsNetAssistInvocation,
    #[serde(rename = "MS_DYN_POLICY_INVOCATION")]
    MsDynPolicyInvocation,
    #[serde(rename = "MS_ACCESS_ACTIVITY")]
    MsAccessActivity,
}

impl std::fmt::Display for AfEventAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            AfEventAnyOf::SvcExperience => write!(f, "SVC_EXPERIENCE"),
            AfEventAnyOf::UeMobility => write!(f, "UE_MOBILITY"),
            AfEventAnyOf::UeComm => write!(f, "UE_COMM"),
            AfEventAnyOf::Exceptions => write!(f, "EXCEPTIONS"),
            AfEventAnyOf::UserDataCongestion => write!(f, "USER_DATA_CONGESTION"),
            AfEventAnyOf::PerfData => write!(f, "PERF_DATA"),
            AfEventAnyOf::Dispersion => write!(f, "DISPERSION"),
            AfEventAnyOf::CollectiveBehaviour => write!(f, "COLLECTIVE_BEHAVIOUR"),
            AfEventAnyOf::MsQoeMetrics => write!(f, "MS_QOE_METRICS"),
            AfEventAnyOf::MsConsumption => write!(f, "MS_CONSUMPTION"),
            AfEventAnyOf::MsNetAssistInvocation => write!(f, "MS_NET_ASSIST_INVOCATION"),
            AfEventAnyOf::MsDynPolicyInvocation => write!(f, "MS_DYN_POLICY_INVOCATION"),
            AfEventAnyOf::MsAccessActivity => write!(f, "MS_ACCESS_ACTIVITY"),
        }
    }
}

impl std::str::FromStr for AfEventAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "SVC_EXPERIENCE" => std::result::Result::Ok(AfEventAnyOf::SvcExperience),
            "UE_MOBILITY" => std::result::Result::Ok(AfEventAnyOf::UeMobility),
            "UE_COMM" => std::result::Result::Ok(AfEventAnyOf::UeComm),
            "EXCEPTIONS" => std::result::Result::Ok(AfEventAnyOf::Exceptions),
            "USER_DATA_CONGESTION" => std::result::Result::Ok(AfEventAnyOf::UserDataCongestion),
            "PERF_DATA" => std::result::Result::Ok(AfEventAnyOf::PerfData),
            "DISPERSION" => std::result::Result::Ok(AfEventAnyOf::Dispersion),
            "COLLECTIVE_BEHAVIOUR" => std::result::Result::Ok(AfEventAnyOf::CollectiveBehaviour),
            "MS_QOE_METRICS" => std::result::Result::Ok(AfEventAnyOf::MsQoeMetrics),
            "MS_CONSUMPTION" => std::result::Result::Ok(AfEventAnyOf::MsConsumption),
            "MS_NET_ASSIST_INVOCATION" => {
                std::result::Result::Ok(AfEventAnyOf::MsNetAssistInvocation)
            }
            "MS_DYN_POLICY_INVOCATION" => {
                std::result::Result::Ok(AfEventAnyOf::MsDynPolicyInvocation)
            }
            "MS_ACCESS_ACTIVITY" => std::result::Result::Ok(AfEventAnyOf::MsAccessActivity),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// AF Event Exposure data managed by a given NEF Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AfEventExposureData {
    #[serde(rename = "afEvents")]
    pub af_events: Vec<models::AfEvent>,

    #[serde(rename = "afIds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub af_ids: Option<Vec<String>>,

    #[serde(rename = "appIds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub app_ids: Option<Vec<String>>,
}

impl AfEventExposureData {
    #[allow(clippy::new_without_default)]
    pub fn new(af_events: Vec<models::AfEvent>) -> AfEventExposureData {
        AfEventExposureData {
            af_events,
            af_ids: None,
            app_ids: None,
        }
    }
}

/// Converts the AfEventExposureData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AfEventExposureData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping afEvents in query parameter serialization
            self.af_ids.as_ref().map(|af_ids| {
                vec![
                    "afIds".to_string(),
                    af_ids
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.app_ids.as_ref().map(|app_ids| {
                vec![
                    "appIds".to_string(),
                    app_ids
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AfEventExposureData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AfEventExposureData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub af_events: Vec<Vec<models::AfEvent>>,
            pub af_ids: Vec<Vec<String>>,
            pub app_ids: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AfEventExposureData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "afEvents" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in AfEventExposureData"
                            .to_string(),
                    ),
                    "afIds" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in AfEventExposureData"
                            .to_string(),
                    ),
                    "appIds" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in AfEventExposureData"
                            .to_string(),
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AfEventExposureData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AfEventExposureData {
            af_events: intermediate_rep
                .af_events
                .into_iter()
                .next()
                .ok_or_else(|| "afEvents missing in AfEventExposureData".to_string())?,
            af_ids: intermediate_rep.af_ids.into_iter().next(),
            app_ids: intermediate_rep.app_ids.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AfEventExposureData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AfEventExposureData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AfEventExposureData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AfEventExposureData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<AfEventExposureData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AfEventExposureData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AfEventExposureData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// String identifying the AMF ID composed of AMF Region ID (8 bits), AMF Set ID (10 bits) and AMF  Pointer (6 bits) as specified in clause 2.10.1 of 3GPP TS 23.003. It is encoded as a string of  6 hexadecimal characters (i.e., 24 bits).
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AmfId(String);

impl std::convert::From<String> for AmfId {
    fn from(x: String) -> Self {
        AmfId(x)
    }
}

impl std::string::ToString for AmfId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for AmfId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(AmfId(x.to_string()))
    }
}

impl std::convert::From<AmfId> for String {
    fn from(x: AmfId) -> Self {
        x.0
    }
}

impl std::ops::Deref for AmfId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for AmfId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Information of an AMF NF Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AmfInfo {
    /// String identifying the AMF Set ID (10 bits) as specified in clause 2.10.1 of 3GPP TS 23.003.  It is encoded as a string of 3 hexadecimal characters where the first character is limited to  values 0 to 3 (i.e. 10 bits).
    #[serde(rename = "amfSetId")]
    pub amf_set_id: String,

    /// String identifying the AMF Set ID (10 bits) as specified in clause 2.10.1 of 3GPP TS 23.003.  It is encoded as a string of 3 hexadecimal characters where the first character is limited to  values 0 to 3 (i.e. 10 bits)
    #[serde(rename = "amfRegionId")]
    pub amf_region_id: String,

    #[serde(rename = "guamiList")]
    pub guami_list: Vec<models::Guami>,

    #[serde(rename = "taiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tai_list: Option<Vec<models::Tai>>,

    #[serde(rename = "taiRangeList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tai_range_list: Option<Vec<models::TaiRange>>,

    #[serde(rename = "backupInfoAmfFailure")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub backup_info_amf_failure: Option<Vec<models::Guami>>,

    #[serde(rename = "backupInfoAmfRemoval")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub backup_info_amf_removal: Option<Vec<models::Guami>>,

    #[serde(rename = "n2InterfaceAmfInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n2_interface_amf_info: Option<models::N2InterfaceAmfInfo>,

    #[serde(rename = "amfOnboardingCapability")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub amf_onboarding_capability: Option<bool>,
}

impl AmfInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(
        amf_set_id: String,
        amf_region_id: String,
        guami_list: Vec<models::Guami>,
    ) -> AmfInfo {
        AmfInfo {
            amf_set_id,
            amf_region_id,
            guami_list,
            tai_list: None,
            tai_range_list: None,
            backup_info_amf_failure: None,
            backup_info_amf_removal: None,
            n2_interface_amf_info: None,
            amf_onboarding_capability: Some(false),
        }
    }
}

/// Converts the AmfInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AmfInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("amfSetId".to_string()),
            Some(self.amf_set_id.to_string()),
            Some("amfRegionId".to_string()),
            Some(self.amf_region_id.to_string()),
            // Skipping guamiList in query parameter serialization

            // Skipping taiList in query parameter serialization

            // Skipping taiRangeList in query parameter serialization

            // Skipping backupInfoAmfFailure in query parameter serialization

            // Skipping backupInfoAmfRemoval in query parameter serialization

            // Skipping n2InterfaceAmfInfo in query parameter serialization
            self.amf_onboarding_capability
                .as_ref()
                .map(|amf_onboarding_capability| {
                    vec![
                        "amfOnboardingCapability".to_string(),
                        amf_onboarding_capability.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AmfInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AmfInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub amf_set_id: Vec<String>,
            pub amf_region_id: Vec<String>,
            pub guami_list: Vec<Vec<models::Guami>>,
            pub tai_list: Vec<Vec<models::Tai>>,
            pub tai_range_list: Vec<Vec<models::TaiRange>>,
            pub backup_info_amf_failure: Vec<Vec<models::Guami>>,
            pub backup_info_amf_removal: Vec<Vec<models::Guami>>,
            pub n2_interface_amf_info: Vec<models::N2InterfaceAmfInfo>,
            pub amf_onboarding_capability: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AmfInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "amfSetId" => intermediate_rep.amf_set_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "amfRegionId" => intermediate_rep.amf_region_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "guamiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AmfInfo"
                                .to_string(),
                        )
                    }
                    "taiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AmfInfo"
                                .to_string(),
                        )
                    }
                    "taiRangeList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AmfInfo"
                                .to_string(),
                        )
                    }
                    "backupInfoAmfFailure" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AmfInfo"
                                .to_string(),
                        )
                    }
                    "backupInfoAmfRemoval" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AmfInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "n2InterfaceAmfInfo" => intermediate_rep.n2_interface_amf_info.push(
                        <models::N2InterfaceAmfInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "amfOnboardingCapability" => intermediate_rep.amf_onboarding_capability.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AmfInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AmfInfo {
            amf_set_id: intermediate_rep
                .amf_set_id
                .into_iter()
                .next()
                .ok_or_else(|| "amfSetId missing in AmfInfo".to_string())?,
            amf_region_id: intermediate_rep
                .amf_region_id
                .into_iter()
                .next()
                .ok_or_else(|| "amfRegionId missing in AmfInfo".to_string())?,
            guami_list: intermediate_rep
                .guami_list
                .into_iter()
                .next()
                .ok_or_else(|| "guamiList missing in AmfInfo".to_string())?,
            tai_list: intermediate_rep.tai_list.into_iter().next(),
            tai_range_list: intermediate_rep.tai_range_list.into_iter().next(),
            backup_info_amf_failure: intermediate_rep.backup_info_amf_failure.into_iter().next(),
            backup_info_amf_removal: intermediate_rep.backup_info_amf_removal.into_iter().next(),
            n2_interface_amf_info: intermediate_rep.n2_interface_amf_info.into_iter().next(),
            amf_onboarding_capability: intermediate_rep
                .amf_onboarding_capability
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AmfInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AmfInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AmfInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AmfInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AmfInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AmfInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AmfInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Fully Qualified Domain Name
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AmfName {}

impl AmfName {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AmfName {
        AmfName {}
    }
}

/// Converts the AmfName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AmfName {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AmfName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AmfName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AmfName".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AmfName".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AmfName {})
    }
}

// Methods for converting between header::IntoHeaderValue<AmfName> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AmfName>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AmfName>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AmfName - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AmfName> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AmfName as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AmfName - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// String identifying the AMF Set ID (10 bits) as specified in clause 2.10.1 of 3GPP TS 23.003.  It is encoded as a string of 3 hexadecimal characters where the first character is limited to  values 0 to 3 (i.e. 10 bits)
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AmfRegionId(String);

impl std::convert::From<String> for AmfRegionId {
    fn from(x: String) -> Self {
        AmfRegionId(x)
    }
}

impl std::string::ToString for AmfRegionId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for AmfRegionId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(AmfRegionId(x.to_string()))
    }
}

impl std::convert::From<AmfRegionId> for String {
    fn from(x: AmfRegionId) -> Self {
        x.0
    }
}

impl std::ops::Deref for AmfRegionId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for AmfRegionId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// String identifying the AMF Set ID (10 bits) as specified in clause 2.10.1 of 3GPP TS 23.003.  It is encoded as a string of 3 hexadecimal characters where the first character is limited to  values 0 to 3 (i.e. 10 bits).
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AmfSetId(String);

impl std::convert::From<String> for AmfSetId {
    fn from(x: String) -> Self {
        AmfSetId(x)
    }
}

impl std::string::ToString for AmfSetId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for AmfSetId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(AmfSetId(x.to_string()))
    }
}

impl std::convert::From<AmfSetId> for String {
    fn from(x: AmfSetId) -> Self {
        x.0
    }
}

impl std::ops::Deref for AmfSetId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for AmfSetId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Access Network Node Type (gNB, ng-eNB...)
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AnNodeType {}

impl AnNodeType {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AnNodeType {
        AnNodeType {}
    }
}

/// Converts the AnNodeType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AnNodeType {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AnNodeType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AnNodeType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AnNodeType".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AnNodeType".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AnNodeType {})
    }
}

// Methods for converting between header::IntoHeaderValue<AnNodeType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AnNodeType>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AnNodeType>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AnNodeType - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AnNodeType> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AnNodeType as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AnNodeType - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum AnNodeTypeAnyOf {
    #[serde(rename = "GNB")]
    Gnb,
    #[serde(rename = "NG_ENB")]
    NgEnb,
}

impl std::fmt::Display for AnNodeTypeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            AnNodeTypeAnyOf::Gnb => write!(f, "GNB"),
            AnNodeTypeAnyOf::NgEnb => write!(f, "NG_ENB"),
        }
    }
}

impl std::str::FromStr for AnNodeTypeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "GNB" => std::result::Result::Ok(AnNodeTypeAnyOf::Gnb),
            "NG_ENB" => std::result::Result::Ok(AnNodeTypeAnyOf::NgEnb),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Integer where the allowed values correspond to the value range of an unsigned 16-bit integer.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AreaSessionId {}

impl AreaSessionId {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AreaSessionId {
        AreaSessionId {}
    }
}

/// Converts the AreaSessionId value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AreaSessionId {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AreaSessionId value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AreaSessionId {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AreaSessionId".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AreaSessionId".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AreaSessionId {})
    }
}

// Methods for converting between header::IntoHeaderValue<AreaSessionId> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AreaSessionId>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AreaSessionId>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AreaSessionId - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AreaSessionId> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AreaSessionId as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AreaSessionId - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// contains a search parameter and its positive or negative content.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Atom {
    /// contains the name of a defined query parameter.
    #[serde(rename = "attr")]
    pub attr: String,

    #[serde(rename = "value")]
    pub value: serde_json::Value,

    /// indicates whether the negative condition applies for the query condition.
    #[serde(rename = "negative")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub negative: Option<bool>,
}

impl Atom {
    #[allow(clippy::new_without_default)]
    pub fn new(attr: String, value: serde_json::Value) -> Atom {
        Atom {
            attr,
            value,
            negative: None,
        }
    }
}

/// Converts the Atom value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Atom {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("attr".to_string()),
            Some(self.attr.to_string()),
            // Skipping value in query parameter serialization
            self.negative
                .as_ref()
                .map(|negative| vec!["negative".to_string(), negative.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Atom value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Atom {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub attr: Vec<String>,
            pub value: Vec<serde_json::Value>,
            pub negative: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err("Missing value while parsing Atom".to_string())
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "attr" => intermediate_rep.attr.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(
                        <serde_json::Value as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "negative" => intermediate_rep.negative.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Atom".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Atom {
            attr: intermediate_rep
                .attr
                .into_iter()
                .next()
                .ok_or_else(|| "attr missing in Atom".to_string())?,
            value: intermediate_rep
                .value
                .into_iter()
                .next()
                .ok_or_else(|| "value missing in Atom".to_string())?,
            negative: intermediate_rep.negative.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Atom> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Atom>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Atom>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Atom - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Atom> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Atom as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Atom - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Containes Capability to support procedures related to Access Traffic Steering, Switching, Splitting.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AtsssCapability {
    /// Indicates the ATSSS-LL capability to support procedures related to Access Traffic Steering, Switching, Splitting (see clauses 4.2.10, 5.32 of 3GPP TS 23.501). true: Supported false (default): Not Supported
    #[serde(rename = "atsssLL")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub atsss_ll: Option<bool>,

    /// Indicates the MPTCP capability to support procedures related to Access Traffic Steering, Switching, Splitting (see clauses 4.2.10, 5.32 of 3GPPÂ TSÂ 23.501 true: Supported false (default): Not Supported
    #[serde(rename = "mptcp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mptcp: Option<bool>,

    /// This IE is only used by the UPF to indicate whether the UPF supports RTT measurement without PMF (see clausesÂ 5.32.2, 6.3.3.3 of 3GPPÂ TSÂ 23.501 true: Supported false (default): Not Supported
    #[serde(rename = "rttWithoutPmf")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rtt_without_pmf: Option<bool>,
}

impl AtsssCapability {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AtsssCapability {
        AtsssCapability {
            atsss_ll: Some(false),
            mptcp: Some(false),
            rtt_without_pmf: Some(false),
        }
    }
}

/// Converts the AtsssCapability value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AtsssCapability {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.atsss_ll
                .as_ref()
                .map(|atsss_ll| vec!["atsssLL".to_string(), atsss_ll.to_string()].join(",")),
            self.mptcp
                .as_ref()
                .map(|mptcp| vec!["mptcp".to_string(), mptcp.to_string()].join(",")),
            self.rtt_without_pmf.as_ref().map(|rtt_without_pmf| {
                vec!["rttWithoutPmf".to_string(), rtt_without_pmf.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AtsssCapability value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AtsssCapability {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub atsss_ll: Vec<bool>,
            pub mptcp: Vec<bool>,
            pub rtt_without_pmf: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AtsssCapability".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "atsssLL" => intermediate_rep.atsss_ll.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "mptcp" => intermediate_rep.mptcp.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "rttWithoutPmf" => intermediate_rep.rtt_without_pmf.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AtsssCapability".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AtsssCapability {
            atsss_ll: intermediate_rep.atsss_ll.into_iter().next(),
            mptcp: intermediate_rep.mptcp.into_iter().next(),
            rtt_without_pmf: intermediate_rep.rtt_without_pmf.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AtsssCapability> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AtsssCapability>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AtsssCapability>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AtsssCapability - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<AtsssCapability>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AtsssCapability as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AtsssCapability - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Information of an AUSF NF Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AusfInfo {
    /// Identifier of a group of NFs.
    #[serde(rename = "groupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub group_id: Option<String>,

    #[serde(rename = "supiRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supi_ranges: Option<Vec<models::SupiRange>>,

    #[serde(rename = "routingIndicators")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub routing_indicators: Option<Vec<String>>,

    #[serde(rename = "suciInfos")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suci_infos: Option<Vec<models::SuciInfo>>,
}

impl AusfInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AusfInfo {
        AusfInfo {
            group_id: None,
            supi_ranges: None,
            routing_indicators: None,
            suci_infos: None,
        }
    }
}

/// Converts the AusfInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AusfInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.group_id
                .as_ref()
                .map(|group_id| vec!["groupId".to_string(), group_id.to_string()].join(",")),
            // Skipping supiRanges in query parameter serialization
            self.routing_indicators.as_ref().map(|routing_indicators| {
                vec![
                    "routingIndicators".to_string(),
                    routing_indicators
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping suciInfos in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AusfInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AusfInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub group_id: Vec<String>,
            pub supi_ranges: Vec<Vec<models::SupiRange>>,
            pub routing_indicators: Vec<Vec<String>>,
            pub suci_infos: Vec<Vec<models::SuciInfo>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AusfInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "groupId" => intermediate_rep.group_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "supiRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AusfInfo"
                                .to_string(),
                        )
                    }
                    "routingIndicators" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AusfInfo"
                                .to_string(),
                        )
                    }
                    "suciInfos" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AusfInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AusfInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AusfInfo {
            group_id: intermediate_rep.group_id.into_iter().next(),
            supi_ranges: intermediate_rep.supi_ranges.into_iter().next(),
            routing_indicators: intermediate_rep.routing_indicators.into_iter().next(),
            suci_infos: intermediate_rep.suci_infos.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AusfInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AusfInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AusfInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AusfInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AusfInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AusfInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AusfInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Information of a BSF NF Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BsfInfo {
    #[serde(rename = "dnnList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dnn_list: Option<Vec<models::Dnn>>,

    #[serde(rename = "ipDomainList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ip_domain_list: Option<Vec<String>>,

    #[serde(rename = "ipv4AddressRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv4_address_ranges: Option<Vec<models::Ipv4AddressRange>>,

    #[serde(rename = "ipv6PrefixRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_prefix_ranges: Option<Vec<models::Ipv6PrefixRange>>,

    /// Fully Qualified Domain Name
    #[serde(rename = "rxDiamHost")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rx_diam_host: Option<String>,

    /// Fully Qualified Domain Name
    #[serde(rename = "rxDiamRealm")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rx_diam_realm: Option<String>,

    /// Identifier of a group of NFs.
    #[serde(rename = "groupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub group_id: Option<String>,

    #[serde(rename = "supiRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supi_ranges: Option<Vec<models::SupiRange>>,

    #[serde(rename = "gpsiRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gpsi_ranges: Option<Vec<models::IdentityRange>>,
}

impl BsfInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> BsfInfo {
        BsfInfo {
            dnn_list: None,
            ip_domain_list: None,
            ipv4_address_ranges: None,
            ipv6_prefix_ranges: None,
            rx_diam_host: None,
            rx_diam_realm: None,
            group_id: None,
            supi_ranges: None,
            gpsi_ranges: None,
        }
    }
}

/// Converts the BsfInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for BsfInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.dnn_list.as_ref().map(|dnn_list| {
                vec![
                    "dnnList".to_string(),
                    dnn_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.ip_domain_list.as_ref().map(|ip_domain_list| {
                vec![
                    "ipDomainList".to_string(),
                    ip_domain_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping ipv4AddressRanges in query parameter serialization

            // Skipping ipv6PrefixRanges in query parameter serialization
            self.rx_diam_host.as_ref().map(|rx_diam_host| {
                vec!["rxDiamHost".to_string(), rx_diam_host.to_string()].join(",")
            }),
            self.rx_diam_realm.as_ref().map(|rx_diam_realm| {
                vec!["rxDiamRealm".to_string(), rx_diam_realm.to_string()].join(",")
            }),
            self.group_id
                .as_ref()
                .map(|group_id| vec!["groupId".to_string(), group_id.to_string()].join(",")),
            // Skipping supiRanges in query parameter serialization

            // Skipping gpsiRanges in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BsfInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BsfInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub dnn_list: Vec<Vec<models::Dnn>>,
            pub ip_domain_list: Vec<Vec<String>>,
            pub ipv4_address_ranges: Vec<Vec<models::Ipv4AddressRange>>,
            pub ipv6_prefix_ranges: Vec<Vec<models::Ipv6PrefixRange>>,
            pub rx_diam_host: Vec<String>,
            pub rx_diam_realm: Vec<String>,
            pub group_id: Vec<String>,
            pub supi_ranges: Vec<Vec<models::SupiRange>>,
            pub gpsi_ranges: Vec<Vec<models::IdentityRange>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing BsfInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "dnnList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in BsfInfo"
                                .to_string(),
                        )
                    }
                    "ipDomainList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in BsfInfo"
                                .to_string(),
                        )
                    }
                    "ipv4AddressRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in BsfInfo"
                                .to_string(),
                        )
                    }
                    "ipv6PrefixRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in BsfInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "rxDiamHost" => intermediate_rep.rx_diam_host.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "rxDiamRealm" => intermediate_rep.rx_diam_realm.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "groupId" => intermediate_rep.group_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "supiRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in BsfInfo"
                                .to_string(),
                        )
                    }
                    "gpsiRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in BsfInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing BsfInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BsfInfo {
            dnn_list: intermediate_rep.dnn_list.into_iter().next(),
            ip_domain_list: intermediate_rep.ip_domain_list.into_iter().next(),
            ipv4_address_ranges: intermediate_rep.ipv4_address_ranges.into_iter().next(),
            ipv6_prefix_ranges: intermediate_rep.ipv6_prefix_ranges.into_iter().next(),
            rx_diam_host: intermediate_rep.rx_diam_host.into_iter().next(),
            rx_diam_realm: intermediate_rep.rx_diam_realm.into_iter().next(),
            group_id: intermediate_rep.group_id.into_iter().next(),
            supi_ranges: intermediate_rep.supi_ranges.into_iter().next(),
            gpsi_ranges: intermediate_rep.gpsi_ranges.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BsfInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<BsfInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<BsfInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for BsfInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<BsfInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <BsfInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into BsfInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Information of a CHF NF Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChfInfo {
    #[serde(rename = "supiRangeList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supi_range_list: Option<Vec<models::SupiRange>>,

    #[serde(rename = "gpsiRangeList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gpsi_range_list: Option<Vec<models::IdentityRange>>,

    #[serde(rename = "plmnRangeList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub plmn_range_list: Option<Vec<models::PlmnRange>>,

    /// Identifier of a group of NFs.
    #[serde(rename = "groupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub group_id: Option<String>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "primaryChfInstance")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub primary_chf_instance: Option<uuid::Uuid>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "secondaryChfInstance")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub secondary_chf_instance: Option<uuid::Uuid>,
}

impl ChfInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ChfInfo {
        ChfInfo {
            supi_range_list: None,
            gpsi_range_list: None,
            plmn_range_list: None,
            group_id: None,
            primary_chf_instance: None,
            secondary_chf_instance: None,
        }
    }
}

/// Converts the ChfInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ChfInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping supiRangeList in query parameter serialization

            // Skipping gpsiRangeList in query parameter serialization

            // Skipping plmnRangeList in query parameter serialization
            self.group_id
                .as_ref()
                .map(|group_id| vec!["groupId".to_string(), group_id.to_string()].join(",")),
            // Skipping primaryChfInstance in query parameter serialization

            // Skipping secondaryChfInstance in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChfInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChfInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub supi_range_list: Vec<Vec<models::SupiRange>>,
            pub gpsi_range_list: Vec<Vec<models::IdentityRange>>,
            pub plmn_range_list: Vec<Vec<models::PlmnRange>>,
            pub group_id: Vec<String>,
            pub primary_chf_instance: Vec<uuid::Uuid>,
            pub secondary_chf_instance: Vec<uuid::Uuid>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ChfInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "supiRangeList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in ChfInfo"
                                .to_string(),
                        )
                    }
                    "gpsiRangeList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in ChfInfo"
                                .to_string(),
                        )
                    }
                    "plmnRangeList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in ChfInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "groupId" => intermediate_rep.group_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "primaryChfInstance" => intermediate_rep.primary_chf_instance.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "secondaryChfInstance" => intermediate_rep.secondary_chf_instance.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ChfInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChfInfo {
            supi_range_list: intermediate_rep.supi_range_list.into_iter().next(),
            gpsi_range_list: intermediate_rep.gpsi_range_list.into_iter().next(),
            plmn_range_list: intermediate_rep.plmn_range_list.into_iter().next(),
            group_id: intermediate_rep.group_id.into_iter().next(),
            primary_chf_instance: intermediate_rep.primary_chf_instance.into_iter().next(),
            secondary_chf_instance: intermediate_rep.secondary_chf_instance.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChfInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ChfInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ChfInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ChfInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ChfInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ChfInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ChfInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A conjunctive normal form
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Cnf {
    #[serde(rename = "cnfUnits")]
    pub cnf_units: Vec<models::CnfUnit>,
}

impl Cnf {
    #[allow(clippy::new_without_default)]
    pub fn new(cnf_units: Vec<models::CnfUnit>) -> Cnf {
        Cnf { cnf_units }
    }
}

/// Converts the Cnf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Cnf {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping cnfUnits in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Cnf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Cnf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cnf_units: Vec<Vec<models::CnfUnit>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err("Missing value while parsing Cnf".to_string())
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "cnfUnits" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Cnf".to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Cnf".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Cnf {
            cnf_units: intermediate_rep
                .cnf_units
                .into_iter()
                .next()
                .ok_or_else(|| "cnfUnits missing in Cnf".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Cnf> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Cnf>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Cnf>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Cnf - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Cnf> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Cnf as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Cnf - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// During the processing of cnfUnits attribute, all the members in the array shall be  interpreted as logically concatenated with logical \"AND\".
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CnfUnit {
    #[serde(rename = "cnfUnit")]
    pub cnf_unit: Vec<models::Atom>,
}

impl CnfUnit {
    #[allow(clippy::new_without_default)]
    pub fn new(cnf_unit: Vec<models::Atom>) -> CnfUnit {
        CnfUnit { cnf_unit }
    }
}

/// Converts the CnfUnit value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CnfUnit {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping cnfUnit in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CnfUnit value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CnfUnit {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cnf_unit: Vec<Vec<models::Atom>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing CnfUnit".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "cnfUnit" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in CnfUnit"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing CnfUnit".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CnfUnit {
            cnf_unit: intermediate_rep
                .cnf_unit
                .into_iter()
                .next()
                .ok_or_else(|| "cnfUnit missing in CnfUnit".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CnfUnit> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CnfUnit>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<CnfUnit>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for CnfUnit - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CnfUnit> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <CnfUnit as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into CnfUnit - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Information of an collocated NF Instance registered in the NRF
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CollocatedNfInstance {
    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "nfInstanceId")]
    pub nf_instance_id: uuid::Uuid,

    #[serde(rename = "nfType")]
    pub nf_type: models::CollocatedNfType,
}

impl CollocatedNfInstance {
    #[allow(clippy::new_without_default)]
    pub fn new(
        nf_instance_id: uuid::Uuid,
        nf_type: models::CollocatedNfType,
    ) -> CollocatedNfInstance {
        CollocatedNfInstance {
            nf_instance_id,
            nf_type,
        }
    }
}

/// Converts the CollocatedNfInstance value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CollocatedNfInstance {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping nfInstanceId in query parameter serialization

            // Skipping nfType in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CollocatedNfInstance value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CollocatedNfInstance {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub nf_instance_id: Vec<uuid::Uuid>,
            pub nf_type: Vec<models::CollocatedNfType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing CollocatedNfInstance".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "nfInstanceId" => intermediate_rep.nf_instance_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nfType" => intermediate_rep.nf_type.push(
                        <models::CollocatedNfType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing CollocatedNfInstance".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CollocatedNfInstance {
            nf_instance_id: intermediate_rep
                .nf_instance_id
                .into_iter()
                .next()
                .ok_or_else(|| "nfInstanceId missing in CollocatedNfInstance".to_string())?,
            nf_type: intermediate_rep
                .nf_type
                .into_iter()
                .next()
                .ok_or_else(|| "nfType missing in CollocatedNfInstance".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CollocatedNfInstance> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CollocatedNfInstance>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<CollocatedNfInstance>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for CollocatedNfInstance - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<CollocatedNfInstance>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <CollocatedNfInstance as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into CollocatedNfInstance - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// NF types for a collocated NF
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CollocatedNfType {}

impl CollocatedNfType {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CollocatedNfType {
        CollocatedNfType {}
    }
}

/// Converts the CollocatedNfType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CollocatedNfType {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CollocatedNfType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CollocatedNfType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing CollocatedNfType".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing CollocatedNfType".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CollocatedNfType {})
    }
}

// Methods for converting between header::IntoHeaderValue<CollocatedNfType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CollocatedNfType>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<CollocatedNfType>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for CollocatedNfType - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<CollocatedNfType>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <CollocatedNfType as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into CollocatedNfType - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum CollocatedNfTypeAnyOf {
    #[serde(rename = "UPF")]
    Upf,
    #[serde(rename = "SMF")]
    Smf,
    #[serde(rename = "MB_UPF")]
    MbUpf,
    #[serde(rename = "MB_SMF")]
    MbSmf,
}

impl std::fmt::Display for CollocatedNfTypeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            CollocatedNfTypeAnyOf::Upf => write!(f, "UPF"),
            CollocatedNfTypeAnyOf::Smf => write!(f, "SMF"),
            CollocatedNfTypeAnyOf::MbUpf => write!(f, "MB_UPF"),
            CollocatedNfTypeAnyOf::MbSmf => write!(f, "MB_SMF"),
        }
    }
}

impl std::str::FromStr for CollocatedNfTypeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "UPF" => std::result::Result::Ok(CollocatedNfTypeAnyOf::Upf),
            "SMF" => std::result::Result::Ok(CollocatedNfTypeAnyOf::Smf),
            "MB_UPF" => std::result::Result::Ok(CollocatedNfTypeAnyOf::MbUpf),
            "MB_SMF" => std::result::Result::Ok(CollocatedNfTypeAnyOf::MbSmf),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// The ComplexQuery data type is either a conjunctive normal form or a disjunctive normal form.  The attribute names \"cnfUnits\" and \"dnfUnits\" (see clause 5.2.4.11 and clause 5.2.4.12)  serve as discriminator.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ComplexQuery {
    #[serde(rename = "cnfUnits")]
    pub cnf_units: Vec<models::CnfUnit>,

    #[serde(rename = "dnfUnits")]
    pub dnf_units: Vec<models::DnfUnit>,
}

impl ComplexQuery {
    #[allow(clippy::new_without_default)]
    pub fn new(cnf_units: Vec<models::CnfUnit>, dnf_units: Vec<models::DnfUnit>) -> ComplexQuery {
        ComplexQuery {
            cnf_units,
            dnf_units,
        }
    }
}

/// Converts the ComplexQuery value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ComplexQuery {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping cnfUnits in query parameter serialization

            // Skipping dnfUnits in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ComplexQuery value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ComplexQuery {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cnf_units: Vec<Vec<models::CnfUnit>>,
            pub dnf_units: Vec<Vec<models::DnfUnit>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ComplexQuery".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "cnfUnits" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in ComplexQuery"
                                .to_string(),
                        )
                    }
                    "dnfUnits" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in ComplexQuery"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ComplexQuery".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ComplexQuery {
            cnf_units: intermediate_rep
                .cnf_units
                .into_iter()
                .next()
                .ok_or_else(|| "cnfUnits missing in ComplexQuery".to_string())?,
            dnf_units: intermediate_rep
                .dnf_units
                .into_iter()
                .next()
                .ok_or_else(|| "dnfUnits missing in ComplexQuery".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ComplexQuery> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ComplexQuery>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ComplexQuery>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ComplexQuery - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ComplexQuery> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ComplexQuery as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ComplexQuery - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Types of data sets and subsets stored in UDR
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DataSetId {}

impl DataSetId {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DataSetId {
        DataSetId {}
    }
}

/// Converts the DataSetId value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DataSetId {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DataSetId value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DataSetId {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing DataSetId".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing DataSetId".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DataSetId {})
    }
}

// Methods for converting between header::IntoHeaderValue<DataSetId> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DataSetId>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<DataSetId>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for DataSetId - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DataSetId> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <DataSetId as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into DataSetId - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum DataSetIdAnyOf {
    #[serde(rename = "SUBSCRIPTION")]
    Subscription,
    #[serde(rename = "POLICY")]
    Policy,
    #[serde(rename = "EXPOSURE")]
    Exposure,
    #[serde(rename = "APPLICATION")]
    Application,
    #[serde(rename = "A_PFD")]
    APfd,
    #[serde(rename = "A_AFTI")]
    AAfti,
    #[serde(rename = "A_IPTV")]
    AIptv,
    #[serde(rename = "A_BDT")]
    ABdt,
    #[serde(rename = "A_SPD")]
    ASpd,
    #[serde(rename = "A_EASD")]
    AEasd,
    #[serde(rename = "A_AMI")]
    AAmi,
    #[serde(rename = "P_UE")]
    PUe,
    #[serde(rename = "P_SCD")]
    PScd,
    #[serde(rename = "P_BDT")]
    PBdt,
    #[serde(rename = "P_PLMNUE")]
    PPlmnue,
    #[serde(rename = "P_NSSCD")]
    PNsscd,
}

impl std::fmt::Display for DataSetIdAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            DataSetIdAnyOf::Subscription => write!(f, "SUBSCRIPTION"),
            DataSetIdAnyOf::Policy => write!(f, "POLICY"),
            DataSetIdAnyOf::Exposure => write!(f, "EXPOSURE"),
            DataSetIdAnyOf::Application => write!(f, "APPLICATION"),
            DataSetIdAnyOf::APfd => write!(f, "A_PFD"),
            DataSetIdAnyOf::AAfti => write!(f, "A_AFTI"),
            DataSetIdAnyOf::AIptv => write!(f, "A_IPTV"),
            DataSetIdAnyOf::ABdt => write!(f, "A_BDT"),
            DataSetIdAnyOf::ASpd => write!(f, "A_SPD"),
            DataSetIdAnyOf::AEasd => write!(f, "A_EASD"),
            DataSetIdAnyOf::AAmi => write!(f, "A_AMI"),
            DataSetIdAnyOf::PUe => write!(f, "P_UE"),
            DataSetIdAnyOf::PScd => write!(f, "P_SCD"),
            DataSetIdAnyOf::PBdt => write!(f, "P_BDT"),
            DataSetIdAnyOf::PPlmnue => write!(f, "P_PLMNUE"),
            DataSetIdAnyOf::PNsscd => write!(f, "P_NSSCD"),
        }
    }
}

impl std::str::FromStr for DataSetIdAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "SUBSCRIPTION" => std::result::Result::Ok(DataSetIdAnyOf::Subscription),
            "POLICY" => std::result::Result::Ok(DataSetIdAnyOf::Policy),
            "EXPOSURE" => std::result::Result::Ok(DataSetIdAnyOf::Exposure),
            "APPLICATION" => std::result::Result::Ok(DataSetIdAnyOf::Application),
            "A_PFD" => std::result::Result::Ok(DataSetIdAnyOf::APfd),
            "A_AFTI" => std::result::Result::Ok(DataSetIdAnyOf::AAfti),
            "A_IPTV" => std::result::Result::Ok(DataSetIdAnyOf::AIptv),
            "A_BDT" => std::result::Result::Ok(DataSetIdAnyOf::ABdt),
            "A_SPD" => std::result::Result::Ok(DataSetIdAnyOf::ASpd),
            "A_EASD" => std::result::Result::Ok(DataSetIdAnyOf::AEasd),
            "A_AMI" => std::result::Result::Ok(DataSetIdAnyOf::AAmi),
            "P_UE" => std::result::Result::Ok(DataSetIdAnyOf::PUe),
            "P_SCD" => std::result::Result::Ok(DataSetIdAnyOf::PScd),
            "P_BDT" => std::result::Result::Ok(DataSetIdAnyOf::PBdt),
            "P_PLMNUE" => std::result::Result::Ok(DataSetIdAnyOf::PPlmnue),
            "P_NSSCD" => std::result::Result::Ok(DataSetIdAnyOf::PNsscd),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// string with format 'date-time' as defined in OpenAPI.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DateTime(chrono::DateTime<chrono::Utc>);

impl std::convert::From<chrono::DateTime<chrono::Utc>> for DateTime {
    fn from(x: chrono::DateTime<chrono::Utc>) -> Self {
        DateTime(x)
    }
}

impl std::convert::From<DateTime> for chrono::DateTime<chrono::Utc> {
    fn from(x: DateTime) -> Self {
        x.0
    }
}

impl std::ops::Deref for DateTime {
    type Target = chrono::DateTime<chrono::Utc>;
    fn deref(&self) -> &chrono::DateTime<chrono::Utc> {
        &self.0
    }
}

impl std::ops::DerefMut for DateTime {
    fn deref_mut(&mut self) -> &mut chrono::DateTime<chrono::Utc> {
        &mut self.0
    }
}

/// Information of a DCCF NF Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DccfInfo {
    #[serde(rename = "servingNfTypeList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub serving_nf_type_list: Option<Vec<models::NfType>>,

    #[serde(rename = "servingNfSetIdList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub serving_nf_set_id_list: Option<Vec<models::NfSetId>>,

    #[serde(rename = "taiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tai_list: Option<Vec<models::Tai>>,

    #[serde(rename = "taiRangeList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tai_range_list: Option<Vec<models::TaiRange>>,
}

impl DccfInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DccfInfo {
        DccfInfo {
            serving_nf_type_list: None,
            serving_nf_set_id_list: None,
            tai_list: None,
            tai_range_list: None,
        }
    }
}

/// Converts the DccfInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DccfInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping servingNfTypeList in query parameter serialization
            self.serving_nf_set_id_list
                .as_ref()
                .map(|serving_nf_set_id_list| {
                    vec![
                        "servingNfSetIdList".to_string(),
                        serving_nf_set_id_list
                            .iter()
                            .map(|x| x.to_string())
                            .collect::<Vec<_>>()
                            .join(","),
                    ]
                    .join(",")
                }),
            // Skipping taiList in query parameter serialization

            // Skipping taiRangeList in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DccfInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DccfInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub serving_nf_type_list: Vec<Vec<models::NfType>>,
            pub serving_nf_set_id_list: Vec<Vec<models::NfSetId>>,
            pub tai_list: Vec<Vec<models::Tai>>,
            pub tai_range_list: Vec<Vec<models::TaiRange>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing DccfInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "servingNfTypeList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in DccfInfo"
                                .to_string(),
                        )
                    }
                    "servingNfSetIdList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in DccfInfo"
                                .to_string(),
                        )
                    }
                    "taiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in DccfInfo"
                                .to_string(),
                        )
                    }
                    "taiRangeList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in DccfInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing DccfInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DccfInfo {
            serving_nf_type_list: intermediate_rep.serving_nf_type_list.into_iter().next(),
            serving_nf_set_id_list: intermediate_rep.serving_nf_set_id_list.into_iter().next(),
            tai_list: intermediate_rep.tai_list.into_iter().next(),
            tai_range_list: intermediate_rep.tai_range_list.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DccfInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DccfInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<DccfInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for DccfInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DccfInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <DccfInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into DccfInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Service Specific information for Default Notification Subscription.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DefSubServiceInfo {
    #[serde(rename = "versions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub versions: Option<Vec<String>>,

    /// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  tableÂ 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.
    #[serde(rename = "supportedFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_features: Option<String>,
}

impl DefSubServiceInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DefSubServiceInfo {
        DefSubServiceInfo {
            versions: None,
            supported_features: None,
        }
    }
}

/// Converts the DefSubServiceInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DefSubServiceInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.versions.as_ref().map(|versions| {
                vec![
                    "versions".to_string(),
                    versions
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.supported_features.as_ref().map(|supported_features| {
                vec![
                    "supportedFeatures".to_string(),
                    supported_features.to_string(),
                ]
                .join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DefSubServiceInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DefSubServiceInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub versions: Vec<Vec<String>>,
            pub supported_features: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing DefSubServiceInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "versions" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in DefSubServiceInfo"
                            .to_string(),
                    ),
                    #[allow(clippy::redundant_clone)]
                    "supportedFeatures" => intermediate_rep.supported_features.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing DefSubServiceInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DefSubServiceInfo {
            versions: intermediate_rep.versions.into_iter().next(),
            supported_features: intermediate_rep.supported_features.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DefSubServiceInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DefSubServiceInfo>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<DefSubServiceInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for DefSubServiceInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<DefSubServiceInfo>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <DefSubServiceInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into DefSubServiceInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Data structure for specifying the notifications the NF service subscribes by default, along with callback URI
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DefaultNotificationSubscription {
    #[serde(rename = "notificationType")]
    pub notification_type: models::NotificationType,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "callbackUri")]
    pub callback_uri: String,

    #[serde(rename = "n1MessageClass")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n1_message_class: Option<models::N1MessageClass>,

    #[serde(rename = "n2InformationClass")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n2_information_class: Option<models::N2InformationClass>,

    #[serde(rename = "versions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub versions: Option<Vec<String>>,

    #[serde(rename = "binding")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub binding: Option<String>,

    #[serde(rename = "acceptedEncoding")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub accepted_encoding: Option<String>,

    /// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  tableÂ 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.
    #[serde(rename = "supportedFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_features: Option<String>,

    /// A map of service specific information. The name of the corresponding service (as specified in ServiceName data type) is the key.
    #[serde(rename = "serviceInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_info_list: Option<std::collections::HashMap<String, models::DefSubServiceInfo>>,
}

impl DefaultNotificationSubscription {
    #[allow(clippy::new_without_default)]
    pub fn new(
        notification_type: models::NotificationType,
        callback_uri: String,
    ) -> DefaultNotificationSubscription {
        DefaultNotificationSubscription {
            notification_type,
            callback_uri,
            n1_message_class: None,
            n2_information_class: None,
            versions: None,
            binding: None,
            accepted_encoding: None,
            supported_features: None,
            service_info_list: None,
        }
    }
}

/// Converts the DefaultNotificationSubscription value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DefaultNotificationSubscription {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping notificationType in query parameter serialization
            Some("callbackUri".to_string()),
            Some(self.callback_uri.to_string()),
            // Skipping n1MessageClass in query parameter serialization

            // Skipping n2InformationClass in query parameter serialization
            self.versions.as_ref().map(|versions| {
                vec![
                    "versions".to_string(),
                    versions
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.binding
                .as_ref()
                .map(|binding| vec!["binding".to_string(), binding.to_string()].join(",")),
            self.accepted_encoding.as_ref().map(|accepted_encoding| {
                vec![
                    "acceptedEncoding".to_string(),
                    accepted_encoding.to_string(),
                ]
                .join(",")
            }),
            self.supported_features.as_ref().map(|supported_features| {
                vec![
                    "supportedFeatures".to_string(),
                    supported_features.to_string(),
                ]
                .join(",")
            }),
            // Skipping serviceInfoList in query parameter serialization
            // Skipping serviceInfoList in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DefaultNotificationSubscription value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DefaultNotificationSubscription {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub notification_type: Vec<models::NotificationType>,
            pub callback_uri: Vec<String>,
            pub n1_message_class: Vec<models::N1MessageClass>,
            pub n2_information_class: Vec<models::N2InformationClass>,
            pub versions: Vec<Vec<String>>,
            pub binding: Vec<String>,
            pub accepted_encoding: Vec<String>,
            pub supported_features: Vec<String>,
            pub service_info_list:
                Vec<std::collections::HashMap<String, models::DefSubServiceInfo>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing DefaultNotificationSubscription".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "notificationType" => intermediate_rep.notification_type.push(<models::NotificationType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "callbackUri" => intermediate_rep.callback_uri.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "n1MessageClass" => intermediate_rep.n1_message_class.push(<models::N1MessageClass as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "n2InformationClass" => intermediate_rep.n2_information_class.push(<models::N2InformationClass as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "versions" => return std::result::Result::Err("Parsing a container in this style is not supported in DefaultNotificationSubscription".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "binding" => intermediate_rep.binding.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "acceptedEncoding" => intermediate_rep.accepted_encoding.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "supportedFeatures" => intermediate_rep.supported_features.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "serviceInfoList" => return std::result::Result::Err("Parsing a container in this style is not supported in DefaultNotificationSubscription".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing DefaultNotificationSubscription".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DefaultNotificationSubscription {
            notification_type: intermediate_rep
                .notification_type
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "notificationType missing in DefaultNotificationSubscription".to_string()
                })?,
            callback_uri: intermediate_rep
                .callback_uri
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "callbackUri missing in DefaultNotificationSubscription".to_string()
                })?,
            n1_message_class: intermediate_rep.n1_message_class.into_iter().next(),
            n2_information_class: intermediate_rep.n2_information_class.into_iter().next(),
            versions: intermediate_rep.versions.into_iter().next(),
            binding: intermediate_rep.binding.into_iter().next(),
            accepted_encoding: intermediate_rep.accepted_encoding.into_iter().next(),
            supported_features: intermediate_rep.supported_features.into_iter().next(),
            service_info_list: intermediate_rep.service_info_list.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DefaultNotificationSubscription> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DefaultNotificationSubscription>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<DefaultNotificationSubscription>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DefaultNotificationSubscription - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<DefaultNotificationSubscription>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DefaultNotificationSubscription as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DefaultNotificationSubscription - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

/// Fully Qualified Domain Name
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DiameterIdentity {}

impl DiameterIdentity {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DiameterIdentity {
        DiameterIdentity {}
    }
}

/// Converts the DiameterIdentity value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DiameterIdentity {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DiameterIdentity value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DiameterIdentity {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing DiameterIdentity".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing DiameterIdentity".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DiameterIdentity {})
    }
}

// Methods for converting between header::IntoHeaderValue<DiameterIdentity> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DiameterIdentity>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<DiameterIdentity>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for DiameterIdentity - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<DiameterIdentity>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <DiameterIdentity as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into DiameterIdentity - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// DNAI (Data network access identifier), see clause 5.6.7 of 3GPP TS 23.501.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Dnai(String);

impl std::convert::From<String> for Dnai {
    fn from(x: String) -> Self {
        Dnai(x)
    }
}

impl std::string::ToString for Dnai {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Dnai {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Dnai(x.to_string()))
    }
}

impl std::convert::From<Dnai> for String {
    fn from(x: Dnai) -> Self {
        x.0
    }
}

impl std::ops::Deref for Dnai {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Dnai {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// A disjunctive normal form.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Dnf {
    #[serde(rename = "dnfUnits")]
    pub dnf_units: Vec<models::DnfUnit>,
}

impl Dnf {
    #[allow(clippy::new_without_default)]
    pub fn new(dnf_units: Vec<models::DnfUnit>) -> Dnf {
        Dnf { dnf_units }
    }
}

/// Converts the Dnf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Dnf {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping dnfUnits in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Dnf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Dnf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub dnf_units: Vec<Vec<models::DnfUnit>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err("Missing value while parsing Dnf".to_string())
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "dnfUnits" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Dnf".to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Dnf".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Dnf {
            dnf_units: intermediate_rep
                .dnf_units
                .into_iter()
                .next()
                .ok_or_else(|| "dnfUnits missing in Dnf".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Dnf> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Dnf>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Dnf>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Dnf - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Dnf> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Dnf as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Dnf - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// During the processing of dnfUnits attribute, all the members in the array shall be  interpreted as logically concatenated with logical \"OR\".
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DnfUnit {
    #[serde(rename = "dnfUnit")]
    pub dnf_unit: Vec<models::Atom>,
}

impl DnfUnit {
    #[allow(clippy::new_without_default)]
    pub fn new(dnf_unit: Vec<models::Atom>) -> DnfUnit {
        DnfUnit { dnf_unit }
    }
}

/// Converts the DnfUnit value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DnfUnit {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping dnfUnit in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DnfUnit value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DnfUnit {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub dnf_unit: Vec<Vec<models::Atom>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing DnfUnit".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "dnfUnit" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in DnfUnit"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing DnfUnit".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DnfUnit {
            dnf_unit: intermediate_rep
                .dnf_unit
                .into_iter()
                .next()
                .ok_or_else(|| "dnfUnit missing in DnfUnit".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DnfUnit> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DnfUnit>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<DnfUnit>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for DnfUnit - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DnfUnit> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <DnfUnit as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into DnfUnit - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// String representing a Data Network as defined in clause 9A of 3GPP TS 23.003;  it shall contain either a DNN Network Identifier, or a full DNN with both the Network  Identifier and Operator Identifier, as specified in 3GPP TS 23.003 clause 9.1.1 and 9.1.2. It shall be coded as string in which the labels are separated by dots  (e.g. \"Label1.Label2.Label3\").
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Dnn(String);

impl std::convert::From<String> for Dnn {
    fn from(x: String) -> Self {
        Dnn(x)
    }
}

impl std::string::ToString for Dnn {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Dnn {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Dnn(x.to_string()))
    }
}

impl std::convert::From<Dnn> for String {
    fn from(x: Dnn) -> Self {
        x.0
    }
}

impl std::ops::Deref for Dnn {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Dnn {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Set of parameters supported by EASDF for a given DNN
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DnnEasdfInfoItem {
    #[serde(rename = "dnn")]
    pub dnn: models::DnnSmfInfoItemDnn,

    #[serde(rename = "dnaiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dnai_list: Option<Vec<models::Dnai>>,
}

impl DnnEasdfInfoItem {
    #[allow(clippy::new_without_default)]
    pub fn new(dnn: models::DnnSmfInfoItemDnn) -> DnnEasdfInfoItem {
        DnnEasdfInfoItem {
            dnn,
            dnai_list: None,
        }
    }
}

/// Converts the DnnEasdfInfoItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DnnEasdfInfoItem {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping dnn in query parameter serialization
            self.dnai_list.as_ref().map(|dnai_list| {
                vec![
                    "dnaiList".to_string(),
                    dnai_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DnnEasdfInfoItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DnnEasdfInfoItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub dnn: Vec<models::DnnSmfInfoItemDnn>,
            pub dnai_list: Vec<Vec<models::Dnai>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing DnnEasdfInfoItem".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "dnn" => intermediate_rep.dnn.push(
                        <models::DnnSmfInfoItemDnn as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "dnaiList" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in DnnEasdfInfoItem"
                            .to_string(),
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing DnnEasdfInfoItem".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DnnEasdfInfoItem {
            dnn: intermediate_rep
                .dnn
                .into_iter()
                .next()
                .ok_or_else(|| "dnn missing in DnnEasdfInfoItem".to_string())?,
            dnai_list: intermediate_rep.dnai_list.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DnnEasdfInfoItem> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DnnEasdfInfoItem>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<DnnEasdfInfoItem>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for DnnEasdfInfoItem - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<DnnEasdfInfoItem>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <DnnEasdfInfoItem as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into DnnEasdfInfoItem - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Set of parameters supported by NF for a given DNN
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DnnInfoItem {
    #[serde(rename = "dnn")]
    pub dnn: models::DnnSmfInfoItemDnn,
}

impl DnnInfoItem {
    #[allow(clippy::new_without_default)]
    pub fn new(dnn: models::DnnSmfInfoItemDnn) -> DnnInfoItem {
        DnnInfoItem { dnn }
    }
}

/// Converts the DnnInfoItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DnnInfoItem {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping dnn in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DnnInfoItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DnnInfoItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub dnn: Vec<models::DnnSmfInfoItemDnn>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing DnnInfoItem".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "dnn" => intermediate_rep.dnn.push(
                        <models::DnnSmfInfoItemDnn as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing DnnInfoItem".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DnnInfoItem {
            dnn: intermediate_rep
                .dnn
                .into_iter()
                .next()
                .ok_or_else(|| "dnn missing in DnnInfoItem".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DnnInfoItem> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DnnInfoItem>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<DnnInfoItem>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for DnnInfoItem - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DnnInfoItem> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <DnnInfoItem as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into DnnInfoItem - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Parameters supported by an MB-SMF for a given DNN
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DnnMbSmfInfoItem {
    #[serde(rename = "dnn")]
    pub dnn: models::DnnSmfInfoItemDnn,
}

impl DnnMbSmfInfoItem {
    #[allow(clippy::new_without_default)]
    pub fn new(dnn: models::DnnSmfInfoItemDnn) -> DnnMbSmfInfoItem {
        DnnMbSmfInfoItem { dnn }
    }
}

/// Converts the DnnMbSmfInfoItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DnnMbSmfInfoItem {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping dnn in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DnnMbSmfInfoItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DnnMbSmfInfoItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub dnn: Vec<models::DnnSmfInfoItemDnn>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing DnnMbSmfInfoItem".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "dnn" => intermediate_rep.dnn.push(
                        <models::DnnSmfInfoItemDnn as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing DnnMbSmfInfoItem".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DnnMbSmfInfoItem {
            dnn: intermediate_rep
                .dnn
                .into_iter()
                .next()
                .ok_or_else(|| "dnn missing in DnnMbSmfInfoItem".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DnnMbSmfInfoItem> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DnnMbSmfInfoItem>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<DnnMbSmfInfoItem>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for DnnMbSmfInfoItem - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<DnnMbSmfInfoItem>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <DnnMbSmfInfoItem as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into DnnMbSmfInfoItem - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Set of parameters supported by SMF for a given DNN
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DnnSmfInfoItem {
    #[serde(rename = "dnn")]
    pub dnn: models::DnnSmfInfoItemDnn,

    #[serde(rename = "dnaiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dnai_list: Option<Vec<models::DnnSmfInfoItemDnaiListInner>>,
}

impl DnnSmfInfoItem {
    #[allow(clippy::new_without_default)]
    pub fn new(dnn: models::DnnSmfInfoItemDnn) -> DnnSmfInfoItem {
        DnnSmfInfoItem {
            dnn,
            dnai_list: None,
        }
    }
}

/// Converts the DnnSmfInfoItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DnnSmfInfoItem {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping dnn in query parameter serialization

            // Skipping dnaiList in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DnnSmfInfoItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DnnSmfInfoItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub dnn: Vec<models::DnnSmfInfoItemDnn>,
            pub dnai_list: Vec<Vec<models::DnnSmfInfoItemDnaiListInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing DnnSmfInfoItem".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "dnn" => intermediate_rep.dnn.push(
                        <models::DnnSmfInfoItemDnn as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "dnaiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in DnnSmfInfoItem"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing DnnSmfInfoItem".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DnnSmfInfoItem {
            dnn: intermediate_rep
                .dnn
                .into_iter()
                .next()
                .ok_or_else(|| "dnn missing in DnnSmfInfoItem".to_string())?,
            dnai_list: intermediate_rep.dnai_list.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DnnSmfInfoItem> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DnnSmfInfoItem>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<DnnSmfInfoItem>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for DnnSmfInfoItem - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DnnSmfInfoItem> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <DnnSmfInfoItem as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into DnnSmfInfoItem - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DnnSmfInfoItemDnaiListInner {}

impl DnnSmfInfoItemDnaiListInner {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DnnSmfInfoItemDnaiListInner {
        DnnSmfInfoItemDnaiListInner {}
    }
}

/// Converts the DnnSmfInfoItemDnaiListInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DnnSmfInfoItemDnaiListInner {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DnnSmfInfoItemDnaiListInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DnnSmfInfoItemDnaiListInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing DnnSmfInfoItemDnaiListInner".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing DnnSmfInfoItemDnaiListInner".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DnnSmfInfoItemDnaiListInner {})
    }
}

// Methods for converting between header::IntoHeaderValue<DnnSmfInfoItemDnaiListInner> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DnnSmfInfoItemDnaiListInner>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<DnnSmfInfoItemDnaiListInner>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for DnnSmfInfoItemDnaiListInner - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<DnnSmfInfoItemDnaiListInner>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <DnnSmfInfoItemDnaiListInner as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into DnnSmfInfoItemDnaiListInner - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DnnSmfInfoItemDnn {}

impl DnnSmfInfoItemDnn {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DnnSmfInfoItemDnn {
        DnnSmfInfoItemDnn {}
    }
}

/// Converts the DnnSmfInfoItemDnn value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DnnSmfInfoItemDnn {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DnnSmfInfoItemDnn value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DnnSmfInfoItemDnn {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing DnnSmfInfoItemDnn".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing DnnSmfInfoItemDnn".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DnnSmfInfoItemDnn {})
    }
}

// Methods for converting between header::IntoHeaderValue<DnnSmfInfoItemDnn> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DnnSmfInfoItemDnn>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<DnnSmfInfoItemDnn>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for DnnSmfInfoItemDnn - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<DnnSmfInfoItemDnn>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <DnnSmfInfoItemDnn as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into DnnSmfInfoItemDnn - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Parameters supported by an TSCTSF for a given DNN
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DnnTsctsfInfoItem {
    #[serde(rename = "dnn")]
    pub dnn: models::DnnSmfInfoItemDnn,
}

impl DnnTsctsfInfoItem {
    #[allow(clippy::new_without_default)]
    pub fn new(dnn: models::DnnSmfInfoItemDnn) -> DnnTsctsfInfoItem {
        DnnTsctsfInfoItem { dnn }
    }
}

/// Converts the DnnTsctsfInfoItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DnnTsctsfInfoItem {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping dnn in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DnnTsctsfInfoItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DnnTsctsfInfoItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub dnn: Vec<models::DnnSmfInfoItemDnn>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing DnnTsctsfInfoItem".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "dnn" => intermediate_rep.dnn.push(
                        <models::DnnSmfInfoItemDnn as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing DnnTsctsfInfoItem".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DnnTsctsfInfoItem {
            dnn: intermediate_rep
                .dnn
                .into_iter()
                .next()
                .ok_or_else(|| "dnn missing in DnnTsctsfInfoItem".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DnnTsctsfInfoItem> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DnnTsctsfInfoItem>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<DnnTsctsfInfoItem>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for DnnTsctsfInfoItem - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<DnnTsctsfInfoItem>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <DnnTsctsfInfoItem as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into DnnTsctsfInfoItem - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Set of parameters supported by UPF for a given DNN
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DnnUpfInfoItem {
    /// String representing a Data Network as defined in clause 9A of 3GPP TS 23.003;  it shall contain either a DNN Network Identifier, or a full DNN with both the Network  Identifier and Operator Identifier, as specified in 3GPP TS 23.003 clause 9.1.1 and 9.1.2. It shall be coded as string in which the labels are separated by dots  (e.g. \"Label1.Label2.Label3\").
    #[serde(rename = "dnn")]
    pub dnn: String,

    #[serde(rename = "dnaiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dnai_list: Option<Vec<models::Dnai>>,

    #[serde(rename = "pduSessionTypes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pdu_session_types: Option<Vec<models::PduSessionType>>,

    #[serde(rename = "ipv4AddressRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv4_address_ranges: Option<Vec<models::Ipv4AddressRange>>,

    #[serde(rename = "ipv6PrefixRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_prefix_ranges: Option<Vec<models::Ipv6PrefixRange>>,

    #[serde(rename = "ipv4IndexList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv4_index_list: Option<Vec<models::IpIndex>>,

    #[serde(rename = "ipv6IndexList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_index_list: Option<Vec<models::IpIndex>>,

    /// Map of network instance per DNAI for the DNN, where the key of the map is the DNAI. When present, the value of each entry of the map shall contain a N6 network instance that is configured for the DNAI indicated by the key.
    #[serde(rename = "dnaiNwInstanceList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dnai_nw_instance_list: Option<std::collections::HashMap<String, String>>,
}

impl DnnUpfInfoItem {
    #[allow(clippy::new_without_default)]
    pub fn new(dnn: String) -> DnnUpfInfoItem {
        DnnUpfInfoItem {
            dnn,
            dnai_list: None,
            pdu_session_types: None,
            ipv4_address_ranges: None,
            ipv6_prefix_ranges: None,
            ipv4_index_list: None,
            ipv6_index_list: None,
            dnai_nw_instance_list: None,
        }
    }
}

/// Converts the DnnUpfInfoItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DnnUpfInfoItem {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("dnn".to_string()),
            Some(self.dnn.to_string()),
            self.dnai_list.as_ref().map(|dnai_list| {
                vec![
                    "dnaiList".to_string(),
                    dnai_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping pduSessionTypes in query parameter serialization

            // Skipping ipv4AddressRanges in query parameter serialization

            // Skipping ipv6PrefixRanges in query parameter serialization

            // Skipping ipv4IndexList in query parameter serialization

            // Skipping ipv6IndexList in query parameter serialization

            // Skipping dnaiNwInstanceList in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DnnUpfInfoItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DnnUpfInfoItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub dnn: Vec<String>,
            pub dnai_list: Vec<Vec<models::Dnai>>,
            pub pdu_session_types: Vec<Vec<models::PduSessionType>>,
            pub ipv4_address_ranges: Vec<Vec<models::Ipv4AddressRange>>,
            pub ipv6_prefix_ranges: Vec<Vec<models::Ipv6PrefixRange>>,
            pub ipv4_index_list: Vec<Vec<models::IpIndex>>,
            pub ipv6_index_list: Vec<Vec<models::IpIndex>>,
            pub dnai_nw_instance_list: Vec<std::collections::HashMap<String, String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing DnnUpfInfoItem".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "dnn" => intermediate_rep.dnn.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "dnaiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in DnnUpfInfoItem"
                                .to_string(),
                        )
                    }
                    "pduSessionTypes" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in DnnUpfInfoItem"
                                .to_string(),
                        )
                    }
                    "ipv4AddressRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in DnnUpfInfoItem"
                                .to_string(),
                        )
                    }
                    "ipv6PrefixRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in DnnUpfInfoItem"
                                .to_string(),
                        )
                    }
                    "ipv4IndexList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in DnnUpfInfoItem"
                                .to_string(),
                        )
                    }
                    "ipv6IndexList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in DnnUpfInfoItem"
                                .to_string(),
                        )
                    }
                    "dnaiNwInstanceList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in DnnUpfInfoItem"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing DnnUpfInfoItem".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DnnUpfInfoItem {
            dnn: intermediate_rep
                .dnn
                .into_iter()
                .next()
                .ok_or_else(|| "dnn missing in DnnUpfInfoItem".to_string())?,
            dnai_list: intermediate_rep.dnai_list.into_iter().next(),
            pdu_session_types: intermediate_rep.pdu_session_types.into_iter().next(),
            ipv4_address_ranges: intermediate_rep.ipv4_address_ranges.into_iter().next(),
            ipv6_prefix_ranges: intermediate_rep.ipv6_prefix_ranges.into_iter().next(),
            ipv4_index_list: intermediate_rep.ipv4_index_list.into_iter().next(),
            ipv6_index_list: intermediate_rep.ipv6_index_list.into_iter().next(),
            dnai_nw_instance_list: intermediate_rep.dnai_nw_instance_list.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DnnUpfInfoItem> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DnnUpfInfoItem>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<DnnUpfInfoItem>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for DnnUpfInfoItem - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DnnUpfInfoItem> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <DnnUpfInfoItem as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into DnnUpfInfoItem - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// indicating a time in seconds.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DurationSec(i32);

impl std::convert::From<i32> for DurationSec {
    fn from(x: i32) -> Self {
        DurationSec(x)
    }
}

impl std::convert::From<DurationSec> for i32 {
    fn from(x: DurationSec) -> Self {
        x.0
    }
}

impl std::ops::Deref for DurationSec {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for DurationSec {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// Information of an EASDF NF Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EasdfInfo {
    #[serde(rename = "sNssaiEasdfInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub s_nssai_easdf_info_list: Option<Vec<models::SnssaiEasdfInfoItem>>,

    #[serde(rename = "easdfN6IpAddressList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub easdf_n6_ip_address_list: Option<Vec<models::IpAddr>>,

    #[serde(rename = "upfN6IpAddressList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub upf_n6_ip_address_list: Option<Vec<models::IpAddr>>,
}

impl EasdfInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> EasdfInfo {
        EasdfInfo {
            s_nssai_easdf_info_list: None,
            easdf_n6_ip_address_list: None,
            upf_n6_ip_address_list: None,
        }
    }
}

/// Converts the EasdfInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EasdfInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping sNssaiEasdfInfoList in query parameter serialization

            // Skipping easdfN6IpAddressList in query parameter serialization

            // Skipping upfN6IpAddressList in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EasdfInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EasdfInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub s_nssai_easdf_info_list: Vec<Vec<models::SnssaiEasdfInfoItem>>,
            pub easdf_n6_ip_address_list: Vec<Vec<models::IpAddr>>,
            pub upf_n6_ip_address_list: Vec<Vec<models::IpAddr>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing EasdfInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "sNssaiEasdfInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in EasdfInfo"
                                .to_string(),
                        )
                    }
                    "easdfN6IpAddressList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in EasdfInfo"
                                .to_string(),
                        )
                    }
                    "upfN6IpAddressList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in EasdfInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing EasdfInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EasdfInfo {
            s_nssai_easdf_info_list: intermediate_rep.s_nssai_easdf_info_list.into_iter().next(),
            easdf_n6_ip_address_list: intermediate_rep.easdf_n6_ip_address_list.into_iter().next(),
            upf_n6_ip_address_list: intermediate_rep.upf_n6_ip_address_list.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EasdfInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<EasdfInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<EasdfInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for EasdfInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<EasdfInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <EasdfInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into EasdfInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Possible values are: - LOAD_LEVEL_INFORMATION: Represent the analytics of load level information of corresponding network slice. - NETWORK_PERFORMANCE: Represent the analytics of network performance information. - NF_LOAD: Indicates that the event subscribed is NF Load. - SERVICE_EXPERIENCE: Represent the analytics of service experience information of the specific applications. - UE_MOBILITY: Represent the analytics of UE mobility. - UE_COMMUNICATION: Represent the analytics of UE communication. - QOS_SUSTAINABILITY: Represent the analytics of QoS sustainability information in the certain area. - ABNORMAL_BEHAVIOUR: Indicates that the event subscribed is abnormal behaviour information. - USER_DATA_CONGESTION: Represent the analytics of the user data congestion in the certain area. - NSI_LOAD_LEVEL: Represent the analytics of Network Slice and the optionally associated Network Slice Instance. - SM_CONGESTION: Represent the analytics of Session Management congestion control experience information for specific DNN and/or S-NSSAI. - DISPERSION: Represents the analytics of dispersion. - RED_TRANS_EXP: Represents the analytics of Redundant Transmission Experience. - WLAN_PERFORMANCE: Represents the analytics of WLAN performance. - DN_PERFORMANCE: Represents the analytics of DN performance.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EventId {}

impl EventId {
    #[allow(clippy::new_without_default)]
    pub fn new() -> EventId {
        EventId {}
    }
}

/// Converts the EventId value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EventId {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EventId value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EventId {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing EventId".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing EventId".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EventId {})
    }
}

// Methods for converting between header::IntoHeaderValue<EventId> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<EventId>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<EventId>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for EventId - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<EventId> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <EventId as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into EventId - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum EventIdAnyOf {
    #[serde(rename = "LOAD_LEVEL_INFORMATION")]
    LoadLevelInformation,
    #[serde(rename = "NETWORK_PERFORMANCE")]
    NetworkPerformance,
    #[serde(rename = "NF_LOAD")]
    NfLoad,
    #[serde(rename = "SERVICE_EXPERIENCE")]
    ServiceExperience,
    #[serde(rename = "UE_MOBILITY")]
    UeMobility,
    #[serde(rename = "UE_COMMUNICATION")]
    UeCommunication,
    #[serde(rename = "QOS_SUSTAINABILITY")]
    QosSustainability,
    #[serde(rename = "ABNORMAL_BEHAVIOUR")]
    AbnormalBehaviour,
    #[serde(rename = "USER_DATA_CONGESTION")]
    UserDataCongestion,
    #[serde(rename = "NSI_LOAD_LEVEL")]
    NsiLoadLevel,
    #[serde(rename = "SM_CONGESTION")]
    SmCongestion,
    #[serde(rename = "DISPERSION")]
    Dispersion,
    #[serde(rename = "RED_TRANS_EXP")]
    RedTransExp,
    #[serde(rename = "WLAN_PERFORMANCE")]
    WlanPerformance,
    #[serde(rename = "DN_PERFORMANCE")]
    DnPerformance,
}

impl std::fmt::Display for EventIdAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            EventIdAnyOf::LoadLevelInformation => write!(f, "LOAD_LEVEL_INFORMATION"),
            EventIdAnyOf::NetworkPerformance => write!(f, "NETWORK_PERFORMANCE"),
            EventIdAnyOf::NfLoad => write!(f, "NF_LOAD"),
            EventIdAnyOf::ServiceExperience => write!(f, "SERVICE_EXPERIENCE"),
            EventIdAnyOf::UeMobility => write!(f, "UE_MOBILITY"),
            EventIdAnyOf::UeCommunication => write!(f, "UE_COMMUNICATION"),
            EventIdAnyOf::QosSustainability => write!(f, "QOS_SUSTAINABILITY"),
            EventIdAnyOf::AbnormalBehaviour => write!(f, "ABNORMAL_BEHAVIOUR"),
            EventIdAnyOf::UserDataCongestion => write!(f, "USER_DATA_CONGESTION"),
            EventIdAnyOf::NsiLoadLevel => write!(f, "NSI_LOAD_LEVEL"),
            EventIdAnyOf::SmCongestion => write!(f, "SM_CONGESTION"),
            EventIdAnyOf::Dispersion => write!(f, "DISPERSION"),
            EventIdAnyOf::RedTransExp => write!(f, "RED_TRANS_EXP"),
            EventIdAnyOf::WlanPerformance => write!(f, "WLAN_PERFORMANCE"),
            EventIdAnyOf::DnPerformance => write!(f, "DN_PERFORMANCE"),
        }
    }
}

impl std::str::FromStr for EventIdAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "LOAD_LEVEL_INFORMATION" => std::result::Result::Ok(EventIdAnyOf::LoadLevelInformation),
            "NETWORK_PERFORMANCE" => std::result::Result::Ok(EventIdAnyOf::NetworkPerformance),
            "NF_LOAD" => std::result::Result::Ok(EventIdAnyOf::NfLoad),
            "SERVICE_EXPERIENCE" => std::result::Result::Ok(EventIdAnyOf::ServiceExperience),
            "UE_MOBILITY" => std::result::Result::Ok(EventIdAnyOf::UeMobility),
            "UE_COMMUNICATION" => std::result::Result::Ok(EventIdAnyOf::UeCommunication),
            "QOS_SUSTAINABILITY" => std::result::Result::Ok(EventIdAnyOf::QosSustainability),
            "ABNORMAL_BEHAVIOUR" => std::result::Result::Ok(EventIdAnyOf::AbnormalBehaviour),
            "USER_DATA_CONGESTION" => std::result::Result::Ok(EventIdAnyOf::UserDataCongestion),
            "NSI_LOAD_LEVEL" => std::result::Result::Ok(EventIdAnyOf::NsiLoadLevel),
            "SM_CONGESTION" => std::result::Result::Ok(EventIdAnyOf::SmCongestion),
            "DISPERSION" => std::result::Result::Ok(EventIdAnyOf::Dispersion),
            "RED_TRANS_EXP" => std::result::Result::Ok(EventIdAnyOf::RedTransExp),
            "WLAN_PERFORMANCE" => std::result::Result::Ok(EventIdAnyOf::WlanPerformance),
            "DN_PERFORMANCE" => std::result::Result::Ok(EventIdAnyOf::DnPerformance),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ExtGroupId(String);

impl std::convert::From<String> for ExtGroupId {
    fn from(x: String) -> Self {
        ExtGroupId(x)
    }
}

impl std::string::ToString for ExtGroupId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for ExtGroupId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(ExtGroupId(x.to_string()))
    }
}

impl std::convert::From<ExtGroupId> for String {
    fn from(x: ExtGroupId) -> Self {
        x.0
    }
}

impl std::ops::Deref for ExtGroupId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for ExtGroupId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// The sdRanges and wildcardSd attributes shall be exclusive from each other. If one of these attributes is present,  the sd attribute shall also be present and it shall contain one Slice Differentiator value within the range of SD  (if the sdRanges attribute is present) or with any value (if the wildcardSd attribute is present).
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ExtSnssai {
    /// Unsigned integer, within the range 0 to 255, representing the Slice/Service Type.  It indicates the expected Network Slice behaviour in terms of features and services. Values 0 to 127 correspond to the standardized SST range. Values 128 to 255 correspond  to the Operator-specific range. See clause 28.4.2 of 3GPP TS 23.003. Standardized values are defined in clause 5.15.2.2 of 3GPP TS 23.501.
    #[serde(rename = "sst")]
    pub sst: u8,

    /// 3-octet string, representing the Slice Differentiator, in hexadecimal representation. Each character in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character representing the 4 most significant bits of the SD shall appear first in the string, and the character representing the 4 least significant bit of the SD shall appear last in the string. This is an optional parameter that complements the Slice/Service type(s) to allow to  differentiate amongst multiple Network Slices of the same Slice/Service type. This IE shall be absent if no SD value is associated with the SST.
    #[serde(rename = "sd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sd: Option<String>,

    /// When present, it shall contain the range(s) of Slice Differentiator values supported for the Slice/Service Type value indicated in the sst attribute of the Snssai data type
    #[serde(rename = "sdRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sd_ranges: Option<Vec<models::SdRange>>,

    /// When present, it shall be set to true, to indicate that all SD values are supported for the Slice/Service Type value indicated in the sst attribute of the Snssai data type.
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "wildcardSd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub wildcard_sd: Option<bool>,
}

impl ExtSnssai {
    #[allow(clippy::new_without_default)]
    pub fn new(sst: u8) -> ExtSnssai {
        ExtSnssai {
            sst,
            sd: None,
            sd_ranges: None,
            wildcard_sd: None,
        }
    }
}

/// Converts the ExtSnssai value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ExtSnssai {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("sst".to_string()),
            Some(self.sst.to_string()),
            self.sd
                .as_ref()
                .map(|sd| vec!["sd".to_string(), sd.to_string()].join(",")),
            // Skipping sdRanges in query parameter serialization
            self.wildcard_sd.as_ref().map(|wildcard_sd| {
                vec!["wildcardSd".to_string(), wildcard_sd.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ExtSnssai value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ExtSnssai {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub sst: Vec<u8>,
            pub sd: Vec<String>,
            pub sd_ranges: Vec<Vec<models::SdRange>>,
            pub wildcard_sd: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ExtSnssai".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "sst" => intermediate_rep
                        .sst
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sd" => intermediate_rep.sd.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "sdRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in ExtSnssai"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "wildcardSd" => intermediate_rep.wildcard_sd.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ExtSnssai".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ExtSnssai {
            sst: intermediate_rep
                .sst
                .into_iter()
                .next()
                .ok_or_else(|| "sst missing in ExtSnssai".to_string())?,
            sd: intermediate_rep.sd.into_iter().next(),
            sd_ranges: intermediate_rep.sd_ranges.into_iter().next(),
            wildcard_sd: intermediate_rep.wildcard_sd.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ExtSnssai> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ExtSnssai>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ExtSnssai>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ExtSnssai - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ExtSnssai> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ExtSnssai as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ExtSnssai - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Indicates types of External Clients.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ExternalClientType {}

impl ExternalClientType {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ExternalClientType {
        ExternalClientType {}
    }
}

/// Converts the ExternalClientType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ExternalClientType {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ExternalClientType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ExternalClientType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ExternalClientType".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ExternalClientType".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ExternalClientType {})
    }
}

// Methods for converting between header::IntoHeaderValue<ExternalClientType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ExternalClientType>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ExternalClientType>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ExternalClientType - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ExternalClientType>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ExternalClientType as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ExternalClientType - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ExternalClientTypeAnyOf {
    #[serde(rename = "EMERGENCY_SERVICES")]
    EmergencyServices,
    #[serde(rename = "VALUE_ADDED_SERVICES")]
    ValueAddedServices,
    #[serde(rename = "PLMN_OPERATOR_SERVICES")]
    PlmnOperatorServices,
    #[serde(rename = "LAWFUL_INTERCEPT_SERVICES")]
    LawfulInterceptServices,
    #[serde(rename = "PLMN_OPERATOR_BROADCAST_SERVICES")]
    PlmnOperatorBroadcastServices,
    #[serde(rename = "PLMN_OPERATOR_OM")]
    PlmnOperatorOm,
    #[serde(rename = "PLMN_OPERATOR_ANONYMOUS_STATISTICS")]
    PlmnOperatorAnonymousStatistics,
    #[serde(rename = "PLMN_OPERATOR_TARGET_MS_SERVICE_SUPPORT")]
    PlmnOperatorTargetMsServiceSupport,
}

impl std::fmt::Display for ExternalClientTypeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ExternalClientTypeAnyOf::EmergencyServices => write!(f, "EMERGENCY_SERVICES"),
            ExternalClientTypeAnyOf::ValueAddedServices => write!(f, "VALUE_ADDED_SERVICES"),
            ExternalClientTypeAnyOf::PlmnOperatorServices => write!(f, "PLMN_OPERATOR_SERVICES"),
            ExternalClientTypeAnyOf::LawfulInterceptServices => {
                write!(f, "LAWFUL_INTERCEPT_SERVICES")
            }
            ExternalClientTypeAnyOf::PlmnOperatorBroadcastServices => {
                write!(f, "PLMN_OPERATOR_BROADCAST_SERVICES")
            }
            ExternalClientTypeAnyOf::PlmnOperatorOm => write!(f, "PLMN_OPERATOR_OM"),
            ExternalClientTypeAnyOf::PlmnOperatorAnonymousStatistics => {
                write!(f, "PLMN_OPERATOR_ANONYMOUS_STATISTICS")
            }
            ExternalClientTypeAnyOf::PlmnOperatorTargetMsServiceSupport => {
                write!(f, "PLMN_OPERATOR_TARGET_MS_SERVICE_SUPPORT")
            }
        }
    }
}

impl std::str::FromStr for ExternalClientTypeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "EMERGENCY_SERVICES" => {
                std::result::Result::Ok(ExternalClientTypeAnyOf::EmergencyServices)
            }
            "VALUE_ADDED_SERVICES" => {
                std::result::Result::Ok(ExternalClientTypeAnyOf::ValueAddedServices)
            }
            "PLMN_OPERATOR_SERVICES" => {
                std::result::Result::Ok(ExternalClientTypeAnyOf::PlmnOperatorServices)
            }
            "LAWFUL_INTERCEPT_SERVICES" => {
                std::result::Result::Ok(ExternalClientTypeAnyOf::LawfulInterceptServices)
            }
            "PLMN_OPERATOR_BROADCAST_SERVICES" => {
                std::result::Result::Ok(ExternalClientTypeAnyOf::PlmnOperatorBroadcastServices)
            }
            "PLMN_OPERATOR_OM" => std::result::Result::Ok(ExternalClientTypeAnyOf::PlmnOperatorOm),
            "PLMN_OPERATOR_ANONYMOUS_STATISTICS" => {
                std::result::Result::Ok(ExternalClientTypeAnyOf::PlmnOperatorAnonymousStatistics)
            }
            "PLMN_OPERATOR_TARGET_MS_SERVICE_SUPPORT" => {
                std::result::Result::Ok(ExternalClientTypeAnyOf::PlmnOperatorTargetMsServiceSupport)
            }
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Fully Qualified Domain Name
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Fqdn(String);

impl std::convert::From<String> for Fqdn {
    fn from(x: String) -> Self {
        Fqdn(x)
    }
}

impl std::string::ToString for Fqdn {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Fqdn {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Fqdn(x.to_string()))
    }
}

impl std::convert::From<Fqdn> for String {
    fn from(x: Fqdn) -> Self {
        x.0
    }
}

impl std::ops::Deref for Fqdn {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Fqdn {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Information of a GMLC NF Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GmlcInfo {
    #[serde(rename = "servingClientTypes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub serving_client_types: Option<Vec<models::ExternalClientType>>,

    #[serde(rename = "gmlcNumbers")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gmlc_numbers: Option<Vec<String>>,
}

impl GmlcInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GmlcInfo {
        GmlcInfo {
            serving_client_types: None,
            gmlc_numbers: None,
        }
    }
}

/// Converts the GmlcInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GmlcInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping servingClientTypes in query parameter serialization
            self.gmlc_numbers.as_ref().map(|gmlc_numbers| {
                vec![
                    "gmlcNumbers".to_string(),
                    gmlc_numbers
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GmlcInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GmlcInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub serving_client_types: Vec<Vec<models::ExternalClientType>>,
            pub gmlc_numbers: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GmlcInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "servingClientTypes" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in GmlcInfo"
                                .to_string(),
                        )
                    }
                    "gmlcNumbers" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in GmlcInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GmlcInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GmlcInfo {
            serving_client_types: intermediate_rep.serving_client_types.into_iter().next(),
            gmlc_numbers: intermediate_rep.gmlc_numbers.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GmlcInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GmlcInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GmlcInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GmlcInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GmlcInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GmlcInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GmlcInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// String identifying a Gpsi shall contain either an External Id or an MSISDN.  It shall be formatted as follows -External Identifier= \"extid-'extid', where 'extid'  shall be formatted according to clause 19.7.2 of 3GPP TS 23.003 that describes an  External Identifier.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Gpsi(String);

impl std::convert::From<String> for Gpsi {
    fn from(x: String) -> Self {
        Gpsi(x)
    }
}

impl std::string::ToString for Gpsi {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Gpsi {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Gpsi(x.to_string()))
    }
}

impl std::convert::From<Gpsi> for String {
    fn from(x: Gpsi) -> Self {
        x.0
    }
}

impl std::ops::Deref for Gpsi {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Gpsi {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// String identifying a group of devices network internal globally unique ID which identifies a set of IMSIs, as specified in clause 19.9 of 3GPP TS 23.003.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GroupId(String);

impl std::convert::From<String> for GroupId {
    fn from(x: String) -> Self {
        GroupId(x)
    }
}

impl std::string::ToString for GroupId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for GroupId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(GroupId(x.to_string()))
    }
}

impl std::convert::From<GroupId> for String {
    fn from(x: GroupId) -> Self {
        x.0
    }
}

impl std::ops::Deref for GroupId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for GroupId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Globally Unique AMF Identifier constructed out of PLMN, Network and AMF identity.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Guami {
    #[serde(rename = "plmnId")]
    pub plmn_id: models::PlmnIdNid,

    /// String identifying the AMF ID composed of AMF Region ID (8 bits), AMF Set ID (10 bits) and AMF  Pointer (6 bits) as specified in clause 2.10.1 of 3GPP TS 23.003. It is encoded as a string of  6 hexadecimal characters (i.e., 24 bits).
    #[serde(rename = "amfId")]
    pub amf_id: String,
}

impl Guami {
    #[allow(clippy::new_without_default)]
    pub fn new(plmn_id: models::PlmnIdNid, amf_id: String) -> Guami {
        Guami { plmn_id, amf_id }
    }
}

/// Converts the Guami value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Guami {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping plmnId in query parameter serialization
            Some("amfId".to_string()),
            Some(self.amf_id.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Guami value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Guami {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub plmn_id: Vec<models::PlmnIdNid>,
            pub amf_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Guami".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "plmnId" => intermediate_rep.plmn_id.push(
                        <models::PlmnIdNid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "amfId" => intermediate_rep.amf_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Guami".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Guami {
            plmn_id: intermediate_rep
                .plmn_id
                .into_iter()
                .next()
                .ok_or_else(|| "plmnId missing in Guami".to_string())?,
            amf_id: intermediate_rep
                .amf_id
                .into_iter()
                .next()
                .ok_or_else(|| "amfId missing in Guami".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Guami> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Guami>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Guami>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Guami - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Guami> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Guami as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Guami - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Information of an HSS NF Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct HssInfo {
    /// Identifier of a group of NFs.
    #[serde(rename = "groupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub group_id: Option<String>,

    #[serde(rename = "imsiRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub imsi_ranges: Option<Vec<models::ImsiRange>>,

    #[serde(rename = "imsPrivateIdentityRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ims_private_identity_ranges: Option<Vec<models::IdentityRange>>,

    #[serde(rename = "imsPublicIdentityRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ims_public_identity_ranges: Option<Vec<models::IdentityRange>>,

    #[serde(rename = "msisdnRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub msisdn_ranges: Option<Vec<models::IdentityRange>>,

    #[serde(rename = "externalGroupIdentifiersRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub external_group_identifiers_ranges: Option<Vec<models::IdentityRange>>,

    #[serde(rename = "hssDiameterAddress")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hss_diameter_address: Option<models::NetworkNodeDiameterAddress>,
}

impl HssInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> HssInfo {
        HssInfo {
            group_id: None,
            imsi_ranges: None,
            ims_private_identity_ranges: None,
            ims_public_identity_ranges: None,
            msisdn_ranges: None,
            external_group_identifiers_ranges: None,
            hss_diameter_address: None,
        }
    }
}

/// Converts the HssInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for HssInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.group_id
                .as_ref()
                .map(|group_id| vec!["groupId".to_string(), group_id.to_string()].join(",")),
            // Skipping imsiRanges in query parameter serialization

            // Skipping imsPrivateIdentityRanges in query parameter serialization

            // Skipping imsPublicIdentityRanges in query parameter serialization

            // Skipping msisdnRanges in query parameter serialization

            // Skipping externalGroupIdentifiersRanges in query parameter serialization

            // Skipping hssDiameterAddress in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a HssInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for HssInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub group_id: Vec<String>,
            pub imsi_ranges: Vec<Vec<models::ImsiRange>>,
            pub ims_private_identity_ranges: Vec<Vec<models::IdentityRange>>,
            pub ims_public_identity_ranges: Vec<Vec<models::IdentityRange>>,
            pub msisdn_ranges: Vec<Vec<models::IdentityRange>>,
            pub external_group_identifiers_ranges: Vec<Vec<models::IdentityRange>>,
            pub hss_diameter_address: Vec<models::NetworkNodeDiameterAddress>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing HssInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "groupId" => intermediate_rep.group_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "imsiRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in HssInfo"
                                .to_string(),
                        )
                    }
                    "imsPrivateIdentityRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in HssInfo"
                                .to_string(),
                        )
                    }
                    "imsPublicIdentityRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in HssInfo"
                                .to_string(),
                        )
                    }
                    "msisdnRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in HssInfo"
                                .to_string(),
                        )
                    }
                    "externalGroupIdentifiersRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in HssInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "hssDiameterAddress" => intermediate_rep.hss_diameter_address.push(
                        <models::NetworkNodeDiameterAddress as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing HssInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(HssInfo {
            group_id: intermediate_rep.group_id.into_iter().next(),
            imsi_ranges: intermediate_rep.imsi_ranges.into_iter().next(),
            ims_private_identity_ranges: intermediate_rep
                .ims_private_identity_ranges
                .into_iter()
                .next(),
            ims_public_identity_ranges: intermediate_rep
                .ims_public_identity_ranges
                .into_iter()
                .next(),
            msisdn_ranges: intermediate_rep.msisdn_ranges.into_iter().next(),
            external_group_identifiers_ranges: intermediate_rep
                .external_group_identifiers_ranges
                .into_iter()
                .next(),
            hss_diameter_address: intermediate_rep.hss_diameter_address.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<HssInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<HssInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<HssInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for HssInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<HssInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <HssInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into HssInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A range of GPSIs (subscriber identities), either based on a numeric range, or based on regular-expression matching
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IdentityRange {
    #[serde(rename = "start")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start: Option<String>,

    #[serde(rename = "end")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end: Option<String>,

    #[serde(rename = "pattern")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
}

impl IdentityRange {
    #[allow(clippy::new_without_default)]
    pub fn new() -> IdentityRange {
        IdentityRange {
            start: None,
            end: None,
            pattern: None,
        }
    }
}

/// Converts the IdentityRange value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for IdentityRange {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.start
                .as_ref()
                .map(|start| vec!["start".to_string(), start.to_string()].join(",")),
            self.end
                .as_ref()
                .map(|end| vec!["end".to_string(), end.to_string()].join(",")),
            self.pattern
                .as_ref()
                .map(|pattern| vec!["pattern".to_string(), pattern.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IdentityRange value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IdentityRange {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub start: Vec<String>,
            pub end: Vec<String>,
            pub pattern: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing IdentityRange".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "start" => intermediate_rep.start.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "end" => intermediate_rep.end.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "pattern" => intermediate_rep.pattern.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing IdentityRange".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IdentityRange {
            start: intermediate_rep.start.into_iter().next(),
            end: intermediate_rep.end.into_iter().next(),
            pattern: intermediate_rep.pattern.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IdentityRange> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<IdentityRange>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<IdentityRange>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for IdentityRange - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<IdentityRange> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <IdentityRange as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into IdentityRange - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A range of IMSIs (subscriber identities), either based on a numeric range, or based on regular-expression matching
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ImsiRange {
    #[serde(rename = "start")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start: Option<String>,

    #[serde(rename = "end")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end: Option<String>,

    #[serde(rename = "pattern")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
}

impl ImsiRange {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ImsiRange {
        ImsiRange {
            start: None,
            end: None,
            pattern: None,
        }
    }
}

/// Converts the ImsiRange value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ImsiRange {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.start
                .as_ref()
                .map(|start| vec!["start".to_string(), start.to_string()].join(",")),
            self.end
                .as_ref()
                .map(|end| vec!["end".to_string(), end.to_string()].join(",")),
            self.pattern
                .as_ref()
                .map(|pattern| vec!["pattern".to_string(), pattern.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ImsiRange value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ImsiRange {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub start: Vec<String>,
            pub end: Vec<String>,
            pub pattern: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ImsiRange".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "start" => intermediate_rep.start.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "end" => intermediate_rep.end.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "pattern" => intermediate_rep.pattern.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ImsiRange".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ImsiRange {
            start: intermediate_rep.start.into_iter().next(),
            end: intermediate_rep.end.into_iter().next(),
            pattern: intermediate_rep.pattern.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ImsiRange> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ImsiRange>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ImsiRange>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ImsiRange - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ImsiRange> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ImsiRange as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ImsiRange - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Information of a given IP interface of an UPF
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InterfaceUpfInfoItem {
    #[serde(rename = "interfaceType")]
    pub interface_type: models::UpInterfaceType,

    #[serde(rename = "ipv4EndpointAddresses")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv4_endpoint_addresses: Option<Vec<models::Ipv4Addr>>,

    #[serde(rename = "ipv6EndpointAddresses")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_endpoint_addresses: Option<Vec<models::Ipv6Addr>>,

    /// Fully Qualified Domain Name
    #[serde(rename = "endpointFqdn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub endpoint_fqdn: Option<String>,

    #[serde(rename = "networkInstance")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub network_instance: Option<String>,
}

impl InterfaceUpfInfoItem {
    #[allow(clippy::new_without_default)]
    pub fn new(interface_type: models::UpInterfaceType) -> InterfaceUpfInfoItem {
        InterfaceUpfInfoItem {
            interface_type,
            ipv4_endpoint_addresses: None,
            ipv6_endpoint_addresses: None,
            endpoint_fqdn: None,
            network_instance: None,
        }
    }
}

/// Converts the InterfaceUpfInfoItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for InterfaceUpfInfoItem {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping interfaceType in query parameter serialization
            self.ipv4_endpoint_addresses
                .as_ref()
                .map(|ipv4_endpoint_addresses| {
                    vec![
                        "ipv4EndpointAddresses".to_string(),
                        ipv4_endpoint_addresses
                            .iter()
                            .map(|x| x.to_string())
                            .collect::<Vec<_>>()
                            .join(","),
                    ]
                    .join(",")
                }),
            // Skipping ipv6EndpointAddresses in query parameter serialization
            self.endpoint_fqdn.as_ref().map(|endpoint_fqdn| {
                vec!["endpointFqdn".to_string(), endpoint_fqdn.to_string()].join(",")
            }),
            self.network_instance.as_ref().map(|network_instance| {
                vec!["networkInstance".to_string(), network_instance.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InterfaceUpfInfoItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InterfaceUpfInfoItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub interface_type: Vec<models::UpInterfaceType>,
            pub ipv4_endpoint_addresses: Vec<Vec<models::Ipv4Addr>>,
            pub ipv6_endpoint_addresses: Vec<Vec<models::Ipv6Addr>>,
            pub endpoint_fqdn: Vec<String>,
            pub network_instance: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing InterfaceUpfInfoItem".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "interfaceType" => intermediate_rep.interface_type.push(<models::UpInterfaceType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "ipv4EndpointAddresses" => return std::result::Result::Err("Parsing a container in this style is not supported in InterfaceUpfInfoItem".to_string()),
                    "ipv6EndpointAddresses" => return std::result::Result::Err("Parsing a container in this style is not supported in InterfaceUpfInfoItem".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "endpointFqdn" => intermediate_rep.endpoint_fqdn.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "networkInstance" => intermediate_rep.network_instance.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing InterfaceUpfInfoItem".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InterfaceUpfInfoItem {
            interface_type: intermediate_rep
                .interface_type
                .into_iter()
                .next()
                .ok_or_else(|| "interfaceType missing in InterfaceUpfInfoItem".to_string())?,
            ipv4_endpoint_addresses: intermediate_rep.ipv4_endpoint_addresses.into_iter().next(),
            ipv6_endpoint_addresses: intermediate_rep.ipv6_endpoint_addresses.into_iter().next(),
            endpoint_fqdn: intermediate_rep.endpoint_fqdn.into_iter().next(),
            network_instance: intermediate_rep.network_instance.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InterfaceUpfInfoItem> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<InterfaceUpfInfoItem>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<InterfaceUpfInfoItem>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for InterfaceUpfInfoItem - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<InterfaceUpfInfoItem>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <InterfaceUpfInfoItem as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into InterfaceUpfInfoItem - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A range of Group IDs (internal group identities), either based on a numeric range, or based on regular-expression matching
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InternalGroupIdRange {
    /// String identifying a group of devices network internal globally unique ID which identifies a set of IMSIs, as specified in clause 19.9 of 3GPP TS 23.003.
    #[serde(rename = "start")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start: Option<String>,

    /// String identifying a group of devices network internal globally unique ID which identifies a set of IMSIs, as specified in clause 19.9 of 3GPP TS 23.003.
    #[serde(rename = "end")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end: Option<String>,

    #[serde(rename = "pattern")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
}

impl InternalGroupIdRange {
    #[allow(clippy::new_without_default)]
    pub fn new() -> InternalGroupIdRange {
        InternalGroupIdRange {
            start: None,
            end: None,
            pattern: None,
        }
    }
}

/// Converts the InternalGroupIdRange value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for InternalGroupIdRange {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.start
                .as_ref()
                .map(|start| vec!["start".to_string(), start.to_string()].join(",")),
            self.end
                .as_ref()
                .map(|end| vec!["end".to_string(), end.to_string()].join(",")),
            self.pattern
                .as_ref()
                .map(|pattern| vec!["pattern".to_string(), pattern.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InternalGroupIdRange value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InternalGroupIdRange {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub start: Vec<String>,
            pub end: Vec<String>,
            pub pattern: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing InternalGroupIdRange".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "start" => intermediate_rep.start.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "end" => intermediate_rep.end.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "pattern" => intermediate_rep.pattern.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing InternalGroupIdRange".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InternalGroupIdRange {
            start: intermediate_rep.start.into_iter().next(),
            end: intermediate_rep.end.into_iter().next(),
            pattern: intermediate_rep.pattern.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InternalGroupIdRange> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<InternalGroupIdRange>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<InternalGroupIdRange>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for InternalGroupIdRange - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<InternalGroupIdRange>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <InternalGroupIdRange as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into InternalGroupIdRange - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// It contains an invalid parameter and a related description.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InvalidParam {
    /// If the invalid parameter is an attribute in a JSON body, this IE shall contain the  attribute's name and shall be encoded as a JSON Pointer. If the invalid parameter is  an HTTP header, this IE shall be formatted as the concatenation of the string \"header \"  plus the name of such header. If the invalid parameter is a query parameter, this IE  shall be formatted as the concatenation of the string \"query \" plus the name of such  query parameter. If the invalid parameter is a variable part in the path of a resource  URI, this IE shall contain the name of the variable, including the symbols \"{\" and \"}\"  used in OpenAPI specification as the notation to represent variable path segments.
    #[serde(rename = "param")]
    pub param: String,

    /// A human-readable reason, e.g. \"must be a positive integer\". In cases involving failed  operations in a PATCH request, the reason string should identify the operation that  failed using the operation's array index to assist in correlation of the invalid  parameter with the failed operation, e.g.\" Replacement value invalid for attribute  (failed operation index= 4)\"
    #[serde(rename = "reason")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
}

impl InvalidParam {
    #[allow(clippy::new_without_default)]
    pub fn new(param: String) -> InvalidParam {
        InvalidParam {
            param,
            reason: None,
        }
    }
}

/// Converts the InvalidParam value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for InvalidParam {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("param".to_string()),
            Some(self.param.to_string()),
            self.reason
                .as_ref()
                .map(|reason| vec!["reason".to_string(), reason.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InvalidParam value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InvalidParam {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub param: Vec<String>,
            pub reason: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing InvalidParam".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "param" => intermediate_rep.param.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "reason" => intermediate_rep.reason.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing InvalidParam".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InvalidParam {
            param: intermediate_rep
                .param
                .into_iter()
                .next()
                .ok_or_else(|| "param missing in InvalidParam".to_string())?,
            reason: intermediate_rep.reason.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InvalidParam> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<InvalidParam>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<InvalidParam>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for InvalidParam - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<InvalidParam> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <InvalidParam as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into InvalidParam - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains an IP adresse.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IpAddr {
    /// String identifying a IPv4 address formatted in the 'dotted decimal' notation as defined in RFC 1166.
    #[serde(rename = "ipv4Addr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv4_addr: Option<String>,

    #[serde(rename = "ipv6Addr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_addr: Option<models::Ipv6Addr>,

    #[serde(rename = "ipv6Prefix")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_prefix: Option<models::Ipv6Prefix>,
}

impl IpAddr {
    #[allow(clippy::new_without_default)]
    pub fn new() -> IpAddr {
        IpAddr {
            ipv4_addr: None,
            ipv6_addr: None,
            ipv6_prefix: None,
        }
    }
}

/// Converts the IpAddr value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for IpAddr {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.ipv4_addr
                .as_ref()
                .map(|ipv4_addr| vec!["ipv4Addr".to_string(), ipv4_addr.to_string()].join(",")),
            // Skipping ipv6Addr in query parameter serialization

            // Skipping ipv6Prefix in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IpAddr value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IpAddr {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ipv4_addr: Vec<String>,
            pub ipv6_addr: Vec<models::Ipv6Addr>,
            pub ipv6_prefix: Vec<models::Ipv6Prefix>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing IpAddr".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ipv4Addr" => intermediate_rep.ipv4_addr.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ipv6Addr" => intermediate_rep.ipv6_addr.push(
                        <models::Ipv6Addr as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ipv6Prefix" => intermediate_rep.ipv6_prefix.push(
                        <models::Ipv6Prefix as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing IpAddr".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IpAddr {
            ipv4_addr: intermediate_rep.ipv4_addr.into_iter().next(),
            ipv6_addr: intermediate_rep.ipv6_addr.into_iter().next(),
            ipv6_prefix: intermediate_rep.ipv6_prefix.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IpAddr> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<IpAddr>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<IpAddr>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for IpAddr - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<IpAddr> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <IpAddr as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into IpAddr - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// IP addressing information of a given NFService; it consists on, e.g. IP address, TCP port, transport protocol...
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IpEndPoint {
    /// String identifying a IPv4 address formatted in the 'dotted decimal' notation as defined in RFC 1166.
    #[serde(rename = "ipv4Address")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv4_address: Option<String>,

    #[serde(rename = "ipv6Address")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_address: Option<models::Ipv6Addr>,

    #[serde(rename = "transport")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transport: Option<models::TransportProtocol>,

    #[serde(rename = "port")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub port: Option<u16>,
}

impl IpEndPoint {
    #[allow(clippy::new_without_default)]
    pub fn new() -> IpEndPoint {
        IpEndPoint {
            ipv4_address: None,
            ipv6_address: None,
            transport: None,
            port: None,
        }
    }
}

/// Converts the IpEndPoint value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for IpEndPoint {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.ipv4_address.as_ref().map(|ipv4_address| {
                vec!["ipv4Address".to_string(), ipv4_address.to_string()].join(",")
            }),
            // Skipping ipv6Address in query parameter serialization

            // Skipping transport in query parameter serialization
            self.port
                .as_ref()
                .map(|port| vec!["port".to_string(), port.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IpEndPoint value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IpEndPoint {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ipv4_address: Vec<String>,
            pub ipv6_address: Vec<models::Ipv6Addr>,
            pub transport: Vec<models::TransportProtocol>,
            pub port: Vec<u16>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing IpEndPoint".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ipv4Address" => intermediate_rep.ipv4_address.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ipv6Address" => intermediate_rep.ipv6_address.push(
                        <models::Ipv6Addr as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "transport" => intermediate_rep.transport.push(
                        <models::TransportProtocol as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "port" => intermediate_rep.port.push(
                        <u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing IpEndPoint".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IpEndPoint {
            ipv4_address: intermediate_rep.ipv4_address.into_iter().next(),
            ipv6_address: intermediate_rep.ipv6_address.into_iter().next(),
            transport: intermediate_rep.transport.into_iter().next(),
            port: intermediate_rep.port.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IpEndPoint> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<IpEndPoint>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<IpEndPoint>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for IpEndPoint - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<IpEndPoint> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <IpEndPoint as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into IpEndPoint - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Represents the IP Index to be sent from UDM to the SMF (its value can be either an integer or a string)
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IpIndex {}

impl IpIndex {
    #[allow(clippy::new_without_default)]
    pub fn new() -> IpIndex {
        IpIndex {}
    }
}

/// Converts the IpIndex value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for IpIndex {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IpIndex value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IpIndex {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing IpIndex".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing IpIndex".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IpIndex {})
    }
}

// Methods for converting between header::IntoHeaderValue<IpIndex> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<IpIndex>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<IpIndex>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for IpIndex - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<IpIndex> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <IpIndex as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into IpIndex - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Indicates the type(s) of IP addresses reachable via an SCP
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IpReachability {}

impl IpReachability {
    #[allow(clippy::new_without_default)]
    pub fn new() -> IpReachability {
        IpReachability {}
    }
}

/// Converts the IpReachability value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for IpReachability {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IpReachability value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IpReachability {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing IpReachability".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing IpReachability".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IpReachability {})
    }
}

// Methods for converting between header::IntoHeaderValue<IpReachability> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<IpReachability>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<IpReachability>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for IpReachability - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<IpReachability> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <IpReachability as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into IpReachability - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum IpReachabilityAnyOf {
    #[serde(rename = "IPV4")]
    Ipv4,
    #[serde(rename = "IPV6")]
    Ipv6,
    #[serde(rename = "IPV4V6")]
    Ipv4V6,
}

impl std::fmt::Display for IpReachabilityAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            IpReachabilityAnyOf::Ipv4 => write!(f, "IPV4"),
            IpReachabilityAnyOf::Ipv6 => write!(f, "IPV6"),
            IpReachabilityAnyOf::Ipv4V6 => write!(f, "IPV4V6"),
        }
    }
}

impl std::str::FromStr for IpReachabilityAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "IPV4" => std::result::Result::Ok(IpReachabilityAnyOf::Ipv4),
            "IPV6" => std::result::Result::Ok(IpReachabilityAnyOf::Ipv6),
            "IPV4V6" => std::result::Result::Ok(IpReachabilityAnyOf::Ipv4V6),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// String identifying a IPv4 address formatted in the 'dotted decimal' notation as defined in RFC 1166.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Ipv4Addr(String);

impl std::convert::From<String> for Ipv4Addr {
    fn from(x: String) -> Self {
        Ipv4Addr(x)
    }
}

impl std::string::ToString for Ipv4Addr {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Ipv4Addr {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Ipv4Addr(x.to_string()))
    }
}

impl std::convert::From<Ipv4Addr> for String {
    fn from(x: Ipv4Addr) -> Self {
        x.0
    }
}

impl std::ops::Deref for Ipv4Addr {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Ipv4Addr {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Range of IPv4 addresses
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Ipv4AddressRange {
    /// String identifying a IPv4 address formatted in the 'dotted decimal' notation as defined in RFC 1166.
    #[serde(rename = "start")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start: Option<String>,

    /// String identifying a IPv4 address formatted in the 'dotted decimal' notation as defined in RFC 1166.
    #[serde(rename = "end")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end: Option<String>,
}

impl Ipv4AddressRange {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Ipv4AddressRange {
        Ipv4AddressRange {
            start: None,
            end: None,
        }
    }
}

/// Converts the Ipv4AddressRange value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Ipv4AddressRange {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.start
                .as_ref()
                .map(|start| vec!["start".to_string(), start.to_string()].join(",")),
            self.end
                .as_ref()
                .map(|end| vec!["end".to_string(), end.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Ipv4AddressRange value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Ipv4AddressRange {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub start: Vec<String>,
            pub end: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Ipv4AddressRange".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "start" => intermediate_rep.start.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "end" => intermediate_rep.end.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Ipv4AddressRange".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Ipv4AddressRange {
            start: intermediate_rep.start.into_iter().next(),
            end: intermediate_rep.end.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Ipv4AddressRange> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Ipv4AddressRange>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Ipv4AddressRange>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Ipv4AddressRange - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<Ipv4AddressRange>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <Ipv4AddressRange as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into Ipv4AddressRange - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// String identifying an IPv6 address formatted according to clause 4 of RFC5952. The mixed IPv4 IPv6 notation according to clause 5 of RFC5952 shall not be used.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Ipv6Addr(serde_json::Value);

impl std::convert::From<serde_json::Value> for Ipv6Addr {
    fn from(x: serde_json::Value) -> Self {
        Ipv6Addr(x)
    }
}

impl std::convert::From<Ipv6Addr> for serde_json::Value {
    fn from(x: Ipv6Addr) -> Self {
        x.0
    }
}

impl std::ops::Deref for Ipv6Addr {
    type Target = serde_json::Value;
    fn deref(&self) -> &serde_json::Value {
        &self.0
    }
}

impl std::ops::DerefMut for Ipv6Addr {
    fn deref_mut(&mut self) -> &mut serde_json::Value {
        &mut self.0
    }
}

impl FromStr for Ipv6Addr {
    type Err = serde_json::Error;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(Self(serde_json::from_str(s)?))
    }
}

/// String identifying an IPv6 address prefix formatted according to clause 4 of RFC 5952. IPv6Prefix data type may contain an individual /128 IPv6 address.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Ipv6Prefix(serde_json::Value);

impl std::convert::From<serde_json::Value> for Ipv6Prefix {
    fn from(x: serde_json::Value) -> Self {
        Ipv6Prefix(x)
    }
}

impl std::convert::From<Ipv6Prefix> for serde_json::Value {
    fn from(x: Ipv6Prefix) -> Self {
        x.0
    }
}

impl std::ops::Deref for Ipv6Prefix {
    type Target = serde_json::Value;
    fn deref(&self) -> &serde_json::Value {
        &self.0
    }
}

impl std::ops::DerefMut for Ipv6Prefix {
    fn deref_mut(&mut self) -> &mut serde_json::Value {
        &mut self.0
    }
}

impl FromStr for Ipv6Prefix {
    type Err = serde_json::Error;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(Self(serde_json::from_str(s)?))
    }
}

/// Range of IPv6 prefixes
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Ipv6PrefixRange {
    #[serde(rename = "start")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start: Option<models::Ipv6Prefix>,

    #[serde(rename = "end")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end: Option<models::Ipv6Prefix>,
}

impl Ipv6PrefixRange {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Ipv6PrefixRange {
        Ipv6PrefixRange {
            start: None,
            end: None,
        }
    }
}

/// Converts the Ipv6PrefixRange value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Ipv6PrefixRange {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping start in query parameter serialization

            // Skipping end in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Ipv6PrefixRange value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Ipv6PrefixRange {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub start: Vec<models::Ipv6Prefix>,
            pub end: Vec<models::Ipv6Prefix>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Ipv6PrefixRange".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "start" => intermediate_rep.start.push(
                        <models::Ipv6Prefix as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "end" => intermediate_rep.end.push(
                        <models::Ipv6Prefix as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Ipv6PrefixRange".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Ipv6PrefixRange {
            start: intermediate_rep.start.into_iter().next(),
            end: intermediate_rep.end.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Ipv6PrefixRange> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Ipv6PrefixRange>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Ipv6PrefixRange>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Ipv6PrefixRange - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<Ipv6PrefixRange>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <Ipv6PrefixRange as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into Ipv6PrefixRange - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Information of an SMS-IWMSC NF Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IwmscInfo {
    #[serde(rename = "msisdnRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub msisdn_ranges: Option<Vec<models::IdentityRange>>,

    #[serde(rename = "supiRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supi_ranges: Option<Vec<models::SupiRange>>,

    #[serde(rename = "taiRangeList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tai_range_list: Option<Vec<models::TaiRange>>,

    #[serde(rename = "scNumber")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sc_number: Option<String>,
}

impl IwmscInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> IwmscInfo {
        IwmscInfo {
            msisdn_ranges: None,
            supi_ranges: None,
            tai_range_list: None,
            sc_number: None,
        }
    }
}

/// Converts the IwmscInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for IwmscInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping msisdnRanges in query parameter serialization

            // Skipping supiRanges in query parameter serialization

            // Skipping taiRangeList in query parameter serialization
            self.sc_number
                .as_ref()
                .map(|sc_number| vec!["scNumber".to_string(), sc_number.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IwmscInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IwmscInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub msisdn_ranges: Vec<Vec<models::IdentityRange>>,
            pub supi_ranges: Vec<Vec<models::SupiRange>>,
            pub tai_range_list: Vec<Vec<models::TaiRange>>,
            pub sc_number: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing IwmscInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "msisdnRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in IwmscInfo"
                                .to_string(),
                        )
                    }
                    "supiRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in IwmscInfo"
                                .to_string(),
                        )
                    }
                    "taiRangeList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in IwmscInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "scNumber" => intermediate_rep.sc_number.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing IwmscInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IwmscInfo {
            msisdn_ranges: intermediate_rep.msisdn_ranges.into_iter().next(),
            supi_ranges: intermediate_rep.supi_ranges.into_iter().next(),
            tai_range_list: intermediate_rep.tai_range_list.into_iter().next(),
            sc_number: intermediate_rep.sc_number.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IwmscInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<IwmscInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<IwmscInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for IwmscInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<IwmscInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <IwmscInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into IwmscInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// LMF identification.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LmfIdentification(String);

impl std::convert::From<String> for LmfIdentification {
    fn from(x: String) -> Self {
        LmfIdentification(x)
    }
}

impl std::string::ToString for LmfIdentification {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for LmfIdentification {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(LmfIdentification(x.to_string()))
    }
}

impl std::convert::From<LmfIdentification> for String {
    fn from(x: LmfIdentification) -> Self {
        x.0
    }
}

impl std::ops::Deref for LmfIdentification {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for LmfIdentification {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Information of an LMF NF Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LmfInfo {
    #[serde(rename = "servingClientTypes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub serving_client_types: Option<Vec<models::ExternalClientType>>,

    /// LMF identification.
    #[serde(rename = "lmfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lmf_id: Option<String>,

    #[serde(rename = "servingAccessTypes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub serving_access_types: Option<Vec<models::AccessType>>,

    #[serde(rename = "servingAnNodeTypes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub serving_an_node_types: Option<Vec<models::AnNodeType>>,

    #[serde(rename = "servingRatTypes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub serving_rat_types: Option<Vec<models::RatType>>,

    #[serde(rename = "taiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tai_list: Option<Vec<models::Tai>>,

    #[serde(rename = "taiRangeList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tai_range_list: Option<Vec<models::TaiRange>>,

    #[serde(rename = "supportedGADShapes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_gad_shapes: Option<Vec<models::SupportedGadShapes>>,
}

impl LmfInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> LmfInfo {
        LmfInfo {
            serving_client_types: None,
            lmf_id: None,
            serving_access_types: None,
            serving_an_node_types: None,
            serving_rat_types: None,
            tai_list: None,
            tai_range_list: None,
            supported_gad_shapes: None,
        }
    }
}

/// Converts the LmfInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for LmfInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping servingClientTypes in query parameter serialization
            self.lmf_id
                .as_ref()
                .map(|lmf_id| vec!["lmfId".to_string(), lmf_id.to_string()].join(",")),
            // Skipping servingAccessTypes in query parameter serialization

            // Skipping servingAnNodeTypes in query parameter serialization

            // Skipping servingRatTypes in query parameter serialization

            // Skipping taiList in query parameter serialization

            // Skipping taiRangeList in query parameter serialization

            // Skipping supportedGADShapes in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LmfInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LmfInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub serving_client_types: Vec<Vec<models::ExternalClientType>>,
            pub lmf_id: Vec<String>,
            pub serving_access_types: Vec<Vec<models::AccessType>>,
            pub serving_an_node_types: Vec<Vec<models::AnNodeType>>,
            pub serving_rat_types: Vec<Vec<models::RatType>>,
            pub tai_list: Vec<Vec<models::Tai>>,
            pub tai_range_list: Vec<Vec<models::TaiRange>>,
            pub supported_gad_shapes: Vec<Vec<models::SupportedGadShapes>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing LmfInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "servingClientTypes" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in LmfInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "lmfId" => intermediate_rep.lmf_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "servingAccessTypes" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in LmfInfo"
                                .to_string(),
                        )
                    }
                    "servingAnNodeTypes" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in LmfInfo"
                                .to_string(),
                        )
                    }
                    "servingRatTypes" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in LmfInfo"
                                .to_string(),
                        )
                    }
                    "taiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in LmfInfo"
                                .to_string(),
                        )
                    }
                    "taiRangeList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in LmfInfo"
                                .to_string(),
                        )
                    }
                    "supportedGADShapes" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in LmfInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing LmfInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LmfInfo {
            serving_client_types: intermediate_rep.serving_client_types.into_iter().next(),
            lmf_id: intermediate_rep.lmf_id.into_iter().next(),
            serving_access_types: intermediate_rep.serving_access_types.into_iter().next(),
            serving_an_node_types: intermediate_rep.serving_an_node_types.into_iter().next(),
            serving_rat_types: intermediate_rep.serving_rat_types.into_iter().next(),
            tai_list: intermediate_rep.tai_list.into_iter().next(),
            tai_range_list: intermediate_rep.tai_range_list.into_iter().next(),
            supported_gad_shapes: intermediate_rep.supported_gad_shapes.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LmfInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<LmfInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<LmfInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for LmfInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<LmfInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <LmfInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into LmfInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Information of an MB-SMF NF Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MbSmfInfo {
    /// A map (list of key-value pairs) where a valid JSON string serves as key
    #[serde(rename = "sNssaiInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub s_nssai_info_list: Option<std::collections::HashMap<String, models::SnssaiMbSmfInfoItem>>,

    /// A map (list of key-value pairs) where a valid JSON string serves as key
    #[serde(rename = "tmgiRangeList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tmgi_range_list: Option<std::collections::HashMap<String, models::TmgiRange>>,

    #[serde(rename = "taiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tai_list: Option<Vec<models::Tai>>,

    #[serde(rename = "taiRangeList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tai_range_list: Option<Vec<models::TaiRange>>,

    /// A map (list of key-value pairs) where a valid JSON string serves as key
    #[serde(rename = "mbsSessionList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mbs_session_list: Option<std::collections::HashMap<String, models::MbsSession>>,
}

impl MbSmfInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> MbSmfInfo {
        MbSmfInfo {
            s_nssai_info_list: None,
            tmgi_range_list: None,
            tai_list: None,
            tai_range_list: None,
            mbs_session_list: None,
        }
    }
}

/// Converts the MbSmfInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MbSmfInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping sNssaiInfoList in query parameter serialization
            // Skipping sNssaiInfoList in query parameter serialization

            // Skipping tmgiRangeList in query parameter serialization
            // Skipping tmgiRangeList in query parameter serialization

            // Skipping taiList in query parameter serialization

            // Skipping taiRangeList in query parameter serialization

            // Skipping mbsSessionList in query parameter serialization
            // Skipping mbsSessionList in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MbSmfInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MbSmfInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub s_nssai_info_list:
                Vec<std::collections::HashMap<String, models::SnssaiMbSmfInfoItem>>,
            pub tmgi_range_list: Vec<std::collections::HashMap<String, models::TmgiRange>>,
            pub tai_list: Vec<Vec<models::Tai>>,
            pub tai_range_list: Vec<Vec<models::TaiRange>>,
            pub mbs_session_list: Vec<std::collections::HashMap<String, models::MbsSession>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing MbSmfInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "sNssaiInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in MbSmfInfo"
                                .to_string(),
                        )
                    }
                    "tmgiRangeList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in MbSmfInfo"
                                .to_string(),
                        )
                    }
                    "taiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in MbSmfInfo"
                                .to_string(),
                        )
                    }
                    "taiRangeList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in MbSmfInfo"
                                .to_string(),
                        )
                    }
                    "mbsSessionList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in MbSmfInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing MbSmfInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MbSmfInfo {
            s_nssai_info_list: intermediate_rep.s_nssai_info_list.into_iter().next(),
            tmgi_range_list: intermediate_rep.tmgi_range_list.into_iter().next(),
            tai_list: intermediate_rep.tai_list.into_iter().next(),
            tai_range_list: intermediate_rep.tai_range_list.into_iter().next(),
            mbs_session_list: intermediate_rep.mbs_session_list.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MbSmfInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MbSmfInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<MbSmfInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for MbSmfInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<MbSmfInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <MbSmfInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into MbSmfInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Information of an MB-UPF NF Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MbUpfInfo {
    #[serde(rename = "sNssaiMbUpfInfoList")]
    pub s_nssai_mb_upf_info_list: Vec<models::SnssaiUpfInfoItem>,

    #[serde(rename = "mbSmfServingArea")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mb_smf_serving_area: Option<Vec<String>>,

    #[serde(rename = "interfaceMbUpfInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub interface_mb_upf_info_list: Option<Vec<models::InterfaceUpfInfoItem>>,

    #[serde(rename = "taiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tai_list: Option<Vec<models::Tai>>,

    #[serde(rename = "taiRangeList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tai_range_list: Option<Vec<models::TaiRange>>,

    #[serde(rename = "priority")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority: Option<u16>,

    #[serde(rename = "supportedPfcpFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_pfcp_features: Option<String>,
}

impl MbUpfInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(s_nssai_mb_upf_info_list: Vec<models::SnssaiUpfInfoItem>) -> MbUpfInfo {
        MbUpfInfo {
            s_nssai_mb_upf_info_list,
            mb_smf_serving_area: None,
            interface_mb_upf_info_list: None,
            tai_list: None,
            tai_range_list: None,
            priority: None,
            supported_pfcp_features: None,
        }
    }
}

/// Converts the MbUpfInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MbUpfInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping sNssaiMbUpfInfoList in query parameter serialization
            self.mb_smf_serving_area
                .as_ref()
                .map(|mb_smf_serving_area| {
                    vec![
                        "mbSmfServingArea".to_string(),
                        mb_smf_serving_area
                            .iter()
                            .map(|x| x.to_string())
                            .collect::<Vec<_>>()
                            .join(","),
                    ]
                    .join(",")
                }),
            // Skipping interfaceMbUpfInfoList in query parameter serialization

            // Skipping taiList in query parameter serialization

            // Skipping taiRangeList in query parameter serialization
            self.priority
                .as_ref()
                .map(|priority| vec!["priority".to_string(), priority.to_string()].join(",")),
            self.supported_pfcp_features
                .as_ref()
                .map(|supported_pfcp_features| {
                    vec![
                        "supportedPfcpFeatures".to_string(),
                        supported_pfcp_features.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MbUpfInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MbUpfInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub s_nssai_mb_upf_info_list: Vec<Vec<models::SnssaiUpfInfoItem>>,
            pub mb_smf_serving_area: Vec<Vec<String>>,
            pub interface_mb_upf_info_list: Vec<Vec<models::InterfaceUpfInfoItem>>,
            pub tai_list: Vec<Vec<models::Tai>>,
            pub tai_range_list: Vec<Vec<models::TaiRange>>,
            pub priority: Vec<u16>,
            pub supported_pfcp_features: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing MbUpfInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "sNssaiMbUpfInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in MbUpfInfo"
                                .to_string(),
                        )
                    }
                    "mbSmfServingArea" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in MbUpfInfo"
                                .to_string(),
                        )
                    }
                    "interfaceMbUpfInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in MbUpfInfo"
                                .to_string(),
                        )
                    }
                    "taiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in MbUpfInfo"
                                .to_string(),
                        )
                    }
                    "taiRangeList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in MbUpfInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "priority" => intermediate_rep.priority.push(
                        <u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "supportedPfcpFeatures" => intermediate_rep.supported_pfcp_features.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing MbUpfInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MbUpfInfo {
            s_nssai_mb_upf_info_list: intermediate_rep
                .s_nssai_mb_upf_info_list
                .into_iter()
                .next()
                .ok_or_else(|| "sNssaiMbUpfInfoList missing in MbUpfInfo".to_string())?,
            mb_smf_serving_area: intermediate_rep.mb_smf_serving_area.into_iter().next(),
            interface_mb_upf_info_list: intermediate_rep
                .interface_mb_upf_info_list
                .into_iter()
                .next(),
            tai_list: intermediate_rep.tai_list.into_iter().next(),
            tai_range_list: intermediate_rep.tai_range_list.into_iter().next(),
            priority: intermediate_rep.priority.into_iter().next(),
            supported_pfcp_features: intermediate_rep.supported_pfcp_features.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MbUpfInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MbUpfInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<MbUpfInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for MbUpfInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<MbUpfInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <MbUpfInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into MbUpfInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// MBS Service Area
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MbsServiceArea {
    /// List of NR cell Ids
    #[serde(rename = "ncgiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ncgi_list: Option<Vec<models::NcgiTai>>,

    /// List of tracking area Ids
    #[serde(rename = "taiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tai_list: Option<Vec<models::Tai>>,
}

impl MbsServiceArea {
    #[allow(clippy::new_without_default)]
    pub fn new() -> MbsServiceArea {
        MbsServiceArea {
            ncgi_list: None,
            tai_list: None,
        }
    }
}

/// Converts the MbsServiceArea value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MbsServiceArea {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping ncgiList in query parameter serialization

            // Skipping taiList in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MbsServiceArea value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MbsServiceArea {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ncgi_list: Vec<Vec<models::NcgiTai>>,
            pub tai_list: Vec<Vec<models::Tai>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing MbsServiceArea".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "ncgiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in MbsServiceArea"
                                .to_string(),
                        )
                    }
                    "taiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in MbsServiceArea"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing MbsServiceArea".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MbsServiceArea {
            ncgi_list: intermediate_rep.ncgi_list.into_iter().next(),
            tai_list: intermediate_rep.tai_list.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MbsServiceArea> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MbsServiceArea>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<MbsServiceArea>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for MbsServiceArea - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<MbsServiceArea> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <MbsServiceArea as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into MbsServiceArea - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// MBS Service Area Information for location dependent MBS session
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MbsServiceAreaInfo {
    /// Integer where the allowed values correspond to the value range of an unsigned 16-bit integer.
    #[serde(rename = "areaSessionId")]
    pub area_session_id: u16,

    #[serde(rename = "mbsServiceArea")]
    pub mbs_service_area: models::MbsServiceArea,
}

impl MbsServiceAreaInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(
        area_session_id: u16,
        mbs_service_area: models::MbsServiceArea,
    ) -> MbsServiceAreaInfo {
        MbsServiceAreaInfo {
            area_session_id,
            mbs_service_area,
        }
    }
}

/// Converts the MbsServiceAreaInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MbsServiceAreaInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("areaSessionId".to_string()),
            Some(self.area_session_id.to_string()),
            // Skipping mbsServiceArea in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MbsServiceAreaInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MbsServiceAreaInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub area_session_id: Vec<u16>,
            pub mbs_service_area: Vec<models::MbsServiceArea>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing MbsServiceAreaInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "areaSessionId" => intermediate_rep.area_session_id.push(
                        <u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "mbsServiceArea" => intermediate_rep.mbs_service_area.push(
                        <models::MbsServiceArea as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing MbsServiceAreaInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MbsServiceAreaInfo {
            area_session_id: intermediate_rep
                .area_session_id
                .into_iter()
                .next()
                .ok_or_else(|| "areaSessionId missing in MbsServiceAreaInfo".to_string())?,
            mbs_service_area: intermediate_rep
                .mbs_service_area
                .into_iter()
                .next()
                .ok_or_else(|| "mbsServiceArea missing in MbsServiceAreaInfo".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MbsServiceAreaInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MbsServiceAreaInfo>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<MbsServiceAreaInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for MbsServiceAreaInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<MbsServiceAreaInfo>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <MbsServiceAreaInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into MbsServiceAreaInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// MBS Session currently served by an MB-SMF
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MbsSession {
    #[serde(rename = "mbsSessionId")]
    pub mbs_session_id: models::MbsSessionId,

    /// A map (list of key-value pairs) where the key identifies an areaSessionId
    #[serde(rename = "mbsAreaSessions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mbs_area_sessions: Option<std::collections::HashMap<String, models::MbsServiceAreaInfo>>,
}

impl MbsSession {
    #[allow(clippy::new_without_default)]
    pub fn new(mbs_session_id: models::MbsSessionId) -> MbsSession {
        MbsSession {
            mbs_session_id,
            mbs_area_sessions: None,
        }
    }
}

/// Converts the MbsSession value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MbsSession {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping mbsSessionId in query parameter serialization

            // Skipping mbsAreaSessions in query parameter serialization
            // Skipping mbsAreaSessions in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MbsSession value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MbsSession {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub mbs_session_id: Vec<models::MbsSessionId>,
            pub mbs_area_sessions:
                Vec<std::collections::HashMap<String, models::MbsServiceAreaInfo>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing MbsSession".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "mbsSessionId" => intermediate_rep.mbs_session_id.push(
                        <models::MbsSessionId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "mbsAreaSessions" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in MbsSession"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing MbsSession".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MbsSession {
            mbs_session_id: intermediate_rep
                .mbs_session_id
                .into_iter()
                .next()
                .ok_or_else(|| "mbsSessionId missing in MbsSession".to_string())?,
            mbs_area_sessions: intermediate_rep.mbs_area_sessions.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MbsSession> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MbsSession>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<MbsSession>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for MbsSession - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<MbsSession> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <MbsSession as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into MbsSession - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// MBS Session Identifier
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MbsSessionId {
    #[serde(rename = "tmgi")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tmgi: Option<models::Tmgi>,

    #[serde(rename = "ssm")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ssm: Option<models::Ssm>,

    /// This represents the Network Identifier, which together with a PLMN ID is used to identify an SNPN (see 3GPP TS 23.003 and 3GPP TS 23.501 clause 5.30.2.1).
    #[serde(rename = "nid")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nid: Option<String>,
}

impl MbsSessionId {
    #[allow(clippy::new_without_default)]
    pub fn new() -> MbsSessionId {
        MbsSessionId {
            tmgi: None,
            ssm: None,
            nid: None,
        }
    }
}

/// Converts the MbsSessionId value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MbsSessionId {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping tmgi in query parameter serialization

            // Skipping ssm in query parameter serialization
            self.nid
                .as_ref()
                .map(|nid| vec!["nid".to_string(), nid.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MbsSessionId value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MbsSessionId {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub tmgi: Vec<models::Tmgi>,
            pub ssm: Vec<models::Ssm>,
            pub nid: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing MbsSessionId".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "tmgi" => intermediate_rep.tmgi.push(
                        <models::Tmgi as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ssm" => intermediate_rep.ssm.push(
                        <models::Ssm as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nid" => intermediate_rep.nid.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing MbsSessionId".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MbsSessionId {
            tmgi: intermediate_rep.tmgi.into_iter().next(),
            ssm: intermediate_rep.ssm.into_iter().next(),
            nid: intermediate_rep.nid.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MbsSessionId> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MbsSessionId>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<MbsSessionId>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for MbsSessionId - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<MbsSessionId> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <MbsSessionId as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into MbsSessionId - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Mobile Country Code part of the PLMN, comprising 3 digits, as defined in clause 9.3.3.5 of 3GPP TS 38.413.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Mcc(String);

impl std::convert::From<String> for Mcc {
    fn from(x: String) -> Self {
        Mcc(x)
    }
}

impl std::string::ToString for Mcc {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Mcc {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Mcc(x.to_string()))
    }
}

impl std::convert::From<Mcc> for String {
    fn from(x: Mcc) -> Self {
        x.0
    }
}

impl std::ops::Deref for Mcc {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Mcc {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Information of a MFAF NF Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MfafInfo {
    #[serde(rename = "servingNfTypeList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub serving_nf_type_list: Option<Vec<models::NfType>>,

    #[serde(rename = "servingNfSetIdList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub serving_nf_set_id_list: Option<Vec<models::NfSetId>>,

    #[serde(rename = "taiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tai_list: Option<Vec<models::Tai>>,

    #[serde(rename = "taiRangeList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tai_range_list: Option<Vec<models::TaiRange>>,
}

impl MfafInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> MfafInfo {
        MfafInfo {
            serving_nf_type_list: None,
            serving_nf_set_id_list: None,
            tai_list: None,
            tai_range_list: None,
        }
    }
}

/// Converts the MfafInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MfafInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping servingNfTypeList in query parameter serialization
            self.serving_nf_set_id_list
                .as_ref()
                .map(|serving_nf_set_id_list| {
                    vec![
                        "servingNfSetIdList".to_string(),
                        serving_nf_set_id_list
                            .iter()
                            .map(|x| x.to_string())
                            .collect::<Vec<_>>()
                            .join(","),
                    ]
                    .join(",")
                }),
            // Skipping taiList in query parameter serialization

            // Skipping taiRangeList in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MfafInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MfafInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub serving_nf_type_list: Vec<Vec<models::NfType>>,
            pub serving_nf_set_id_list: Vec<Vec<models::NfSetId>>,
            pub tai_list: Vec<Vec<models::Tai>>,
            pub tai_range_list: Vec<Vec<models::TaiRange>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing MfafInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "servingNfTypeList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in MfafInfo"
                                .to_string(),
                        )
                    }
                    "servingNfSetIdList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in MfafInfo"
                                .to_string(),
                        )
                    }
                    "taiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in MfafInfo"
                                .to_string(),
                        )
                    }
                    "taiRangeList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in MfafInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing MfafInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MfafInfo {
            serving_nf_type_list: intermediate_rep.serving_nf_type_list.into_iter().next(),
            serving_nf_set_id_list: intermediate_rep.serving_nf_set_id_list.into_iter().next(),
            tai_list: intermediate_rep.tai_list.into_iter().next(),
            tai_range_list: intermediate_rep.tai_range_list.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MfafInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MfafInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<MfafInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for MfafInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<MfafInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <MfafInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into MfafInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// ML Analytics Filter information supported by the Nnwdaf_MLModelProvision service
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MlAnalyticsInfo {
    #[serde(rename = "mlAnalyticsIds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ml_analytics_ids: Option<Vec<models::NwdafEvent>>,

    #[serde(rename = "snssaiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub snssai_list: Option<Vec<models::Snssai>>,

    #[serde(rename = "trackingAreaList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tracking_area_list: Option<Vec<models::Tai>>,
}

impl MlAnalyticsInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> MlAnalyticsInfo {
        MlAnalyticsInfo {
            ml_analytics_ids: None,
            snssai_list: None,
            tracking_area_list: None,
        }
    }
}

/// Converts the MlAnalyticsInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MlAnalyticsInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping mlAnalyticsIds in query parameter serialization

            // Skipping snssaiList in query parameter serialization

            // Skipping trackingAreaList in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MlAnalyticsInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MlAnalyticsInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ml_analytics_ids: Vec<Vec<models::NwdafEvent>>,
            pub snssai_list: Vec<Vec<models::Snssai>>,
            pub tracking_area_list: Vec<Vec<models::Tai>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing MlAnalyticsInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "mlAnalyticsIds" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in MlAnalyticsInfo"
                                .to_string(),
                        )
                    }
                    "snssaiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in MlAnalyticsInfo"
                                .to_string(),
                        )
                    }
                    "trackingAreaList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in MlAnalyticsInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing MlAnalyticsInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MlAnalyticsInfo {
            ml_analytics_ids: intermediate_rep.ml_analytics_ids.into_iter().next(),
            snssai_list: intermediate_rep.snssai_list.into_iter().next(),
            tracking_area_list: intermediate_rep.tracking_area_list.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MlAnalyticsInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MlAnalyticsInfo>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<MlAnalyticsInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for MlAnalyticsInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<MlAnalyticsInfo>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <MlAnalyticsInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into MlAnalyticsInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Mobile Network Code part of the PLMN, comprising 2 or 3 digits, as defined in clause 9.3.3.5 of 3GPP TS 38.413.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Mnc(String);

impl std::convert::From<String> for Mnc {
    fn from(x: String) -> Self {
        Mnc(x)
    }
}

impl std::string::ToString for Mnc {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Mnc {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Mnc(x.to_string()))
    }
}

impl std::convert::From<Mnc> for String {
    fn from(x: Mnc) -> Self {
        x.0
    }
}

impl std::ops::Deref for Mnc {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Mnc {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Information of an MNPF Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MnpfInfo {
    #[serde(rename = "msisdnRanges")]
    pub msisdn_ranges: Vec<models::IdentityRange>,
}

impl MnpfInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(msisdn_ranges: Vec<models::IdentityRange>) -> MnpfInfo {
        MnpfInfo { msisdn_ranges }
    }
}

/// Converts the MnpfInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MnpfInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping msisdnRanges in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MnpfInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MnpfInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub msisdn_ranges: Vec<Vec<models::IdentityRange>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing MnpfInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "msisdnRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in MnpfInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing MnpfInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MnpfInfo {
            msisdn_ranges: intermediate_rep
                .msisdn_ranges
                .into_iter()
                .next()
                .ok_or_else(|| "msisdnRanges missing in MnpfInfo".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MnpfInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MnpfInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<MnpfInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for MnpfInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<MnpfInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <MnpfInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into MnpfInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration for N1 Message Class
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct N1MessageClass {}

impl N1MessageClass {
    #[allow(clippy::new_without_default)]
    pub fn new() -> N1MessageClass {
        N1MessageClass {}
    }
}

/// Converts the N1MessageClass value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for N1MessageClass {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a N1MessageClass value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for N1MessageClass {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing N1MessageClass".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing N1MessageClass".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(N1MessageClass {})
    }
}

// Methods for converting between header::IntoHeaderValue<N1MessageClass> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<N1MessageClass>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<N1MessageClass>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for N1MessageClass - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<N1MessageClass> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <N1MessageClass as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into N1MessageClass - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum N1MessageClassAnyOf {
    #[serde(rename = "5GMM")]
    Variant5Gmm,
    #[serde(rename = "SM")]
    Sm,
    #[serde(rename = "LPP")]
    Lpp,
    #[serde(rename = "SMS")]
    Sms,
    #[serde(rename = "UPDP")]
    Updp,
    #[serde(rename = "LCS")]
    Lcs,
}

impl std::fmt::Display for N1MessageClassAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            N1MessageClassAnyOf::Variant5Gmm => write!(f, "5GMM"),
            N1MessageClassAnyOf::Sm => write!(f, "SM"),
            N1MessageClassAnyOf::Lpp => write!(f, "LPP"),
            N1MessageClassAnyOf::Sms => write!(f, "SMS"),
            N1MessageClassAnyOf::Updp => write!(f, "UPDP"),
            N1MessageClassAnyOf::Lcs => write!(f, "LCS"),
        }
    }
}

impl std::str::FromStr for N1MessageClassAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "5GMM" => std::result::Result::Ok(N1MessageClassAnyOf::Variant5Gmm),
            "SM" => std::result::Result::Ok(N1MessageClassAnyOf::Sm),
            "LPP" => std::result::Result::Ok(N1MessageClassAnyOf::Lpp),
            "SMS" => std::result::Result::Ok(N1MessageClassAnyOf::Sms),
            "UPDP" => std::result::Result::Ok(N1MessageClassAnyOf::Updp),
            "LCS" => std::result::Result::Ok(N1MessageClassAnyOf::Lcs),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Enumeration for N2 Information Class
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct N2InformationClass {}

impl N2InformationClass {
    #[allow(clippy::new_without_default)]
    pub fn new() -> N2InformationClass {
        N2InformationClass {}
    }
}

/// Converts the N2InformationClass value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for N2InformationClass {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a N2InformationClass value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for N2InformationClass {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing N2InformationClass".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing N2InformationClass".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(N2InformationClass {})
    }
}

// Methods for converting between header::IntoHeaderValue<N2InformationClass> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<N2InformationClass>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<N2InformationClass>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for N2InformationClass - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<N2InformationClass>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <N2InformationClass as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into N2InformationClass - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum N2InformationClassAnyOf {
    #[serde(rename = "SM")]
    Sm,
    #[serde(rename = "NRPPa")]
    Nrppa,
    #[serde(rename = "PWS")]
    Pws,
    #[serde(rename = "PWS-BCAL")]
    PwsBcal,
    #[serde(rename = "PWS-RF")]
    PwsRf,
    #[serde(rename = "RAN")]
    Ran,
    #[serde(rename = "V2X")]
    V2X,
    #[serde(rename = "PROSE")]
    Prose,
}

impl std::fmt::Display for N2InformationClassAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            N2InformationClassAnyOf::Sm => write!(f, "SM"),
            N2InformationClassAnyOf::Nrppa => write!(f, "NRPPa"),
            N2InformationClassAnyOf::Pws => write!(f, "PWS"),
            N2InformationClassAnyOf::PwsBcal => write!(f, "PWS-BCAL"),
            N2InformationClassAnyOf::PwsRf => write!(f, "PWS-RF"),
            N2InformationClassAnyOf::Ran => write!(f, "RAN"),
            N2InformationClassAnyOf::V2X => write!(f, "V2X"),
            N2InformationClassAnyOf::Prose => write!(f, "PROSE"),
        }
    }
}

impl std::str::FromStr for N2InformationClassAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "SM" => std::result::Result::Ok(N2InformationClassAnyOf::Sm),
            "NRPPa" => std::result::Result::Ok(N2InformationClassAnyOf::Nrppa),
            "PWS" => std::result::Result::Ok(N2InformationClassAnyOf::Pws),
            "PWS-BCAL" => std::result::Result::Ok(N2InformationClassAnyOf::PwsBcal),
            "PWS-RF" => std::result::Result::Ok(N2InformationClassAnyOf::PwsRf),
            "RAN" => std::result::Result::Ok(N2InformationClassAnyOf::Ran),
            "V2X" => std::result::Result::Ok(N2InformationClassAnyOf::V2X),
            "PROSE" => std::result::Result::Ok(N2InformationClassAnyOf::Prose),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// AMF N2 interface information
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct N2InterfaceAmfInfo {
    #[serde(rename = "ipv4EndpointAddress")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv4_endpoint_address: Option<Vec<models::Ipv4Addr>>,

    #[serde(rename = "ipv6EndpointAddress")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_endpoint_address: Option<Vec<models::Ipv6Addr>>,

    /// Fully Qualified Domain Name
    #[serde(rename = "amfName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub amf_name: Option<String>,
}

impl N2InterfaceAmfInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> N2InterfaceAmfInfo {
        N2InterfaceAmfInfo {
            ipv4_endpoint_address: None,
            ipv6_endpoint_address: None,
            amf_name: None,
        }
    }
}

/// Converts the N2InterfaceAmfInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for N2InterfaceAmfInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.ipv4_endpoint_address
                .as_ref()
                .map(|ipv4_endpoint_address| {
                    vec![
                        "ipv4EndpointAddress".to_string(),
                        ipv4_endpoint_address
                            .iter()
                            .map(|x| x.to_string())
                            .collect::<Vec<_>>()
                            .join(","),
                    ]
                    .join(",")
                }),
            // Skipping ipv6EndpointAddress in query parameter serialization
            self.amf_name
                .as_ref()
                .map(|amf_name| vec!["amfName".to_string(), amf_name.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a N2InterfaceAmfInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for N2InterfaceAmfInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ipv4_endpoint_address: Vec<Vec<models::Ipv4Addr>>,
            pub ipv6_endpoint_address: Vec<Vec<models::Ipv6Addr>>,
            pub amf_name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing N2InterfaceAmfInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "ipv4EndpointAddress" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in N2InterfaceAmfInfo"
                            .to_string(),
                    ),
                    "ipv6EndpointAddress" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in N2InterfaceAmfInfo"
                            .to_string(),
                    ),
                    #[allow(clippy::redundant_clone)]
                    "amfName" => intermediate_rep.amf_name.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing N2InterfaceAmfInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(N2InterfaceAmfInfo {
            ipv4_endpoint_address: intermediate_rep.ipv4_endpoint_address.into_iter().next(),
            ipv6_endpoint_address: intermediate_rep.ipv6_endpoint_address.into_iter().next(),
            amf_name: intermediate_rep.amf_name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<N2InterfaceAmfInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<N2InterfaceAmfInfo>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<N2InterfaceAmfInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for N2InterfaceAmfInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<N2InterfaceAmfInfo>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <N2InterfaceAmfInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into N2InterfaceAmfInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains the NCGI (NR Cell Global Identity), as described in 3GPP 23.003
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Ncgi {
    #[serde(rename = "plmnId")]
    pub plmn_id: models::PlmnId,

    /// 36-bit string identifying an NR Cell Id as specified in clause 9.3.1.7 of 3GPP TS 38.413,  in hexadecimal representation. Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character  representing the 4 most significant bits of the Cell Id shall appear first in the string, and  the character representing the 4 least significant bit of the Cell Id shall appear last in the  string.
    #[serde(rename = "nrCellId")]
    pub nr_cell_id: String,

    /// This represents the Network Identifier, which together with a PLMN ID is used to identify an SNPN (see 3GPP TS 23.003 and 3GPP TS 23.501 clause 5.30.2.1).
    #[serde(rename = "nid")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nid: Option<String>,
}

impl Ncgi {
    #[allow(clippy::new_without_default)]
    pub fn new(plmn_id: models::PlmnId, nr_cell_id: String) -> Ncgi {
        Ncgi {
            plmn_id,
            nr_cell_id,
            nid: None,
        }
    }
}

/// Converts the Ncgi value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Ncgi {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping plmnId in query parameter serialization
            Some("nrCellId".to_string()),
            Some(self.nr_cell_id.to_string()),
            self.nid
                .as_ref()
                .map(|nid| vec!["nid".to_string(), nid.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Ncgi value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Ncgi {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub plmn_id: Vec<models::PlmnId>,
            pub nr_cell_id: Vec<String>,
            pub nid: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err("Missing value while parsing Ncgi".to_string())
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "plmnId" => intermediate_rep.plmn_id.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nrCellId" => intermediate_rep.nr_cell_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nid" => intermediate_rep.nid.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Ncgi".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Ncgi {
            plmn_id: intermediate_rep
                .plmn_id
                .into_iter()
                .next()
                .ok_or_else(|| "plmnId missing in Ncgi".to_string())?,
            nr_cell_id: intermediate_rep
                .nr_cell_id
                .into_iter()
                .next()
                .ok_or_else(|| "nrCellId missing in Ncgi".to_string())?,
            nid: intermediate_rep.nid.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Ncgi> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Ncgi>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Ncgi>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Ncgi - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Ncgi> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Ncgi as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Ncgi - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// List of NR cell ids, with their pertaining TAIs
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NcgiTai {
    #[serde(rename = "tai")]
    pub tai: models::Tai,

    /// List of List of NR cell ids
    #[serde(rename = "cellList")]
    pub cell_list: Vec<models::Ncgi>,
}

impl NcgiTai {
    #[allow(clippy::new_without_default)]
    pub fn new(tai: models::Tai, cell_list: Vec<models::Ncgi>) -> NcgiTai {
        NcgiTai { tai, cell_list }
    }
}

/// Converts the NcgiTai value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NcgiTai {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping tai in query parameter serialization

            // Skipping cellList in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NcgiTai value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NcgiTai {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub tai: Vec<models::Tai>,
            pub cell_list: Vec<Vec<models::Ncgi>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NcgiTai".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "tai" => intermediate_rep.tai.push(
                        <models::Tai as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "cellList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NcgiTai"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NcgiTai".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NcgiTai {
            tai: intermediate_rep
                .tai
                .into_iter()
                .next()
                .ok_or_else(|| "tai missing in NcgiTai".to_string())?,
            cell_list: intermediate_rep
                .cell_list
                .into_iter()
                .next()
                .ok_or_else(|| "cellList missing in NcgiTai".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NcgiTai> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NcgiTai>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NcgiTai>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NcgiTai - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<NcgiTai> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NcgiTai as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NcgiTai - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Identity of the NEF
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NefId(String);

impl std::convert::From<String> for NefId {
    fn from(x: String) -> Self {
        NefId(x)
    }
}

impl std::string::ToString for NefId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for NefId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(NefId(x.to_string()))
    }
}

impl std::convert::From<NefId> for String {
    fn from(x: NefId) -> Self {
        x.0
    }
}

impl std::ops::Deref for NefId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for NefId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Information of an NEF NF Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NefInfo {
    /// Identity of the NEF
    #[serde(rename = "nefId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nef_id: Option<String>,

    #[serde(rename = "pfdData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pfd_data: Option<models::PfdData>,

    #[serde(rename = "afEeData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub af_ee_data: Option<models::AfEventExposureData>,

    #[serde(rename = "gpsiRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gpsi_ranges: Option<Vec<models::IdentityRange>>,

    #[serde(rename = "externalGroupIdentifiersRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub external_group_identifiers_ranges: Option<Vec<models::IdentityRange>>,

    #[serde(rename = "servedFqdnList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub served_fqdn_list: Option<Vec<String>>,

    #[serde(rename = "taiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tai_list: Option<Vec<models::Tai>>,

    #[serde(rename = "taiRangeList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tai_range_list: Option<Vec<models::TaiRange>>,

    #[serde(rename = "dnaiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dnai_list: Option<Vec<models::Dnai>>,

    #[serde(rename = "unTrustAfInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub un_trust_af_info_list: Option<Vec<models::UnTrustAfInfo>>,

    #[serde(rename = "uasNfFunctionalityInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub uas_nf_functionality_ind: Option<bool>,
}

impl NefInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> NefInfo {
        NefInfo {
            nef_id: None,
            pfd_data: None,
            af_ee_data: None,
            gpsi_ranges: None,
            external_group_identifiers_ranges: None,
            served_fqdn_list: None,
            tai_list: None,
            tai_range_list: None,
            dnai_list: None,
            un_trust_af_info_list: None,
            uas_nf_functionality_ind: Some(false),
        }
    }
}

/// Converts the NefInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NefInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.nef_id
                .as_ref()
                .map(|nef_id| vec!["nefId".to_string(), nef_id.to_string()].join(",")),
            // Skipping pfdData in query parameter serialization

            // Skipping afEeData in query parameter serialization

            // Skipping gpsiRanges in query parameter serialization

            // Skipping externalGroupIdentifiersRanges in query parameter serialization
            self.served_fqdn_list.as_ref().map(|served_fqdn_list| {
                vec![
                    "servedFqdnList".to_string(),
                    served_fqdn_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping taiList in query parameter serialization

            // Skipping taiRangeList in query parameter serialization
            self.dnai_list.as_ref().map(|dnai_list| {
                vec![
                    "dnaiList".to_string(),
                    dnai_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping unTrustAfInfoList in query parameter serialization
            self.uas_nf_functionality_ind
                .as_ref()
                .map(|uas_nf_functionality_ind| {
                    vec![
                        "uasNfFunctionalityInd".to_string(),
                        uas_nf_functionality_ind.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NefInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NefInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub nef_id: Vec<String>,
            pub pfd_data: Vec<models::PfdData>,
            pub af_ee_data: Vec<models::AfEventExposureData>,
            pub gpsi_ranges: Vec<Vec<models::IdentityRange>>,
            pub external_group_identifiers_ranges: Vec<Vec<models::IdentityRange>>,
            pub served_fqdn_list: Vec<Vec<String>>,
            pub tai_list: Vec<Vec<models::Tai>>,
            pub tai_range_list: Vec<Vec<models::TaiRange>>,
            pub dnai_list: Vec<Vec<models::Dnai>>,
            pub un_trust_af_info_list: Vec<Vec<models::UnTrustAfInfo>>,
            pub uas_nf_functionality_ind: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NefInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "nefId" => intermediate_rep.nef_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "pfdData" => intermediate_rep.pfd_data.push(
                        <models::PfdData as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "afEeData" => intermediate_rep.af_ee_data.push(
                        <models::AfEventExposureData as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "gpsiRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NefInfo"
                                .to_string(),
                        )
                    }
                    "externalGroupIdentifiersRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NefInfo"
                                .to_string(),
                        )
                    }
                    "servedFqdnList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NefInfo"
                                .to_string(),
                        )
                    }
                    "taiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NefInfo"
                                .to_string(),
                        )
                    }
                    "taiRangeList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NefInfo"
                                .to_string(),
                        )
                    }
                    "dnaiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NefInfo"
                                .to_string(),
                        )
                    }
                    "unTrustAfInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NefInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "uasNfFunctionalityInd" => intermediate_rep.uas_nf_functionality_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NefInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NefInfo {
            nef_id: intermediate_rep.nef_id.into_iter().next(),
            pfd_data: intermediate_rep.pfd_data.into_iter().next(),
            af_ee_data: intermediate_rep.af_ee_data.into_iter().next(),
            gpsi_ranges: intermediate_rep.gpsi_ranges.into_iter().next(),
            external_group_identifiers_ranges: intermediate_rep
                .external_group_identifiers_ranges
                .into_iter()
                .next(),
            served_fqdn_list: intermediate_rep.served_fqdn_list.into_iter().next(),
            tai_list: intermediate_rep.tai_list.into_iter().next(),
            tai_range_list: intermediate_rep.tai_range_list.into_iter().next(),
            dnai_list: intermediate_rep.dnai_list.into_iter().next(),
            un_trust_af_info_list: intermediate_rep.un_trust_af_info_list.into_iter().next(),
            uas_nf_functionality_ind: intermediate_rep.uas_nf_functionality_ind.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NefInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NefInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NefInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NefInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<NefInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NefInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NefInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NetworkNodeDiameterAddress {
    /// Fully Qualified Domain Name
    #[serde(rename = "name")]
    pub name: String,

    /// Fully Qualified Domain Name
    #[serde(rename = "realm")]
    pub realm: String,
}

impl NetworkNodeDiameterAddress {
    #[allow(clippy::new_without_default)]
    pub fn new(name: String, realm: String) -> NetworkNodeDiameterAddress {
        NetworkNodeDiameterAddress { name, realm }
    }
}

/// Converts the NetworkNodeDiameterAddress value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NetworkNodeDiameterAddress {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("name".to_string()),
            Some(self.name.to_string()),
            Some("realm".to_string()),
            Some(self.realm.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NetworkNodeDiameterAddress value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NetworkNodeDiameterAddress {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub realm: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NetworkNodeDiameterAddress".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "realm" => intermediate_rep.realm.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NetworkNodeDiameterAddress".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NetworkNodeDiameterAddress {
            name: intermediate_rep
                .name
                .into_iter()
                .next()
                .ok_or_else(|| "name missing in NetworkNodeDiameterAddress".to_string())?,
            realm: intermediate_rep
                .realm
                .into_iter()
                .next()
                .ok_or_else(|| "realm missing in NetworkNodeDiameterAddress".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NetworkNodeDiameterAddress> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NetworkNodeDiameterAddress>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NetworkNodeDiameterAddress>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NetworkNodeDiameterAddress - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<NetworkNodeDiameterAddress>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NetworkNodeDiameterAddress as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NetworkNodeDiameterAddress - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Identifier of a group of NFs.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NfGroupId(String);

impl std::convert::From<String> for NfGroupId {
    fn from(x: String) -> Self {
        NfGroupId(x)
    }
}

impl std::string::ToString for NfGroupId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for NfGroupId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(NfGroupId(x.to_string()))
    }
}

impl std::convert::From<NfGroupId> for String {
    fn from(x: NfGroupId) -> Self {
        x.0
    }
}

impl std::ops::Deref for NfGroupId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for NfGroupId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize, Display)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NfInstanceId(uuid::Uuid);

impl std::convert::From<uuid::Uuid> for NfInstanceId {
    fn from(x: uuid::Uuid) -> Self {
        NfInstanceId(x)
    }
}

impl std::convert::From<NfInstanceId> for uuid::Uuid {
    fn from(x: NfInstanceId) -> Self {
        x.0
    }
}

impl std::ops::Deref for NfInstanceId {
    type Target = uuid::Uuid;
    fn deref(&self) -> &uuid::Uuid {
        &self.0
    }
}

impl std::ops::DerefMut for NfInstanceId {
    fn deref_mut(&mut self) -> &mut uuid::Uuid {
        &mut self.0
    }
}

impl FromStr for NfInstanceId {
    type Err = uuid::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(NfInstanceId(uuid::Uuid::parse_str(s)?))
    }
}

/// Contains information on an NF profile matching a discovery request
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NfInstanceInfo {
    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "nrfDiscApiUri")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nrf_disc_api_uri: Option<String>,

    #[serde(rename = "preferredSearch")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub preferred_search: Option<models::PreferredSearch>,

    /// The key of the map is the JSON Pointer of the priority IE in the NFProfile data type that is altered by the NRF
    #[serde(rename = "nrfAlteredPriorities")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nrf_altered_priorities: Option<std::collections::HashMap<String, i32>>,
}

impl NfInstanceInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> NfInstanceInfo {
        NfInstanceInfo {
            nrf_disc_api_uri: None,
            preferred_search: None,
            nrf_altered_priorities: None,
        }
    }
}

/// Converts the NfInstanceInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NfInstanceInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.nrf_disc_api_uri.as_ref().map(|nrf_disc_api_uri| {
                vec!["nrfDiscApiUri".to_string(), nrf_disc_api_uri.to_string()].join(",")
            }),
            // Skipping preferredSearch in query parameter serialization

            // Skipping nrfAlteredPriorities in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NfInstanceInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NfInstanceInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub nrf_disc_api_uri: Vec<String>,
            pub preferred_search: Vec<models::PreferredSearch>,
            pub nrf_altered_priorities: Vec<std::collections::HashMap<String, i32>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NfInstanceInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "nrfDiscApiUri" => intermediate_rep.nrf_disc_api_uri.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "preferredSearch" => intermediate_rep.preferred_search.push(
                        <models::PreferredSearch as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "nrfAlteredPriorities" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfInstanceInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NfInstanceInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NfInstanceInfo {
            nrf_disc_api_uri: intermediate_rep.nrf_disc_api_uri.into_iter().next(),
            preferred_search: intermediate_rep.preferred_search.into_iter().next(),
            nrf_altered_priorities: intermediate_rep.nrf_altered_priorities.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NfInstanceInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NfInstanceInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NfInstanceInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NfInstanceInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<NfInstanceInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NfInstanceInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NfInstanceInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Information of an NF Instance discovered by the NRF
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NfProfile {
    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "nfInstanceId")]
    pub nf_instance_id: uuid::Uuid,

    #[serde(rename = "nfInstanceName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nf_instance_name: Option<String>,

    #[serde(rename = "nfType")]
    pub nf_type: models::NfType,

    #[serde(rename = "nfStatus")]
    pub nf_status: models::NfStatus,

    #[serde(rename = "collocatedNfInstances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub collocated_nf_instances: Option<Vec<models::CollocatedNfInstance>>,

    #[serde(rename = "plmnList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub plmn_list: Option<Vec<models::PlmnId>>,

    #[serde(rename = "sNssais")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub s_nssais: Option<Vec<models::ExtSnssai>>,

    #[serde(rename = "perPlmnSnssaiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub per_plmn_snssai_list: Option<Vec<models::PlmnSnssai>>,

    #[serde(rename = "nsiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nsi_list: Option<Vec<String>>,

    /// Fully Qualified Domain Name
    #[serde(rename = "fqdn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fqdn: Option<String>,

    /// Fully Qualified Domain Name
    #[serde(rename = "interPlmnFqdn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub inter_plmn_fqdn: Option<String>,

    #[serde(rename = "ipv4Addresses")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv4_addresses: Option<Vec<models::Ipv4Addr>>,

    #[serde(rename = "ipv6Addresses")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_addresses: Option<Vec<models::Ipv6Addr>>,

    #[serde(rename = "capacity")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub capacity: Option<u16>,

    #[serde(rename = "load")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub load: Option<u8>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "loadTimeStamp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub load_time_stamp: Option<chrono::DateTime<chrono::Utc>>,

    #[serde(rename = "locality")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub locality: Option<String>,

    #[serde(rename = "priority")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority: Option<u16>,

    #[serde(rename = "udrInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub udr_info: Option<models::UdrInfo>,

    /// A map (list of key-value pairs) where a (unique) valid JSON string serves as key of UdrInfo
    #[serde(rename = "udrInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub udr_info_list: Option<std::collections::HashMap<String, models::UdrInfo>>,

    #[serde(rename = "udmInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub udm_info: Option<models::UdmInfo>,

    /// A map (list of key-value pairs) where a (unique) valid JSON string serves as key of UdmInfo
    #[serde(rename = "udmInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub udm_info_list: Option<std::collections::HashMap<String, models::UdmInfo>>,

    #[serde(rename = "ausfInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ausf_info: Option<models::AusfInfo>,

    /// A map (list of key-value pairs) where a (unique) valid JSON string serves as key of AusfInfo
    #[serde(rename = "ausfInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ausf_info_list: Option<std::collections::HashMap<String, models::AusfInfo>>,

    #[serde(rename = "amfInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub amf_info: Option<models::AmfInfo>,

    /// A map (list of key-value pairs) where a (unique) valid JSON string serves as key of AmfInfo
    #[serde(rename = "amfInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub amf_info_list: Option<std::collections::HashMap<String, models::AmfInfo>>,

    #[serde(rename = "smfInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub smf_info: Option<models::SmfInfo>,

    /// A map (list of key-value pairs) where a (unique) valid JSON string serves as key of SmfInfo
    #[serde(rename = "smfInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub smf_info_list: Option<std::collections::HashMap<String, models::SmfInfo>>,

    #[serde(rename = "upfInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub upf_info: Option<models::UpfInfo>,

    /// A map (list of key-value pairs) where a (unique) valid JSON string serves as key of UpfInfo
    #[serde(rename = "upfInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub upf_info_list: Option<std::collections::HashMap<String, models::UpfInfo>>,

    #[serde(rename = "pcfInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pcf_info: Option<models::PcfInfo>,

    /// A map (list of key-value pairs) where a (unique) valid JSON string serves as key of PcfInfo
    #[serde(rename = "pcfInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pcf_info_list: Option<std::collections::HashMap<String, models::PcfInfo>>,

    #[serde(rename = "bsfInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bsf_info: Option<models::BsfInfo>,

    /// A map (list of key-value pairs) where a (unique) valid JSON string serves as key of BsfInfo
    #[serde(rename = "bsfInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bsf_info_list: Option<std::collections::HashMap<String, models::BsfInfo>>,

    #[serde(rename = "chfInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub chf_info: Option<models::ChfInfo>,

    /// A map (list of key-value pairs) where a (unique) valid JSON string serves as key of ChfInfo
    #[serde(rename = "chfInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub chf_info_list: Option<std::collections::HashMap<String, models::ChfInfo>>,

    #[serde(rename = "udsfInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub udsf_info: Option<models::UdsfInfo>,

    /// A map (list of key-value pairs) where a (unique) valid JSON string serves as key of UdsfInfo
    #[serde(rename = "udsfInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub udsf_info_list: Option<std::collections::HashMap<String, models::UdsfInfo>>,

    #[serde(rename = "nwdafInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nwdaf_info: Option<models::NwdafInfo>,

    /// A map (list of key-value pairs) where a (unique) valid JSON string serves as key of NwdafInfo
    #[serde(rename = "nwdafInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nwdaf_info_list: Option<std::collections::HashMap<String, models::NwdafInfo>>,

    #[serde(rename = "nefInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nef_info: Option<models::NefInfo>,

    /// A map (list of key-value pairs) where a (unique) valid JSON string serves as key of PcscfInfo
    #[serde(rename = "pcscfInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pcscf_info_list: Option<std::collections::HashMap<String, models::PcscfInfo>>,

    /// A map (list of key-value pairs) where a (unique) valid JSON string serves as key of HssInfo
    #[serde(rename = "hssInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hss_info_list: Option<std::collections::HashMap<String, models::HssInfo>>,

    #[serde(rename = "customInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub custom_info: Option<serde_json::Value>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "recoveryTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recovery_time: Option<chrono::DateTime<chrono::Utc>>,

    #[serde(rename = "nfServicePersistence")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nf_service_persistence: Option<bool>,

    #[serde(rename = "nfServices")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nf_services: Option<Vec<models::NfService>>,

    /// A map (list of key-value pairs) where serviceInstanceId serves as key of NFService
    #[serde(rename = "nfServiceList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nf_service_list: Option<std::collections::HashMap<String, models::NfService>>,

    #[serde(rename = "defaultNotificationSubscriptions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_notification_subscriptions: Option<Vec<models::DefaultNotificationSubscription>>,

    #[serde(rename = "lmfInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lmf_info: Option<models::LmfInfo>,

    #[serde(rename = "gmlcInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gmlc_info: Option<models::GmlcInfo>,

    #[serde(rename = "snpnList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub snpn_list: Option<Vec<models::PlmnIdNid>>,

    #[serde(rename = "nfSetIdList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nf_set_id_list: Option<Vec<models::NfSetId>>,

    #[serde(rename = "servingScope")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub serving_scope: Option<Vec<String>>,

    #[serde(rename = "lcHSupportInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lc_h_support_ind: Option<bool>,

    #[serde(rename = "olcHSupportInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub olc_h_support_ind: Option<bool>,

    /// A map (list of key-value pairs) where NfSetId serves as key of DateTime
    #[serde(rename = "nfSetRecoveryTimeList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nf_set_recovery_time_list: Option<std::collections::HashMap<String, models::DateTime>>,

    /// A map (list of key-value pairs) where NfServiceSetId serves as key of DateTime
    #[serde(rename = "serviceSetRecoveryTimeList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_set_recovery_time_list: Option<std::collections::HashMap<String, models::DateTime>>,

    #[serde(rename = "scpDomains")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scp_domains: Option<Vec<String>>,

    #[serde(rename = "scpInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scp_info: Option<models::ScpInfo>,

    #[serde(rename = "seppInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sepp_info: Option<models::SeppInfo>,

    /// Vendor ID of the NF Service instance (Private Enterprise Number assigned by IANA)
    #[serde(rename = "vendorId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub vendor_id: Option<String>,

    /// The key of the map is the IANA-assigned SMI Network Management Private Enterprise Codes
    #[serde(rename = "supportedVendorSpecificFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_vendor_specific_features:
        Option<std::collections::HashMap<String, Vec<models::VendorSpecificFeature>>>,

    /// A map (list of key-value pairs) where a (unique) valid JSON string serves as key of AanfInfo
    #[serde(rename = "aanfInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aanf_info_list: Option<std::collections::HashMap<String, models::AanfInfo>>,

    #[serde(rename = "mfafInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mfaf_info: Option<models::MfafInfo>,

    /// A map(list of key-value pairs) where a (unique) valid JSON string serves as key of EasdfInfo
    #[serde(rename = "easdfInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub easdf_info_list: Option<std::collections::HashMap<String, models::EasdfInfo>>,

    #[serde(rename = "dccfInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dccf_info: Option<models::DccfInfo>,

    /// A map (list of key-value pairs) where a (unique) valid JSON string serves as key of NsacfInfo
    #[serde(rename = "nsacfInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nsacf_info_list: Option<std::collections::HashMap<String, models::NsacfInfo>>,

    /// A map (list of key-value pairs) where a (unique) valid JSON string serves as key of MbSmfInfo
    #[serde(rename = "mbSmfInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mb_smf_info_list: Option<std::collections::HashMap<String, models::MbSmfInfo>>,

    /// A map (list of key-value pairs) where a (unique) valid JSON string serves as key of TsctsfInfo
    #[serde(rename = "tsctsfInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tsctsf_info_list: Option<std::collections::HashMap<String, models::TsctsfInfo>>,

    /// A map (list of key-value pairs) where a (unique) valid JSON string serves as key of MbUpfInfo
    #[serde(rename = "mbUpfInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mb_upf_info_list: Option<std::collections::HashMap<String, models::MbUpfInfo>>,

    #[serde(rename = "trustAfInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trust_af_info: Option<models::TrustAfInfo>,

    #[serde(rename = "nssaafInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nssaaf_info: Option<models::NssaafInfo>,

    #[serde(rename = "hniList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hni_list: Option<Vec<models::Fqdn>>,

    #[serde(rename = "iwmscInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub iwmsc_info: Option<models::IwmscInfo>,

    #[serde(rename = "mnpfInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mnpf_info: Option<models::MnpfInfo>,
}

impl NfProfile {
    #[allow(clippy::new_without_default)]
    pub fn new(
        nf_instance_id: uuid::Uuid,
        nf_type: models::NfType,
        nf_status: models::NfStatus,
    ) -> NfProfile {
        NfProfile {
            nf_instance_id,
            nf_instance_name: None,
            nf_type,
            nf_status,
            collocated_nf_instances: None,
            plmn_list: None,
            s_nssais: None,
            per_plmn_snssai_list: None,
            nsi_list: None,
            fqdn: None,
            inter_plmn_fqdn: None,
            ipv4_addresses: None,
            ipv6_addresses: None,
            capacity: None,
            load: None,
            load_time_stamp: None,
            locality: None,
            priority: None,
            udr_info: None,
            udr_info_list: None,
            udm_info: None,
            udm_info_list: None,
            ausf_info: None,
            ausf_info_list: None,
            amf_info: None,
            amf_info_list: None,
            smf_info: None,
            smf_info_list: None,
            upf_info: None,
            upf_info_list: None,
            pcf_info: None,
            pcf_info_list: None,
            bsf_info: None,
            bsf_info_list: None,
            chf_info: None,
            chf_info_list: None,
            udsf_info: None,
            udsf_info_list: None,
            nwdaf_info: None,
            nwdaf_info_list: None,
            nef_info: None,
            pcscf_info_list: None,
            hss_info_list: None,
            custom_info: None,
            recovery_time: None,
            nf_service_persistence: Some(false),
            nf_services: None,
            nf_service_list: None,
            default_notification_subscriptions: None,
            lmf_info: None,
            gmlc_info: None,
            snpn_list: None,
            nf_set_id_list: None,
            serving_scope: None,
            lc_h_support_ind: Some(false),
            olc_h_support_ind: Some(false),
            nf_set_recovery_time_list: None,
            service_set_recovery_time_list: None,
            scp_domains: None,
            scp_info: None,
            sepp_info: None,
            vendor_id: None,
            supported_vendor_specific_features: None,
            aanf_info_list: None,
            mfaf_info: None,
            easdf_info_list: None,
            dccf_info: None,
            nsacf_info_list: None,
            mb_smf_info_list: None,
            tsctsf_info_list: None,
            mb_upf_info_list: None,
            trust_af_info: None,
            nssaaf_info: None,
            hni_list: None,
            iwmsc_info: None,
            mnpf_info: None,
        }
    }
}

/// Converts the NfProfile value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NfProfile {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping nfInstanceId in query parameter serialization
            self.nf_instance_name.as_ref().map(|nf_instance_name| {
                vec!["nfInstanceName".to_string(), nf_instance_name.to_string()].join(",")
            }),
            // Skipping nfType in query parameter serialization

            // Skipping nfStatus in query parameter serialization

            // Skipping collocatedNfInstances in query parameter serialization

            // Skipping plmnList in query parameter serialization

            // Skipping sNssais in query parameter serialization

            // Skipping perPlmnSnssaiList in query parameter serialization
            self.nsi_list.as_ref().map(|nsi_list| {
                vec![
                    "nsiList".to_string(),
                    nsi_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.fqdn
                .as_ref()
                .map(|fqdn| vec!["fqdn".to_string(), fqdn.to_string()].join(",")),
            self.inter_plmn_fqdn.as_ref().map(|inter_plmn_fqdn| {
                vec!["interPlmnFqdn".to_string(), inter_plmn_fqdn.to_string()].join(",")
            }),
            self.ipv4_addresses.as_ref().map(|ipv4_addresses| {
                vec![
                    "ipv4Addresses".to_string(),
                    ipv4_addresses
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping ipv6Addresses in query parameter serialization
            self.capacity
                .as_ref()
                .map(|capacity| vec!["capacity".to_string(), capacity.to_string()].join(",")),
            self.load
                .as_ref()
                .map(|load| vec!["load".to_string(), load.to_string()].join(",")),
            // Skipping loadTimeStamp in query parameter serialization
            self.locality
                .as_ref()
                .map(|locality| vec!["locality".to_string(), locality.to_string()].join(",")),
            self.priority
                .as_ref()
                .map(|priority| vec!["priority".to_string(), priority.to_string()].join(",")),
            // Skipping udrInfo in query parameter serialization

            // Skipping udrInfoList in query parameter serialization
            // Skipping udrInfoList in query parameter serialization

            // Skipping udmInfo in query parameter serialization

            // Skipping udmInfoList in query parameter serialization
            // Skipping udmInfoList in query parameter serialization

            // Skipping ausfInfo in query parameter serialization

            // Skipping ausfInfoList in query parameter serialization
            // Skipping ausfInfoList in query parameter serialization

            // Skipping amfInfo in query parameter serialization

            // Skipping amfInfoList in query parameter serialization
            // Skipping amfInfoList in query parameter serialization

            // Skipping smfInfo in query parameter serialization

            // Skipping smfInfoList in query parameter serialization
            // Skipping smfInfoList in query parameter serialization

            // Skipping upfInfo in query parameter serialization

            // Skipping upfInfoList in query parameter serialization
            // Skipping upfInfoList in query parameter serialization

            // Skipping pcfInfo in query parameter serialization

            // Skipping pcfInfoList in query parameter serialization
            // Skipping pcfInfoList in query parameter serialization

            // Skipping bsfInfo in query parameter serialization

            // Skipping bsfInfoList in query parameter serialization
            // Skipping bsfInfoList in query parameter serialization

            // Skipping chfInfo in query parameter serialization

            // Skipping chfInfoList in query parameter serialization
            // Skipping chfInfoList in query parameter serialization

            // Skipping udsfInfo in query parameter serialization

            // Skipping udsfInfoList in query parameter serialization
            // Skipping udsfInfoList in query parameter serialization

            // Skipping nwdafInfo in query parameter serialization

            // Skipping nwdafInfoList in query parameter serialization
            // Skipping nwdafInfoList in query parameter serialization

            // Skipping nefInfo in query parameter serialization

            // Skipping pcscfInfoList in query parameter serialization
            // Skipping pcscfInfoList in query parameter serialization

            // Skipping hssInfoList in query parameter serialization
            // Skipping hssInfoList in query parameter serialization

            // Skipping customInfo in query parameter serialization

            // Skipping recoveryTime in query parameter serialization
            self.nf_service_persistence
                .as_ref()
                .map(|nf_service_persistence| {
                    vec![
                        "nfServicePersistence".to_string(),
                        nf_service_persistence.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping nfServices in query parameter serialization

            // Skipping nfServiceList in query parameter serialization
            // Skipping nfServiceList in query parameter serialization

            // Skipping defaultNotificationSubscriptions in query parameter serialization

            // Skipping lmfInfo in query parameter serialization

            // Skipping gmlcInfo in query parameter serialization

            // Skipping snpnList in query parameter serialization
            self.nf_set_id_list.as_ref().map(|nf_set_id_list| {
                vec![
                    "nfSetIdList".to_string(),
                    nf_set_id_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.serving_scope.as_ref().map(|serving_scope| {
                vec![
                    "servingScope".to_string(),
                    serving_scope
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.lc_h_support_ind.as_ref().map(|lc_h_support_ind| {
                vec!["lcHSupportInd".to_string(), lc_h_support_ind.to_string()].join(",")
            }),
            self.olc_h_support_ind.as_ref().map(|olc_h_support_ind| {
                vec!["olcHSupportInd".to_string(), olc_h_support_ind.to_string()].join(",")
            }),
            // Skipping nfSetRecoveryTimeList in query parameter serialization
            // Skipping nfSetRecoveryTimeList in query parameter serialization

            // Skipping serviceSetRecoveryTimeList in query parameter serialization
            // Skipping serviceSetRecoveryTimeList in query parameter serialization
            self.scp_domains.as_ref().map(|scp_domains| {
                vec![
                    "scpDomains".to_string(),
                    scp_domains
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping scpInfo in query parameter serialization

            // Skipping seppInfo in query parameter serialization
            self.vendor_id
                .as_ref()
                .map(|vendor_id| vec!["vendorId".to_string(), vendor_id.to_string()].join(",")),
            // Skipping supportedVendorSpecificFeatures in query parameter serialization
            // Skipping supportedVendorSpecificFeatures in query parameter serialization

            // Skipping aanfInfoList in query parameter serialization
            // Skipping aanfInfoList in query parameter serialization

            // Skipping mfafInfo in query parameter serialization

            // Skipping easdfInfoList in query parameter serialization
            // Skipping easdfInfoList in query parameter serialization

            // Skipping dccfInfo in query parameter serialization

            // Skipping nsacfInfoList in query parameter serialization
            // Skipping nsacfInfoList in query parameter serialization

            // Skipping mbSmfInfoList in query parameter serialization
            // Skipping mbSmfInfoList in query parameter serialization

            // Skipping tsctsfInfoList in query parameter serialization
            // Skipping tsctsfInfoList in query parameter serialization

            // Skipping mbUpfInfoList in query parameter serialization
            // Skipping mbUpfInfoList in query parameter serialization

            // Skipping trustAfInfo in query parameter serialization

            // Skipping nssaafInfo in query parameter serialization
            self.hni_list.as_ref().map(|hni_list| {
                vec![
                    "hniList".to_string(),
                    hni_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping iwmscInfo in query parameter serialization

            // Skipping mnpfInfo in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NfProfile value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NfProfile {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub nf_instance_id: Vec<uuid::Uuid>,
            pub nf_instance_name: Vec<String>,
            pub nf_type: Vec<models::NfType>,
            pub nf_status: Vec<models::NfStatus>,
            pub collocated_nf_instances: Vec<Vec<models::CollocatedNfInstance>>,
            pub plmn_list: Vec<Vec<models::PlmnId>>,
            pub s_nssais: Vec<Vec<models::ExtSnssai>>,
            pub per_plmn_snssai_list: Vec<Vec<models::PlmnSnssai>>,
            pub nsi_list: Vec<Vec<String>>,
            pub fqdn: Vec<String>,
            pub inter_plmn_fqdn: Vec<String>,
            pub ipv4_addresses: Vec<Vec<models::Ipv4Addr>>,
            pub ipv6_addresses: Vec<Vec<models::Ipv6Addr>>,
            pub capacity: Vec<u16>,
            pub load: Vec<u8>,
            pub load_time_stamp: Vec<chrono::DateTime<chrono::Utc>>,
            pub locality: Vec<String>,
            pub priority: Vec<u16>,
            pub udr_info: Vec<models::UdrInfo>,
            pub udr_info_list: Vec<std::collections::HashMap<String, models::UdrInfo>>,
            pub udm_info: Vec<models::UdmInfo>,
            pub udm_info_list: Vec<std::collections::HashMap<String, models::UdmInfo>>,
            pub ausf_info: Vec<models::AusfInfo>,
            pub ausf_info_list: Vec<std::collections::HashMap<String, models::AusfInfo>>,
            pub amf_info: Vec<models::AmfInfo>,
            pub amf_info_list: Vec<std::collections::HashMap<String, models::AmfInfo>>,
            pub smf_info: Vec<models::SmfInfo>,
            pub smf_info_list: Vec<std::collections::HashMap<String, models::SmfInfo>>,
            pub upf_info: Vec<models::UpfInfo>,
            pub upf_info_list: Vec<std::collections::HashMap<String, models::UpfInfo>>,
            pub pcf_info: Vec<models::PcfInfo>,
            pub pcf_info_list: Vec<std::collections::HashMap<String, models::PcfInfo>>,
            pub bsf_info: Vec<models::BsfInfo>,
            pub bsf_info_list: Vec<std::collections::HashMap<String, models::BsfInfo>>,
            pub chf_info: Vec<models::ChfInfo>,
            pub chf_info_list: Vec<std::collections::HashMap<String, models::ChfInfo>>,
            pub udsf_info: Vec<models::UdsfInfo>,
            pub udsf_info_list: Vec<std::collections::HashMap<String, models::UdsfInfo>>,
            pub nwdaf_info: Vec<models::NwdafInfo>,
            pub nwdaf_info_list: Vec<std::collections::HashMap<String, models::NwdafInfo>>,
            pub nef_info: Vec<models::NefInfo>,
            pub pcscf_info_list: Vec<std::collections::HashMap<String, models::PcscfInfo>>,
            pub hss_info_list: Vec<std::collections::HashMap<String, models::HssInfo>>,
            pub custom_info: Vec<serde_json::Value>,
            pub recovery_time: Vec<chrono::DateTime<chrono::Utc>>,
            pub nf_service_persistence: Vec<bool>,
            pub nf_services: Vec<Vec<models::NfService>>,
            pub nf_service_list: Vec<std::collections::HashMap<String, models::NfService>>,
            pub default_notification_subscriptions:
                Vec<Vec<models::DefaultNotificationSubscription>>,
            pub lmf_info: Vec<models::LmfInfo>,
            pub gmlc_info: Vec<models::GmlcInfo>,
            pub snpn_list: Vec<Vec<models::PlmnIdNid>>,
            pub nf_set_id_list: Vec<Vec<models::NfSetId>>,
            pub serving_scope: Vec<Vec<String>>,
            pub lc_h_support_ind: Vec<bool>,
            pub olc_h_support_ind: Vec<bool>,
            pub nf_set_recovery_time_list: Vec<std::collections::HashMap<String, models::DateTime>>,
            pub service_set_recovery_time_list:
                Vec<std::collections::HashMap<String, models::DateTime>>,
            pub scp_domains: Vec<Vec<String>>,
            pub scp_info: Vec<models::ScpInfo>,
            pub sepp_info: Vec<models::SeppInfo>,
            pub vendor_id: Vec<String>,
            pub supported_vendor_specific_features:
                Vec<std::collections::HashMap<String, Vec<models::VendorSpecificFeature>>>,
            pub aanf_info_list: Vec<std::collections::HashMap<String, models::AanfInfo>>,
            pub mfaf_info: Vec<models::MfafInfo>,
            pub easdf_info_list: Vec<std::collections::HashMap<String, models::EasdfInfo>>,
            pub dccf_info: Vec<models::DccfInfo>,
            pub nsacf_info_list: Vec<std::collections::HashMap<String, models::NsacfInfo>>,
            pub mb_smf_info_list: Vec<std::collections::HashMap<String, models::MbSmfInfo>>,
            pub tsctsf_info_list: Vec<std::collections::HashMap<String, models::TsctsfInfo>>,
            pub mb_upf_info_list: Vec<std::collections::HashMap<String, models::MbUpfInfo>>,
            pub trust_af_info: Vec<models::TrustAfInfo>,
            pub nssaaf_info: Vec<models::NssaafInfo>,
            pub hni_list: Vec<Vec<models::Fqdn>>,
            pub iwmsc_info: Vec<models::IwmscInfo>,
            pub mnpf_info: Vec<models::MnpfInfo>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NfProfile".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "nfInstanceId" => intermediate_rep.nf_instance_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nfInstanceName" => intermediate_rep.nf_instance_name.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nfType" => intermediate_rep.nf_type.push(
                        <models::NfType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nfStatus" => intermediate_rep.nf_status.push(
                        <models::NfStatus as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "collocatedNfInstances" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    "plmnList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    "sNssais" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    "perPlmnSnssaiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    "nsiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "fqdn" => intermediate_rep.fqdn.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "interPlmnFqdn" => intermediate_rep.inter_plmn_fqdn.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "ipv4Addresses" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    "ipv6Addresses" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "capacity" => intermediate_rep.capacity.push(
                        <u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "load" => intermediate_rep
                        .load
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "loadTimeStamp" => intermediate_rep.load_time_stamp.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "locality" => intermediate_rep.locality.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "priority" => intermediate_rep.priority.push(
                        <u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "udrInfo" => intermediate_rep.udr_info.push(
                        <models::UdrInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "udrInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "udmInfo" => intermediate_rep.udm_info.push(
                        <models::UdmInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "udmInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "ausfInfo" => intermediate_rep.ausf_info.push(
                        <models::AusfInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "ausfInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "amfInfo" => intermediate_rep.amf_info.push(
                        <models::AmfInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "amfInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "smfInfo" => intermediate_rep.smf_info.push(
                        <models::SmfInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "smfInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "upfInfo" => intermediate_rep.upf_info.push(
                        <models::UpfInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "upfInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "pcfInfo" => intermediate_rep.pcf_info.push(
                        <models::PcfInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "pcfInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "bsfInfo" => intermediate_rep.bsf_info.push(
                        <models::BsfInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "bsfInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "chfInfo" => intermediate_rep.chf_info.push(
                        <models::ChfInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "chfInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "udsfInfo" => intermediate_rep.udsf_info.push(
                        <models::UdsfInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "udsfInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "nwdafInfo" => intermediate_rep.nwdaf_info.push(
                        <models::NwdafInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "nwdafInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "nefInfo" => intermediate_rep.nef_info.push(
                        <models::NefInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "pcscfInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    "hssInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "customInfo" => intermediate_rep.custom_info.push(
                        <serde_json::Value as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "recoveryTime" => intermediate_rep.recovery_time.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nfServicePersistence" => intermediate_rep.nf_service_persistence.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "nfServices" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    "nfServiceList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    "defaultNotificationSubscriptions" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "lmfInfo" => intermediate_rep.lmf_info.push(
                        <models::LmfInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "gmlcInfo" => intermediate_rep.gmlc_info.push(
                        <models::GmlcInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "snpnList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    "nfSetIdList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    "servingScope" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "lcHSupportInd" => intermediate_rep.lc_h_support_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "olcHSupportInd" => intermediate_rep.olc_h_support_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "nfSetRecoveryTimeList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    "serviceSetRecoveryTimeList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    "scpDomains" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "scpInfo" => intermediate_rep.scp_info.push(
                        <models::ScpInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "seppInfo" => intermediate_rep.sepp_info.push(
                        <models::SeppInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "vendorId" => intermediate_rep.vendor_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "supportedVendorSpecificFeatures" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    "aanfInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "mfafInfo" => intermediate_rep.mfaf_info.push(
                        <models::MfafInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "easdfInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "dccfInfo" => intermediate_rep.dccf_info.push(
                        <models::DccfInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "nsacfInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    "mbSmfInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    "tsctsfInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    "mbUpfInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "trustAfInfo" => intermediate_rep.trust_af_info.push(
                        <models::TrustAfInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nssaafInfo" => intermediate_rep.nssaaf_info.push(
                        <models::NssaafInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "hniList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfProfile"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "iwmscInfo" => intermediate_rep.iwmsc_info.push(
                        <models::IwmscInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "mnpfInfo" => intermediate_rep.mnpf_info.push(
                        <models::MnpfInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NfProfile".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NfProfile {
            nf_instance_id: intermediate_rep
                .nf_instance_id
                .into_iter()
                .next()
                .ok_or_else(|| "nfInstanceId missing in NfProfile".to_string())?,
            nf_instance_name: intermediate_rep.nf_instance_name.into_iter().next(),
            nf_type: intermediate_rep
                .nf_type
                .into_iter()
                .next()
                .ok_or_else(|| "nfType missing in NfProfile".to_string())?,
            nf_status: intermediate_rep
                .nf_status
                .into_iter()
                .next()
                .ok_or_else(|| "nfStatus missing in NfProfile".to_string())?,
            collocated_nf_instances: intermediate_rep.collocated_nf_instances.into_iter().next(),
            plmn_list: intermediate_rep.plmn_list.into_iter().next(),
            s_nssais: intermediate_rep.s_nssais.into_iter().next(),
            per_plmn_snssai_list: intermediate_rep.per_plmn_snssai_list.into_iter().next(),
            nsi_list: intermediate_rep.nsi_list.into_iter().next(),
            fqdn: intermediate_rep.fqdn.into_iter().next(),
            inter_plmn_fqdn: intermediate_rep.inter_plmn_fqdn.into_iter().next(),
            ipv4_addresses: intermediate_rep.ipv4_addresses.into_iter().next(),
            ipv6_addresses: intermediate_rep.ipv6_addresses.into_iter().next(),
            capacity: intermediate_rep.capacity.into_iter().next(),
            load: intermediate_rep.load.into_iter().next(),
            load_time_stamp: intermediate_rep.load_time_stamp.into_iter().next(),
            locality: intermediate_rep.locality.into_iter().next(),
            priority: intermediate_rep.priority.into_iter().next(),
            udr_info: intermediate_rep.udr_info.into_iter().next(),
            udr_info_list: intermediate_rep.udr_info_list.into_iter().next(),
            udm_info: intermediate_rep.udm_info.into_iter().next(),
            udm_info_list: intermediate_rep.udm_info_list.into_iter().next(),
            ausf_info: intermediate_rep.ausf_info.into_iter().next(),
            ausf_info_list: intermediate_rep.ausf_info_list.into_iter().next(),
            amf_info: intermediate_rep.amf_info.into_iter().next(),
            amf_info_list: intermediate_rep.amf_info_list.into_iter().next(),
            smf_info: intermediate_rep.smf_info.into_iter().next(),
            smf_info_list: intermediate_rep.smf_info_list.into_iter().next(),
            upf_info: intermediate_rep.upf_info.into_iter().next(),
            upf_info_list: intermediate_rep.upf_info_list.into_iter().next(),
            pcf_info: intermediate_rep.pcf_info.into_iter().next(),
            pcf_info_list: intermediate_rep.pcf_info_list.into_iter().next(),
            bsf_info: intermediate_rep.bsf_info.into_iter().next(),
            bsf_info_list: intermediate_rep.bsf_info_list.into_iter().next(),
            chf_info: intermediate_rep.chf_info.into_iter().next(),
            chf_info_list: intermediate_rep.chf_info_list.into_iter().next(),
            udsf_info: intermediate_rep.udsf_info.into_iter().next(),
            udsf_info_list: intermediate_rep.udsf_info_list.into_iter().next(),
            nwdaf_info: intermediate_rep.nwdaf_info.into_iter().next(),
            nwdaf_info_list: intermediate_rep.nwdaf_info_list.into_iter().next(),
            nef_info: intermediate_rep.nef_info.into_iter().next(),
            pcscf_info_list: intermediate_rep.pcscf_info_list.into_iter().next(),
            hss_info_list: intermediate_rep.hss_info_list.into_iter().next(),
            custom_info: intermediate_rep.custom_info.into_iter().next(),
            recovery_time: intermediate_rep.recovery_time.into_iter().next(),
            nf_service_persistence: intermediate_rep.nf_service_persistence.into_iter().next(),
            nf_services: intermediate_rep.nf_services.into_iter().next(),
            nf_service_list: intermediate_rep.nf_service_list.into_iter().next(),
            default_notification_subscriptions: intermediate_rep
                .default_notification_subscriptions
                .into_iter()
                .next(),
            lmf_info: intermediate_rep.lmf_info.into_iter().next(),
            gmlc_info: intermediate_rep.gmlc_info.into_iter().next(),
            snpn_list: intermediate_rep.snpn_list.into_iter().next(),
            nf_set_id_list: intermediate_rep.nf_set_id_list.into_iter().next(),
            serving_scope: intermediate_rep.serving_scope.into_iter().next(),
            lc_h_support_ind: intermediate_rep.lc_h_support_ind.into_iter().next(),
            olc_h_support_ind: intermediate_rep.olc_h_support_ind.into_iter().next(),
            nf_set_recovery_time_list: intermediate_rep
                .nf_set_recovery_time_list
                .into_iter()
                .next(),
            service_set_recovery_time_list: intermediate_rep
                .service_set_recovery_time_list
                .into_iter()
                .next(),
            scp_domains: intermediate_rep.scp_domains.into_iter().next(),
            scp_info: intermediate_rep.scp_info.into_iter().next(),
            sepp_info: intermediate_rep.sepp_info.into_iter().next(),
            vendor_id: intermediate_rep.vendor_id.into_iter().next(),
            supported_vendor_specific_features: intermediate_rep
                .supported_vendor_specific_features
                .into_iter()
                .next(),
            aanf_info_list: intermediate_rep.aanf_info_list.into_iter().next(),
            mfaf_info: intermediate_rep.mfaf_info.into_iter().next(),
            easdf_info_list: intermediate_rep.easdf_info_list.into_iter().next(),
            dccf_info: intermediate_rep.dccf_info.into_iter().next(),
            nsacf_info_list: intermediate_rep.nsacf_info_list.into_iter().next(),
            mb_smf_info_list: intermediate_rep.mb_smf_info_list.into_iter().next(),
            tsctsf_info_list: intermediate_rep.tsctsf_info_list.into_iter().next(),
            mb_upf_info_list: intermediate_rep.mb_upf_info_list.into_iter().next(),
            trust_af_info: intermediate_rep.trust_af_info.into_iter().next(),
            nssaaf_info: intermediate_rep.nssaaf_info.into_iter().next(),
            hni_list: intermediate_rep.hni_list.into_iter().next(),
            iwmsc_info: intermediate_rep.iwmsc_info.into_iter().next(),
            mnpf_info: intermediate_rep.mnpf_info.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NfProfile> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NfProfile>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NfProfile>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NfProfile - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<NfProfile> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NfProfile as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NfProfile - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Information of a given NF Service Instance; it is part of the NFProfile of an NF Instance discovered by the NRF
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NfService {
    #[serde(rename = "serviceInstanceId")]
    pub service_instance_id: String,

    #[serde(rename = "serviceName")]
    pub service_name: models::ServiceName,

    #[serde(rename = "versions")]
    pub versions: Vec<models::NfServiceVersion>,

    #[serde(rename = "scheme")]
    pub scheme: models::UriScheme,

    #[serde(rename = "nfServiceStatus")]
    pub nf_service_status: models::NfServiceStatus,

    /// Fully Qualified Domain Name
    #[serde(rename = "fqdn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fqdn: Option<String>,

    /// Fully Qualified Domain Name
    #[serde(rename = "interPlmnFqdn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub inter_plmn_fqdn: Option<String>,

    #[serde(rename = "ipEndPoints")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ip_end_points: Option<Vec<models::IpEndPoint>>,

    #[serde(rename = "apiPrefix")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub api_prefix: Option<String>,

    #[serde(rename = "defaultNotificationSubscriptions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_notification_subscriptions: Option<Vec<models::DefaultNotificationSubscription>>,

    #[serde(rename = "capacity")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub capacity: Option<u16>,

    #[serde(rename = "load")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub load: Option<u8>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "loadTimeStamp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub load_time_stamp: Option<chrono::DateTime<chrono::Utc>>,

    #[serde(rename = "priority")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority: Option<u16>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "recoveryTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recovery_time: Option<chrono::DateTime<chrono::Utc>>,

    /// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  tableÂ 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.
    #[serde(rename = "supportedFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_features: Option<String>,

    #[serde(rename = "nfServiceSetIdList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nf_service_set_id_list: Option<Vec<models::NfServiceSetId>>,

    #[serde(rename = "sNssais")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub s_nssais: Option<Vec<models::ExtSnssai>>,

    #[serde(rename = "perPlmnSnssaiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub per_plmn_snssai_list: Option<Vec<models::PlmnSnssai>>,

    /// Vendor ID of the NF Service instance (Private Enterprise Number assigned by IANA)
    #[serde(rename = "vendorId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub vendor_id: Option<String>,

    /// The key of the map is the IANA-assigned SMI Network Management Private Enterprise Codes
    #[serde(rename = "supportedVendorSpecificFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_vendor_specific_features:
        Option<std::collections::HashMap<String, Vec<models::VendorSpecificFeature>>>,

    #[serde(rename = "oauth2Required")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oauth2_required: Option<bool>,

    /// A map (list of key-value pairs) where NF Type serves as key
    #[serde(rename = "allowedOperationsPerNfType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allowed_operations_per_nf_type: Option<std::collections::HashMap<String, Vec<String>>>,

    /// A map (list of key-value pairs) where NF Instance Id serves as key
    #[serde(rename = "allowedOperationsPerNfInstance")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allowed_operations_per_nf_instance: Option<std::collections::HashMap<String, Vec<String>>>,
}

impl NfService {
    #[allow(clippy::new_without_default)]
    pub fn new(
        service_instance_id: String,
        service_name: models::ServiceName,
        versions: Vec<models::NfServiceVersion>,
        scheme: models::UriScheme,
        nf_service_status: models::NfServiceStatus,
    ) -> NfService {
        NfService {
            service_instance_id,
            service_name,
            versions,
            scheme,
            nf_service_status,
            fqdn: None,
            inter_plmn_fqdn: None,
            ip_end_points: None,
            api_prefix: None,
            default_notification_subscriptions: None,
            capacity: None,
            load: None,
            load_time_stamp: None,
            priority: None,
            recovery_time: None,
            supported_features: None,
            nf_service_set_id_list: None,
            s_nssais: None,
            per_plmn_snssai_list: None,
            vendor_id: None,
            supported_vendor_specific_features: None,
            oauth2_required: None,
            allowed_operations_per_nf_type: None,
            allowed_operations_per_nf_instance: None,
        }
    }
}

/// Converts the NfService value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NfService {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("serviceInstanceId".to_string()),
            Some(self.service_instance_id.to_string()),
            // Skipping serviceName in query parameter serialization

            // Skipping versions in query parameter serialization

            // Skipping scheme in query parameter serialization

            // Skipping nfServiceStatus in query parameter serialization
            self.fqdn
                .as_ref()
                .map(|fqdn| vec!["fqdn".to_string(), fqdn.to_string()].join(",")),
            self.inter_plmn_fqdn.as_ref().map(|inter_plmn_fqdn| {
                vec!["interPlmnFqdn".to_string(), inter_plmn_fqdn.to_string()].join(",")
            }),
            // Skipping ipEndPoints in query parameter serialization
            self.api_prefix
                .as_ref()
                .map(|api_prefix| vec!["apiPrefix".to_string(), api_prefix.to_string()].join(",")),
            // Skipping defaultNotificationSubscriptions in query parameter serialization
            self.capacity
                .as_ref()
                .map(|capacity| vec!["capacity".to_string(), capacity.to_string()].join(",")),
            self.load
                .as_ref()
                .map(|load| vec!["load".to_string(), load.to_string()].join(",")),
            // Skipping loadTimeStamp in query parameter serialization
            self.priority
                .as_ref()
                .map(|priority| vec!["priority".to_string(), priority.to_string()].join(",")),
            // Skipping recoveryTime in query parameter serialization
            self.supported_features.as_ref().map(|supported_features| {
                vec![
                    "supportedFeatures".to_string(),
                    supported_features.to_string(),
                ]
                .join(",")
            }),
            self.nf_service_set_id_list
                .as_ref()
                .map(|nf_service_set_id_list| {
                    vec![
                        "nfServiceSetIdList".to_string(),
                        nf_service_set_id_list
                            .iter()
                            .map(|x| x.to_string())
                            .collect::<Vec<_>>()
                            .join(","),
                    ]
                    .join(",")
                }),
            // Skipping sNssais in query parameter serialization

            // Skipping perPlmnSnssaiList in query parameter serialization
            self.vendor_id
                .as_ref()
                .map(|vendor_id| vec!["vendorId".to_string(), vendor_id.to_string()].join(",")),
            // Skipping supportedVendorSpecificFeatures in query parameter serialization
            // Skipping supportedVendorSpecificFeatures in query parameter serialization
            self.oauth2_required.as_ref().map(|oauth2_required| {
                vec!["oauth2Required".to_string(), oauth2_required.to_string()].join(",")
            }),
            // Skipping allowedOperationsPerNfType in query parameter serialization
            // Skipping allowedOperationsPerNfType in query parameter serialization

            // Skipping allowedOperationsPerNfInstance in query parameter serialization
            // Skipping allowedOperationsPerNfInstance in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NfService value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NfService {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub service_instance_id: Vec<String>,
            pub service_name: Vec<models::ServiceName>,
            pub versions: Vec<Vec<models::NfServiceVersion>>,
            pub scheme: Vec<models::UriScheme>,
            pub nf_service_status: Vec<models::NfServiceStatus>,
            pub fqdn: Vec<String>,
            pub inter_plmn_fqdn: Vec<String>,
            pub ip_end_points: Vec<Vec<models::IpEndPoint>>,
            pub api_prefix: Vec<String>,
            pub default_notification_subscriptions:
                Vec<Vec<models::DefaultNotificationSubscription>>,
            pub capacity: Vec<u16>,
            pub load: Vec<u8>,
            pub load_time_stamp: Vec<chrono::DateTime<chrono::Utc>>,
            pub priority: Vec<u16>,
            pub recovery_time: Vec<chrono::DateTime<chrono::Utc>>,
            pub supported_features: Vec<String>,
            pub nf_service_set_id_list: Vec<Vec<models::NfServiceSetId>>,
            pub s_nssais: Vec<Vec<models::ExtSnssai>>,
            pub per_plmn_snssai_list: Vec<Vec<models::PlmnSnssai>>,
            pub vendor_id: Vec<String>,
            pub supported_vendor_specific_features:
                Vec<std::collections::HashMap<String, Vec<models::VendorSpecificFeature>>>,
            pub oauth2_required: Vec<bool>,
            pub allowed_operations_per_nf_type: Vec<std::collections::HashMap<String, Vec<String>>>,
            pub allowed_operations_per_nf_instance:
                Vec<std::collections::HashMap<String, Vec<String>>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NfService".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "serviceInstanceId" => intermediate_rep.service_instance_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "serviceName" => intermediate_rep.service_name.push(
                        <models::ServiceName as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "versions" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfService"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "scheme" => intermediate_rep.scheme.push(
                        <models::UriScheme as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nfServiceStatus" => intermediate_rep.nf_service_status.push(
                        <models::NfServiceStatus as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "fqdn" => intermediate_rep.fqdn.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "interPlmnFqdn" => intermediate_rep.inter_plmn_fqdn.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "ipEndPoints" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfService"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "apiPrefix" => intermediate_rep.api_prefix.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "defaultNotificationSubscriptions" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfService"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "capacity" => intermediate_rep.capacity.push(
                        <u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "load" => intermediate_rep
                        .load
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "loadTimeStamp" => intermediate_rep.load_time_stamp.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "priority" => intermediate_rep.priority.push(
                        <u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "recoveryTime" => intermediate_rep.recovery_time.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "supportedFeatures" => intermediate_rep.supported_features.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "nfServiceSetIdList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfService"
                                .to_string(),
                        )
                    }
                    "sNssais" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfService"
                                .to_string(),
                        )
                    }
                    "perPlmnSnssaiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfService"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "vendorId" => intermediate_rep.vendor_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "supportedVendorSpecificFeatures" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfService"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "oauth2Required" => intermediate_rep.oauth2_required.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "allowedOperationsPerNfType" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfService"
                                .to_string(),
                        )
                    }
                    "allowedOperationsPerNfInstance" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NfService"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NfService".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NfService {
            service_instance_id: intermediate_rep
                .service_instance_id
                .into_iter()
                .next()
                .ok_or_else(|| "serviceInstanceId missing in NfService".to_string())?,
            service_name: intermediate_rep
                .service_name
                .into_iter()
                .next()
                .ok_or_else(|| "serviceName missing in NfService".to_string())?,
            versions: intermediate_rep
                .versions
                .into_iter()
                .next()
                .ok_or_else(|| "versions missing in NfService".to_string())?,
            scheme: intermediate_rep
                .scheme
                .into_iter()
                .next()
                .ok_or_else(|| "scheme missing in NfService".to_string())?,
            nf_service_status: intermediate_rep
                .nf_service_status
                .into_iter()
                .next()
                .ok_or_else(|| "nfServiceStatus missing in NfService".to_string())?,
            fqdn: intermediate_rep.fqdn.into_iter().next(),
            inter_plmn_fqdn: intermediate_rep.inter_plmn_fqdn.into_iter().next(),
            ip_end_points: intermediate_rep.ip_end_points.into_iter().next(),
            api_prefix: intermediate_rep.api_prefix.into_iter().next(),
            default_notification_subscriptions: intermediate_rep
                .default_notification_subscriptions
                .into_iter()
                .next(),
            capacity: intermediate_rep.capacity.into_iter().next(),
            load: intermediate_rep.load.into_iter().next(),
            load_time_stamp: intermediate_rep.load_time_stamp.into_iter().next(),
            priority: intermediate_rep.priority.into_iter().next(),
            recovery_time: intermediate_rep.recovery_time.into_iter().next(),
            supported_features: intermediate_rep.supported_features.into_iter().next(),
            nf_service_set_id_list: intermediate_rep.nf_service_set_id_list.into_iter().next(),
            s_nssais: intermediate_rep.s_nssais.into_iter().next(),
            per_plmn_snssai_list: intermediate_rep.per_plmn_snssai_list.into_iter().next(),
            vendor_id: intermediate_rep.vendor_id.into_iter().next(),
            supported_vendor_specific_features: intermediate_rep
                .supported_vendor_specific_features
                .into_iter()
                .next(),
            oauth2_required: intermediate_rep.oauth2_required.into_iter().next(),
            allowed_operations_per_nf_type: intermediate_rep
                .allowed_operations_per_nf_type
                .into_iter()
                .next(),
            allowed_operations_per_nf_instance: intermediate_rep
                .allowed_operations_per_nf_instance
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NfService> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NfService>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NfService>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NfService - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<NfService> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NfService as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NfService - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// NF service instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NfServiceInstance {
    #[serde(rename = "serviceInstanceId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_instance_id: Option<String>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "nfInstanceId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nf_instance_id: Option<uuid::Uuid>,

    /// NF Service Set Identifier (see clause 28.12 of 3GPP TS 23.003) formatted as the following  string \"set<Set ID>.sn<Service Name>.nfi<NF Instance ID>.5gc.mnc<MNC>.mcc<MCC>\", or  \"set<SetID>.sn<ServiceName>.nfi<NFInstanceID>.5gc.nid<NID>.mnc<MNC>.mcc<MCC>\" with  <MCC> encoded as defined in clause 5.4.2 (\"Mcc\" data type definition)   <MNC> encoding the Mobile Network Code part of the PLMN, comprising 3 digits.    If there are only 2 significant digits in the MNC, one \"0\" digit shall be inserted    at the left side to fill the 3 digits coding of MNC.  Pattern: '^[0-9]{3}$' <NID> encoded as defined in clauseÂ 5.4.2 (\"Nid\" data type definition)  <NFInstanceId> encoded as defined in clause 5.3.2  <ServiceName> encoded as defined in 3GPP TS 29.510  <Set ID> encoded as a string of characters consisting of alphabetic    characters (A-Z and a-z), digits (0-9) and/or the hyphen (-) and that shall end    with either an alphabetic character or a digit.
    #[serde(rename = "nfServiceSetId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nf_service_set_id: Option<String>,
}

impl NfServiceInstance {
    #[allow(clippy::new_without_default)]
    pub fn new() -> NfServiceInstance {
        NfServiceInstance {
            service_instance_id: None,
            nf_instance_id: None,
            nf_service_set_id: None,
        }
    }
}

/// Converts the NfServiceInstance value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NfServiceInstance {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.service_instance_id
                .as_ref()
                .map(|service_instance_id| {
                    vec![
                        "serviceInstanceId".to_string(),
                        service_instance_id.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping nfInstanceId in query parameter serialization
            self.nf_service_set_id.as_ref().map(|nf_service_set_id| {
                vec!["nfServiceSetId".to_string(), nf_service_set_id.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NfServiceInstance value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NfServiceInstance {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub service_instance_id: Vec<String>,
            pub nf_instance_id: Vec<uuid::Uuid>,
            pub nf_service_set_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NfServiceInstance".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "serviceInstanceId" => intermediate_rep.service_instance_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nfInstanceId" => intermediate_rep.nf_instance_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nfServiceSetId" => intermediate_rep.nf_service_set_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NfServiceInstance".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NfServiceInstance {
            service_instance_id: intermediate_rep.service_instance_id.into_iter().next(),
            nf_instance_id: intermediate_rep.nf_instance_id.into_iter().next(),
            nf_service_set_id: intermediate_rep.nf_service_set_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NfServiceInstance> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NfServiceInstance>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NfServiceInstance>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NfServiceInstance - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<NfServiceInstance>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NfServiceInstance as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NfServiceInstance - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// NF Service Set Identifier (see clause 28.12 of 3GPP TS 23.003) formatted as the following  string \"set<Set ID>.sn<Service Name>.nfi<NF Instance ID>.5gc.mnc<MNC>.mcc<MCC>\", or  \"set<SetID>.sn<ServiceName>.nfi<NFInstanceID>.5gc.nid<NID>.mnc<MNC>.mcc<MCC>\" with  <MCC> encoded as defined in clause 5.4.2 (\"Mcc\" data type definition)   <MNC> encoding the Mobile Network Code part of the PLMN, comprising 3 digits.    If there are only 2 significant digits in the MNC, one \"0\" digit shall be inserted    at the left side to fill the 3 digits coding of MNC.  Pattern: '^[0-9]{3}$' <NID> encoded as defined in clauseÂ 5.4.2 (\"Nid\" data type definition)  <NFInstanceId> encoded as defined in clause 5.3.2  <ServiceName> encoded as defined in 3GPP TS 29.510  <Set ID> encoded as a string of characters consisting of alphabetic    characters (A-Z and a-z), digits (0-9) and/or the hyphen (-) and that shall end    with either an alphabetic character or a digit.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NfServiceSetId(String);

impl std::convert::From<String> for NfServiceSetId {
    fn from(x: String) -> Self {
        NfServiceSetId(x)
    }
}

impl std::string::ToString for NfServiceSetId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for NfServiceSetId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(NfServiceSetId(x.to_string()))
    }
}

impl std::convert::From<NfServiceSetId> for String {
    fn from(x: NfServiceSetId) -> Self {
        x.0
    }
}

impl std::ops::Deref for NfServiceSetId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for NfServiceSetId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Status of a given NF Service Instance of an NF Instance stored in NRF
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NfServiceStatus(String);

impl NfServiceStatus {
    #[allow(clippy::new_without_default)]
    pub fn new(s: String) -> NfServiceStatus {
        NfServiceStatus(s)
    }
}

/// Converts the NfServiceStatus value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NfServiceStatus {
    fn to_string(&self) -> String {
        self.0.clone()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NfServiceStatus value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NfServiceStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(NfServiceStatus(s.to_string()))
    }
}

// Methods for converting between header::IntoHeaderValue<NfServiceStatus> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NfServiceStatus>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NfServiceStatus>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NfServiceStatus - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<NfServiceStatus>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NfServiceStatus as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NfServiceStatus - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains the version details of an NF service
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NfServiceVersion {
    #[serde(rename = "apiVersionInUri")]
    pub api_version_in_uri: String,

    #[serde(rename = "apiFullVersion")]
    pub api_full_version: String,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "expiry")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expiry: Option<chrono::DateTime<chrono::Utc>>,
}

impl NfServiceVersion {
    #[allow(clippy::new_without_default)]
    pub fn new(api_version_in_uri: String, api_full_version: String) -> NfServiceVersion {
        NfServiceVersion {
            api_version_in_uri,
            api_full_version,
            expiry: None,
        }
    }
}

/// Converts the NfServiceVersion value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NfServiceVersion {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("apiVersionInUri".to_string()),
            Some(self.api_version_in_uri.to_string()),
            Some("apiFullVersion".to_string()),
            Some(self.api_full_version.to_string()),
            // Skipping expiry in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NfServiceVersion value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NfServiceVersion {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub api_version_in_uri: Vec<String>,
            pub api_full_version: Vec<String>,
            pub expiry: Vec<chrono::DateTime<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NfServiceVersion".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "apiVersionInUri" => intermediate_rep.api_version_in_uri.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "apiFullVersion" => intermediate_rep.api_full_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "expiry" => intermediate_rep.expiry.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NfServiceVersion".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NfServiceVersion {
            api_version_in_uri: intermediate_rep
                .api_version_in_uri
                .into_iter()
                .next()
                .ok_or_else(|| "apiVersionInUri missing in NfServiceVersion".to_string())?,
            api_full_version: intermediate_rep
                .api_full_version
                .into_iter()
                .next()
                .ok_or_else(|| "apiFullVersion missing in NfServiceVersion".to_string())?,
            expiry: intermediate_rep.expiry.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NfServiceVersion> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NfServiceVersion>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NfServiceVersion>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NfServiceVersion - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<NfServiceVersion>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NfServiceVersion as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NfServiceVersion - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// NF Set Identifier (see clause 28.12 of 3GPP TS 23.003), formatted as the following string \"set<Set ID>.<nftype>set.5gc.mnc<MNC>.mcc<MCC>\", or  \"set<SetID>.<NFType>set.5gc.nid<NID>.mnc<MNC>.mcc<MCC>\" with  <MCC> encoded as defined in clause 5.4.2 (\"Mcc\" data type definition)  <MNC> encoding the Mobile Network Code part of the PLMN, comprising 3 digits.    If there are only 2 significant digits in the MNC, one \"0\" digit shall be inserted    at the left side to fill the 3 digits coding of MNC.  Pattern: '^[0-9]{3}$' <NFType> encoded as a value defined in Table 6.1.6.3.3-1 of 3GPP TS 29.510 but    with lower case characters <Set ID> encoded as a string of characters consisting of    alphabetic characters (A-Z and a-z), digits (0-9) and/or the hyphen (-) and that    shall end with either an alphabetic character or a digit.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NfSetId(String);

impl std::convert::From<String> for NfSetId {
    fn from(x: String) -> Self {
        NfSetId(x)
    }
}

impl std::string::ToString for NfSetId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for NfSetId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(NfSetId(x.to_string()))
    }
}

impl std::convert::From<NfSetId> for String {
    fn from(x: NfSetId) -> Self {
        x.0
    }
}

impl std::ops::Deref for NfSetId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for NfSetId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Status of a given NF Instance stored in NRF
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NfStatus(String);

impl NfStatus {
    #[allow(clippy::new_without_default)]
    pub fn new(status: String) -> NfStatus {
        NfStatus(status)
    }
}

/// Converts the NfStatus value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NfStatus {
    fn to_string(&self) -> String {
        self.0.clone()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NfStatus value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NfStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(NfStatus(s.to_string()))
    }
}

// Methods for converting between header::IntoHeaderValue<NfStatus> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NfStatus>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NfStatus>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NfStatus - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<NfStatus> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NfStatus as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NfStatus - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum NfStatusAnyOf {
    #[serde(rename = "REGISTERED")]
    Registered,
    #[serde(rename = "SUSPENDED")]
    Suspended,
    #[serde(rename = "UNDISCOVERABLE")]
    Undiscoverable,
}

impl std::fmt::Display for NfStatusAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            NfStatusAnyOf::Registered => write!(f, "REGISTERED"),
            NfStatusAnyOf::Suspended => write!(f, "SUSPENDED"),
            NfStatusAnyOf::Undiscoverable => write!(f, "UNDISCOVERABLE"),
        }
    }
}

impl std::str::FromStr for NfStatusAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "REGISTERED" => std::result::Result::Ok(NfStatusAnyOf::Registered),
            "SUSPENDED" => std::result::Result::Ok(NfStatusAnyOf::Suspended),
            "UNDISCOVERABLE" => std::result::Result::Ok(NfStatusAnyOf::Undiscoverable),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// NF types known to NRF
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub enum NfType {
    AMF,
    SMF,
    UDM,
    PCF,
    UPF,
}

impl NfType {
    #[allow(clippy::new_without_default)]
    pub fn new(s: &str) -> NfType {
        match serde_json::from_str(s) {
            Ok(nft) => nft,
            Err(_) => Self::AMF,
        }
    }
}

/// Converts the NfType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NfType {
    fn to_string(&self) -> String {
        match serde_json::to_string(self) {
            Ok(nft) => nft,
            Err(_) => "AMF".to_string(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NfType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NfType {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

// Methods for converting between header::IntoHeaderValue<NfType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NfType>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NfType>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NfType - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<NfType> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NfType as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NfType - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum NfTypeAnyOf {
    #[serde(rename = "NRF")]
    Nrf,
    #[serde(rename = "UDM")]
    Udm,
    #[serde(rename = "AMF")]
    Amf,
    #[serde(rename = "SMF")]
    Smf,
    #[serde(rename = "AUSF")]
    Ausf,
    #[serde(rename = "NEF")]
    Nef,
    #[serde(rename = "PCF")]
    Pcf,
    #[serde(rename = "SMSF")]
    Smsf,
    #[serde(rename = "NSSF")]
    Nssf,
    #[serde(rename = "UDR")]
    Udr,
    #[serde(rename = "LMF")]
    Lmf,
    #[serde(rename = "GMLC")]
    Gmlc,
    #[serde(rename = "5G_EIR")]
    Variant5GEir,
    #[serde(rename = "SEPP")]
    Sepp,
    #[serde(rename = "UPF")]
    Upf,
    #[serde(rename = "N3IWF")]
    N3Iwf,
    #[serde(rename = "AF")]
    Af,
    #[serde(rename = "UDSF")]
    Udsf,
    #[serde(rename = "BSF")]
    Bsf,
    #[serde(rename = "CHF")]
    Chf,
    #[serde(rename = "NWDAF")]
    Nwdaf,
    #[serde(rename = "PCSCF")]
    Pcscf,
    #[serde(rename = "CBCF")]
    Cbcf,
    #[serde(rename = "HSS")]
    Hss,
    #[serde(rename = "UCMF")]
    Ucmf,
    #[serde(rename = "SOR_AF")]
    SorAf,
    #[serde(rename = "SPAF")]
    Spaf,
    #[serde(rename = "MME")]
    Mme,
    #[serde(rename = "SCSAS")]
    Scsas,
    #[serde(rename = "SCEF")]
    Scef,
    #[serde(rename = "SCP")]
    Scp,
    #[serde(rename = "NSSAAF")]
    Nssaaf,
    #[serde(rename = "ICSCF")]
    Icscf,
    #[serde(rename = "SCSCF")]
    Scscf,
    #[serde(rename = "DRA")]
    Dra,
    #[serde(rename = "IMS_AS")]
    ImsAs,
    #[serde(rename = "AANF")]
    Aanf,
    #[serde(rename = "5G_DDNMF")]
    Variant5GDdnmf,
    #[serde(rename = "NSACF")]
    Nsacf,
    #[serde(rename = "MFAF")]
    Mfaf,
    #[serde(rename = "EASDF")]
    Easdf,
    #[serde(rename = "DCCF")]
    Dccf,
    #[serde(rename = "MB_SMF")]
    MbSmf,
    #[serde(rename = "TSCTSF")]
    Tsctsf,
    #[serde(rename = "ADRF")]
    Adrf,
    #[serde(rename = "GBA_BSF")]
    GbaBsf,
    #[serde(rename = "CEF")]
    Cef,
    #[serde(rename = "MB_UPF")]
    MbUpf,
    #[serde(rename = "NSWOF")]
    Nswof,
    #[serde(rename = "PKMF")]
    Pkmf,
    #[serde(rename = "MNPF")]
    Mnpf,
    #[serde(rename = "SMS_GMSC")]
    SmsGmsc,
    #[serde(rename = "SMS_IWMSC")]
    SmsIwmsc,
    #[serde(rename = "MBSF")]
    Mbsf,
    #[serde(rename = "MBSTF")]
    Mbstf,
    #[serde(rename = "PANF")]
    Panf,
}

impl std::fmt::Display for NfTypeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            NfTypeAnyOf::Nrf => write!(f, "NRF"),
            NfTypeAnyOf::Udm => write!(f, "UDM"),
            NfTypeAnyOf::Amf => write!(f, "AMF"),
            NfTypeAnyOf::Smf => write!(f, "SMF"),
            NfTypeAnyOf::Ausf => write!(f, "AUSF"),
            NfTypeAnyOf::Nef => write!(f, "NEF"),
            NfTypeAnyOf::Pcf => write!(f, "PCF"),
            NfTypeAnyOf::Smsf => write!(f, "SMSF"),
            NfTypeAnyOf::Nssf => write!(f, "NSSF"),
            NfTypeAnyOf::Udr => write!(f, "UDR"),
            NfTypeAnyOf::Lmf => write!(f, "LMF"),
            NfTypeAnyOf::Gmlc => write!(f, "GMLC"),
            NfTypeAnyOf::Variant5GEir => write!(f, "5G_EIR"),
            NfTypeAnyOf::Sepp => write!(f, "SEPP"),
            NfTypeAnyOf::Upf => write!(f, "UPF"),
            NfTypeAnyOf::N3Iwf => write!(f, "N3IWF"),
            NfTypeAnyOf::Af => write!(f, "AF"),
            NfTypeAnyOf::Udsf => write!(f, "UDSF"),
            NfTypeAnyOf::Bsf => write!(f, "BSF"),
            NfTypeAnyOf::Chf => write!(f, "CHF"),
            NfTypeAnyOf::Nwdaf => write!(f, "NWDAF"),
            NfTypeAnyOf::Pcscf => write!(f, "PCSCF"),
            NfTypeAnyOf::Cbcf => write!(f, "CBCF"),
            NfTypeAnyOf::Hss => write!(f, "HSS"),
            NfTypeAnyOf::Ucmf => write!(f, "UCMF"),
            NfTypeAnyOf::SorAf => write!(f, "SOR_AF"),
            NfTypeAnyOf::Spaf => write!(f, "SPAF"),
            NfTypeAnyOf::Mme => write!(f, "MME"),
            NfTypeAnyOf::Scsas => write!(f, "SCSAS"),
            NfTypeAnyOf::Scef => write!(f, "SCEF"),
            NfTypeAnyOf::Scp => write!(f, "SCP"),
            NfTypeAnyOf::Nssaaf => write!(f, "NSSAAF"),
            NfTypeAnyOf::Icscf => write!(f, "ICSCF"),
            NfTypeAnyOf::Scscf => write!(f, "SCSCF"),
            NfTypeAnyOf::Dra => write!(f, "DRA"),
            NfTypeAnyOf::ImsAs => write!(f, "IMS_AS"),
            NfTypeAnyOf::Aanf => write!(f, "AANF"),
            NfTypeAnyOf::Variant5GDdnmf => write!(f, "5G_DDNMF"),
            NfTypeAnyOf::Nsacf => write!(f, "NSACF"),
            NfTypeAnyOf::Mfaf => write!(f, "MFAF"),
            NfTypeAnyOf::Easdf => write!(f, "EASDF"),
            NfTypeAnyOf::Dccf => write!(f, "DCCF"),
            NfTypeAnyOf::MbSmf => write!(f, "MB_SMF"),
            NfTypeAnyOf::Tsctsf => write!(f, "TSCTSF"),
            NfTypeAnyOf::Adrf => write!(f, "ADRF"),
            NfTypeAnyOf::GbaBsf => write!(f, "GBA_BSF"),
            NfTypeAnyOf::Cef => write!(f, "CEF"),
            NfTypeAnyOf::MbUpf => write!(f, "MB_UPF"),
            NfTypeAnyOf::Nswof => write!(f, "NSWOF"),
            NfTypeAnyOf::Pkmf => write!(f, "PKMF"),
            NfTypeAnyOf::Mnpf => write!(f, "MNPF"),
            NfTypeAnyOf::SmsGmsc => write!(f, "SMS_GMSC"),
            NfTypeAnyOf::SmsIwmsc => write!(f, "SMS_IWMSC"),
            NfTypeAnyOf::Mbsf => write!(f, "MBSF"),
            NfTypeAnyOf::Mbstf => write!(f, "MBSTF"),
            NfTypeAnyOf::Panf => write!(f, "PANF"),
        }
    }
}

impl std::str::FromStr for NfTypeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "NRF" => std::result::Result::Ok(NfTypeAnyOf::Nrf),
            "UDM" => std::result::Result::Ok(NfTypeAnyOf::Udm),
            "AMF" => std::result::Result::Ok(NfTypeAnyOf::Amf),
            "SMF" => std::result::Result::Ok(NfTypeAnyOf::Smf),
            "AUSF" => std::result::Result::Ok(NfTypeAnyOf::Ausf),
            "NEF" => std::result::Result::Ok(NfTypeAnyOf::Nef),
            "PCF" => std::result::Result::Ok(NfTypeAnyOf::Pcf),
            "SMSF" => std::result::Result::Ok(NfTypeAnyOf::Smsf),
            "NSSF" => std::result::Result::Ok(NfTypeAnyOf::Nssf),
            "UDR" => std::result::Result::Ok(NfTypeAnyOf::Udr),
            "LMF" => std::result::Result::Ok(NfTypeAnyOf::Lmf),
            "GMLC" => std::result::Result::Ok(NfTypeAnyOf::Gmlc),
            "5G_EIR" => std::result::Result::Ok(NfTypeAnyOf::Variant5GEir),
            "SEPP" => std::result::Result::Ok(NfTypeAnyOf::Sepp),
            "UPF" => std::result::Result::Ok(NfTypeAnyOf::Upf),
            "N3IWF" => std::result::Result::Ok(NfTypeAnyOf::N3Iwf),
            "AF" => std::result::Result::Ok(NfTypeAnyOf::Af),
            "UDSF" => std::result::Result::Ok(NfTypeAnyOf::Udsf),
            "BSF" => std::result::Result::Ok(NfTypeAnyOf::Bsf),
            "CHF" => std::result::Result::Ok(NfTypeAnyOf::Chf),
            "NWDAF" => std::result::Result::Ok(NfTypeAnyOf::Nwdaf),
            "PCSCF" => std::result::Result::Ok(NfTypeAnyOf::Pcscf),
            "CBCF" => std::result::Result::Ok(NfTypeAnyOf::Cbcf),
            "HSS" => std::result::Result::Ok(NfTypeAnyOf::Hss),
            "UCMF" => std::result::Result::Ok(NfTypeAnyOf::Ucmf),
            "SOR_AF" => std::result::Result::Ok(NfTypeAnyOf::SorAf),
            "SPAF" => std::result::Result::Ok(NfTypeAnyOf::Spaf),
            "MME" => std::result::Result::Ok(NfTypeAnyOf::Mme),
            "SCSAS" => std::result::Result::Ok(NfTypeAnyOf::Scsas),
            "SCEF" => std::result::Result::Ok(NfTypeAnyOf::Scef),
            "SCP" => std::result::Result::Ok(NfTypeAnyOf::Scp),
            "NSSAAF" => std::result::Result::Ok(NfTypeAnyOf::Nssaaf),
            "ICSCF" => std::result::Result::Ok(NfTypeAnyOf::Icscf),
            "SCSCF" => std::result::Result::Ok(NfTypeAnyOf::Scscf),
            "DRA" => std::result::Result::Ok(NfTypeAnyOf::Dra),
            "IMS_AS" => std::result::Result::Ok(NfTypeAnyOf::ImsAs),
            "AANF" => std::result::Result::Ok(NfTypeAnyOf::Aanf),
            "5G_DDNMF" => std::result::Result::Ok(NfTypeAnyOf::Variant5GDdnmf),
            "NSACF" => std::result::Result::Ok(NfTypeAnyOf::Nsacf),
            "MFAF" => std::result::Result::Ok(NfTypeAnyOf::Mfaf),
            "EASDF" => std::result::Result::Ok(NfTypeAnyOf::Easdf),
            "DCCF" => std::result::Result::Ok(NfTypeAnyOf::Dccf),
            "MB_SMF" => std::result::Result::Ok(NfTypeAnyOf::MbSmf),
            "TSCTSF" => std::result::Result::Ok(NfTypeAnyOf::Tsctsf),
            "ADRF" => std::result::Result::Ok(NfTypeAnyOf::Adrf),
            "GBA_BSF" => std::result::Result::Ok(NfTypeAnyOf::GbaBsf),
            "CEF" => std::result::Result::Ok(NfTypeAnyOf::Cef),
            "MB_UPF" => std::result::Result::Ok(NfTypeAnyOf::MbUpf),
            "NSWOF" => std::result::Result::Ok(NfTypeAnyOf::Nswof),
            "PKMF" => std::result::Result::Ok(NfTypeAnyOf::Pkmf),
            "MNPF" => std::result::Result::Ok(NfTypeAnyOf::Mnpf),
            "SMS_GMSC" => std::result::Result::Ok(NfTypeAnyOf::SmsGmsc),
            "SMS_IWMSC" => std::result::Result::Ok(NfTypeAnyOf::SmsIwmsc),
            "MBSF" => std::result::Result::Ok(NfTypeAnyOf::Mbsf),
            "MBSTF" => std::result::Result::Ok(NfTypeAnyOf::Mbstf),
            "PANF" => std::result::Result::Ok(NfTypeAnyOf::Panf),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// This represents the Network Identifier, which together with a PLMN ID is used to identify an SNPN (see 3GPP TS 23.003 and 3GPP TS 23.501 clause 5.30.2.1).
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Nid(String);

impl std::convert::From<String> for Nid {
    fn from(x: String) -> Self {
        Nid(x)
    }
}

impl std::string::ToString for Nid {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Nid {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Nid(x.to_string()))
    }
}

impl std::convert::From<Nid> for String {
    fn from(x: Nid) -> Self {
        x.0
    }
}

impl std::ops::Deref for Nid {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Nid {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Provides the reason for not finding NF matching the search criteria
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NoProfileMatchInfo {
    #[serde(rename = "reason")]
    pub reason: models::NoProfileMatchReason,

    #[serde(rename = "queryParamCombinationList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query_param_combination_list: Option<Vec<models::QueryParamCombination>>,
}

impl NoProfileMatchInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(reason: models::NoProfileMatchReason) -> NoProfileMatchInfo {
        NoProfileMatchInfo {
            reason,
            query_param_combination_list: None,
        }
    }
}

/// Converts the NoProfileMatchInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NoProfileMatchInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping reason in query parameter serialization

            // Skipping queryParamCombinationList in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NoProfileMatchInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NoProfileMatchInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub reason: Vec<models::NoProfileMatchReason>,
            pub query_param_combination_list: Vec<Vec<models::QueryParamCombination>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NoProfileMatchInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "reason" => intermediate_rep.reason.push(
                        <models::NoProfileMatchReason as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "queryParamCombinationList" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in NoProfileMatchInfo"
                            .to_string(),
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NoProfileMatchInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NoProfileMatchInfo {
            reason: intermediate_rep
                .reason
                .into_iter()
                .next()
                .ok_or_else(|| "reason missing in NoProfileMatchInfo".to_string())?,
            query_param_combination_list: intermediate_rep
                .query_param_combination_list
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NoProfileMatchInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NoProfileMatchInfo>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NoProfileMatchInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NoProfileMatchInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<NoProfileMatchInfo>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NoProfileMatchInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NoProfileMatchInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// No Profile Match Reason
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NoProfileMatchReason {}

impl NoProfileMatchReason {
    #[allow(clippy::new_without_default)]
    pub fn new() -> NoProfileMatchReason {
        NoProfileMatchReason {}
    }
}

/// Converts the NoProfileMatchReason value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NoProfileMatchReason {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NoProfileMatchReason value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NoProfileMatchReason {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NoProfileMatchReason".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NoProfileMatchReason".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NoProfileMatchReason {})
    }
}

// Methods for converting between header::IntoHeaderValue<NoProfileMatchReason> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NoProfileMatchReason>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NoProfileMatchReason>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NoProfileMatchReason - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<NoProfileMatchReason>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NoProfileMatchReason as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NoProfileMatchReason - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum NoProfileMatchReasonAnyOf {
    #[serde(rename = "REQUESTER_PLMN_NOT_ALLOWED")]
    RequesterPlmnNotAllowed,
    #[serde(rename = "TARGET_NF_SUSPENDED")]
    TargetNfSuspended,
    #[serde(rename = "TARGET_NF_UNDISCOVERABLE")]
    TargetNfUndiscoverable,
    #[serde(rename = "QUERY_PARAMS_COMBINATION_NO_MATCH")]
    QueryParamsCombinationNoMatch,
    #[serde(rename = "UNSPECIFIED")]
    Unspecified,
}

impl std::fmt::Display for NoProfileMatchReasonAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            NoProfileMatchReasonAnyOf::RequesterPlmnNotAllowed => {
                write!(f, "REQUESTER_PLMN_NOT_ALLOWED")
            }
            NoProfileMatchReasonAnyOf::TargetNfSuspended => write!(f, "TARGET_NF_SUSPENDED"),
            NoProfileMatchReasonAnyOf::TargetNfUndiscoverable => {
                write!(f, "TARGET_NF_UNDISCOVERABLE")
            }
            NoProfileMatchReasonAnyOf::QueryParamsCombinationNoMatch => {
                write!(f, "QUERY_PARAMS_COMBINATION_NO_MATCH")
            }
            NoProfileMatchReasonAnyOf::Unspecified => write!(f, "UNSPECIFIED"),
        }
    }
}

impl std::str::FromStr for NoProfileMatchReasonAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "REQUESTER_PLMN_NOT_ALLOWED" => {
                std::result::Result::Ok(NoProfileMatchReasonAnyOf::RequesterPlmnNotAllowed)
            }
            "TARGET_NF_SUSPENDED" => {
                std::result::Result::Ok(NoProfileMatchReasonAnyOf::TargetNfSuspended)
            }
            "TARGET_NF_UNDISCOVERABLE" => {
                std::result::Result::Ok(NoProfileMatchReasonAnyOf::TargetNfUndiscoverable)
            }
            "QUERY_PARAMS_COMBINATION_NO_MATCH" => {
                std::result::Result::Ok(NoProfileMatchReasonAnyOf::QueryParamsCombinationNoMatch)
            }
            "UNSPECIFIED" => std::result::Result::Ok(NoProfileMatchReasonAnyOf::Unspecified),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Types of notifications used in Default Notification URIs in the NF Profile of an NF Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NotificationType {}

impl NotificationType {
    #[allow(clippy::new_without_default)]
    pub fn new() -> NotificationType {
        NotificationType {}
    }
}

/// Converts the NotificationType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NotificationType {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NotificationType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NotificationType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NotificationType".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NotificationType".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NotificationType {})
    }
}

// Methods for converting between header::IntoHeaderValue<NotificationType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NotificationType>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NotificationType>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NotificationType - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<NotificationType>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NotificationType as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NotificationType - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum NotificationTypeAnyOf {
    #[serde(rename = "N1_MESSAGES")]
    N1Messages,
    #[serde(rename = "N2_INFORMATION")]
    N2Information,
    #[serde(rename = "LOCATION_NOTIFICATION")]
    LocationNotification,
    #[serde(rename = "DATA_REMOVAL_NOTIFICATION")]
    DataRemovalNotification,
    #[serde(rename = "DATA_CHANGE_NOTIFICATION")]
    DataChangeNotification,
    #[serde(rename = "LOCATION_UPDATE_NOTIFICATION")]
    LocationUpdateNotification,
    #[serde(rename = "NSSAA_REAUTH_NOTIFICATION")]
    NssaaReauthNotification,
    #[serde(rename = "NSSAA_REVOC_NOTIFICATION")]
    NssaaRevocNotification,
    #[serde(rename = "MATCH_INFO_NOTIFICATION")]
    MatchInfoNotification,
    #[serde(rename = "DATA_RESTORATION_NOTIFICATION")]
    DataRestorationNotification,
    #[serde(rename = "TSCTS_NOTIFICATION")]
    TsctsNotification,
    #[serde(rename = "LCS_KEY_DELIVERY_NOTIFICATION")]
    LcsKeyDeliveryNotification,
}

impl std::fmt::Display for NotificationTypeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            NotificationTypeAnyOf::N1Messages => write!(f, "N1_MESSAGES"),
            NotificationTypeAnyOf::N2Information => write!(f, "N2_INFORMATION"),
            NotificationTypeAnyOf::LocationNotification => write!(f, "LOCATION_NOTIFICATION"),
            NotificationTypeAnyOf::DataRemovalNotification => {
                write!(f, "DATA_REMOVAL_NOTIFICATION")
            }
            NotificationTypeAnyOf::DataChangeNotification => write!(f, "DATA_CHANGE_NOTIFICATION"),
            NotificationTypeAnyOf::LocationUpdateNotification => {
                write!(f, "LOCATION_UPDATE_NOTIFICATION")
            }
            NotificationTypeAnyOf::NssaaReauthNotification => {
                write!(f, "NSSAA_REAUTH_NOTIFICATION")
            }
            NotificationTypeAnyOf::NssaaRevocNotification => write!(f, "NSSAA_REVOC_NOTIFICATION"),
            NotificationTypeAnyOf::MatchInfoNotification => write!(f, "MATCH_INFO_NOTIFICATION"),
            NotificationTypeAnyOf::DataRestorationNotification => {
                write!(f, "DATA_RESTORATION_NOTIFICATION")
            }
            NotificationTypeAnyOf::TsctsNotification => write!(f, "TSCTS_NOTIFICATION"),
            NotificationTypeAnyOf::LcsKeyDeliveryNotification => {
                write!(f, "LCS_KEY_DELIVERY_NOTIFICATION")
            }
        }
    }
}

impl std::str::FromStr for NotificationTypeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "N1_MESSAGES" => std::result::Result::Ok(NotificationTypeAnyOf::N1Messages),
            "N2_INFORMATION" => std::result::Result::Ok(NotificationTypeAnyOf::N2Information),
            "LOCATION_NOTIFICATION" => {
                std::result::Result::Ok(NotificationTypeAnyOf::LocationNotification)
            }
            "DATA_REMOVAL_NOTIFICATION" => {
                std::result::Result::Ok(NotificationTypeAnyOf::DataRemovalNotification)
            }
            "DATA_CHANGE_NOTIFICATION" => {
                std::result::Result::Ok(NotificationTypeAnyOf::DataChangeNotification)
            }
            "LOCATION_UPDATE_NOTIFICATION" => {
                std::result::Result::Ok(NotificationTypeAnyOf::LocationUpdateNotification)
            }
            "NSSAA_REAUTH_NOTIFICATION" => {
                std::result::Result::Ok(NotificationTypeAnyOf::NssaaReauthNotification)
            }
            "NSSAA_REVOC_NOTIFICATION" => {
                std::result::Result::Ok(NotificationTypeAnyOf::NssaaRevocNotification)
            }
            "MATCH_INFO_NOTIFICATION" => {
                std::result::Result::Ok(NotificationTypeAnyOf::MatchInfoNotification)
            }
            "DATA_RESTORATION_NOTIFICATION" => {
                std::result::Result::Ok(NotificationTypeAnyOf::DataRestorationNotification)
            }
            "TSCTS_NOTIFICATION" => {
                std::result::Result::Ok(NotificationTypeAnyOf::TsctsNotification)
            }
            "LCS_KEY_DELIVERY_NOTIFICATION" => {
                std::result::Result::Ok(NotificationTypeAnyOf::LcsKeyDeliveryNotification)
            }
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// 36-bit string identifying an NR Cell Id as specified in clause 9.3.1.7 of 3GPP TS 38.413,  in hexadecimal representation. Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character  representing the 4 most significant bits of the Cell Id shall appear first in the string, and  the character representing the 4 least significant bit of the Cell Id shall appear last in the  string.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NrCellId(String);

impl std::convert::From<String> for NrCellId {
    fn from(x: String) -> Self {
        NrCellId(x)
    }
}

impl std::string::ToString for NrCellId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for NrCellId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(NrCellId(x.to_string()))
    }
}

impl std::convert::From<NrCellId> for String {
    fn from(x: NrCellId) -> Self {
        x.0
    }
}

impl std::ops::Deref for NrCellId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for NrCellId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// NSACF service capabilities (e.g. to monitor and control the number of registered UEs or established PDU sessions per network slice)
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NsacfCapability {
    /// Indicates the service capability of the NSACF to monitor and control the number of registered UEs per network slice for the network slice that is subject to NSAC   true: Supported   false (default): Not Supported
    #[serde(rename = "supportUeSAC")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub support_ue_sac: Option<bool>,

    /// Indicates the service capability of the NSACF to monitor and control the number of established PDU sessions per network slice for the network slice that is subject to NSAC   true: Supported   false (default): Not Supported
    #[serde(rename = "supportPduSAC")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub support_pdu_sac: Option<bool>,
}

impl NsacfCapability {
    #[allow(clippy::new_without_default)]
    pub fn new() -> NsacfCapability {
        NsacfCapability {
            support_ue_sac: Some(false),
            support_pdu_sac: Some(false),
        }
    }
}

/// Converts the NsacfCapability value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NsacfCapability {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.support_ue_sac.as_ref().map(|support_ue_sac| {
                vec!["supportUeSAC".to_string(), support_ue_sac.to_string()].join(",")
            }),
            self.support_pdu_sac.as_ref().map(|support_pdu_sac| {
                vec!["supportPduSAC".to_string(), support_pdu_sac.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NsacfCapability value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NsacfCapability {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub support_ue_sac: Vec<bool>,
            pub support_pdu_sac: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NsacfCapability".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "supportUeSAC" => intermediate_rep.support_ue_sac.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "supportPduSAC" => intermediate_rep.support_pdu_sac.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NsacfCapability".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NsacfCapability {
            support_ue_sac: intermediate_rep.support_ue_sac.into_iter().next(),
            support_pdu_sac: intermediate_rep.support_pdu_sac.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NsacfCapability> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NsacfCapability>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NsacfCapability>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NsacfCapability - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<NsacfCapability>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NsacfCapability as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NsacfCapability - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Information of a NSACF NF Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NsacfInfo {
    #[serde(rename = "nsacfCapability")]
    pub nsacf_capability: models::NsacfCapability,

    #[serde(rename = "taiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tai_list: Option<Vec<models::Tai>>,

    #[serde(rename = "taiRangeList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tai_range_list: Option<Vec<models::TaiRange>>,
}

impl NsacfInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(nsacf_capability: models::NsacfCapability) -> NsacfInfo {
        NsacfInfo {
            nsacf_capability,
            tai_list: None,
            tai_range_list: None,
        }
    }
}

/// Converts the NsacfInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NsacfInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping nsacfCapability in query parameter serialization

            // Skipping taiList in query parameter serialization

            // Skipping taiRangeList in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NsacfInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NsacfInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub nsacf_capability: Vec<models::NsacfCapability>,
            pub tai_list: Vec<Vec<models::Tai>>,
            pub tai_range_list: Vec<Vec<models::TaiRange>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NsacfInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "nsacfCapability" => intermediate_rep.nsacf_capability.push(
                        <models::NsacfCapability as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "taiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NsacfInfo"
                                .to_string(),
                        )
                    }
                    "taiRangeList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NsacfInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NsacfInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NsacfInfo {
            nsacf_capability: intermediate_rep
                .nsacf_capability
                .into_iter()
                .next()
                .ok_or_else(|| "nsacfCapability missing in NsacfInfo".to_string())?,
            tai_list: intermediate_rep.tai_list.into_iter().next(),
            tai_range_list: intermediate_rep.tai_range_list.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NsacfInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NsacfInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NsacfInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NsacfInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<NsacfInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NsacfInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NsacfInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Information of a NSSAAF Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NssaafInfo {
    #[serde(rename = "supiRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supi_ranges: Option<Vec<models::SupiRange>>,

    #[serde(rename = "internalGroupIdentifiersRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub internal_group_identifiers_ranges: Option<Vec<models::InternalGroupIdRange>>,
}

impl NssaafInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> NssaafInfo {
        NssaafInfo {
            supi_ranges: None,
            internal_group_identifiers_ranges: None,
        }
    }
}

/// Converts the NssaafInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NssaafInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping supiRanges in query parameter serialization

            // Skipping internalGroupIdentifiersRanges in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NssaafInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NssaafInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub supi_ranges: Vec<Vec<models::SupiRange>>,
            pub internal_group_identifiers_ranges: Vec<Vec<models::InternalGroupIdRange>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NssaafInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "supiRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NssaafInfo"
                                .to_string(),
                        )
                    }
                    "internalGroupIdentifiersRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NssaafInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NssaafInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NssaafInfo {
            supi_ranges: intermediate_rep.supi_ranges.into_iter().next(),
            internal_group_identifiers_ranges: intermediate_rep
                .internal_group_identifiers_ranges
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NssaafInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NssaafInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NssaafInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NssaafInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<NssaafInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NssaafInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NssaafInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Indicates the capability supported by the NWDAF
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NwdafCapability {
    #[serde(rename = "analyticsAggregation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub analytics_aggregation: Option<bool>,

    #[serde(rename = "analyticsMetadataProvisioning")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub analytics_metadata_provisioning: Option<bool>,
}

impl NwdafCapability {
    #[allow(clippy::new_without_default)]
    pub fn new() -> NwdafCapability {
        NwdafCapability {
            analytics_aggregation: Some(false),
            analytics_metadata_provisioning: Some(false),
        }
    }
}

/// Converts the NwdafCapability value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NwdafCapability {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.analytics_aggregation
                .as_ref()
                .map(|analytics_aggregation| {
                    vec![
                        "analyticsAggregation".to_string(),
                        analytics_aggregation.to_string(),
                    ]
                    .join(",")
                }),
            self.analytics_metadata_provisioning
                .as_ref()
                .map(|analytics_metadata_provisioning| {
                    vec![
                        "analyticsMetadataProvisioning".to_string(),
                        analytics_metadata_provisioning.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NwdafCapability value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NwdafCapability {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub analytics_aggregation: Vec<bool>,
            pub analytics_metadata_provisioning: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NwdafCapability".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "analyticsAggregation" => intermediate_rep.analytics_aggregation.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "analyticsMetadataProvisioning" => {
                        intermediate_rep.analytics_metadata_provisioning.push(
                            <bool as std::str::FromStr>::from_str(val)
                                .map_err(|x| x.to_string())?,
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NwdafCapability".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NwdafCapability {
            analytics_aggregation: intermediate_rep.analytics_aggregation.into_iter().next(),
            analytics_metadata_provisioning: intermediate_rep
                .analytics_metadata_provisioning
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NwdafCapability> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NwdafCapability>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NwdafCapability>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NwdafCapability - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<NwdafCapability>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NwdafCapability as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NwdafCapability - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Possible values are: - SLICE_LOAD_LEVEL: Indicates that the event subscribed is load level information of Network Slice   - NETWORK_PERFORMANCE: Indicates that the event subscribed is network performance information.   - NF_LOAD: Indicates that the event subscribed is load level and status of one or several Network Functions.   - SERVICE_EXPERIENCE: Indicates that the event subscribed is service experience.   - UE_MOBILITY: Indicates that the event subscribed is UE mobility information.   - UE_COMMUNICATION: Indicates that the event subscribed is UE communication information.   - QOS_SUSTAINABILITY: Indicates that the event subscribed is QoS sustainability.   - ABNORMAL_BEHAVIOUR: Indicates that the event subscribed is abnormal behaviour.   - USER_DATA_CONGESTION: Indicates that the event subscribed is user data congestion information.   - NSI_LOAD_LEVEL: Indicates that the event subscribed is load level information of Network Slice and the optionally associated Network Slice Instance   - DN_PERFORMANCE: Indicates that the event subscribed is DN performance information.   - DISPERSION: Indicates that the event subscribed is dispersion information.   - RED_TRANS_EXP: Indicates that the event subscribed is redundant transmission experience.   - WLAN_PERFORMANCE: Indicates that the event subscribed is WLAN performance.   - SM_CONGESTION: Indicates the Session Management Congestion Control Experience information for specific DNN and/or S-NSSAI.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NwdafEvent {}

impl NwdafEvent {
    #[allow(clippy::new_without_default)]
    pub fn new() -> NwdafEvent {
        NwdafEvent {}
    }
}

/// Converts the NwdafEvent value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NwdafEvent {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NwdafEvent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NwdafEvent {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NwdafEvent".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NwdafEvent".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NwdafEvent {})
    }
}

// Methods for converting between header::IntoHeaderValue<NwdafEvent> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NwdafEvent>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NwdafEvent>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NwdafEvent - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<NwdafEvent> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NwdafEvent as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NwdafEvent - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum NwdafEventAnyOf {
    #[serde(rename = "SLICE_LOAD_LEVEL")]
    SliceLoadLevel,
    #[serde(rename = "NETWORK_PERFORMANCE")]
    NetworkPerformance,
    #[serde(rename = "NF_LOAD")]
    NfLoad,
    #[serde(rename = "SERVICE_EXPERIENCE")]
    ServiceExperience,
    #[serde(rename = "UE_MOBILITY")]
    UeMobility,
    #[serde(rename = "UE_COMMUNICATION")]
    UeCommunication,
    #[serde(rename = "QOS_SUSTAINABILITY")]
    QosSustainability,
    #[serde(rename = "ABNORMAL_BEHAVIOUR")]
    AbnormalBehaviour,
    #[serde(rename = "USER_DATA_CONGESTION")]
    UserDataCongestion,
    #[serde(rename = "NSI_LOAD_LEVEL")]
    NsiLoadLevel,
    #[serde(rename = "DN_PERFORMANCE")]
    DnPerformance,
    #[serde(rename = "DISPERSION")]
    Dispersion,
    #[serde(rename = "RED_TRANS_EXP")]
    RedTransExp,
    #[serde(rename = "WLAN_PERFORMANCE")]
    WlanPerformance,
    #[serde(rename = "SM_CONGESTION")]
    SmCongestion,
}

impl std::fmt::Display for NwdafEventAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            NwdafEventAnyOf::SliceLoadLevel => write!(f, "SLICE_LOAD_LEVEL"),
            NwdafEventAnyOf::NetworkPerformance => write!(f, "NETWORK_PERFORMANCE"),
            NwdafEventAnyOf::NfLoad => write!(f, "NF_LOAD"),
            NwdafEventAnyOf::ServiceExperience => write!(f, "SERVICE_EXPERIENCE"),
            NwdafEventAnyOf::UeMobility => write!(f, "UE_MOBILITY"),
            NwdafEventAnyOf::UeCommunication => write!(f, "UE_COMMUNICATION"),
            NwdafEventAnyOf::QosSustainability => write!(f, "QOS_SUSTAINABILITY"),
            NwdafEventAnyOf::AbnormalBehaviour => write!(f, "ABNORMAL_BEHAVIOUR"),
            NwdafEventAnyOf::UserDataCongestion => write!(f, "USER_DATA_CONGESTION"),
            NwdafEventAnyOf::NsiLoadLevel => write!(f, "NSI_LOAD_LEVEL"),
            NwdafEventAnyOf::DnPerformance => write!(f, "DN_PERFORMANCE"),
            NwdafEventAnyOf::Dispersion => write!(f, "DISPERSION"),
            NwdafEventAnyOf::RedTransExp => write!(f, "RED_TRANS_EXP"),
            NwdafEventAnyOf::WlanPerformance => write!(f, "WLAN_PERFORMANCE"),
            NwdafEventAnyOf::SmCongestion => write!(f, "SM_CONGESTION"),
        }
    }
}

impl std::str::FromStr for NwdafEventAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "SLICE_LOAD_LEVEL" => std::result::Result::Ok(NwdafEventAnyOf::SliceLoadLevel),
            "NETWORK_PERFORMANCE" => std::result::Result::Ok(NwdafEventAnyOf::NetworkPerformance),
            "NF_LOAD" => std::result::Result::Ok(NwdafEventAnyOf::NfLoad),
            "SERVICE_EXPERIENCE" => std::result::Result::Ok(NwdafEventAnyOf::ServiceExperience),
            "UE_MOBILITY" => std::result::Result::Ok(NwdafEventAnyOf::UeMobility),
            "UE_COMMUNICATION" => std::result::Result::Ok(NwdafEventAnyOf::UeCommunication),
            "QOS_SUSTAINABILITY" => std::result::Result::Ok(NwdafEventAnyOf::QosSustainability),
            "ABNORMAL_BEHAVIOUR" => std::result::Result::Ok(NwdafEventAnyOf::AbnormalBehaviour),
            "USER_DATA_CONGESTION" => std::result::Result::Ok(NwdafEventAnyOf::UserDataCongestion),
            "NSI_LOAD_LEVEL" => std::result::Result::Ok(NwdafEventAnyOf::NsiLoadLevel),
            "DN_PERFORMANCE" => std::result::Result::Ok(NwdafEventAnyOf::DnPerformance),
            "DISPERSION" => std::result::Result::Ok(NwdafEventAnyOf::Dispersion),
            "RED_TRANS_EXP" => std::result::Result::Ok(NwdafEventAnyOf::RedTransExp),
            "WLAN_PERFORMANCE" => std::result::Result::Ok(NwdafEventAnyOf::WlanPerformance),
            "SM_CONGESTION" => std::result::Result::Ok(NwdafEventAnyOf::SmCongestion),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Information of a NWDAF NF Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NwdafInfo {
    #[serde(rename = "eventIds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub event_ids: Option<Vec<models::EventId>>,

    #[serde(rename = "nwdafEvents")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nwdaf_events: Option<Vec<models::NwdafEvent>>,

    #[serde(rename = "taiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tai_list: Option<Vec<models::Tai>>,

    #[serde(rename = "taiRangeList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tai_range_list: Option<Vec<models::TaiRange>>,

    #[serde(rename = "nwdafCapability")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nwdaf_capability: Option<models::NwdafCapability>,

    /// indicating a time in seconds.
    #[serde(rename = "analyticsDelay")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub analytics_delay: Option<i32>,

    #[serde(rename = "servingNfSetIdList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub serving_nf_set_id_list: Option<Vec<models::NfSetId>>,

    #[serde(rename = "servingNfTypeList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub serving_nf_type_list: Option<Vec<models::NfType>>,

    #[serde(rename = "mlAnalyticsList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ml_analytics_list: Option<Vec<models::MlAnalyticsInfo>>,
}

impl NwdafInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> NwdafInfo {
        NwdafInfo {
            event_ids: None,
            nwdaf_events: None,
            tai_list: None,
            tai_range_list: None,
            nwdaf_capability: None,
            analytics_delay: None,
            serving_nf_set_id_list: None,
            serving_nf_type_list: None,
            ml_analytics_list: None,
        }
    }
}

/// Converts the NwdafInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NwdafInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping eventIds in query parameter serialization

            // Skipping nwdafEvents in query parameter serialization

            // Skipping taiList in query parameter serialization

            // Skipping taiRangeList in query parameter serialization

            // Skipping nwdafCapability in query parameter serialization
            self.analytics_delay.as_ref().map(|analytics_delay| {
                vec!["analyticsDelay".to_string(), analytics_delay.to_string()].join(",")
            }),
            self.serving_nf_set_id_list
                .as_ref()
                .map(|serving_nf_set_id_list| {
                    vec![
                        "servingNfSetIdList".to_string(),
                        serving_nf_set_id_list
                            .iter()
                            .map(|x| x.to_string())
                            .collect::<Vec<_>>()
                            .join(","),
                    ]
                    .join(",")
                }),
            // Skipping servingNfTypeList in query parameter serialization

            // Skipping mlAnalyticsList in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NwdafInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NwdafInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_ids: Vec<Vec<models::EventId>>,
            pub nwdaf_events: Vec<Vec<models::NwdafEvent>>,
            pub tai_list: Vec<Vec<models::Tai>>,
            pub tai_range_list: Vec<Vec<models::TaiRange>>,
            pub nwdaf_capability: Vec<models::NwdafCapability>,
            pub analytics_delay: Vec<i32>,
            pub serving_nf_set_id_list: Vec<Vec<models::NfSetId>>,
            pub serving_nf_type_list: Vec<Vec<models::NfType>>,
            pub ml_analytics_list: Vec<Vec<models::MlAnalyticsInfo>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NwdafInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "eventIds" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NwdafInfo"
                                .to_string(),
                        )
                    }
                    "nwdafEvents" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NwdafInfo"
                                .to_string(),
                        )
                    }
                    "taiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NwdafInfo"
                                .to_string(),
                        )
                    }
                    "taiRangeList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NwdafInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "nwdafCapability" => intermediate_rep.nwdaf_capability.push(
                        <models::NwdafCapability as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "analyticsDelay" => intermediate_rep.analytics_delay.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "servingNfSetIdList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NwdafInfo"
                                .to_string(),
                        )
                    }
                    "servingNfTypeList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NwdafInfo"
                                .to_string(),
                        )
                    }
                    "mlAnalyticsList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NwdafInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NwdafInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NwdafInfo {
            event_ids: intermediate_rep.event_ids.into_iter().next(),
            nwdaf_events: intermediate_rep.nwdaf_events.into_iter().next(),
            tai_list: intermediate_rep.tai_list.into_iter().next(),
            tai_range_list: intermediate_rep.tai_range_list.into_iter().next(),
            nwdaf_capability: intermediate_rep.nwdaf_capability.into_iter().next(),
            analytics_delay: intermediate_rep.analytics_delay.into_iter().next(),
            serving_nf_set_id_list: intermediate_rep.serving_nf_set_id_list.into_iter().next(),
            serving_nf_type_list: intermediate_rep.serving_nf_type_list.into_iter().next(),
            ml_analytics_list: intermediate_rep.ml_analytics_list.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NwdafInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NwdafInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NwdafInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NwdafInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<NwdafInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NwdafInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NwdafInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Information of a PCF NF Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PcfInfo {
    /// Identifier of a group of NFs.
    #[serde(rename = "groupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub group_id: Option<String>,

    #[serde(rename = "dnnList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dnn_list: Option<Vec<models::Dnn>>,

    #[serde(rename = "supiRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supi_ranges: Option<Vec<models::SupiRange>>,

    #[serde(rename = "gpsiRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gpsi_ranges: Option<Vec<models::IdentityRange>>,

    /// Fully Qualified Domain Name
    #[serde(rename = "rxDiamHost")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rx_diam_host: Option<String>,

    /// Fully Qualified Domain Name
    #[serde(rename = "rxDiamRealm")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rx_diam_realm: Option<String>,

    #[serde(rename = "v2xSupportInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub v2x_support_ind: Option<bool>,

    #[serde(rename = "proseSupportInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prose_support_ind: Option<bool>,

    #[serde(rename = "proseCapability")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prose_capability: Option<models::ProSeCapability>,

    #[serde(rename = "v2xCapability")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub v2x_capability: Option<models::V2xCapability>,
}

impl PcfInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PcfInfo {
        PcfInfo {
            group_id: None,
            dnn_list: None,
            supi_ranges: None,
            gpsi_ranges: None,
            rx_diam_host: None,
            rx_diam_realm: None,
            v2x_support_ind: Some(false),
            prose_support_ind: Some(false),
            prose_capability: None,
            v2x_capability: None,
        }
    }
}

/// Converts the PcfInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PcfInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.group_id
                .as_ref()
                .map(|group_id| vec!["groupId".to_string(), group_id.to_string()].join(",")),
            self.dnn_list.as_ref().map(|dnn_list| {
                vec![
                    "dnnList".to_string(),
                    dnn_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping supiRanges in query parameter serialization

            // Skipping gpsiRanges in query parameter serialization
            self.rx_diam_host.as_ref().map(|rx_diam_host| {
                vec!["rxDiamHost".to_string(), rx_diam_host.to_string()].join(",")
            }),
            self.rx_diam_realm.as_ref().map(|rx_diam_realm| {
                vec!["rxDiamRealm".to_string(), rx_diam_realm.to_string()].join(",")
            }),
            self.v2x_support_ind.as_ref().map(|v2x_support_ind| {
                vec!["v2xSupportInd".to_string(), v2x_support_ind.to_string()].join(",")
            }),
            self.prose_support_ind.as_ref().map(|prose_support_ind| {
                vec!["proseSupportInd".to_string(), prose_support_ind.to_string()].join(",")
            }),
            // Skipping proseCapability in query parameter serialization

            // Skipping v2xCapability in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PcfInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PcfInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub group_id: Vec<String>,
            pub dnn_list: Vec<Vec<models::Dnn>>,
            pub supi_ranges: Vec<Vec<models::SupiRange>>,
            pub gpsi_ranges: Vec<Vec<models::IdentityRange>>,
            pub rx_diam_host: Vec<String>,
            pub rx_diam_realm: Vec<String>,
            pub v2x_support_ind: Vec<bool>,
            pub prose_support_ind: Vec<bool>,
            pub prose_capability: Vec<models::ProSeCapability>,
            pub v2x_capability: Vec<models::V2xCapability>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PcfInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "groupId" => intermediate_rep.group_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "dnnList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PcfInfo"
                                .to_string(),
                        )
                    }
                    "supiRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PcfInfo"
                                .to_string(),
                        )
                    }
                    "gpsiRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PcfInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "rxDiamHost" => intermediate_rep.rx_diam_host.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "rxDiamRealm" => intermediate_rep.rx_diam_realm.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "v2xSupportInd" => intermediate_rep.v2x_support_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "proseSupportInd" => intermediate_rep.prose_support_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "proseCapability" => intermediate_rep.prose_capability.push(
                        <models::ProSeCapability as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "v2xCapability" => intermediate_rep.v2x_capability.push(
                        <models::V2xCapability as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PcfInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PcfInfo {
            group_id: intermediate_rep.group_id.into_iter().next(),
            dnn_list: intermediate_rep.dnn_list.into_iter().next(),
            supi_ranges: intermediate_rep.supi_ranges.into_iter().next(),
            gpsi_ranges: intermediate_rep.gpsi_ranges.into_iter().next(),
            rx_diam_host: intermediate_rep.rx_diam_host.into_iter().next(),
            rx_diam_realm: intermediate_rep.rx_diam_realm.into_iter().next(),
            v2x_support_ind: intermediate_rep.v2x_support_ind.into_iter().next(),
            prose_support_ind: intermediate_rep.prose_support_ind.into_iter().next(),
            prose_capability: intermediate_rep.prose_capability.into_iter().next(),
            v2x_capability: intermediate_rep.v2x_capability.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PcfInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PcfInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PcfInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PcfInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PcfInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PcfInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PcfInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Information of a P-CSCF NF Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PcscfInfo {
    #[serde(rename = "accessType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub access_type: Option<Vec<models::AccessType>>,

    #[serde(rename = "dnnList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dnn_list: Option<Vec<models::Dnn>>,

    /// Fully Qualified Domain Name
    #[serde(rename = "gmFqdn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gm_fqdn: Option<String>,

    #[serde(rename = "gmIpv4Addresses")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gm_ipv4_addresses: Option<Vec<models::Ipv4Addr>>,

    #[serde(rename = "gmIpv6Addresses")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gm_ipv6_addresses: Option<Vec<models::Ipv6Addr>>,

    /// Fully Qualified Domain Name
    #[serde(rename = "mwFqdn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mw_fqdn: Option<String>,

    #[serde(rename = "mwIpv4Addresses")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mw_ipv4_addresses: Option<Vec<models::Ipv4Addr>>,

    #[serde(rename = "mwIpv6Addresses")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mw_ipv6_addresses: Option<Vec<models::Ipv6Addr>>,

    #[serde(rename = "servedIpv4AddressRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub served_ipv4_address_ranges: Option<Vec<models::Ipv4AddressRange>>,

    #[serde(rename = "servedIpv6PrefixRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub served_ipv6_prefix_ranges: Option<Vec<models::Ipv6PrefixRange>>,
}

impl PcscfInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PcscfInfo {
        PcscfInfo {
            access_type: None,
            dnn_list: None,
            gm_fqdn: None,
            gm_ipv4_addresses: None,
            gm_ipv6_addresses: None,
            mw_fqdn: None,
            mw_ipv4_addresses: None,
            mw_ipv6_addresses: None,
            served_ipv4_address_ranges: None,
            served_ipv6_prefix_ranges: None,
        }
    }
}

/// Converts the PcscfInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PcscfInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping accessType in query parameter serialization
            self.dnn_list.as_ref().map(|dnn_list| {
                vec![
                    "dnnList".to_string(),
                    dnn_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.gm_fqdn
                .as_ref()
                .map(|gm_fqdn| vec!["gmFqdn".to_string(), gm_fqdn.to_string()].join(",")),
            self.gm_ipv4_addresses.as_ref().map(|gm_ipv4_addresses| {
                vec![
                    "gmIpv4Addresses".to_string(),
                    gm_ipv4_addresses
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping gmIpv6Addresses in query parameter serialization
            self.mw_fqdn
                .as_ref()
                .map(|mw_fqdn| vec!["mwFqdn".to_string(), mw_fqdn.to_string()].join(",")),
            self.mw_ipv4_addresses.as_ref().map(|mw_ipv4_addresses| {
                vec![
                    "mwIpv4Addresses".to_string(),
                    mw_ipv4_addresses
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping mwIpv6Addresses in query parameter serialization

            // Skipping servedIpv4AddressRanges in query parameter serialization

            // Skipping servedIpv6PrefixRanges in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PcscfInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PcscfInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub access_type: Vec<Vec<models::AccessType>>,
            pub dnn_list: Vec<Vec<models::Dnn>>,
            pub gm_fqdn: Vec<String>,
            pub gm_ipv4_addresses: Vec<Vec<models::Ipv4Addr>>,
            pub gm_ipv6_addresses: Vec<Vec<models::Ipv6Addr>>,
            pub mw_fqdn: Vec<String>,
            pub mw_ipv4_addresses: Vec<Vec<models::Ipv4Addr>>,
            pub mw_ipv6_addresses: Vec<Vec<models::Ipv6Addr>>,
            pub served_ipv4_address_ranges: Vec<Vec<models::Ipv4AddressRange>>,
            pub served_ipv6_prefix_ranges: Vec<Vec<models::Ipv6PrefixRange>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PcscfInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "accessType" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PcscfInfo"
                                .to_string(),
                        )
                    }
                    "dnnList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PcscfInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "gmFqdn" => intermediate_rep.gm_fqdn.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "gmIpv4Addresses" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PcscfInfo"
                                .to_string(),
                        )
                    }
                    "gmIpv6Addresses" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PcscfInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "mwFqdn" => intermediate_rep.mw_fqdn.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "mwIpv4Addresses" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PcscfInfo"
                                .to_string(),
                        )
                    }
                    "mwIpv6Addresses" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PcscfInfo"
                                .to_string(),
                        )
                    }
                    "servedIpv4AddressRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PcscfInfo"
                                .to_string(),
                        )
                    }
                    "servedIpv6PrefixRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PcscfInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PcscfInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PcscfInfo {
            access_type: intermediate_rep.access_type.into_iter().next(),
            dnn_list: intermediate_rep.dnn_list.into_iter().next(),
            gm_fqdn: intermediate_rep.gm_fqdn.into_iter().next(),
            gm_ipv4_addresses: intermediate_rep.gm_ipv4_addresses.into_iter().next(),
            gm_ipv6_addresses: intermediate_rep.gm_ipv6_addresses.into_iter().next(),
            mw_fqdn: intermediate_rep.mw_fqdn.into_iter().next(),
            mw_ipv4_addresses: intermediate_rep.mw_ipv4_addresses.into_iter().next(),
            mw_ipv6_addresses: intermediate_rep.mw_ipv6_addresses.into_iter().next(),
            served_ipv4_address_ranges: intermediate_rep
                .served_ipv4_address_ranges
                .into_iter()
                .next(),
            served_ipv6_prefix_ranges: intermediate_rep
                .served_ipv6_prefix_ranges
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PcscfInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PcscfInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PcscfInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PcscfInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PcscfInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PcscfInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PcscfInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// PduSessionType indicates the type of a PDU session. It shall comply with the provisions defined in table 5.4.3.3-1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PduSessionType {}

impl PduSessionType {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PduSessionType {
        PduSessionType {}
    }
}

/// Converts the PduSessionType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PduSessionType {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PduSessionType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PduSessionType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PduSessionType".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PduSessionType".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PduSessionType {})
    }
}

// Methods for converting between header::IntoHeaderValue<PduSessionType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PduSessionType>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PduSessionType>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PduSessionType - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PduSessionType> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PduSessionType as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PduSessionType - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PduSessionTypeAnyOf {
    #[serde(rename = "IPV4")]
    Ipv4,
    #[serde(rename = "IPV6")]
    Ipv6,
    #[serde(rename = "IPV4V6")]
    Ipv4V6,
    #[serde(rename = "UNSTRUCTURED")]
    Unstructured,
    #[serde(rename = "ETHERNET")]
    Ethernet,
}

impl std::fmt::Display for PduSessionTypeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PduSessionTypeAnyOf::Ipv4 => write!(f, "IPV4"),
            PduSessionTypeAnyOf::Ipv6 => write!(f, "IPV6"),
            PduSessionTypeAnyOf::Ipv4V6 => write!(f, "IPV4V6"),
            PduSessionTypeAnyOf::Unstructured => write!(f, "UNSTRUCTURED"),
            PduSessionTypeAnyOf::Ethernet => write!(f, "ETHERNET"),
        }
    }
}

impl std::str::FromStr for PduSessionTypeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "IPV4" => std::result::Result::Ok(PduSessionTypeAnyOf::Ipv4),
            "IPV6" => std::result::Result::Ok(PduSessionTypeAnyOf::Ipv6),
            "IPV4V6" => std::result::Result::Ok(PduSessionTypeAnyOf::Ipv4V6),
            "UNSTRUCTURED" => std::result::Result::Ok(PduSessionTypeAnyOf::Unstructured),
            "ETHERNET" => std::result::Result::Ok(PduSessionTypeAnyOf::Ethernet),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// List of Application IDs and/or AF IDs managed by a given NEF Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PfdData {
    #[serde(rename = "appIds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub app_ids: Option<Vec<String>>,

    #[serde(rename = "afIds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub af_ids: Option<Vec<String>>,
}

impl PfdData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PfdData {
        PfdData {
            app_ids: None,
            af_ids: None,
        }
    }
}

/// Converts the PfdData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PfdData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.app_ids.as_ref().map(|app_ids| {
                vec![
                    "appIds".to_string(),
                    app_ids
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.af_ids.as_ref().map(|af_ids| {
                vec![
                    "afIds".to_string(),
                    af_ids
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PfdData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PfdData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub app_ids: Vec<Vec<String>>,
            pub af_ids: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PfdData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "appIds" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PfdData"
                                .to_string(),
                        )
                    }
                    "afIds" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PfdData"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PfdData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PfdData {
            app_ids: intermediate_rep.app_ids.into_iter().next(),
            af_ids: intermediate_rep.af_ids.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PfdData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PfdData>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PfdData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PfdData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PfdData> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PfdData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PfdData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// When PlmnId needs to be converted to string (e.g. when used in maps as key), the string  shall be composed of three digits \"mcc\" followed by \"-\" and two or three digits \"mnc\".
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PlmnId {
    /// Mobile Country Code part of the PLMN, comprising 3 digits, as defined in clause 9.3.3.5 of 3GPP TS 38.413.
    #[serde(rename = "mcc")]
    pub mcc: String,

    /// Mobile Network Code part of the PLMN, comprising 2 or 3 digits, as defined in clause 9.3.3.5 of 3GPP TS 38.413.
    #[serde(rename = "mnc")]
    pub mnc: String,
}

impl PlmnId {
    #[allow(clippy::new_without_default)]
    pub fn new(mcc: String, mnc: String) -> PlmnId {
        PlmnId { mcc, mnc }
    }
}

/// Converts the PlmnId value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PlmnId {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("mcc".to_string()),
            Some(self.mcc.to_string()),
            Some("mnc".to_string()),
            Some(self.mnc.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PlmnId value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PlmnId {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub mcc: Vec<String>,
            pub mnc: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PlmnId".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "mcc" => intermediate_rep.mcc.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "mnc" => intermediate_rep.mnc.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PlmnId".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PlmnId {
            mcc: intermediate_rep
                .mcc
                .into_iter()
                .next()
                .ok_or_else(|| "mcc missing in PlmnId".to_string())?,
            mnc: intermediate_rep
                .mnc
                .into_iter()
                .next()
                .ok_or_else(|| "mnc missing in PlmnId".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PlmnId> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PlmnId>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PlmnId>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PlmnId - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PlmnId> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PlmnId as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PlmnId - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains the serving core network operator PLMN ID and, for an SNPN, the NID that together with the PLMN ID identifies the SNPN.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PlmnIdNid {
    /// Mobile Country Code part of the PLMN, comprising 3 digits, as defined in clause 9.3.3.5 of 3GPP TS 38.413.
    #[serde(rename = "mcc")]
    pub mcc: String,

    /// Mobile Network Code part of the PLMN, comprising 2 or 3 digits, as defined in clause 9.3.3.5 of 3GPP TS 38.413.
    #[serde(rename = "mnc")]
    pub mnc: String,

    /// This represents the Network Identifier, which together with a PLMN ID is used to identify an SNPN (see 3GPP TS 23.003 and 3GPP TS 23.501 clause 5.30.2.1).
    #[serde(rename = "nid")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nid: Option<String>,
}

impl PlmnIdNid {
    #[allow(clippy::new_without_default)]
    pub fn new(mcc: String, mnc: String) -> PlmnIdNid {
        PlmnIdNid {
            mcc,
            mnc,
            nid: None,
        }
    }
}

/// Converts the PlmnIdNid value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PlmnIdNid {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("mcc".to_string()),
            Some(self.mcc.to_string()),
            Some("mnc".to_string()),
            Some(self.mnc.to_string()),
            self.nid
                .as_ref()
                .map(|nid| vec!["nid".to_string(), nid.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PlmnIdNid value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PlmnIdNid {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub mcc: Vec<String>,
            pub mnc: Vec<String>,
            pub nid: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PlmnIdNid".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "mcc" => intermediate_rep.mcc.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "mnc" => intermediate_rep.mnc.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nid" => intermediate_rep.nid.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PlmnIdNid".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PlmnIdNid {
            mcc: intermediate_rep
                .mcc
                .into_iter()
                .next()
                .ok_or_else(|| "mcc missing in PlmnIdNid".to_string())?,
            mnc: intermediate_rep
                .mnc
                .into_iter()
                .next()
                .ok_or_else(|| "mnc missing in PlmnIdNid".to_string())?,
            nid: intermediate_rep.nid.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PlmnIdNid> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PlmnIdNid>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PlmnIdNid>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PlmnIdNid - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PlmnIdNid> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PlmnIdNid as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PlmnIdNid - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Range of PLMN IDs
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PlmnRange {
    #[serde(rename = "start")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start: Option<String>,

    #[serde(rename = "end")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end: Option<String>,

    #[serde(rename = "pattern")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
}

impl PlmnRange {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PlmnRange {
        PlmnRange {
            start: None,
            end: None,
            pattern: None,
        }
    }
}

/// Converts the PlmnRange value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PlmnRange {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.start
                .as_ref()
                .map(|start| vec!["start".to_string(), start.to_string()].join(",")),
            self.end
                .as_ref()
                .map(|end| vec!["end".to_string(), end.to_string()].join(",")),
            self.pattern
                .as_ref()
                .map(|pattern| vec!["pattern".to_string(), pattern.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PlmnRange value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PlmnRange {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub start: Vec<String>,
            pub end: Vec<String>,
            pub pattern: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PlmnRange".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "start" => intermediate_rep.start.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "end" => intermediate_rep.end.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "pattern" => intermediate_rep.pattern.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PlmnRange".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PlmnRange {
            start: intermediate_rep.start.into_iter().next(),
            end: intermediate_rep.end.into_iter().next(),
            pattern: intermediate_rep.pattern.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PlmnRange> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PlmnRange>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PlmnRange>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PlmnRange - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PlmnRange> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PlmnRange as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PlmnRange - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// List of network slices (S-NSSAIs) for a given PLMN ID
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PlmnSnssai {
    #[serde(rename = "plmnId")]
    pub plmn_id: models::PlmnId,

    #[serde(rename = "sNssaiList")]
    pub s_nssai_list: Vec<models::ExtSnssai>,

    /// This represents the Network Identifier, which together with a PLMN ID is used to identify an SNPN (see 3GPP TS 23.003 and 3GPP TS 23.501 clause 5.30.2.1).
    #[serde(rename = "nid")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nid: Option<String>,
}

impl PlmnSnssai {
    #[allow(clippy::new_without_default)]
    pub fn new(plmn_id: models::PlmnId, s_nssai_list: Vec<models::ExtSnssai>) -> PlmnSnssai {
        PlmnSnssai {
            plmn_id,
            s_nssai_list,
            nid: None,
        }
    }
}

/// Converts the PlmnSnssai value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PlmnSnssai {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping plmnId in query parameter serialization

            // Skipping sNssaiList in query parameter serialization
            self.nid
                .as_ref()
                .map(|nid| vec!["nid".to_string(), nid.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PlmnSnssai value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PlmnSnssai {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub plmn_id: Vec<models::PlmnId>,
            pub s_nssai_list: Vec<Vec<models::ExtSnssai>>,
            pub nid: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PlmnSnssai".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "plmnId" => intermediate_rep.plmn_id.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "sNssaiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PlmnSnssai"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "nid" => intermediate_rep.nid.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PlmnSnssai".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PlmnSnssai {
            plmn_id: intermediate_rep
                .plmn_id
                .into_iter()
                .next()
                .ok_or_else(|| "plmnId missing in PlmnSnssai".to_string())?,
            s_nssai_list: intermediate_rep
                .s_nssai_list
                .into_iter()
                .next()
                .ok_or_else(|| "sNssaiList missing in PlmnSnssai".to_string())?,
            nid: intermediate_rep.nid.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PlmnSnssai> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PlmnSnssai>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PlmnSnssai>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PlmnSnssai - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PlmnSnssai> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PlmnSnssai as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PlmnSnssai - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains information on whether the returned NFProfiles match the preferred query parameters
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PreferredSearch {
    #[serde(rename = "preferredTaiMatchInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub preferred_tai_match_ind: Option<bool>,

    #[serde(rename = "preferredFullPlmnMatchInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub preferred_full_plmn_match_ind: Option<bool>,

    #[serde(rename = "preferredApiVersionsMatchInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub preferred_api_versions_match_ind: Option<bool>,

    #[serde(rename = "otherApiVersionsInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub other_api_versions_ind: Option<bool>,

    #[serde(rename = "preferredLocalityMatchInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub preferred_locality_match_ind: Option<bool>,

    #[serde(rename = "otherLocalityInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub other_locality_ind: Option<bool>,

    #[serde(rename = "preferredVendorSpecificFeaturesInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub preferred_vendor_specific_features_ind: Option<bool>,

    #[serde(rename = "preferredCollocatedNfTypeInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub preferred_collocated_nf_type_ind: Option<bool>,

    #[serde(rename = "preferredPgwMatchInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub preferred_pgw_match_ind: Option<bool>,

    #[serde(rename = "preferredAnalyticsDelaysInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub preferred_analytics_delays_ind: Option<bool>,
}

impl PreferredSearch {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PreferredSearch {
        PreferredSearch {
            preferred_tai_match_ind: Some(false),
            preferred_full_plmn_match_ind: Some(false),
            preferred_api_versions_match_ind: None,
            other_api_versions_ind: None,
            preferred_locality_match_ind: Some(false),
            other_locality_ind: Some(false),
            preferred_vendor_specific_features_ind: Some(false),
            preferred_collocated_nf_type_ind: Some(false),
            preferred_pgw_match_ind: None,
            preferred_analytics_delays_ind: None,
        }
    }
}

/// Converts the PreferredSearch value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PreferredSearch {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.preferred_tai_match_ind
                .as_ref()
                .map(|preferred_tai_match_ind| {
                    vec![
                        "preferredTaiMatchInd".to_string(),
                        preferred_tai_match_ind.to_string(),
                    ]
                    .join(",")
                }),
            self.preferred_full_plmn_match_ind
                .as_ref()
                .map(|preferred_full_plmn_match_ind| {
                    vec![
                        "preferredFullPlmnMatchInd".to_string(),
                        preferred_full_plmn_match_ind.to_string(),
                    ]
                    .join(",")
                }),
            self.preferred_api_versions_match_ind.as_ref().map(
                |preferred_api_versions_match_ind| {
                    vec![
                        "preferredApiVersionsMatchInd".to_string(),
                        preferred_api_versions_match_ind.to_string(),
                    ]
                    .join(",")
                },
            ),
            self.other_api_versions_ind
                .as_ref()
                .map(|other_api_versions_ind| {
                    vec![
                        "otherApiVersionsInd".to_string(),
                        other_api_versions_ind.to_string(),
                    ]
                    .join(",")
                }),
            self.preferred_locality_match_ind
                .as_ref()
                .map(|preferred_locality_match_ind| {
                    vec![
                        "preferredLocalityMatchInd".to_string(),
                        preferred_locality_match_ind.to_string(),
                    ]
                    .join(",")
                }),
            self.other_locality_ind.as_ref().map(|other_locality_ind| {
                vec![
                    "otherLocalityInd".to_string(),
                    other_locality_ind.to_string(),
                ]
                .join(",")
            }),
            self.preferred_vendor_specific_features_ind.as_ref().map(
                |preferred_vendor_specific_features_ind| {
                    vec![
                        "preferredVendorSpecificFeaturesInd".to_string(),
                        preferred_vendor_specific_features_ind.to_string(),
                    ]
                    .join(",")
                },
            ),
            self.preferred_collocated_nf_type_ind.as_ref().map(
                |preferred_collocated_nf_type_ind| {
                    vec![
                        "preferredCollocatedNfTypeInd".to_string(),
                        preferred_collocated_nf_type_ind.to_string(),
                    ]
                    .join(",")
                },
            ),
            self.preferred_pgw_match_ind
                .as_ref()
                .map(|preferred_pgw_match_ind| {
                    vec![
                        "preferredPgwMatchInd".to_string(),
                        preferred_pgw_match_ind.to_string(),
                    ]
                    .join(",")
                }),
            self.preferred_analytics_delays_ind
                .as_ref()
                .map(|preferred_analytics_delays_ind| {
                    vec![
                        "preferredAnalyticsDelaysInd".to_string(),
                        preferred_analytics_delays_ind.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PreferredSearch value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PreferredSearch {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub preferred_tai_match_ind: Vec<bool>,
            pub preferred_full_plmn_match_ind: Vec<bool>,
            pub preferred_api_versions_match_ind: Vec<bool>,
            pub other_api_versions_ind: Vec<bool>,
            pub preferred_locality_match_ind: Vec<bool>,
            pub other_locality_ind: Vec<bool>,
            pub preferred_vendor_specific_features_ind: Vec<bool>,
            pub preferred_collocated_nf_type_ind: Vec<bool>,
            pub preferred_pgw_match_ind: Vec<bool>,
            pub preferred_analytics_delays_ind: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PreferredSearch".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "preferredTaiMatchInd" => intermediate_rep.preferred_tai_match_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "preferredFullPlmnMatchInd" => {
                        intermediate_rep.preferred_full_plmn_match_ind.push(
                            <bool as std::str::FromStr>::from_str(val)
                                .map_err(|x| x.to_string())?,
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "preferredApiVersionsMatchInd" => {
                        intermediate_rep.preferred_api_versions_match_ind.push(
                            <bool as std::str::FromStr>::from_str(val)
                                .map_err(|x| x.to_string())?,
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "otherApiVersionsInd" => intermediate_rep.other_api_versions_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "preferredLocalityMatchInd" => {
                        intermediate_rep.preferred_locality_match_ind.push(
                            <bool as std::str::FromStr>::from_str(val)
                                .map_err(|x| x.to_string())?,
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "otherLocalityInd" => intermediate_rep.other_locality_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "preferredVendorSpecificFeaturesInd" => intermediate_rep
                        .preferred_vendor_specific_features_ind
                        .push(
                            <bool as std::str::FromStr>::from_str(val)
                                .map_err(|x| x.to_string())?,
                        ),
                    #[allow(clippy::redundant_clone)]
                    "preferredCollocatedNfTypeInd" => {
                        intermediate_rep.preferred_collocated_nf_type_ind.push(
                            <bool as std::str::FromStr>::from_str(val)
                                .map_err(|x| x.to_string())?,
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "preferredPgwMatchInd" => intermediate_rep.preferred_pgw_match_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "preferredAnalyticsDelaysInd" => {
                        intermediate_rep.preferred_analytics_delays_ind.push(
                            <bool as std::str::FromStr>::from_str(val)
                                .map_err(|x| x.to_string())?,
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PreferredSearch".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PreferredSearch {
            preferred_tai_match_ind: intermediate_rep.preferred_tai_match_ind.into_iter().next(),
            preferred_full_plmn_match_ind: intermediate_rep
                .preferred_full_plmn_match_ind
                .into_iter()
                .next(),
            preferred_api_versions_match_ind: intermediate_rep
                .preferred_api_versions_match_ind
                .into_iter()
                .next(),
            other_api_versions_ind: intermediate_rep.other_api_versions_ind.into_iter().next(),
            preferred_locality_match_ind: intermediate_rep
                .preferred_locality_match_ind
                .into_iter()
                .next(),
            other_locality_ind: intermediate_rep.other_locality_ind.into_iter().next(),
            preferred_vendor_specific_features_ind: intermediate_rep
                .preferred_vendor_specific_features_ind
                .into_iter()
                .next(),
            preferred_collocated_nf_type_ind: intermediate_rep
                .preferred_collocated_nf_type_ind
                .into_iter()
                .next(),
            preferred_pgw_match_ind: intermediate_rep.preferred_pgw_match_ind.into_iter().next(),
            preferred_analytics_delays_ind: intermediate_rep
                .preferred_analytics_delays_ind
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PreferredSearch> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PreferredSearch>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PreferredSearch>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PreferredSearch - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<PreferredSearch>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PreferredSearch as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PreferredSearch - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Indicate the supported ProSe Capability by the PCF.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProSeCapability {
    #[serde(rename = "proseDirectDiscovey")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prose_direct_discovey: Option<bool>,

    #[serde(rename = "proseDirectCommunication")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prose_direct_communication: Option<bool>,

    #[serde(rename = "proseL2UetoNetworkRelay")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prose_l2_ueto_network_relay: Option<bool>,

    #[serde(rename = "proseL3UetoNetworkRelay")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prose_l3_ueto_network_relay: Option<bool>,

    #[serde(rename = "proseL2RemoteUe")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prose_l2_remote_ue: Option<bool>,

    #[serde(rename = "proseL3RemoteUe")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prose_l3_remote_ue: Option<bool>,
}

impl ProSeCapability {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ProSeCapability {
        ProSeCapability {
            prose_direct_discovey: Some(false),
            prose_direct_communication: Some(false),
            prose_l2_ueto_network_relay: Some(false),
            prose_l3_ueto_network_relay: Some(false),
            prose_l2_remote_ue: Some(false),
            prose_l3_remote_ue: Some(false),
        }
    }
}

/// Converts the ProSeCapability value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ProSeCapability {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.prose_direct_discovey
                .as_ref()
                .map(|prose_direct_discovey| {
                    vec![
                        "proseDirectDiscovey".to_string(),
                        prose_direct_discovey.to_string(),
                    ]
                    .join(",")
                }),
            self.prose_direct_communication
                .as_ref()
                .map(|prose_direct_communication| {
                    vec![
                        "proseDirectCommunication".to_string(),
                        prose_direct_communication.to_string(),
                    ]
                    .join(",")
                }),
            self.prose_l2_ueto_network_relay
                .as_ref()
                .map(|prose_l2_ueto_network_relay| {
                    vec![
                        "proseL2UetoNetworkRelay".to_string(),
                        prose_l2_ueto_network_relay.to_string(),
                    ]
                    .join(",")
                }),
            self.prose_l3_ueto_network_relay
                .as_ref()
                .map(|prose_l3_ueto_network_relay| {
                    vec![
                        "proseL3UetoNetworkRelay".to_string(),
                        prose_l3_ueto_network_relay.to_string(),
                    ]
                    .join(",")
                }),
            self.prose_l2_remote_ue.as_ref().map(|prose_l2_remote_ue| {
                vec![
                    "proseL2RemoteUe".to_string(),
                    prose_l2_remote_ue.to_string(),
                ]
                .join(",")
            }),
            self.prose_l3_remote_ue.as_ref().map(|prose_l3_remote_ue| {
                vec![
                    "proseL3RemoteUe".to_string(),
                    prose_l3_remote_ue.to_string(),
                ]
                .join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProSeCapability value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProSeCapability {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub prose_direct_discovey: Vec<bool>,
            pub prose_direct_communication: Vec<bool>,
            pub prose_l2_ueto_network_relay: Vec<bool>,
            pub prose_l3_ueto_network_relay: Vec<bool>,
            pub prose_l2_remote_ue: Vec<bool>,
            pub prose_l3_remote_ue: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ProSeCapability".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "proseDirectDiscovey" => intermediate_rep.prose_direct_discovey.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "proseDirectCommunication" => intermediate_rep.prose_direct_communication.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "proseL2UetoNetworkRelay" => intermediate_rep.prose_l2_ueto_network_relay.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "proseL3UetoNetworkRelay" => intermediate_rep.prose_l3_ueto_network_relay.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "proseL2RemoteUe" => intermediate_rep.prose_l2_remote_ue.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "proseL3RemoteUe" => intermediate_rep.prose_l3_remote_ue.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ProSeCapability".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProSeCapability {
            prose_direct_discovey: intermediate_rep.prose_direct_discovey.into_iter().next(),
            prose_direct_communication: intermediate_rep
                .prose_direct_communication
                .into_iter()
                .next(),
            prose_l2_ueto_network_relay: intermediate_rep
                .prose_l2_ueto_network_relay
                .into_iter()
                .next(),
            prose_l3_ueto_network_relay: intermediate_rep
                .prose_l3_ueto_network_relay
                .into_iter()
                .next(),
            prose_l2_remote_ue: intermediate_rep.prose_l2_remote_ue.into_iter().next(),
            prose_l3_remote_ue: intermediate_rep.prose_l3_remote_ue.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProSeCapability> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ProSeCapability>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ProSeCapability>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ProSeCapability - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ProSeCapability>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ProSeCapability as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ProSeCapability - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Provides additional information in an error response.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProblemDetails {
    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub r#type: Option<String>,

    #[serde(rename = "title")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<i32>,

    /// A human-readable explanation specific to this occurrence of the problem.
    #[serde(rename = "detail")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub detail: Option<String>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "instance")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub instance: Option<String>,

    /// A machine-readable application error cause specific to this occurrence of the problem.  This IE should be present and provide application-related error information, if available.
    #[serde(rename = "cause")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cause: Option<String>,

    #[serde(rename = "invalidParams")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub invalid_params: Option<Vec<models::InvalidParam>>,

    /// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  tableÂ 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.
    #[serde(rename = "supportedFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_features: Option<String>,

    #[serde(rename = "accessTokenError")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub access_token_error: Option<models::AccessTokenErr>,

    #[serde(rename = "accessTokenRequest")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub access_token_request: Option<models::AccessTokenReq>,

    /// Fully Qualified Domain Name
    #[serde(rename = "nrfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nrf_id: Option<String>,
}

impl ProblemDetails {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ProblemDetails {
        ProblemDetails {
            r#type: None,
            title: None,
            status: None,
            detail: None,
            instance: None,
            cause: None,
            invalid_params: None,
            supported_features: None,
            access_token_error: None,
            access_token_request: None,
            nrf_id: None,
        }
    }
}

/// Converts the ProblemDetails value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ProblemDetails {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.r#type
                .as_ref()
                .map(|r#type| vec!["type".to_string(), r#type.to_string()].join(",")),
            self.title
                .as_ref()
                .map(|title| vec!["title".to_string(), title.to_string()].join(",")),
            self.status
                .as_ref()
                .map(|status| vec!["status".to_string(), status.to_string()].join(",")),
            self.detail
                .as_ref()
                .map(|detail| vec!["detail".to_string(), detail.to_string()].join(",")),
            self.instance
                .as_ref()
                .map(|instance| vec!["instance".to_string(), instance.to_string()].join(",")),
            self.cause
                .as_ref()
                .map(|cause| vec!["cause".to_string(), cause.to_string()].join(",")),
            // Skipping invalidParams in query parameter serialization
            self.supported_features.as_ref().map(|supported_features| {
                vec![
                    "supportedFeatures".to_string(),
                    supported_features.to_string(),
                ]
                .join(",")
            }),
            // Skipping accessTokenError in query parameter serialization

            // Skipping accessTokenRequest in query parameter serialization
            self.nrf_id
                .as_ref()
                .map(|nrf_id| vec!["nrfId".to_string(), nrf_id.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProblemDetails value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProblemDetails {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
            pub title: Vec<String>,
            pub status: Vec<i32>,
            pub detail: Vec<String>,
            pub instance: Vec<String>,
            pub cause: Vec<String>,
            pub invalid_params: Vec<Vec<models::InvalidParam>>,
            pub supported_features: Vec<String>,
            pub access_token_error: Vec<models::AccessTokenErr>,
            pub access_token_request: Vec<models::AccessTokenReq>,
            pub nrf_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ProblemDetails".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "title" => intermediate_rep.title.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "detail" => intermediate_rep.detail.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "instance" => intermediate_rep.instance.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "cause" => intermediate_rep.cause.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "invalidParams" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in ProblemDetails"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "supportedFeatures" => intermediate_rep.supported_features.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "accessTokenError" => intermediate_rep.access_token_error.push(
                        <models::AccessTokenErr as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "accessTokenRequest" => intermediate_rep.access_token_request.push(
                        <models::AccessTokenReq as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nrfId" => intermediate_rep.nrf_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ProblemDetails".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProblemDetails {
            r#type: intermediate_rep.r#type.into_iter().next(),
            title: intermediate_rep.title.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            detail: intermediate_rep.detail.into_iter().next(),
            instance: intermediate_rep.instance.into_iter().next(),
            cause: intermediate_rep.cause.into_iter().next(),
            invalid_params: intermediate_rep.invalid_params.into_iter().next(),
            supported_features: intermediate_rep.supported_features.into_iter().next(),
            access_token_error: intermediate_rep.access_token_error.into_iter().next(),
            access_token_request: intermediate_rep.access_token_request.into_iter().next(),
            nrf_id: intermediate_rep.nrf_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProblemDetails> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ProblemDetails>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ProblemDetails>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ProblemDetails - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ProblemDetails> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ProblemDetails as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ProblemDetails - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains a list of Query Parameters
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct QueryParamCombination {
    #[serde(rename = "queryParams")]
    pub query_params: Vec<models::QueryParameter>,
}

impl QueryParamCombination {
    #[allow(clippy::new_without_default)]
    pub fn new(query_params: Vec<models::QueryParameter>) -> QueryParamCombination {
        QueryParamCombination { query_params }
    }
}

/// Converts the QueryParamCombination value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for QueryParamCombination {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping queryParams in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a QueryParamCombination value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for QueryParamCombination {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub query_params: Vec<Vec<models::QueryParameter>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing QueryParamCombination".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "queryParams" => return std::result::Result::Err("Parsing a container in this style is not supported in QueryParamCombination".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing QueryParamCombination".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(QueryParamCombination {
            query_params: intermediate_rep
                .query_params
                .into_iter()
                .next()
                .ok_or_else(|| "queryParams missing in QueryParamCombination".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<QueryParamCombination> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<QueryParamCombination>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<QueryParamCombination>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for QueryParamCombination - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<QueryParamCombination>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <QueryParamCombination as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into QueryParamCombination - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains the name and value of a query parameter
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct QueryParameter {
    #[serde(rename = "name")]
    pub name: String,

    #[serde(rename = "value")]
    pub value: String,
}

impl QueryParameter {
    #[allow(clippy::new_without_default)]
    pub fn new(name: String, value: String) -> QueryParameter {
        QueryParameter { name, value }
    }
}

/// Converts the QueryParameter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for QueryParameter {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("name".to_string()),
            Some(self.name.to_string()),
            Some("value".to_string()),
            Some(self.value.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a QueryParameter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for QueryParameter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub value: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing QueryParameter".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing QueryParameter".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(QueryParameter {
            name: intermediate_rep
                .name
                .into_iter()
                .next()
                .ok_or_else(|| "name missing in QueryParameter".to_string())?,
            value: intermediate_rep
                .value
                .into_iter()
                .next()
                .ok_or_else(|| "value missing in QueryParameter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<QueryParameter> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<QueryParameter>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<QueryParameter>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for QueryParameter - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<QueryParameter> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <QueryParameter as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into QueryParameter - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Indicates the radio access used.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RatType {}

impl RatType {
    #[allow(clippy::new_without_default)]
    pub fn new() -> RatType {
        RatType {}
    }
}

/// Converts the RatType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RatType {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RatType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RatType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing RatType".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing RatType".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RatType {})
    }
}

// Methods for converting between header::IntoHeaderValue<RatType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RatType>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<RatType>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for RatType - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<RatType> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <RatType as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into RatType - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum RatTypeAnyOf {
    #[serde(rename = "NR")]
    Nr,
    #[serde(rename = "EUTRA")]
    Eutra,
    #[serde(rename = "WLAN")]
    Wlan,
    #[serde(rename = "VIRTUAL")]
    Virtual,
    #[serde(rename = "NBIOT")]
    Nbiot,
    #[serde(rename = "WIRELINE")]
    Wireline,
    #[serde(rename = "WIRELINE_CABLE")]
    WirelineCable,
    #[serde(rename = "WIRELINE_BBF")]
    WirelineBbf,
    #[serde(rename = "LTE-M")]
    LteM,
    #[serde(rename = "NR_U")]
    NrU,
    #[serde(rename = "EUTRA_U")]
    EutraU,
    #[serde(rename = "TRUSTED_N3GA")]
    TrustedN3Ga,
    #[serde(rename = "TRUSTED_WLAN")]
    TrustedWlan,
    #[serde(rename = "UTRA")]
    Utra,
    #[serde(rename = "GERA")]
    Gera,
    #[serde(rename = "NR_LEO")]
    NrLeo,
    #[serde(rename = "NR_MEO")]
    NrMeo,
    #[serde(rename = "NR_GEO")]
    NrGeo,
    #[serde(rename = "NR_OTHER_SAT")]
    NrOtherSat,
    #[serde(rename = "NR_REDCAP")]
    NrRedcap,
}

impl std::fmt::Display for RatTypeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            RatTypeAnyOf::Nr => write!(f, "NR"),
            RatTypeAnyOf::Eutra => write!(f, "EUTRA"),
            RatTypeAnyOf::Wlan => write!(f, "WLAN"),
            RatTypeAnyOf::Virtual => write!(f, "VIRTUAL"),
            RatTypeAnyOf::Nbiot => write!(f, "NBIOT"),
            RatTypeAnyOf::Wireline => write!(f, "WIRELINE"),
            RatTypeAnyOf::WirelineCable => write!(f, "WIRELINE_CABLE"),
            RatTypeAnyOf::WirelineBbf => write!(f, "WIRELINE_BBF"),
            RatTypeAnyOf::LteM => write!(f, "LTE-M"),
            RatTypeAnyOf::NrU => write!(f, "NR_U"),
            RatTypeAnyOf::EutraU => write!(f, "EUTRA_U"),
            RatTypeAnyOf::TrustedN3Ga => write!(f, "TRUSTED_N3GA"),
            RatTypeAnyOf::TrustedWlan => write!(f, "TRUSTED_WLAN"),
            RatTypeAnyOf::Utra => write!(f, "UTRA"),
            RatTypeAnyOf::Gera => write!(f, "GERA"),
            RatTypeAnyOf::NrLeo => write!(f, "NR_LEO"),
            RatTypeAnyOf::NrMeo => write!(f, "NR_MEO"),
            RatTypeAnyOf::NrGeo => write!(f, "NR_GEO"),
            RatTypeAnyOf::NrOtherSat => write!(f, "NR_OTHER_SAT"),
            RatTypeAnyOf::NrRedcap => write!(f, "NR_REDCAP"),
        }
    }
}

impl std::str::FromStr for RatTypeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "NR" => std::result::Result::Ok(RatTypeAnyOf::Nr),
            "EUTRA" => std::result::Result::Ok(RatTypeAnyOf::Eutra),
            "WLAN" => std::result::Result::Ok(RatTypeAnyOf::Wlan),
            "VIRTUAL" => std::result::Result::Ok(RatTypeAnyOf::Virtual),
            "NBIOT" => std::result::Result::Ok(RatTypeAnyOf::Nbiot),
            "WIRELINE" => std::result::Result::Ok(RatTypeAnyOf::Wireline),
            "WIRELINE_CABLE" => std::result::Result::Ok(RatTypeAnyOf::WirelineCable),
            "WIRELINE_BBF" => std::result::Result::Ok(RatTypeAnyOf::WirelineBbf),
            "LTE-M" => std::result::Result::Ok(RatTypeAnyOf::LteM),
            "NR_U" => std::result::Result::Ok(RatTypeAnyOf::NrU),
            "EUTRA_U" => std::result::Result::Ok(RatTypeAnyOf::EutraU),
            "TRUSTED_N3GA" => std::result::Result::Ok(RatTypeAnyOf::TrustedN3Ga),
            "TRUSTED_WLAN" => std::result::Result::Ok(RatTypeAnyOf::TrustedWlan),
            "UTRA" => std::result::Result::Ok(RatTypeAnyOf::Utra),
            "GERA" => std::result::Result::Ok(RatTypeAnyOf::Gera),
            "NR_LEO" => std::result::Result::Ok(RatTypeAnyOf::NrLeo),
            "NR_MEO" => std::result::Result::Ok(RatTypeAnyOf::NrMeo),
            "NR_GEO" => std::result::Result::Ok(RatTypeAnyOf::NrGeo),
            "NR_OTHER_SAT" => std::result::Result::Ok(RatTypeAnyOf::NrOtherSat),
            "NR_REDCAP" => std::result::Result::Ok(RatTypeAnyOf::NrRedcap),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// The response shall include a Location header field containing a different URI  (pointing to a different URI of an other service instance), or the same URI if a request  is redirected to the same target resource via a different SCP.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RedirectResponse {
    #[serde(rename = "cause")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cause: Option<String>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "targetScp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_scp: Option<String>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "targetSepp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_sepp: Option<String>,
}

impl RedirectResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> RedirectResponse {
        RedirectResponse {
            cause: None,
            target_scp: None,
            target_sepp: None,
        }
    }
}

/// Converts the RedirectResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RedirectResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.cause
                .as_ref()
                .map(|cause| vec!["cause".to_string(), cause.to_string()].join(",")),
            self.target_scp
                .as_ref()
                .map(|target_scp| vec!["targetScp".to_string(), target_scp.to_string()].join(",")),
            self.target_sepp.as_ref().map(|target_sepp| {
                vec!["targetSepp".to_string(), target_sepp.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RedirectResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RedirectResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cause: Vec<String>,
            pub target_scp: Vec<String>,
            pub target_sepp: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing RedirectResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "cause" => intermediate_rep.cause.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "targetScp" => intermediate_rep.target_scp.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "targetSepp" => intermediate_rep.target_sepp.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing RedirectResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RedirectResponse {
            cause: intermediate_rep.cause.into_iter().next(),
            target_scp: intermediate_rep.target_scp.into_iter().next(),
            target_sepp: intermediate_rep.target_sepp.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RedirectResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RedirectResponse>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<RedirectResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for RedirectResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<RedirectResponse>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <RedirectResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into RedirectResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Indicates the capabilities supported by an SCP
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ScpCapability {}

impl ScpCapability {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ScpCapability {
        ScpCapability {}
    }
}

/// Converts the ScpCapability value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ScpCapability {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ScpCapability value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ScpCapability {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ScpCapability".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ScpCapability".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ScpCapability {})
    }
}

// Methods for converting between header::IntoHeaderValue<ScpCapability> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ScpCapability>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ScpCapability>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ScpCapability - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ScpCapability> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ScpCapability as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ScpCapability - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ScpCapabilityAnyOf {
    #[serde(rename = "INDIRECT_COM_WITH_DELEG_DISC")]
    IndirectComWithDelegDisc,
}

impl std::fmt::Display for ScpCapabilityAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ScpCapabilityAnyOf::IndirectComWithDelegDisc => {
                write!(f, "INDIRECT_COM_WITH_DELEG_DISC")
            }
        }
    }
}

impl std::str::FromStr for ScpCapabilityAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "INDIRECT_COM_WITH_DELEG_DISC" => {
                std::result::Result::Ok(ScpCapabilityAnyOf::IndirectComWithDelegDisc)
            }
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// SCP Domain Connectivity Information
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ScpDomainConnectivity {
    #[serde(rename = "connectedScpDomainList")]
    pub connected_scp_domain_list: Vec<String>,
}

impl ScpDomainConnectivity {
    #[allow(clippy::new_without_default)]
    pub fn new(connected_scp_domain_list: Vec<String>) -> ScpDomainConnectivity {
        ScpDomainConnectivity {
            connected_scp_domain_list,
        }
    }
}

/// Converts the ScpDomainConnectivity value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ScpDomainConnectivity {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("connectedScpDomainList".to_string()),
            Some(
                self.connected_scp_domain_list
                    .iter()
                    .map(|x| x.to_string())
                    .collect::<Vec<_>>()
                    .join(","),
            ),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ScpDomainConnectivity value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ScpDomainConnectivity {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub connected_scp_domain_list: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ScpDomainConnectivity".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "connectedScpDomainList" => return std::result::Result::Err("Parsing a container in this style is not supported in ScpDomainConnectivity".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ScpDomainConnectivity".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ScpDomainConnectivity {
            connected_scp_domain_list: intermediate_rep
                .connected_scp_domain_list
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "connectedScpDomainList missing in ScpDomainConnectivity".to_string()
                })?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ScpDomainConnectivity> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ScpDomainConnectivity>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ScpDomainConnectivity>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ScpDomainConnectivity - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ScpDomainConnectivity>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ScpDomainConnectivity as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ScpDomainConnectivity - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// SCP Domain specific information
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ScpDomainInfo {
    /// Fully Qualified Domain Name
    #[serde(rename = "scpFqdn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scp_fqdn: Option<String>,

    #[serde(rename = "scpIpEndPoints")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scp_ip_end_points: Option<Vec<models::IpEndPoint>>,

    #[serde(rename = "scpPrefix")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scp_prefix: Option<String>,

    /// Port numbers for HTTP and HTTPS. The key of the map shall be \"http\" or \"https\".
    #[serde(rename = "scpPorts")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scp_ports: Option<std::collections::HashMap<String, i32>>,
}

impl ScpDomainInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ScpDomainInfo {
        ScpDomainInfo {
            scp_fqdn: None,
            scp_ip_end_points: None,
            scp_prefix: None,
            scp_ports: None,
        }
    }
}

/// Converts the ScpDomainInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ScpDomainInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.scp_fqdn
                .as_ref()
                .map(|scp_fqdn| vec!["scpFqdn".to_string(), scp_fqdn.to_string()].join(",")),
            // Skipping scpIpEndPoints in query parameter serialization
            self.scp_prefix
                .as_ref()
                .map(|scp_prefix| vec!["scpPrefix".to_string(), scp_prefix.to_string()].join(",")),
            // Skipping scpPorts in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ScpDomainInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ScpDomainInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub scp_fqdn: Vec<String>,
            pub scp_ip_end_points: Vec<Vec<models::IpEndPoint>>,
            pub scp_prefix: Vec<String>,
            pub scp_ports: Vec<std::collections::HashMap<String, i32>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ScpDomainInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "scpFqdn" => intermediate_rep.scp_fqdn.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "scpIpEndPoints" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in ScpDomainInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "scpPrefix" => intermediate_rep.scp_prefix.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "scpPorts" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in ScpDomainInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ScpDomainInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ScpDomainInfo {
            scp_fqdn: intermediate_rep.scp_fqdn.into_iter().next(),
            scp_ip_end_points: intermediate_rep.scp_ip_end_points.into_iter().next(),
            scp_prefix: intermediate_rep.scp_prefix.into_iter().next(),
            scp_ports: intermediate_rep.scp_ports.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ScpDomainInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ScpDomainInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ScpDomainInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ScpDomainInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ScpDomainInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ScpDomainInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ScpDomainInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// SCP Domain Routing Information Notification
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ScpDomainRoutingInfoNotification {
    #[serde(rename = "routingInfo")]
    pub routing_info: models::ScpDomainRoutingInformation,

    #[serde(rename = "localInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub local_ind: Option<bool>,
}

impl ScpDomainRoutingInfoNotification {
    #[allow(clippy::new_without_default)]
    pub fn new(
        routing_info: models::ScpDomainRoutingInformation,
    ) -> ScpDomainRoutingInfoNotification {
        ScpDomainRoutingInfoNotification {
            routing_info,
            local_ind: Some(false),
        }
    }
}

/// Converts the ScpDomainRoutingInfoNotification value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ScpDomainRoutingInfoNotification {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping routingInfo in query parameter serialization
            self.local_ind
                .as_ref()
                .map(|local_ind| vec!["localInd".to_string(), local_ind.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ScpDomainRoutingInfoNotification value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ScpDomainRoutingInfoNotification {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub routing_info: Vec<models::ScpDomainRoutingInformation>,
            pub local_ind: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ScpDomainRoutingInfoNotification".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "routingInfo" => intermediate_rep.routing_info.push(
                        <models::ScpDomainRoutingInformation as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "localInd" => intermediate_rep.local_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ScpDomainRoutingInfoNotification"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ScpDomainRoutingInfoNotification {
            routing_info: intermediate_rep
                .routing_info
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "routingInfo missing in ScpDomainRoutingInfoNotification".to_string()
                })?,
            local_ind: intermediate_rep.local_ind.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ScpDomainRoutingInfoNotification> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ScpDomainRoutingInfoNotification>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ScpDomainRoutingInfoNotification>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ScpDomainRoutingInfoNotification - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ScpDomainRoutingInfoNotification>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ScpDomainRoutingInfoNotification as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ScpDomainRoutingInfoNotification - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

/// SCP Domain Routing Information Subscription
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ScpDomainRoutingInfoSubscription {
    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "callbackUri")]
    pub callback_uri: String,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "validityTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub validity_time: Option<chrono::DateTime<chrono::Utc>>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "reqInstanceId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub req_instance_id: Option<uuid::Uuid>,

    #[serde(rename = "localInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub local_ind: Option<bool>,
}

impl ScpDomainRoutingInfoSubscription {
    #[allow(clippy::new_without_default)]
    pub fn new(callback_uri: String) -> ScpDomainRoutingInfoSubscription {
        ScpDomainRoutingInfoSubscription {
            callback_uri,
            validity_time: None,
            req_instance_id: None,
            local_ind: Some(false),
        }
    }
}

/// Converts the ScpDomainRoutingInfoSubscription value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ScpDomainRoutingInfoSubscription {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("callbackUri".to_string()),
            Some(self.callback_uri.to_string()),
            // Skipping validityTime in query parameter serialization

            // Skipping reqInstanceId in query parameter serialization
            self.local_ind
                .as_ref()
                .map(|local_ind| vec!["localInd".to_string(), local_ind.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ScpDomainRoutingInfoSubscription value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ScpDomainRoutingInfoSubscription {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub callback_uri: Vec<String>,
            pub validity_time: Vec<chrono::DateTime<chrono::Utc>>,
            pub req_instance_id: Vec<uuid::Uuid>,
            pub local_ind: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ScpDomainRoutingInfoSubscription".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "callbackUri" => intermediate_rep.callback_uri.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "validityTime" => intermediate_rep.validity_time.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "reqInstanceId" => intermediate_rep.req_instance_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "localInd" => intermediate_rep.local_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ScpDomainRoutingInfoSubscription"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ScpDomainRoutingInfoSubscription {
            callback_uri: intermediate_rep
                .callback_uri
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "callbackUri missing in ScpDomainRoutingInfoSubscription".to_string()
                })?,
            validity_time: intermediate_rep.validity_time.into_iter().next(),
            req_instance_id: intermediate_rep.req_instance_id.into_iter().next(),
            local_ind: intermediate_rep.local_ind.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ScpDomainRoutingInfoSubscription> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ScpDomainRoutingInfoSubscription>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ScpDomainRoutingInfoSubscription>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ScpDomainRoutingInfoSubscription - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ScpDomainRoutingInfoSubscription>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ScpDomainRoutingInfoSubscription as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ScpDomainRoutingInfoSubscription - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

/// SCP Domain Routing Information
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ScpDomainRoutingInformation {
    /// This IE shall contain a map of SCP domain interconnection information, where the key of the map is a SCP domain. The value of each entry shall be the interconnectivity information of the the SCP domain indicated by the key. An empty map indicates that there is no SCP domain currently registered in the NRF.
    #[serde(rename = "scpDomainList")]
    pub scp_domain_list: std::collections::HashMap<String, models::ScpDomainConnectivity>,
}

impl ScpDomainRoutingInformation {
    #[allow(clippy::new_without_default)]
    pub fn new(
        scp_domain_list: std::collections::HashMap<String, models::ScpDomainConnectivity>,
    ) -> ScpDomainRoutingInformation {
        ScpDomainRoutingInformation { scp_domain_list }
    }
}

/// Converts the ScpDomainRoutingInformation value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ScpDomainRoutingInformation {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping scpDomainList in query parameter serialization
            // Skipping scpDomainList in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ScpDomainRoutingInformation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ScpDomainRoutingInformation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub scp_domain_list:
                Vec<std::collections::HashMap<String, models::ScpDomainConnectivity>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ScpDomainRoutingInformation".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "scpDomainList" => return std::result::Result::Err("Parsing a container in this style is not supported in ScpDomainRoutingInformation".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ScpDomainRoutingInformation".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ScpDomainRoutingInformation {
            scp_domain_list: intermediate_rep
                .scp_domain_list
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "scpDomainList missing in ScpDomainRoutingInformation".to_string()
                })?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ScpDomainRoutingInformation> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ScpDomainRoutingInformation>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ScpDomainRoutingInformation>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ScpDomainRoutingInformation - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ScpDomainRoutingInformation>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ScpDomainRoutingInformation as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ScpDomainRoutingInformation - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Information of an SCP Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ScpInfo {
    /// A map (list of key-value pairs) where the key of the map shall be the string identifying an SCP domain
    #[serde(rename = "scpDomainInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scp_domain_info_list: Option<std::collections::HashMap<String, models::ScpDomainInfo>>,

    #[serde(rename = "scpPrefix")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scp_prefix: Option<String>,

    /// Port numbers for HTTP and HTTPS. The key of the map shall be \"http\" or \"https\".
    #[serde(rename = "scpPorts")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scp_ports: Option<std::collections::HashMap<String, i32>>,

    #[serde(rename = "addressDomains")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub address_domains: Option<Vec<String>>,

    #[serde(rename = "ipv4Addresses")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv4_addresses: Option<Vec<models::Ipv4Addr>>,

    #[serde(rename = "ipv6Prefixes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_prefixes: Option<Vec<models::Ipv6Prefix>>,

    #[serde(rename = "ipv4AddrRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv4_addr_ranges: Option<Vec<models::Ipv4AddressRange>>,

    #[serde(rename = "ipv6PrefixRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_prefix_ranges: Option<Vec<models::Ipv6PrefixRange>>,

    #[serde(rename = "servedNfSetIdList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub served_nf_set_id_list: Option<Vec<models::NfSetId>>,

    #[serde(rename = "remotePlmnList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remote_plmn_list: Option<Vec<models::PlmnId>>,

    #[serde(rename = "remoteSnpnList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remote_snpn_list: Option<Vec<models::PlmnIdNid>>,

    #[serde(rename = "ipReachability")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ip_reachability: Option<models::IpReachability>,

    #[serde(rename = "scpCapabilities")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scp_capabilities: Option<Vec<models::ScpCapability>>,
}

impl ScpInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ScpInfo {
        ScpInfo {
            scp_domain_info_list: None,
            scp_prefix: None,
            scp_ports: None,
            address_domains: None,
            ipv4_addresses: None,
            ipv6_prefixes: None,
            ipv4_addr_ranges: None,
            ipv6_prefix_ranges: None,
            served_nf_set_id_list: None,
            remote_plmn_list: None,
            remote_snpn_list: None,
            ip_reachability: None,
            scp_capabilities: None,
        }
    }
}

/// Converts the ScpInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ScpInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping scpDomainInfoList in query parameter serialization
            // Skipping scpDomainInfoList in query parameter serialization
            self.scp_prefix
                .as_ref()
                .map(|scp_prefix| vec!["scpPrefix".to_string(), scp_prefix.to_string()].join(",")),
            // Skipping scpPorts in query parameter serialization
            self.address_domains.as_ref().map(|address_domains| {
                vec![
                    "addressDomains".to_string(),
                    address_domains
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.ipv4_addresses.as_ref().map(|ipv4_addresses| {
                vec![
                    "ipv4Addresses".to_string(),
                    ipv4_addresses
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping ipv6Prefixes in query parameter serialization

            // Skipping ipv4AddrRanges in query parameter serialization

            // Skipping ipv6PrefixRanges in query parameter serialization
            self.served_nf_set_id_list
                .as_ref()
                .map(|served_nf_set_id_list| {
                    vec![
                        "servedNfSetIdList".to_string(),
                        served_nf_set_id_list
                            .iter()
                            .map(|x| x.to_string())
                            .collect::<Vec<_>>()
                            .join(","),
                    ]
                    .join(",")
                }),
            // Skipping remotePlmnList in query parameter serialization

            // Skipping remoteSnpnList in query parameter serialization

            // Skipping ipReachability in query parameter serialization

            // Skipping scpCapabilities in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ScpInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ScpInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub scp_domain_info_list: Vec<std::collections::HashMap<String, models::ScpDomainInfo>>,
            pub scp_prefix: Vec<String>,
            pub scp_ports: Vec<std::collections::HashMap<String, i32>>,
            pub address_domains: Vec<Vec<String>>,
            pub ipv4_addresses: Vec<Vec<models::Ipv4Addr>>,
            pub ipv6_prefixes: Vec<Vec<models::Ipv6Prefix>>,
            pub ipv4_addr_ranges: Vec<Vec<models::Ipv4AddressRange>>,
            pub ipv6_prefix_ranges: Vec<Vec<models::Ipv6PrefixRange>>,
            pub served_nf_set_id_list: Vec<Vec<models::NfSetId>>,
            pub remote_plmn_list: Vec<Vec<models::PlmnId>>,
            pub remote_snpn_list: Vec<Vec<models::PlmnIdNid>>,
            pub ip_reachability: Vec<models::IpReachability>,
            pub scp_capabilities: Vec<Vec<models::ScpCapability>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ScpInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "scpDomainInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in ScpInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "scpPrefix" => intermediate_rep.scp_prefix.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "scpPorts" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in ScpInfo"
                                .to_string(),
                        )
                    }
                    "addressDomains" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in ScpInfo"
                                .to_string(),
                        )
                    }
                    "ipv4Addresses" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in ScpInfo"
                                .to_string(),
                        )
                    }
                    "ipv6Prefixes" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in ScpInfo"
                                .to_string(),
                        )
                    }
                    "ipv4AddrRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in ScpInfo"
                                .to_string(),
                        )
                    }
                    "ipv6PrefixRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in ScpInfo"
                                .to_string(),
                        )
                    }
                    "servedNfSetIdList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in ScpInfo"
                                .to_string(),
                        )
                    }
                    "remotePlmnList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in ScpInfo"
                                .to_string(),
                        )
                    }
                    "remoteSnpnList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in ScpInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "ipReachability" => intermediate_rep.ip_reachability.push(
                        <models::IpReachability as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "scpCapabilities" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in ScpInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ScpInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ScpInfo {
            scp_domain_info_list: intermediate_rep.scp_domain_info_list.into_iter().next(),
            scp_prefix: intermediate_rep.scp_prefix.into_iter().next(),
            scp_ports: intermediate_rep.scp_ports.into_iter().next(),
            address_domains: intermediate_rep.address_domains.into_iter().next(),
            ipv4_addresses: intermediate_rep.ipv4_addresses.into_iter().next(),
            ipv6_prefixes: intermediate_rep.ipv6_prefixes.into_iter().next(),
            ipv4_addr_ranges: intermediate_rep.ipv4_addr_ranges.into_iter().next(),
            ipv6_prefix_ranges: intermediate_rep.ipv6_prefix_ranges.into_iter().next(),
            served_nf_set_id_list: intermediate_rep.served_nf_set_id_list.into_iter().next(),
            remote_plmn_list: intermediate_rep.remote_plmn_list.into_iter().next(),
            remote_snpn_list: intermediate_rep.remote_snpn_list.into_iter().next(),
            ip_reachability: intermediate_rep.ip_reachability.into_iter().next(),
            scp_capabilities: intermediate_rep.scp_capabilities.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ScpInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ScpInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ScpInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ScpInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ScpInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ScpInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ScpInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A range of SDs (Slice Differentiators)
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SdRange {
    /// First value identifying the start of an SD range. This string shall be formatted as specified for the sd attribute of the Snssai data type in clause 5.4.4.2.
    #[serde(rename = "start")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start: Option<String>,

    /// Last value identifying the end of an SD range. This string shall be formatted as specified for the sd attribute of the Snssai data type in clause 5.4.4.2.
    #[serde(rename = "end")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end: Option<String>,
}

impl SdRange {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SdRange {
        SdRange {
            start: None,
            end: None,
        }
    }
}

/// Converts the SdRange value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SdRange {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.start
                .as_ref()
                .map(|start| vec!["start".to_string(), start.to_string()].join(",")),
            self.end
                .as_ref()
                .map(|end| vec!["end".to_string(), end.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SdRange value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SdRange {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub start: Vec<String>,
            pub end: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SdRange".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "start" => intermediate_rep.start.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "end" => intermediate_rep.end.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SdRange".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SdRange {
            start: intermediate_rep.start.into_iter().next(),
            end: intermediate_rep.end.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SdRange> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SdRange>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SdRange>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SdRange - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SdRange> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SdRange as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SdRange - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains the list of NF Profiles returned in a Discovery response
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SearchResult {
    #[serde(rename = "validityPeriod")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub validity_period: Option<i32>,

    #[serde(rename = "nfInstances")]
    pub nf_instances: Vec<models::NfProfile>,

    #[serde(rename = "searchId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub search_id: Option<String>,

    /// Integer where the allowed values correspond to the value range of an unsigned 32-bit integer.
    #[serde(rename = "numNfInstComplete")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub num_nf_inst_complete: Option<u32>,

    #[serde(rename = "preferredSearch")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub preferred_search: Option<models::PreferredSearch>,

    /// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  tableÂ 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.
    #[serde(rename = "nrfSupportedFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nrf_supported_features: Option<String>,

    /// List of matching NF instances. The key of the map is the NF instance ID.
    #[serde(rename = "nfInstanceList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nf_instance_list: Option<std::collections::HashMap<String, models::NfInstanceInfo>>,

    #[serde(rename = "alteredPriorityInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub altered_priority_ind: Option<bool>,

    #[serde(rename = "noProfileMatchInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub no_profile_match_info: Option<models::NoProfileMatchInfo>,
}

impl SearchResult {
    #[allow(clippy::new_without_default)]
    pub fn new(nf_instances: Vec<models::NfProfile>) -> SearchResult {
        SearchResult {
            validity_period: None,
            nf_instances,
            search_id: None,
            num_nf_inst_complete: None,
            preferred_search: None,
            nrf_supported_features: None,
            nf_instance_list: None,
            altered_priority_ind: None,
            no_profile_match_info: None,
        }
    }
}

/// Converts the SearchResult value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SearchResult {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.validity_period.as_ref().map(|validity_period| {
                vec!["validityPeriod".to_string(), validity_period.to_string()].join(",")
            }),
            // Skipping nfInstances in query parameter serialization
            self.search_id
                .as_ref()
                .map(|search_id| vec!["searchId".to_string(), search_id.to_string()].join(",")),
            self.num_nf_inst_complete
                .as_ref()
                .map(|num_nf_inst_complete| {
                    vec![
                        "numNfInstComplete".to_string(),
                        num_nf_inst_complete.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping preferredSearch in query parameter serialization
            self.nrf_supported_features
                .as_ref()
                .map(|nrf_supported_features| {
                    vec![
                        "nrfSupportedFeatures".to_string(),
                        nrf_supported_features.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping nfInstanceList in query parameter serialization
            // Skipping nfInstanceList in query parameter serialization
            self.altered_priority_ind
                .as_ref()
                .map(|altered_priority_ind| {
                    vec![
                        "alteredPriorityInd".to_string(),
                        altered_priority_ind.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping noProfileMatchInfo in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SearchResult value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SearchResult {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub validity_period: Vec<i32>,
            pub nf_instances: Vec<Vec<models::NfProfile>>,
            pub search_id: Vec<String>,
            pub num_nf_inst_complete: Vec<u32>,
            pub preferred_search: Vec<models::PreferredSearch>,
            pub nrf_supported_features: Vec<String>,
            pub nf_instance_list: Vec<std::collections::HashMap<String, models::NfInstanceInfo>>,
            pub altered_priority_ind: Vec<bool>,
            pub no_profile_match_info: Vec<models::NoProfileMatchInfo>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SearchResult".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "validityPeriod" => intermediate_rep.validity_period.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "nfInstances" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SearchResult"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "searchId" => intermediate_rep.search_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "numNfInstComplete" => intermediate_rep.num_nf_inst_complete.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "preferredSearch" => intermediate_rep.preferred_search.push(
                        <models::PreferredSearch as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nrfSupportedFeatures" => intermediate_rep.nrf_supported_features.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "nfInstanceList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SearchResult"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "alteredPriorityInd" => intermediate_rep.altered_priority_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "noProfileMatchInfo" => intermediate_rep.no_profile_match_info.push(
                        <models::NoProfileMatchInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SearchResult".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SearchResult {
            validity_period: intermediate_rep.validity_period.into_iter().next(),
            nf_instances: intermediate_rep
                .nf_instances
                .into_iter()
                .next()
                .ok_or_else(|| "nfInstances missing in SearchResult".to_string())?,
            search_id: intermediate_rep.search_id.into_iter().next(),
            num_nf_inst_complete: intermediate_rep.num_nf_inst_complete.into_iter().next(),
            preferred_search: intermediate_rep.preferred_search.into_iter().next(),
            nrf_supported_features: intermediate_rep.nrf_supported_features.into_iter().next(),
            nf_instance_list: intermediate_rep.nf_instance_list.into_iter().next(),
            altered_priority_ind: intermediate_rep.altered_priority_ind.into_iter().next(),
            no_profile_match_info: intermediate_rep.no_profile_match_info.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SearchResult> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SearchResult>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SearchResult>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SearchResult - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SearchResult> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SearchResult as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SearchResult - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Information of a SEPP Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SeppInfo {
    #[serde(rename = "seppPrefix")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sepp_prefix: Option<String>,

    /// Port numbers for HTTP and HTTPS. The key of the map shall be \"http\" or \"https\".
    #[serde(rename = "seppPorts")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sepp_ports: Option<std::collections::HashMap<String, i32>>,

    #[serde(rename = "remotePlmnList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remote_plmn_list: Option<Vec<models::PlmnId>>,

    #[serde(rename = "remoteSnpnList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remote_snpn_list: Option<Vec<models::PlmnIdNid>>,
}

impl SeppInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SeppInfo {
        SeppInfo {
            sepp_prefix: None,
            sepp_ports: None,
            remote_plmn_list: None,
            remote_snpn_list: None,
        }
    }
}

/// Converts the SeppInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SeppInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.sepp_prefix.as_ref().map(|sepp_prefix| {
                vec!["seppPrefix".to_string(), sepp_prefix.to_string()].join(",")
            }),
            // Skipping seppPorts in query parameter serialization

            // Skipping remotePlmnList in query parameter serialization

            // Skipping remoteSnpnList in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SeppInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SeppInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub sepp_prefix: Vec<String>,
            pub sepp_ports: Vec<std::collections::HashMap<String, i32>>,
            pub remote_plmn_list: Vec<Vec<models::PlmnId>>,
            pub remote_snpn_list: Vec<Vec<models::PlmnIdNid>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SeppInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "seppPrefix" => intermediate_rep.sepp_prefix.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "seppPorts" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SeppInfo"
                                .to_string(),
                        )
                    }
                    "remotePlmnList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SeppInfo"
                                .to_string(),
                        )
                    }
                    "remoteSnpnList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SeppInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SeppInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SeppInfo {
            sepp_prefix: intermediate_rep.sepp_prefix.into_iter().next(),
            sepp_ports: intermediate_rep.sepp_ports.into_iter().next(),
            remote_plmn_list: intermediate_rep.remote_plmn_list.into_iter().next(),
            remote_snpn_list: intermediate_rep.remote_snpn_list.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SeppInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SeppInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SeppInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SeppInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SeppInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SeppInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SeppInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Service names known to NRF
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ServiceName(String);

impl ServiceName {
    #[allow(clippy::new_without_default)]
    pub fn new(name: String) -> ServiceName {
        ServiceName(name)
    }
}

/// Converts the ServiceName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ServiceName {
    fn to_string(&self) -> String {
        self.0.clone()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ServiceName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ServiceName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(ServiceName(s.to_string()))
    }
}

// Methods for converting between header::IntoHeaderValue<ServiceName> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ServiceName>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ServiceName>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ServiceName - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ServiceName> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ServiceName as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ServiceName - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ServiceNameAnyOf {
    #[serde(rename = "nnrf-nfm")]
    NnrfNfm,
    #[serde(rename = "nnrf-disc")]
    NnrfDisc,
    #[serde(rename = "nnrf-oauth2")]
    NnrfOauth2,
    #[serde(rename = "nudm-sdm")]
    NudmSdm,
    #[serde(rename = "nudm-uecm")]
    NudmUecm,
    #[serde(rename = "nudm-ueau")]
    NudmUeau,
    #[serde(rename = "nudm-ee")]
    NudmEe,
    #[serde(rename = "nudm-pp")]
    NudmPp,
    #[serde(rename = "nudm-niddau")]
    NudmNiddau,
    #[serde(rename = "nudm-mt")]
    NudmMt,
    #[serde(rename = "nudm-ssau")]
    NudmSsau,
    #[serde(rename = "nudm-rsds")]
    NudmRsds,
    #[serde(rename = "namf-comm")]
    NamfComm,
    #[serde(rename = "namf-evts")]
    NamfEvts,
    #[serde(rename = "namf-mt")]
    NamfMt,
    #[serde(rename = "namf-loc")]
    NamfLoc,
    #[serde(rename = "namf-mbs-comm")]
    NamfMbsComm,
    #[serde(rename = "namf-mbs-bc")]
    NamfMbsBc,
    #[serde(rename = "nsmf-pdusession")]
    NsmfPdusession,
    #[serde(rename = "nsmf-event-exposure")]
    NsmfEventExposure,
    #[serde(rename = "nsmf-nidd")]
    NsmfNidd,
    #[serde(rename = "nausf-auth")]
    NausfAuth,
    #[serde(rename = "nausf-sorprotection")]
    NausfSorprotection,
    #[serde(rename = "nausf-upuprotection")]
    NausfUpuprotection,
    #[serde(rename = "nnef-pfdmanagement")]
    NnefPfdmanagement,
    #[serde(rename = "nnef-smcontext")]
    NnefSmcontext,
    #[serde(rename = "nnef-eventexposure")]
    NnefEventexposure,
    #[serde(rename = "nnef-eas-deployment-info")]
    NnefEasDeploymentInfo,
    #[serde(rename = "3gpp-cp-parameter-provisioning")]
    Variant3gppCpParameterProvisioning,
    #[serde(rename = "3gpp-device-triggering")]
    Variant3gppDeviceTriggering,
    #[serde(rename = "3gpp-bdt")]
    Variant3gppBdt,
    #[serde(rename = "3gpp-traffic-influence")]
    Variant3gppTrafficInfluence,
    #[serde(rename = "3gpp-chargeable-party")]
    Variant3gppChargeableParty,
    #[serde(rename = "3gpp-as-session-with-qos")]
    Variant3gppAsSessionWithQos,
    #[serde(rename = "3gpp-msisdn-less-mo-sms")]
    Variant3gppMsisdnLessMoSms,
    #[serde(rename = "3gpp-service-parameter")]
    Variant3gppServiceParameter,
    #[serde(rename = "3gpp-monitoring-event")]
    Variant3gppMonitoringEvent,
    #[serde(rename = "3gpp-nidd-configuration-trigger")]
    Variant3gppNiddConfigurationTrigger,
    #[serde(rename = "3gpp-nidd")]
    Variant3gppNidd,
    #[serde(rename = "3gpp-analyticsexposure")]
    Variant3gppAnalyticsexposure,
    #[serde(rename = "3gpp-racs-parameter-provisioning")]
    Variant3gppRacsParameterProvisioning,
    #[serde(rename = "3gpp-ecr-control")]
    Variant3gppEcrControl,
    #[serde(rename = "3gpp-applying-bdt-policy")]
    Variant3gppApplyingBdtPolicy,
    #[serde(rename = "3gpp-mo-lcs-notify")]
    Variant3gppMoLcsNotify,
    #[serde(rename = "3gpp-time-sync")]
    Variant3gppTimeSync,
    #[serde(rename = "3gpp-am-influence")]
    Variant3gppAmInfluence,
    #[serde(rename = "3gpp-am-policyauthorization")]
    Variant3gppAmPolicyauthorization,
    #[serde(rename = "3gpp-akma")]
    Variant3gppAkma,
    #[serde(rename = "3gpp-eas-deployment")]
    Variant3gppEasDeployment,
    #[serde(rename = "3gpp-iptvconfiguration")]
    Variant3gppIptvconfiguration,
    #[serde(rename = "3gpp-mbs-tmgi")]
    Variant3gppMbsTmgi,
    #[serde(rename = "3gpp-mbs-session")]
    Variant3gppMbsSession,
    #[serde(rename = "3gpp-authentication")]
    Variant3gppAuthentication,
    #[serde(rename = "3gpp-asti")]
    Variant3gppAsti,
    #[serde(rename = "npcf-am-policy-control")]
    NpcfAmPolicyControl,
    #[serde(rename = "npcf-smpolicycontrol")]
    NpcfSmpolicycontrol,
    #[serde(rename = "npcf-policyauthorization")]
    NpcfPolicyauthorization,
    #[serde(rename = "npcf-bdtpolicycontrol")]
    NpcfBdtpolicycontrol,
    #[serde(rename = "npcf-eventexposure")]
    NpcfEventexposure,
    #[serde(rename = "npcf-ue-policy-control")]
    NpcfUePolicyControl,
    #[serde(rename = "npcf-am-policyauthorization")]
    NpcfAmPolicyauthorization,
    #[serde(rename = "nsmsf-sms")]
    NsmsfSms,
    #[serde(rename = "nnssf-nsselection")]
    NnssfNsselection,
    #[serde(rename = "nnssf-nssaiavailability")]
    NnssfNssaiavailability,
    #[serde(rename = "nudr-dr")]
    NudrDr,
    #[serde(rename = "nudr-group-id-map")]
    NudrGroupIdMap,
    #[serde(rename = "nlmf-loc")]
    NlmfLoc,
    #[serde(rename = "n5g-eir-eic")]
    N5gEirEic,
    #[serde(rename = "nbsf-management")]
    NbsfManagement,
    #[serde(rename = "nchf-spendinglimitcontrol")]
    NchfSpendinglimitcontrol,
    #[serde(rename = "nchf-convergedcharging")]
    NchfConvergedcharging,
    #[serde(rename = "nchf-offlineonlycharging")]
    NchfOfflineonlycharging,
    #[serde(rename = "nnwdaf-eventssubscription")]
    NnwdafEventssubscription,
    #[serde(rename = "nnwdaf-analyticsinfo")]
    NnwdafAnalyticsinfo,
    #[serde(rename = "nnwdaf-datamanagement")]
    NnwdafDatamanagement,
    #[serde(rename = "nnwdaf-mlmodelprovision")]
    NnwdafMlmodelprovision,
    #[serde(rename = "ngmlc-loc")]
    NgmlcLoc,
    #[serde(rename = "nucmf-provisioning")]
    NucmfProvisioning,
    #[serde(rename = "nucmf-uecapabilitymanagement")]
    NucmfUecapabilitymanagement,
    #[serde(rename = "nhss-sdm")]
    NhssSdm,
    #[serde(rename = "nhss-uecm")]
    NhssUecm,
    #[serde(rename = "nhss-ueau")]
    NhssUeau,
    #[serde(rename = "nhss-ee")]
    NhssEe,
    #[serde(rename = "nhss-ims-sdm")]
    NhssImsSdm,
    #[serde(rename = "nhss-ims-uecm")]
    NhssImsUecm,
    #[serde(rename = "nhss-ims-ueau")]
    NhssImsUeau,
    #[serde(rename = "nhss-gba-sdm")]
    NhssGbaSdm,
    #[serde(rename = "nhss-gba-ueau")]
    NhssGbaUeau,
    #[serde(rename = "nsepp-telescopic")]
    NseppTelescopic,
    #[serde(rename = "nsoraf-sor")]
    NsorafSor,
    #[serde(rename = "nspaf-secured-packet")]
    NspafSecuredPacket,
    #[serde(rename = "nudsf-dr")]
    NudsfDr,
    #[serde(rename = "nudsf-timer")]
    NudsfTimer,
    #[serde(rename = "nnssaaf-nssaa")]
    NnssaafNssaa,
    #[serde(rename = "nnssaaf-aiw")]
    NnssaafAiw,
    #[serde(rename = "naanf-akma")]
    NaanfAkma,
    #[serde(rename = "n5gddnmf-discovery")]
    N5gddnmfDiscovery,
    #[serde(rename = "nmfaf-3dadm")]
    Nmfaf3dadm,
    #[serde(rename = "nmfaf-3cadm")]
    Nmfaf3cadm,
    #[serde(rename = "neasdf-dnscontext")]
    NeasdfDnscontext,
    #[serde(rename = "neasdf-baselinednspattern")]
    NeasdfBaselinednspattern,
    #[serde(rename = "ndccf-dm")]
    NdccfDm,
    #[serde(rename = "ndccf-cm")]
    NdccfCm,
    #[serde(rename = "nnsacf-nsac")]
    NnsacfNsac,
    #[serde(rename = "nnsacf-slice-ee")]
    NnsacfSliceEe,
    #[serde(rename = "nmbsmf-tmgi")]
    NmbsmfTmgi,
    #[serde(rename = "nmbsmf-mbssession")]
    NmbsmfMbssession,
    #[serde(rename = "nadrf-dm")]
    NadrfDm,
    #[serde(rename = "nbsp-gba")]
    NbspGba,
    #[serde(rename = "ntsctsf-time-sync")]
    NtsctsfTimeSync,
    #[serde(rename = "ntsctsf-qos-tscai")]
    NtsctsfQosTscai,
    #[serde(rename = "ntsctsf-asti")]
    NtsctsfAsti,
    #[serde(rename = "npkmf-keyreq")]
    NpkmfKeyreq,
    #[serde(rename = "nmnpf-npstatus")]
    NmnpfNpstatus,
    #[serde(rename = "niwmsc-smservice")]
    NiwmscSmservice,
    #[serde(rename = "nmbsf-mbsuserserv")]
    NmbsfMbsuserserv,
    #[serde(rename = "nmbsf-mbsuserdataing")]
    NmbsfMbsuserdataing,
    #[serde(rename = "nmbstf-distsession")]
    NmbstfDistsession,
    #[serde(rename = "npanf-prosekey")]
    NpanfProsekey,
}

impl std::fmt::Display for ServiceNameAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ServiceNameAnyOf::NnrfNfm => write!(f, "nnrf-nfm"),
            ServiceNameAnyOf::NnrfDisc => write!(f, "nnrf-disc"),
            ServiceNameAnyOf::NnrfOauth2 => write!(f, "nnrf-oauth2"),
            ServiceNameAnyOf::NudmSdm => write!(f, "nudm-sdm"),
            ServiceNameAnyOf::NudmUecm => write!(f, "nudm-uecm"),
            ServiceNameAnyOf::NudmUeau => write!(f, "nudm-ueau"),
            ServiceNameAnyOf::NudmEe => write!(f, "nudm-ee"),
            ServiceNameAnyOf::NudmPp => write!(f, "nudm-pp"),
            ServiceNameAnyOf::NudmNiddau => write!(f, "nudm-niddau"),
            ServiceNameAnyOf::NudmMt => write!(f, "nudm-mt"),
            ServiceNameAnyOf::NudmSsau => write!(f, "nudm-ssau"),
            ServiceNameAnyOf::NudmRsds => write!(f, "nudm-rsds"),
            ServiceNameAnyOf::NamfComm => write!(f, "namf-comm"),
            ServiceNameAnyOf::NamfEvts => write!(f, "namf-evts"),
            ServiceNameAnyOf::NamfMt => write!(f, "namf-mt"),
            ServiceNameAnyOf::NamfLoc => write!(f, "namf-loc"),
            ServiceNameAnyOf::NamfMbsComm => write!(f, "namf-mbs-comm"),
            ServiceNameAnyOf::NamfMbsBc => write!(f, "namf-mbs-bc"),
            ServiceNameAnyOf::NsmfPdusession => write!(f, "nsmf-pdusession"),
            ServiceNameAnyOf::NsmfEventExposure => write!(f, "nsmf-event-exposure"),
            ServiceNameAnyOf::NsmfNidd => write!(f, "nsmf-nidd"),
            ServiceNameAnyOf::NausfAuth => write!(f, "nausf-auth"),
            ServiceNameAnyOf::NausfSorprotection => write!(f, "nausf-sorprotection"),
            ServiceNameAnyOf::NausfUpuprotection => write!(f, "nausf-upuprotection"),
            ServiceNameAnyOf::NnefPfdmanagement => write!(f, "nnef-pfdmanagement"),
            ServiceNameAnyOf::NnefSmcontext => write!(f, "nnef-smcontext"),
            ServiceNameAnyOf::NnefEventexposure => write!(f, "nnef-eventexposure"),
            ServiceNameAnyOf::NnefEasDeploymentInfo => write!(f, "nnef-eas-deployment-info"),
            ServiceNameAnyOf::Variant3gppCpParameterProvisioning => {
                write!(f, "3gpp-cp-parameter-provisioning")
            }
            ServiceNameAnyOf::Variant3gppDeviceTriggering => write!(f, "3gpp-device-triggering"),
            ServiceNameAnyOf::Variant3gppBdt => write!(f, "3gpp-bdt"),
            ServiceNameAnyOf::Variant3gppTrafficInfluence => write!(f, "3gpp-traffic-influence"),
            ServiceNameAnyOf::Variant3gppChargeableParty => write!(f, "3gpp-chargeable-party"),
            ServiceNameAnyOf::Variant3gppAsSessionWithQos => write!(f, "3gpp-as-session-with-qos"),
            ServiceNameAnyOf::Variant3gppMsisdnLessMoSms => write!(f, "3gpp-msisdn-less-mo-sms"),
            ServiceNameAnyOf::Variant3gppServiceParameter => write!(f, "3gpp-service-parameter"),
            ServiceNameAnyOf::Variant3gppMonitoringEvent => write!(f, "3gpp-monitoring-event"),
            ServiceNameAnyOf::Variant3gppNiddConfigurationTrigger => {
                write!(f, "3gpp-nidd-configuration-trigger")
            }
            ServiceNameAnyOf::Variant3gppNidd => write!(f, "3gpp-nidd"),
            ServiceNameAnyOf::Variant3gppAnalyticsexposure => write!(f, "3gpp-analyticsexposure"),
            ServiceNameAnyOf::Variant3gppRacsParameterProvisioning => {
                write!(f, "3gpp-racs-parameter-provisioning")
            }
            ServiceNameAnyOf::Variant3gppEcrControl => write!(f, "3gpp-ecr-control"),
            ServiceNameAnyOf::Variant3gppApplyingBdtPolicy => write!(f, "3gpp-applying-bdt-policy"),
            ServiceNameAnyOf::Variant3gppMoLcsNotify => write!(f, "3gpp-mo-lcs-notify"),
            ServiceNameAnyOf::Variant3gppTimeSync => write!(f, "3gpp-time-sync"),
            ServiceNameAnyOf::Variant3gppAmInfluence => write!(f, "3gpp-am-influence"),
            ServiceNameAnyOf::Variant3gppAmPolicyauthorization => {
                write!(f, "3gpp-am-policyauthorization")
            }
            ServiceNameAnyOf::Variant3gppAkma => write!(f, "3gpp-akma"),
            ServiceNameAnyOf::Variant3gppEasDeployment => write!(f, "3gpp-eas-deployment"),
            ServiceNameAnyOf::Variant3gppIptvconfiguration => write!(f, "3gpp-iptvconfiguration"),
            ServiceNameAnyOf::Variant3gppMbsTmgi => write!(f, "3gpp-mbs-tmgi"),
            ServiceNameAnyOf::Variant3gppMbsSession => write!(f, "3gpp-mbs-session"),
            ServiceNameAnyOf::Variant3gppAuthentication => write!(f, "3gpp-authentication"),
            ServiceNameAnyOf::Variant3gppAsti => write!(f, "3gpp-asti"),
            ServiceNameAnyOf::NpcfAmPolicyControl => write!(f, "npcf-am-policy-control"),
            ServiceNameAnyOf::NpcfSmpolicycontrol => write!(f, "npcf-smpolicycontrol"),
            ServiceNameAnyOf::NpcfPolicyauthorization => write!(f, "npcf-policyauthorization"),
            ServiceNameAnyOf::NpcfBdtpolicycontrol => write!(f, "npcf-bdtpolicycontrol"),
            ServiceNameAnyOf::NpcfEventexposure => write!(f, "npcf-eventexposure"),
            ServiceNameAnyOf::NpcfUePolicyControl => write!(f, "npcf-ue-policy-control"),
            ServiceNameAnyOf::NpcfAmPolicyauthorization => write!(f, "npcf-am-policyauthorization"),
            ServiceNameAnyOf::NsmsfSms => write!(f, "nsmsf-sms"),
            ServiceNameAnyOf::NnssfNsselection => write!(f, "nnssf-nsselection"),
            ServiceNameAnyOf::NnssfNssaiavailability => write!(f, "nnssf-nssaiavailability"),
            ServiceNameAnyOf::NudrDr => write!(f, "nudr-dr"),
            ServiceNameAnyOf::NudrGroupIdMap => write!(f, "nudr-group-id-map"),
            ServiceNameAnyOf::NlmfLoc => write!(f, "nlmf-loc"),
            ServiceNameAnyOf::N5gEirEic => write!(f, "n5g-eir-eic"),
            ServiceNameAnyOf::NbsfManagement => write!(f, "nbsf-management"),
            ServiceNameAnyOf::NchfSpendinglimitcontrol => write!(f, "nchf-spendinglimitcontrol"),
            ServiceNameAnyOf::NchfConvergedcharging => write!(f, "nchf-convergedcharging"),
            ServiceNameAnyOf::NchfOfflineonlycharging => write!(f, "nchf-offlineonlycharging"),
            ServiceNameAnyOf::NnwdafEventssubscription => write!(f, "nnwdaf-eventssubscription"),
            ServiceNameAnyOf::NnwdafAnalyticsinfo => write!(f, "nnwdaf-analyticsinfo"),
            ServiceNameAnyOf::NnwdafDatamanagement => write!(f, "nnwdaf-datamanagement"),
            ServiceNameAnyOf::NnwdafMlmodelprovision => write!(f, "nnwdaf-mlmodelprovision"),
            ServiceNameAnyOf::NgmlcLoc => write!(f, "ngmlc-loc"),
            ServiceNameAnyOf::NucmfProvisioning => write!(f, "nucmf-provisioning"),
            ServiceNameAnyOf::NucmfUecapabilitymanagement => {
                write!(f, "nucmf-uecapabilitymanagement")
            }
            ServiceNameAnyOf::NhssSdm => write!(f, "nhss-sdm"),
            ServiceNameAnyOf::NhssUecm => write!(f, "nhss-uecm"),
            ServiceNameAnyOf::NhssUeau => write!(f, "nhss-ueau"),
            ServiceNameAnyOf::NhssEe => write!(f, "nhss-ee"),
            ServiceNameAnyOf::NhssImsSdm => write!(f, "nhss-ims-sdm"),
            ServiceNameAnyOf::NhssImsUecm => write!(f, "nhss-ims-uecm"),
            ServiceNameAnyOf::NhssImsUeau => write!(f, "nhss-ims-ueau"),
            ServiceNameAnyOf::NhssGbaSdm => write!(f, "nhss-gba-sdm"),
            ServiceNameAnyOf::NhssGbaUeau => write!(f, "nhss-gba-ueau"),
            ServiceNameAnyOf::NseppTelescopic => write!(f, "nsepp-telescopic"),
            ServiceNameAnyOf::NsorafSor => write!(f, "nsoraf-sor"),
            ServiceNameAnyOf::NspafSecuredPacket => write!(f, "nspaf-secured-packet"),
            ServiceNameAnyOf::NudsfDr => write!(f, "nudsf-dr"),
            ServiceNameAnyOf::NudsfTimer => write!(f, "nudsf-timer"),
            ServiceNameAnyOf::NnssaafNssaa => write!(f, "nnssaaf-nssaa"),
            ServiceNameAnyOf::NnssaafAiw => write!(f, "nnssaaf-aiw"),
            ServiceNameAnyOf::NaanfAkma => write!(f, "naanf-akma"),
            ServiceNameAnyOf::N5gddnmfDiscovery => write!(f, "n5gddnmf-discovery"),
            ServiceNameAnyOf::Nmfaf3dadm => write!(f, "nmfaf-3dadm"),
            ServiceNameAnyOf::Nmfaf3cadm => write!(f, "nmfaf-3cadm"),
            ServiceNameAnyOf::NeasdfDnscontext => write!(f, "neasdf-dnscontext"),
            ServiceNameAnyOf::NeasdfBaselinednspattern => write!(f, "neasdf-baselinednspattern"),
            ServiceNameAnyOf::NdccfDm => write!(f, "ndccf-dm"),
            ServiceNameAnyOf::NdccfCm => write!(f, "ndccf-cm"),
            ServiceNameAnyOf::NnsacfNsac => write!(f, "nnsacf-nsac"),
            ServiceNameAnyOf::NnsacfSliceEe => write!(f, "nnsacf-slice-ee"),
            ServiceNameAnyOf::NmbsmfTmgi => write!(f, "nmbsmf-tmgi"),
            ServiceNameAnyOf::NmbsmfMbssession => write!(f, "nmbsmf-mbssession"),
            ServiceNameAnyOf::NadrfDm => write!(f, "nadrf-dm"),
            ServiceNameAnyOf::NbspGba => write!(f, "nbsp-gba"),
            ServiceNameAnyOf::NtsctsfTimeSync => write!(f, "ntsctsf-time-sync"),
            ServiceNameAnyOf::NtsctsfQosTscai => write!(f, "ntsctsf-qos-tscai"),
            ServiceNameAnyOf::NtsctsfAsti => write!(f, "ntsctsf-asti"),
            ServiceNameAnyOf::NpkmfKeyreq => write!(f, "npkmf-keyreq"),
            ServiceNameAnyOf::NmnpfNpstatus => write!(f, "nmnpf-npstatus"),
            ServiceNameAnyOf::NiwmscSmservice => write!(f, "niwmsc-smservice"),
            ServiceNameAnyOf::NmbsfMbsuserserv => write!(f, "nmbsf-mbsuserserv"),
            ServiceNameAnyOf::NmbsfMbsuserdataing => write!(f, "nmbsf-mbsuserdataing"),
            ServiceNameAnyOf::NmbstfDistsession => write!(f, "nmbstf-distsession"),
            ServiceNameAnyOf::NpanfProsekey => write!(f, "npanf-prosekey"),
        }
    }
}

impl std::str::FromStr for ServiceNameAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "nnrf-nfm" => std::result::Result::Ok(ServiceNameAnyOf::NnrfNfm),
            "nnrf-disc" => std::result::Result::Ok(ServiceNameAnyOf::NnrfDisc),
            "nnrf-oauth2" => std::result::Result::Ok(ServiceNameAnyOf::NnrfOauth2),
            "nudm-sdm" => std::result::Result::Ok(ServiceNameAnyOf::NudmSdm),
            "nudm-uecm" => std::result::Result::Ok(ServiceNameAnyOf::NudmUecm),
            "nudm-ueau" => std::result::Result::Ok(ServiceNameAnyOf::NudmUeau),
            "nudm-ee" => std::result::Result::Ok(ServiceNameAnyOf::NudmEe),
            "nudm-pp" => std::result::Result::Ok(ServiceNameAnyOf::NudmPp),
            "nudm-niddau" => std::result::Result::Ok(ServiceNameAnyOf::NudmNiddau),
            "nudm-mt" => std::result::Result::Ok(ServiceNameAnyOf::NudmMt),
            "nudm-ssau" => std::result::Result::Ok(ServiceNameAnyOf::NudmSsau),
            "nudm-rsds" => std::result::Result::Ok(ServiceNameAnyOf::NudmRsds),
            "namf-comm" => std::result::Result::Ok(ServiceNameAnyOf::NamfComm),
            "namf-evts" => std::result::Result::Ok(ServiceNameAnyOf::NamfEvts),
            "namf-mt" => std::result::Result::Ok(ServiceNameAnyOf::NamfMt),
            "namf-loc" => std::result::Result::Ok(ServiceNameAnyOf::NamfLoc),
            "namf-mbs-comm" => std::result::Result::Ok(ServiceNameAnyOf::NamfMbsComm),
            "namf-mbs-bc" => std::result::Result::Ok(ServiceNameAnyOf::NamfMbsBc),
            "nsmf-pdusession" => std::result::Result::Ok(ServiceNameAnyOf::NsmfPdusession),
            "nsmf-event-exposure" => std::result::Result::Ok(ServiceNameAnyOf::NsmfEventExposure),
            "nsmf-nidd" => std::result::Result::Ok(ServiceNameAnyOf::NsmfNidd),
            "nausf-auth" => std::result::Result::Ok(ServiceNameAnyOf::NausfAuth),
            "nausf-sorprotection" => std::result::Result::Ok(ServiceNameAnyOf::NausfSorprotection),
            "nausf-upuprotection" => std::result::Result::Ok(ServiceNameAnyOf::NausfUpuprotection),
            "nnef-pfdmanagement" => std::result::Result::Ok(ServiceNameAnyOf::NnefPfdmanagement),
            "nnef-smcontext" => std::result::Result::Ok(ServiceNameAnyOf::NnefSmcontext),
            "nnef-eventexposure" => std::result::Result::Ok(ServiceNameAnyOf::NnefEventexposure),
            "nnef-eas-deployment-info" => {
                std::result::Result::Ok(ServiceNameAnyOf::NnefEasDeploymentInfo)
            }
            "3gpp-cp-parameter-provisioning" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppCpParameterProvisioning)
            }
            "3gpp-device-triggering" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppDeviceTriggering)
            }
            "3gpp-bdt" => std::result::Result::Ok(ServiceNameAnyOf::Variant3gppBdt),
            "3gpp-traffic-influence" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppTrafficInfluence)
            }
            "3gpp-chargeable-party" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppChargeableParty)
            }
            "3gpp-as-session-with-qos" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppAsSessionWithQos)
            }
            "3gpp-msisdn-less-mo-sms" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppMsisdnLessMoSms)
            }
            "3gpp-service-parameter" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppServiceParameter)
            }
            "3gpp-monitoring-event" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppMonitoringEvent)
            }
            "3gpp-nidd-configuration-trigger" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppNiddConfigurationTrigger)
            }
            "3gpp-nidd" => std::result::Result::Ok(ServiceNameAnyOf::Variant3gppNidd),
            "3gpp-analyticsexposure" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppAnalyticsexposure)
            }
            "3gpp-racs-parameter-provisioning" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppRacsParameterProvisioning)
            }
            "3gpp-ecr-control" => std::result::Result::Ok(ServiceNameAnyOf::Variant3gppEcrControl),
            "3gpp-applying-bdt-policy" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppApplyingBdtPolicy)
            }
            "3gpp-mo-lcs-notify" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppMoLcsNotify)
            }
            "3gpp-time-sync" => std::result::Result::Ok(ServiceNameAnyOf::Variant3gppTimeSync),
            "3gpp-am-influence" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppAmInfluence)
            }
            "3gpp-am-policyauthorization" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppAmPolicyauthorization)
            }
            "3gpp-akma" => std::result::Result::Ok(ServiceNameAnyOf::Variant3gppAkma),
            "3gpp-eas-deployment" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppEasDeployment)
            }
            "3gpp-iptvconfiguration" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppIptvconfiguration)
            }
            "3gpp-mbs-tmgi" => std::result::Result::Ok(ServiceNameAnyOf::Variant3gppMbsTmgi),
            "3gpp-mbs-session" => std::result::Result::Ok(ServiceNameAnyOf::Variant3gppMbsSession),
            "3gpp-authentication" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppAuthentication)
            }
            "3gpp-asti" => std::result::Result::Ok(ServiceNameAnyOf::Variant3gppAsti),
            "npcf-am-policy-control" => {
                std::result::Result::Ok(ServiceNameAnyOf::NpcfAmPolicyControl)
            }
            "npcf-smpolicycontrol" => {
                std::result::Result::Ok(ServiceNameAnyOf::NpcfSmpolicycontrol)
            }
            "npcf-policyauthorization" => {
                std::result::Result::Ok(ServiceNameAnyOf::NpcfPolicyauthorization)
            }
            "npcf-bdtpolicycontrol" => {
                std::result::Result::Ok(ServiceNameAnyOf::NpcfBdtpolicycontrol)
            }
            "npcf-eventexposure" => std::result::Result::Ok(ServiceNameAnyOf::NpcfEventexposure),
            "npcf-ue-policy-control" => {
                std::result::Result::Ok(ServiceNameAnyOf::NpcfUePolicyControl)
            }
            "npcf-am-policyauthorization" => {
                std::result::Result::Ok(ServiceNameAnyOf::NpcfAmPolicyauthorization)
            }
            "nsmsf-sms" => std::result::Result::Ok(ServiceNameAnyOf::NsmsfSms),
            "nnssf-nsselection" => std::result::Result::Ok(ServiceNameAnyOf::NnssfNsselection),
            "nnssf-nssaiavailability" => {
                std::result::Result::Ok(ServiceNameAnyOf::NnssfNssaiavailability)
            }
            "nudr-dr" => std::result::Result::Ok(ServiceNameAnyOf::NudrDr),
            "nudr-group-id-map" => std::result::Result::Ok(ServiceNameAnyOf::NudrGroupIdMap),
            "nlmf-loc" => std::result::Result::Ok(ServiceNameAnyOf::NlmfLoc),
            "n5g-eir-eic" => std::result::Result::Ok(ServiceNameAnyOf::N5gEirEic),
            "nbsf-management" => std::result::Result::Ok(ServiceNameAnyOf::NbsfManagement),
            "nchf-spendinglimitcontrol" => {
                std::result::Result::Ok(ServiceNameAnyOf::NchfSpendinglimitcontrol)
            }
            "nchf-convergedcharging" => {
                std::result::Result::Ok(ServiceNameAnyOf::NchfConvergedcharging)
            }
            "nchf-offlineonlycharging" => {
                std::result::Result::Ok(ServiceNameAnyOf::NchfOfflineonlycharging)
            }
            "nnwdaf-eventssubscription" => {
                std::result::Result::Ok(ServiceNameAnyOf::NnwdafEventssubscription)
            }
            "nnwdaf-analyticsinfo" => {
                std::result::Result::Ok(ServiceNameAnyOf::NnwdafAnalyticsinfo)
            }
            "nnwdaf-datamanagement" => {
                std::result::Result::Ok(ServiceNameAnyOf::NnwdafDatamanagement)
            }
            "nnwdaf-mlmodelprovision" => {
                std::result::Result::Ok(ServiceNameAnyOf::NnwdafMlmodelprovision)
            }
            "ngmlc-loc" => std::result::Result::Ok(ServiceNameAnyOf::NgmlcLoc),
            "nucmf-provisioning" => std::result::Result::Ok(ServiceNameAnyOf::NucmfProvisioning),
            "nucmf-uecapabilitymanagement" => {
                std::result::Result::Ok(ServiceNameAnyOf::NucmfUecapabilitymanagement)
            }
            "nhss-sdm" => std::result::Result::Ok(ServiceNameAnyOf::NhssSdm),
            "nhss-uecm" => std::result::Result::Ok(ServiceNameAnyOf::NhssUecm),
            "nhss-ueau" => std::result::Result::Ok(ServiceNameAnyOf::NhssUeau),
            "nhss-ee" => std::result::Result::Ok(ServiceNameAnyOf::NhssEe),
            "nhss-ims-sdm" => std::result::Result::Ok(ServiceNameAnyOf::NhssImsSdm),
            "nhss-ims-uecm" => std::result::Result::Ok(ServiceNameAnyOf::NhssImsUecm),
            "nhss-ims-ueau" => std::result::Result::Ok(ServiceNameAnyOf::NhssImsUeau),
            "nhss-gba-sdm" => std::result::Result::Ok(ServiceNameAnyOf::NhssGbaSdm),
            "nhss-gba-ueau" => std::result::Result::Ok(ServiceNameAnyOf::NhssGbaUeau),
            "nsepp-telescopic" => std::result::Result::Ok(ServiceNameAnyOf::NseppTelescopic),
            "nsoraf-sor" => std::result::Result::Ok(ServiceNameAnyOf::NsorafSor),
            "nspaf-secured-packet" => std::result::Result::Ok(ServiceNameAnyOf::NspafSecuredPacket),
            "nudsf-dr" => std::result::Result::Ok(ServiceNameAnyOf::NudsfDr),
            "nudsf-timer" => std::result::Result::Ok(ServiceNameAnyOf::NudsfTimer),
            "nnssaaf-nssaa" => std::result::Result::Ok(ServiceNameAnyOf::NnssaafNssaa),
            "nnssaaf-aiw" => std::result::Result::Ok(ServiceNameAnyOf::NnssaafAiw),
            "naanf-akma" => std::result::Result::Ok(ServiceNameAnyOf::NaanfAkma),
            "n5gddnmf-discovery" => std::result::Result::Ok(ServiceNameAnyOf::N5gddnmfDiscovery),
            "nmfaf-3dadm" => std::result::Result::Ok(ServiceNameAnyOf::Nmfaf3dadm),
            "nmfaf-3cadm" => std::result::Result::Ok(ServiceNameAnyOf::Nmfaf3cadm),
            "neasdf-dnscontext" => std::result::Result::Ok(ServiceNameAnyOf::NeasdfDnscontext),
            "neasdf-baselinednspattern" => {
                std::result::Result::Ok(ServiceNameAnyOf::NeasdfBaselinednspattern)
            }
            "ndccf-dm" => std::result::Result::Ok(ServiceNameAnyOf::NdccfDm),
            "ndccf-cm" => std::result::Result::Ok(ServiceNameAnyOf::NdccfCm),
            "nnsacf-nsac" => std::result::Result::Ok(ServiceNameAnyOf::NnsacfNsac),
            "nnsacf-slice-ee" => std::result::Result::Ok(ServiceNameAnyOf::NnsacfSliceEe),
            "nmbsmf-tmgi" => std::result::Result::Ok(ServiceNameAnyOf::NmbsmfTmgi),
            "nmbsmf-mbssession" => std::result::Result::Ok(ServiceNameAnyOf::NmbsmfMbssession),
            "nadrf-dm" => std::result::Result::Ok(ServiceNameAnyOf::NadrfDm),
            "nbsp-gba" => std::result::Result::Ok(ServiceNameAnyOf::NbspGba),
            "ntsctsf-time-sync" => std::result::Result::Ok(ServiceNameAnyOf::NtsctsfTimeSync),
            "ntsctsf-qos-tscai" => std::result::Result::Ok(ServiceNameAnyOf::NtsctsfQosTscai),
            "ntsctsf-asti" => std::result::Result::Ok(ServiceNameAnyOf::NtsctsfAsti),
            "npkmf-keyreq" => std::result::Result::Ok(ServiceNameAnyOf::NpkmfKeyreq),
            "nmnpf-npstatus" => std::result::Result::Ok(ServiceNameAnyOf::NmnpfNpstatus),
            "niwmsc-smservice" => std::result::Result::Ok(ServiceNameAnyOf::NiwmscSmservice),
            "nmbsf-mbsuserserv" => std::result::Result::Ok(ServiceNameAnyOf::NmbsfMbsuserserv),
            "nmbsf-mbsuserdataing" => {
                std::result::Result::Ok(ServiceNameAnyOf::NmbsfMbsuserdataing)
            }
            "nmbstf-distsession" => std::result::Result::Ok(ServiceNameAnyOf::NmbstfDistsession),
            "npanf-prosekey" => std::result::Result::Ok(ServiceNameAnyOf::NpanfProsekey),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SharedDataId(String);

impl std::convert::From<String> for SharedDataId {
    fn from(x: String) -> Self {
        SharedDataId(x)
    }
}

impl std::string::ToString for SharedDataId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for SharedDataId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(SharedDataId(x.to_string()))
    }
}

impl std::convert::From<SharedDataId> for String {
    fn from(x: SharedDataId) -> Self {
        x.0
    }
}

impl std::ops::Deref for SharedDataId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for SharedDataId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// A range of SharedDataIds based on regular-expression matching
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SharedDataIdRange {
    #[serde(rename = "pattern")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
}

impl SharedDataIdRange {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SharedDataIdRange {
        SharedDataIdRange { pattern: None }
    }
}

/// Converts the SharedDataIdRange value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SharedDataIdRange {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![self
            .pattern
            .as_ref()
            .map(|pattern| vec!["pattern".to_string(), pattern.to_string()].join(","))];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SharedDataIdRange value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SharedDataIdRange {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub pattern: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SharedDataIdRange".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "pattern" => intermediate_rep.pattern.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SharedDataIdRange".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SharedDataIdRange {
            pattern: intermediate_rep.pattern.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SharedDataIdRange> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SharedDataIdRange>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SharedDataIdRange>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SharedDataIdRange - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SharedDataIdRange>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SharedDataIdRange as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SharedDataIdRange - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Information of an SMF NF Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SmfInfo {
    #[serde(rename = "sNssaiSmfInfoList")]
    pub s_nssai_smf_info_list: Vec<models::SnssaiSmfInfoItem>,

    #[serde(rename = "taiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tai_list: Option<Vec<models::Tai>>,

    #[serde(rename = "taiRangeList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tai_range_list: Option<Vec<models::TaiRange>>,

    /// Fully Qualified Domain Name
    #[serde(rename = "pgwFqdn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pgw_fqdn: Option<String>,

    #[serde(rename = "pgwIpAddrList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pgw_ip_addr_list: Option<Vec<models::IpAddr>>,

    #[serde(rename = "accessType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub access_type: Option<Vec<models::AccessType>>,

    #[serde(rename = "priority")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority: Option<u16>,

    #[serde(rename = "vsmfSupportInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub vsmf_support_ind: Option<bool>,

    #[serde(rename = "pgwFqdnList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pgw_fqdn_list: Option<Vec<models::Fqdn>>,

    #[serde(rename = "smfOnboardingCapability")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub smf_onboarding_capability: Option<bool>,

    #[serde(rename = "ismfSupportInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ismf_support_ind: Option<bool>,

    #[serde(rename = "smfUPRPCapability")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub smf_uprp_capability: Option<bool>,
}

impl SmfInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(s_nssai_smf_info_list: Vec<models::SnssaiSmfInfoItem>) -> SmfInfo {
        SmfInfo {
            s_nssai_smf_info_list,
            tai_list: None,
            tai_range_list: None,
            pgw_fqdn: None,
            pgw_ip_addr_list: None,
            access_type: None,
            priority: None,
            vsmf_support_ind: None,
            pgw_fqdn_list: None,
            smf_onboarding_capability: Some(false),
            ismf_support_ind: None,
            smf_uprp_capability: Some(false),
        }
    }
}

/// Converts the SmfInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SmfInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping sNssaiSmfInfoList in query parameter serialization

            // Skipping taiList in query parameter serialization

            // Skipping taiRangeList in query parameter serialization
            self.pgw_fqdn
                .as_ref()
                .map(|pgw_fqdn| vec!["pgwFqdn".to_string(), pgw_fqdn.to_string()].join(",")),
            // Skipping pgwIpAddrList in query parameter serialization

            // Skipping accessType in query parameter serialization
            self.priority
                .as_ref()
                .map(|priority| vec!["priority".to_string(), priority.to_string()].join(",")),
            self.vsmf_support_ind.as_ref().map(|vsmf_support_ind| {
                vec!["vsmfSupportInd".to_string(), vsmf_support_ind.to_string()].join(",")
            }),
            self.pgw_fqdn_list.as_ref().map(|pgw_fqdn_list| {
                vec![
                    "pgwFqdnList".to_string(),
                    pgw_fqdn_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.smf_onboarding_capability
                .as_ref()
                .map(|smf_onboarding_capability| {
                    vec![
                        "smfOnboardingCapability".to_string(),
                        smf_onboarding_capability.to_string(),
                    ]
                    .join(",")
                }),
            self.ismf_support_ind.as_ref().map(|ismf_support_ind| {
                vec!["ismfSupportInd".to_string(), ismf_support_ind.to_string()].join(",")
            }),
            self.smf_uprp_capability
                .as_ref()
                .map(|smf_uprp_capability| {
                    vec![
                        "smfUPRPCapability".to_string(),
                        smf_uprp_capability.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SmfInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SmfInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub s_nssai_smf_info_list: Vec<Vec<models::SnssaiSmfInfoItem>>,
            pub tai_list: Vec<Vec<models::Tai>>,
            pub tai_range_list: Vec<Vec<models::TaiRange>>,
            pub pgw_fqdn: Vec<String>,
            pub pgw_ip_addr_list: Vec<Vec<models::IpAddr>>,
            pub access_type: Vec<Vec<models::AccessType>>,
            pub priority: Vec<u16>,
            pub vsmf_support_ind: Vec<bool>,
            pub pgw_fqdn_list: Vec<Vec<models::Fqdn>>,
            pub smf_onboarding_capability: Vec<bool>,
            pub ismf_support_ind: Vec<bool>,
            pub smf_uprp_capability: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SmfInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "sNssaiSmfInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SmfInfo"
                                .to_string(),
                        )
                    }
                    "taiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SmfInfo"
                                .to_string(),
                        )
                    }
                    "taiRangeList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SmfInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "pgwFqdn" => intermediate_rep.pgw_fqdn.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "pgwIpAddrList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SmfInfo"
                                .to_string(),
                        )
                    }
                    "accessType" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SmfInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "priority" => intermediate_rep.priority.push(
                        <u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "vsmfSupportInd" => intermediate_rep.vsmf_support_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "pgwFqdnList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SmfInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "smfOnboardingCapability" => intermediate_rep.smf_onboarding_capability.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ismfSupportInd" => intermediate_rep.ismf_support_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "smfUPRPCapability" => intermediate_rep.smf_uprp_capability.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SmfInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SmfInfo {
            s_nssai_smf_info_list: intermediate_rep
                .s_nssai_smf_info_list
                .into_iter()
                .next()
                .ok_or_else(|| "sNssaiSmfInfoList missing in SmfInfo".to_string())?,
            tai_list: intermediate_rep.tai_list.into_iter().next(),
            tai_range_list: intermediate_rep.tai_range_list.into_iter().next(),
            pgw_fqdn: intermediate_rep.pgw_fqdn.into_iter().next(),
            pgw_ip_addr_list: intermediate_rep.pgw_ip_addr_list.into_iter().next(),
            access_type: intermediate_rep.access_type.into_iter().next(),
            priority: intermediate_rep.priority.into_iter().next(),
            vsmf_support_ind: intermediate_rep.vsmf_support_ind.into_iter().next(),
            pgw_fqdn_list: intermediate_rep.pgw_fqdn_list.into_iter().next(),
            smf_onboarding_capability: intermediate_rep
                .smf_onboarding_capability
                .into_iter()
                .next(),
            ismf_support_ind: intermediate_rep.ismf_support_ind.into_iter().next(),
            smf_uprp_capability: intermediate_rep.smf_uprp_capability.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SmfInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SmfInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SmfInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SmfInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SmfInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SmfInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SmfInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// When Snssai needs to be converted to string (e.g. when used in maps as key), the string shall be composed of one to three digits \"sst\" optionally followed by \"-\" and 6 hexadecimal digits \"sd\".
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Snssai {
    /// Unsigned integer, within the range 0 to 255, representing the Slice/Service Type.  It indicates the expected Network Slice behaviour in terms of features and services. Values 0 to 127 correspond to the standardized SST range. Values 128 to 255 correspond  to the Operator-specific range. See clause 28.4.2 of 3GPP TS 23.003. Standardized values are defined in clause 5.15.2.2 of 3GPP TS 23.501.
    #[serde(rename = "sst")]
    pub sst: u8,

    /// 3-octet string, representing the Slice Differentiator, in hexadecimal representation. Each character in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character representing the 4 most significant bits of the SD shall appear first in the string, and the character representing the 4 least significant bit of the SD shall appear last in the string. This is an optional parameter that complements the Slice/Service type(s) to allow to  differentiate amongst multiple Network Slices of the same Slice/Service type. This IE shall be absent if no SD value is associated with the SST.
    #[serde(rename = "sd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sd: Option<String>,
}

impl Snssai {
    #[allow(clippy::new_without_default)]
    pub fn new(sst: u8) -> Snssai {
        Snssai { sst, sd: None }
    }
}

/// Converts the Snssai value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Snssai {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("sst".to_string()),
            Some(self.sst.to_string()),
            self.sd
                .as_ref()
                .map(|sd| vec!["sd".to_string(), sd.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Snssai value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Snssai {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub sst: Vec<u8>,
            pub sd: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Snssai".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "sst" => intermediate_rep
                        .sst
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sd" => intermediate_rep.sd.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Snssai".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Snssai {
            sst: intermediate_rep
                .sst
                .into_iter()
                .next()
                .ok_or_else(|| "sst missing in Snssai".to_string())?,
            sd: intermediate_rep.sd.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Snssai> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Snssai>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Snssai>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Snssai - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Snssai> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <Snssai as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into Snssai - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Set of parameters supported by EASDF for a given S-NSSAI
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SnssaiEasdfInfoItem {
    #[serde(rename = "sNssai")]
    pub s_nssai: models::ExtSnssai,

    #[serde(rename = "dnnEasdfInfoList")]
    pub dnn_easdf_info_list: Vec<models::DnnEasdfInfoItem>,
}

impl SnssaiEasdfInfoItem {
    #[allow(clippy::new_without_default)]
    pub fn new(
        s_nssai: models::ExtSnssai,
        dnn_easdf_info_list: Vec<models::DnnEasdfInfoItem>,
    ) -> SnssaiEasdfInfoItem {
        SnssaiEasdfInfoItem {
            s_nssai,
            dnn_easdf_info_list,
        }
    }
}

/// Converts the SnssaiEasdfInfoItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SnssaiEasdfInfoItem {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping sNssai in query parameter serialization

            // Skipping dnnEasdfInfoList in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SnssaiEasdfInfoItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SnssaiEasdfInfoItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub s_nssai: Vec<models::ExtSnssai>,
            pub dnn_easdf_info_list: Vec<Vec<models::DnnEasdfInfoItem>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SnssaiEasdfInfoItem".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "sNssai" => intermediate_rep.s_nssai.push(
                        <models::ExtSnssai as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "dnnEasdfInfoList" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in SnssaiEasdfInfoItem"
                            .to_string(),
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SnssaiEasdfInfoItem".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SnssaiEasdfInfoItem {
            s_nssai: intermediate_rep
                .s_nssai
                .into_iter()
                .next()
                .ok_or_else(|| "sNssai missing in SnssaiEasdfInfoItem".to_string())?,
            dnn_easdf_info_list: intermediate_rep
                .dnn_easdf_info_list
                .into_iter()
                .next()
                .ok_or_else(|| "dnnEasdfInfoList missing in SnssaiEasdfInfoItem".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SnssaiEasdfInfoItem> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SnssaiEasdfInfoItem>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SnssaiEasdfInfoItem>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SnssaiEasdfInfoItem - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SnssaiEasdfInfoItem>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SnssaiEasdfInfoItem as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SnssaiEasdfInfoItem - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Extensions to the Snssai data type, sdRanges and wildcardSd shall not be present simultaneously
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SnssaiExtension {
    /// When present, it shall contain the range(s) of Slice Differentiator values supported for the Slice/Service Type value indicated in the sst attribute of the Snssai data type
    #[serde(rename = "sdRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sd_ranges: Option<Vec<models::SdRange>>,

    /// When present, it shall be set to true, to indicate that all SD values are supported for the Slice/Service Type value indicated in the sst attribute of the Snssai data type.
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "wildcardSd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub wildcard_sd: Option<bool>,
}

impl SnssaiExtension {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SnssaiExtension {
        SnssaiExtension {
            sd_ranges: None,
            wildcard_sd: None,
        }
    }
}

/// Converts the SnssaiExtension value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SnssaiExtension {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping sdRanges in query parameter serialization
            self.wildcard_sd.as_ref().map(|wildcard_sd| {
                vec!["wildcardSd".to_string(), wildcard_sd.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SnssaiExtension value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SnssaiExtension {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub sd_ranges: Vec<Vec<models::SdRange>>,
            pub wildcard_sd: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SnssaiExtension".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "sdRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SnssaiExtension"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "wildcardSd" => intermediate_rep.wildcard_sd.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SnssaiExtension".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SnssaiExtension {
            sd_ranges: intermediate_rep.sd_ranges.into_iter().next(),
            wildcard_sd: intermediate_rep.wildcard_sd.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SnssaiExtension> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SnssaiExtension>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SnssaiExtension>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SnssaiExtension - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SnssaiExtension>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SnssaiExtension as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SnssaiExtension - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Parameters supported by an NF for a given S-NSSAI Set of parameters supported by NF for a given S-NSSAI
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SnssaiInfoItem {
    #[serde(rename = "sNssai")]
    pub s_nssai: models::ExtSnssai,

    #[serde(rename = "dnnInfoList")]
    pub dnn_info_list: Vec<models::DnnInfoItem>,
}

impl SnssaiInfoItem {
    #[allow(clippy::new_without_default)]
    pub fn new(
        s_nssai: models::ExtSnssai,
        dnn_info_list: Vec<models::DnnInfoItem>,
    ) -> SnssaiInfoItem {
        SnssaiInfoItem {
            s_nssai,
            dnn_info_list,
        }
    }
}

/// Converts the SnssaiInfoItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SnssaiInfoItem {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping sNssai in query parameter serialization

            // Skipping dnnInfoList in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SnssaiInfoItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SnssaiInfoItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub s_nssai: Vec<models::ExtSnssai>,
            pub dnn_info_list: Vec<Vec<models::DnnInfoItem>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SnssaiInfoItem".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "sNssai" => intermediate_rep.s_nssai.push(
                        <models::ExtSnssai as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "dnnInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SnssaiInfoItem"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SnssaiInfoItem".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SnssaiInfoItem {
            s_nssai: intermediate_rep
                .s_nssai
                .into_iter()
                .next()
                .ok_or_else(|| "sNssai missing in SnssaiInfoItem".to_string())?,
            dnn_info_list: intermediate_rep
                .dnn_info_list
                .into_iter()
                .next()
                .ok_or_else(|| "dnnInfoList missing in SnssaiInfoItem".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SnssaiInfoItem> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SnssaiInfoItem>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SnssaiInfoItem>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SnssaiInfoItem - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SnssaiInfoItem> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SnssaiInfoItem as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SnssaiInfoItem - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Parameters supported by an MB-SMF for a given S-NSSAI
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SnssaiMbSmfInfoItem {
    #[serde(rename = "sNssai")]
    pub s_nssai: models::ExtSnssai,

    #[serde(rename = "dnnInfoList")]
    pub dnn_info_list: Vec<models::DnnMbSmfInfoItem>,
}

impl SnssaiMbSmfInfoItem {
    #[allow(clippy::new_without_default)]
    pub fn new(
        s_nssai: models::ExtSnssai,
        dnn_info_list: Vec<models::DnnMbSmfInfoItem>,
    ) -> SnssaiMbSmfInfoItem {
        SnssaiMbSmfInfoItem {
            s_nssai,
            dnn_info_list,
        }
    }
}

/// Converts the SnssaiMbSmfInfoItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SnssaiMbSmfInfoItem {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping sNssai in query parameter serialization

            // Skipping dnnInfoList in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SnssaiMbSmfInfoItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SnssaiMbSmfInfoItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub s_nssai: Vec<models::ExtSnssai>,
            pub dnn_info_list: Vec<Vec<models::DnnMbSmfInfoItem>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SnssaiMbSmfInfoItem".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "sNssai" => intermediate_rep.s_nssai.push(
                        <models::ExtSnssai as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "dnnInfoList" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in SnssaiMbSmfInfoItem"
                            .to_string(),
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SnssaiMbSmfInfoItem".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SnssaiMbSmfInfoItem {
            s_nssai: intermediate_rep
                .s_nssai
                .into_iter()
                .next()
                .ok_or_else(|| "sNssai missing in SnssaiMbSmfInfoItem".to_string())?,
            dnn_info_list: intermediate_rep
                .dnn_info_list
                .into_iter()
                .next()
                .ok_or_else(|| "dnnInfoList missing in SnssaiMbSmfInfoItem".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SnssaiMbSmfInfoItem> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SnssaiMbSmfInfoItem>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SnssaiMbSmfInfoItem>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SnssaiMbSmfInfoItem - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SnssaiMbSmfInfoItem>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SnssaiMbSmfInfoItem as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SnssaiMbSmfInfoItem - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Set of parameters supported by SMF for a given S-NSSAI
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SnssaiSmfInfoItem {
    #[serde(rename = "sNssai")]
    pub s_nssai: models::ExtSnssai,

    #[serde(rename = "dnnSmfInfoList")]
    pub dnn_smf_info_list: Vec<models::DnnSmfInfoItem>,
}

impl SnssaiSmfInfoItem {
    #[allow(clippy::new_without_default)]
    pub fn new(
        s_nssai: models::ExtSnssai,
        dnn_smf_info_list: Vec<models::DnnSmfInfoItem>,
    ) -> SnssaiSmfInfoItem {
        SnssaiSmfInfoItem {
            s_nssai,
            dnn_smf_info_list,
        }
    }
}

/// Converts the SnssaiSmfInfoItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SnssaiSmfInfoItem {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping sNssai in query parameter serialization

            // Skipping dnnSmfInfoList in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SnssaiSmfInfoItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SnssaiSmfInfoItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub s_nssai: Vec<models::ExtSnssai>,
            pub dnn_smf_info_list: Vec<Vec<models::DnnSmfInfoItem>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SnssaiSmfInfoItem".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "sNssai" => intermediate_rep.s_nssai.push(
                        <models::ExtSnssai as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "dnnSmfInfoList" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in SnssaiSmfInfoItem"
                            .to_string(),
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SnssaiSmfInfoItem".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SnssaiSmfInfoItem {
            s_nssai: intermediate_rep
                .s_nssai
                .into_iter()
                .next()
                .ok_or_else(|| "sNssai missing in SnssaiSmfInfoItem".to_string())?,
            dnn_smf_info_list: intermediate_rep
                .dnn_smf_info_list
                .into_iter()
                .next()
                .ok_or_else(|| "dnnSmfInfoList missing in SnssaiSmfInfoItem".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SnssaiSmfInfoItem> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SnssaiSmfInfoItem>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SnssaiSmfInfoItem>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SnssaiSmfInfoItem - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SnssaiSmfInfoItem>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SnssaiSmfInfoItem as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SnssaiSmfInfoItem - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Set of parameters supported by TSCTSF for a given S-NSSAI
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SnssaiTsctsfInfoItem {
    #[serde(rename = "sNssai")]
    pub s_nssai: models::ExtSnssai,

    #[serde(rename = "dnnInfoList")]
    pub dnn_info_list: Vec<models::DnnTsctsfInfoItem>,
}

impl SnssaiTsctsfInfoItem {
    #[allow(clippy::new_without_default)]
    pub fn new(
        s_nssai: models::ExtSnssai,
        dnn_info_list: Vec<models::DnnTsctsfInfoItem>,
    ) -> SnssaiTsctsfInfoItem {
        SnssaiTsctsfInfoItem {
            s_nssai,
            dnn_info_list,
        }
    }
}

/// Converts the SnssaiTsctsfInfoItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SnssaiTsctsfInfoItem {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping sNssai in query parameter serialization

            // Skipping dnnInfoList in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SnssaiTsctsfInfoItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SnssaiTsctsfInfoItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub s_nssai: Vec<models::ExtSnssai>,
            pub dnn_info_list: Vec<Vec<models::DnnTsctsfInfoItem>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SnssaiTsctsfInfoItem".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "sNssai" => intermediate_rep.s_nssai.push(<models::ExtSnssai as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "dnnInfoList" => return std::result::Result::Err("Parsing a container in this style is not supported in SnssaiTsctsfInfoItem".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing SnssaiTsctsfInfoItem".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SnssaiTsctsfInfoItem {
            s_nssai: intermediate_rep
                .s_nssai
                .into_iter()
                .next()
                .ok_or_else(|| "sNssai missing in SnssaiTsctsfInfoItem".to_string())?,
            dnn_info_list: intermediate_rep
                .dnn_info_list
                .into_iter()
                .next()
                .ok_or_else(|| "dnnInfoList missing in SnssaiTsctsfInfoItem".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SnssaiTsctsfInfoItem> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SnssaiTsctsfInfoItem>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SnssaiTsctsfInfoItem>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SnssaiTsctsfInfoItem - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SnssaiTsctsfInfoItem>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SnssaiTsctsfInfoItem as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SnssaiTsctsfInfoItem - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Set of parameters supported by UPF for a given S-NSSAI
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SnssaiUpfInfoItem {
    #[serde(rename = "sNssai")]
    pub s_nssai: models::ExtSnssai,

    #[serde(rename = "dnnUpfInfoList")]
    pub dnn_upf_info_list: Vec<models::DnnUpfInfoItem>,

    #[serde(rename = "redundantTransport")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub redundant_transport: Option<bool>,
}

impl SnssaiUpfInfoItem {
    #[allow(clippy::new_without_default)]
    pub fn new(
        s_nssai: models::ExtSnssai,
        dnn_upf_info_list: Vec<models::DnnUpfInfoItem>,
    ) -> SnssaiUpfInfoItem {
        SnssaiUpfInfoItem {
            s_nssai,
            dnn_upf_info_list,
            redundant_transport: Some(false),
        }
    }
}

/// Converts the SnssaiUpfInfoItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SnssaiUpfInfoItem {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping sNssai in query parameter serialization

            // Skipping dnnUpfInfoList in query parameter serialization
            self.redundant_transport
                .as_ref()
                .map(|redundant_transport| {
                    vec![
                        "redundantTransport".to_string(),
                        redundant_transport.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SnssaiUpfInfoItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SnssaiUpfInfoItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub s_nssai: Vec<models::ExtSnssai>,
            pub dnn_upf_info_list: Vec<Vec<models::DnnUpfInfoItem>>,
            pub redundant_transport: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SnssaiUpfInfoItem".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "sNssai" => intermediate_rep.s_nssai.push(
                        <models::ExtSnssai as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "dnnUpfInfoList" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in SnssaiUpfInfoItem"
                            .to_string(),
                    ),
                    #[allow(clippy::redundant_clone)]
                    "redundantTransport" => intermediate_rep.redundant_transport.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SnssaiUpfInfoItem".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SnssaiUpfInfoItem {
            s_nssai: intermediate_rep
                .s_nssai
                .into_iter()
                .next()
                .ok_or_else(|| "sNssai missing in SnssaiUpfInfoItem".to_string())?,
            dnn_upf_info_list: intermediate_rep
                .dnn_upf_info_list
                .into_iter()
                .next()
                .ok_or_else(|| "dnnUpfInfoList missing in SnssaiUpfInfoItem".to_string())?,
            redundant_transport: intermediate_rep.redundant_transport.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SnssaiUpfInfoItem> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SnssaiUpfInfoItem>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SnssaiUpfInfoItem>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SnssaiUpfInfoItem - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SnssaiUpfInfoItem>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SnssaiUpfInfoItem as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SnssaiUpfInfoItem - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Source specific IP multicast address
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Ssm {
    #[serde(rename = "sourceIpAddr")]
    pub source_ip_addr: models::IpAddr,

    #[serde(rename = "destIpAddr")]
    pub dest_ip_addr: models::IpAddr,
}

impl Ssm {
    #[allow(clippy::new_without_default)]
    pub fn new(source_ip_addr: models::IpAddr, dest_ip_addr: models::IpAddr) -> Ssm {
        Ssm {
            source_ip_addr,
            dest_ip_addr,
        }
    }
}

/// Converts the Ssm value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Ssm {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping sourceIpAddr in query parameter serialization

            // Skipping destIpAddr in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Ssm value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Ssm {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub source_ip_addr: Vec<models::IpAddr>,
            pub dest_ip_addr: Vec<models::IpAddr>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err("Missing value while parsing Ssm".to_string())
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "sourceIpAddr" => intermediate_rep.source_ip_addr.push(
                        <models::IpAddr as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "destIpAddr" => intermediate_rep.dest_ip_addr.push(
                        <models::IpAddr as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Ssm".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Ssm {
            source_ip_addr: intermediate_rep
                .source_ip_addr
                .into_iter()
                .next()
                .ok_or_else(|| "sourceIpAddr missing in Ssm".to_string())?,
            dest_ip_addr: intermediate_rep
                .dest_ip_addr
                .into_iter()
                .next()
                .ok_or_else(|| "destIpAddr missing in Ssm".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Ssm> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Ssm>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Ssm>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Ssm - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Ssm> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Ssm as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Ssm - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains a complete search result (i.e. a number of discovered NF Instances), stored by NRF as a consequence of a prior search result
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct StoredSearchResult {
    #[serde(rename = "nfInstances")]
    pub nf_instances: Vec<models::NfProfile>,
}

impl StoredSearchResult {
    #[allow(clippy::new_without_default)]
    pub fn new(nf_instances: Vec<models::NfProfile>) -> StoredSearchResult {
        StoredSearchResult { nf_instances }
    }
}

/// Converts the StoredSearchResult value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for StoredSearchResult {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping nfInstances in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a StoredSearchResult value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for StoredSearchResult {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub nf_instances: Vec<Vec<models::NfProfile>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing StoredSearchResult".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "nfInstances" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in StoredSearchResult"
                            .to_string(),
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing StoredSearchResult".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(StoredSearchResult {
            nf_instances: intermediate_rep
                .nf_instances
                .into_iter()
                .next()
                .ok_or_else(|| "nfInstances missing in StoredSearchResult".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<StoredSearchResult> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<StoredSearchResult>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<StoredSearchResult>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for StoredSearchResult - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<StoredSearchResult>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <StoredSearchResult as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into StoredSearchResult - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// SUCI information containing Routing Indicator and Home Network Public Key ID
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SuciInfo {
    #[serde(rename = "routingInds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub routing_inds: Option<Vec<String>>,

    #[serde(rename = "hNwPubKeyIds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub h_nw_pub_key_ids: Option<Vec<i32>>,
}

impl SuciInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SuciInfo {
        SuciInfo {
            routing_inds: None,
            h_nw_pub_key_ids: None,
        }
    }
}

/// Converts the SuciInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SuciInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.routing_inds.as_ref().map(|routing_inds| {
                vec![
                    "routingInds".to_string(),
                    routing_inds
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.h_nw_pub_key_ids.as_ref().map(|h_nw_pub_key_ids| {
                vec![
                    "hNwPubKeyIds".to_string(),
                    h_nw_pub_key_ids
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SuciInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SuciInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub routing_inds: Vec<Vec<String>>,
            pub h_nw_pub_key_ids: Vec<Vec<i32>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SuciInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "routingInds" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SuciInfo"
                                .to_string(),
                        )
                    }
                    "hNwPubKeyIds" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SuciInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SuciInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SuciInfo {
            routing_inds: intermediate_rep.routing_inds.into_iter().next(),
            h_nw_pub_key_ids: intermediate_rep.h_nw_pub_key_ids.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SuciInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SuciInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SuciInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SuciInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SuciInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SuciInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SuciInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// String identifying a Supi that shall contain either an IMSI, a network specific identifier, a Global Cable Identifier (GCI) or a Global Line Identifier (GLI) as specified in clause  2.2A of 3GPP TS 23.003. It shall be formatted as follows  - for an IMSI \"imsi-<imsi>\", where <imsi> shall be formatted according to clause 2.2    of 3GPP TS 23.003 that describes an IMSI.  - for a network specific identifier \"nai-<nai>, where <nai> shall be formatted    according to clause 28.7.2 of 3GPP TS 23.003 that describes an NAI.  - for a GCI \"gci-<gci>\", where <gci> shall be formatted according to clause 28.15.2    of 3GPP TS 23.003.  - for a GLI \"gli-<gli>\", where <gli> shall be formatted according to clause 28.16.2 of    3GPP TS 23.003.To enable that the value is used as part of an URI, the string shall    only contain characters allowed according to the \"lower-with-hyphen\" naming convention    defined in 3GPP TS 29.501.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Supi(String);

impl std::convert::From<String> for Supi {
    fn from(x: String) -> Self {
        Supi(x)
    }
}

impl std::string::ToString for Supi {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Supi {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Supi(x.to_string()))
    }
}

impl std::convert::From<Supi> for String {
    fn from(x: Supi) -> Self {
        x.0
    }
}

impl std::ops::Deref for Supi {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Supi {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// A range of SUPIs (subscriber identities), either based on a numeric range, or based on regular-expression matching
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SupiRange {
    #[serde(rename = "start")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start: Option<String>,

    #[serde(rename = "end")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end: Option<String>,

    #[serde(rename = "pattern")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
}

impl SupiRange {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SupiRange {
        SupiRange {
            start: None,
            end: None,
            pattern: None,
        }
    }
}

/// Converts the SupiRange value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SupiRange {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.start
                .as_ref()
                .map(|start| vec!["start".to_string(), start.to_string()].join(",")),
            self.end
                .as_ref()
                .map(|end| vec!["end".to_string(), end.to_string()].join(",")),
            self.pattern
                .as_ref()
                .map(|pattern| vec!["pattern".to_string(), pattern.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SupiRange value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SupiRange {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub start: Vec<String>,
            pub end: Vec<String>,
            pub pattern: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SupiRange".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "start" => intermediate_rep.start.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "end" => intermediate_rep.end.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "pattern" => intermediate_rep.pattern.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SupiRange".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SupiRange {
            start: intermediate_rep.start.into_iter().next(),
            end: intermediate_rep.end.into_iter().next(),
            pattern: intermediate_rep.pattern.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SupiRange> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SupiRange>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SupiRange>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SupiRange - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SupiRange> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SupiRange as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SupiRange - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  tableÂ 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SupportedFeatures(String);

impl std::convert::From<String> for SupportedFeatures {
    fn from(x: String) -> Self {
        SupportedFeatures(x)
    }
}

impl std::string::ToString for SupportedFeatures {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for SupportedFeatures {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(SupportedFeatures(x.to_string()))
    }
}

impl std::convert::From<SupportedFeatures> for String {
    fn from(x: SupportedFeatures) -> Self {
        x.0
    }
}

impl std::ops::Deref for SupportedFeatures {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for SupportedFeatures {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Indicates supported GAD shapes.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SupportedGadShapes {}

impl SupportedGadShapes {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SupportedGadShapes {
        SupportedGadShapes {}
    }
}

/// Converts the SupportedGadShapes value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SupportedGadShapes {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SupportedGadShapes value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SupportedGadShapes {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SupportedGadShapes".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SupportedGadShapes".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SupportedGadShapes {})
    }
}

// Methods for converting between header::IntoHeaderValue<SupportedGadShapes> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SupportedGadShapes>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SupportedGadShapes>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SupportedGadShapes - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SupportedGadShapes>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SupportedGadShapes as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SupportedGadShapes - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum SupportedGadShapesAnyOf {
    #[serde(rename = "POINT")]
    Point,
    #[serde(rename = "POINT_UNCERTAINTY_CIRCLE")]
    PointUncertaintyCircle,
    #[serde(rename = "POINT_UNCERTAINTY_ELLIPSE")]
    PointUncertaintyEllipse,
    #[serde(rename = "POLYGON")]
    Polygon,
    #[serde(rename = "POINT_ALTITUDE")]
    PointAltitude,
    #[serde(rename = "POINT_ALTITUDE_UNCERTAINTY")]
    PointAltitudeUncertainty,
    #[serde(rename = "ELLIPSOID_ARC")]
    EllipsoidArc,
    #[serde(rename = "LOCAL_2D_POINT_UNCERTAINTY_ELLIPSE")]
    Local2DPointUncertaintyEllipse,
    #[serde(rename = "LOCAL_3D_POINT_UNCERTAINTY_ELLIPSOID")]
    Local3DPointUncertaintyEllipsoid,
}

impl std::fmt::Display for SupportedGadShapesAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            SupportedGadShapesAnyOf::Point => write!(f, "POINT"),
            SupportedGadShapesAnyOf::PointUncertaintyCircle => {
                write!(f, "POINT_UNCERTAINTY_CIRCLE")
            }
            SupportedGadShapesAnyOf::PointUncertaintyEllipse => {
                write!(f, "POINT_UNCERTAINTY_ELLIPSE")
            }
            SupportedGadShapesAnyOf::Polygon => write!(f, "POLYGON"),
            SupportedGadShapesAnyOf::PointAltitude => write!(f, "POINT_ALTITUDE"),
            SupportedGadShapesAnyOf::PointAltitudeUncertainty => {
                write!(f, "POINT_ALTITUDE_UNCERTAINTY")
            }
            SupportedGadShapesAnyOf::EllipsoidArc => write!(f, "ELLIPSOID_ARC"),
            SupportedGadShapesAnyOf::Local2DPointUncertaintyEllipse => {
                write!(f, "LOCAL_2D_POINT_UNCERTAINTY_ELLIPSE")
            }
            SupportedGadShapesAnyOf::Local3DPointUncertaintyEllipsoid => {
                write!(f, "LOCAL_3D_POINT_UNCERTAINTY_ELLIPSOID")
            }
        }
    }
}

impl std::str::FromStr for SupportedGadShapesAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "POINT" => std::result::Result::Ok(SupportedGadShapesAnyOf::Point),
            "POINT_UNCERTAINTY_CIRCLE" => {
                std::result::Result::Ok(SupportedGadShapesAnyOf::PointUncertaintyCircle)
            }
            "POINT_UNCERTAINTY_ELLIPSE" => {
                std::result::Result::Ok(SupportedGadShapesAnyOf::PointUncertaintyEllipse)
            }
            "POLYGON" => std::result::Result::Ok(SupportedGadShapesAnyOf::Polygon),
            "POINT_ALTITUDE" => std::result::Result::Ok(SupportedGadShapesAnyOf::PointAltitude),
            "POINT_ALTITUDE_UNCERTAINTY" => {
                std::result::Result::Ok(SupportedGadShapesAnyOf::PointAltitudeUncertainty)
            }
            "ELLIPSOID_ARC" => std::result::Result::Ok(SupportedGadShapesAnyOf::EllipsoidArc),
            "LOCAL_2D_POINT_UNCERTAINTY_ELLIPSE" => {
                std::result::Result::Ok(SupportedGadShapesAnyOf::Local2DPointUncertaintyEllipse)
            }
            "LOCAL_3D_POINT_UNCERTAINTY_ELLIPSOID" => {
                std::result::Result::Ok(SupportedGadShapesAnyOf::Local3DPointUncertaintyEllipsoid)
            }
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// 2 or 3-octet string identifying a tracking area code as specified in clause 9.3.3.10  of 3GPP TS 38.413, in hexadecimal representation. Each character in the string shall  take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character representing the 4 most significant bits of the TAC shall  appear first in the string, and the character representing the 4 least significant bit  of the TAC shall appear last in the string.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Tac(String);

impl std::convert::From<String> for Tac {
    fn from(x: String) -> Self {
        Tac(x)
    }
}

impl std::string::ToString for Tac {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Tac {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Tac(x.to_string()))
    }
}

impl std::convert::From<Tac> for String {
    fn from(x: Tac) -> Self {
        x.0
    }
}

impl std::ops::Deref for Tac {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Tac {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Range of TACs (Tracking Area Codes)
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TacRange {
    #[serde(rename = "start")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start: Option<String>,

    #[serde(rename = "end")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end: Option<String>,

    #[serde(rename = "pattern")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pattern: Option<String>,
}

impl TacRange {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TacRange {
        TacRange {
            start: None,
            end: None,
            pattern: None,
        }
    }
}

/// Converts the TacRange value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TacRange {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.start
                .as_ref()
                .map(|start| vec!["start".to_string(), start.to_string()].join(",")),
            self.end
                .as_ref()
                .map(|end| vec!["end".to_string(), end.to_string()].join(",")),
            self.pattern
                .as_ref()
                .map(|pattern| vec!["pattern".to_string(), pattern.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TacRange value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TacRange {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub start: Vec<String>,
            pub end: Vec<String>,
            pub pattern: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TacRange".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "start" => intermediate_rep.start.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "end" => intermediate_rep.end.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "pattern" => intermediate_rep.pattern.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing TacRange".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TacRange {
            start: intermediate_rep.start.into_iter().next(),
            end: intermediate_rep.end.into_iter().next(),
            pattern: intermediate_rep.pattern.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TacRange> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TacRange>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TacRange>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TacRange - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TacRange> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TacRange as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TacRange - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains the tracking area identity as described in 3GPP 23.003
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Tai {
    #[serde(rename = "plmnId")]
    pub plmn_id: models::PlmnId,

    /// 2 or 3-octet string identifying a tracking area code as specified in clause 9.3.3.10  of 3GPP TS 38.413, in hexadecimal representation. Each character in the string shall  take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character representing the 4 most significant bits of the TAC shall  appear first in the string, and the character representing the 4 least significant bit  of the TAC shall appear last in the string.
    #[serde(rename = "tac")]
    pub tac: String,

    /// This represents the Network Identifier, which together with a PLMN ID is used to identify an SNPN (see 3GPP TS 23.003 and 3GPP TS 23.501 clause 5.30.2.1).
    #[serde(rename = "nid")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nid: Option<String>,
}

impl Tai {
    #[allow(clippy::new_without_default)]
    pub fn new(plmn_id: models::PlmnId, tac: String) -> Tai {
        Tai {
            plmn_id,
            tac,
            nid: None,
        }
    }
}

/// Converts the Tai value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Tai {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping plmnId in query parameter serialization
            Some("tac".to_string()),
            Some(self.tac.to_string()),
            self.nid
                .as_ref()
                .map(|nid| vec!["nid".to_string(), nid.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Tai value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Tai {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub plmn_id: Vec<models::PlmnId>,
            pub tac: Vec<String>,
            pub nid: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err("Missing value while parsing Tai".to_string())
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "plmnId" => intermediate_rep.plmn_id.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "tac" => intermediate_rep.tac.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nid" => intermediate_rep.nid.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Tai".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Tai {
            plmn_id: intermediate_rep
                .plmn_id
                .into_iter()
                .next()
                .ok_or_else(|| "plmnId missing in Tai".to_string())?,
            tac: intermediate_rep
                .tac
                .into_iter()
                .next()
                .ok_or_else(|| "tac missing in Tai".to_string())?,
            nid: intermediate_rep.nid.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Tai> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Tai>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Tai>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Tai - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Tai> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Tai as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Tai - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Range of TAIs (Tracking Area Identities)
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TaiRange {
    #[serde(rename = "plmnId")]
    pub plmn_id: models::PlmnId,

    #[serde(rename = "tacRangeList")]
    pub tac_range_list: Vec<models::TacRange>,

    /// This represents the Network Identifier, which together with a PLMN ID is used to identify an SNPN (see 3GPP TS 23.003 and 3GPP TS 23.501 clause 5.30.2.1).
    #[serde(rename = "nid")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nid: Option<String>,
}

impl TaiRange {
    #[allow(clippy::new_without_default)]
    pub fn new(plmn_id: models::PlmnId, tac_range_list: Vec<models::TacRange>) -> TaiRange {
        TaiRange {
            plmn_id,
            tac_range_list,
            nid: None,
        }
    }
}

/// Converts the TaiRange value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TaiRange {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping plmnId in query parameter serialization

            // Skipping tacRangeList in query parameter serialization
            self.nid
                .as_ref()
                .map(|nid| vec!["nid".to_string(), nid.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TaiRange value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TaiRange {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub plmn_id: Vec<models::PlmnId>,
            pub tac_range_list: Vec<Vec<models::TacRange>>,
            pub nid: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TaiRange".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "plmnId" => intermediate_rep.plmn_id.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "tacRangeList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in TaiRange"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "nid" => intermediate_rep.nid.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing TaiRange".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TaiRange {
            plmn_id: intermediate_rep
                .plmn_id
                .into_iter()
                .next()
                .ok_or_else(|| "plmnId missing in TaiRange".to_string())?,
            tac_range_list: intermediate_rep
                .tac_range_list
                .into_iter()
                .next()
                .ok_or_else(|| "tacRangeList missing in TaiRange".to_string())?,
            nid: intermediate_rep.nid.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TaiRange> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TaiRange>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TaiRange>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TaiRange - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TaiRange> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TaiRange as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TaiRange - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Temporary Mobile Group Identity
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Tmgi {
    /// MBS Service ID
    #[serde(rename = "mbsServiceId")]
    pub mbs_service_id: String,

    #[serde(rename = "plmnId")]
    pub plmn_id: models::PlmnId,
}

impl Tmgi {
    #[allow(clippy::new_without_default)]
    pub fn new(mbs_service_id: String, plmn_id: models::PlmnId) -> Tmgi {
        Tmgi {
            mbs_service_id,
            plmn_id,
        }
    }
}

/// Converts the Tmgi value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Tmgi {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("mbsServiceId".to_string()),
            Some(self.mbs_service_id.to_string()),
            // Skipping plmnId in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Tmgi value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Tmgi {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub mbs_service_id: Vec<String>,
            pub plmn_id: Vec<models::PlmnId>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err("Missing value while parsing Tmgi".to_string())
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "mbsServiceId" => intermediate_rep.mbs_service_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "plmnId" => intermediate_rep.plmn_id.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Tmgi".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Tmgi {
            mbs_service_id: intermediate_rep
                .mbs_service_id
                .into_iter()
                .next()
                .ok_or_else(|| "mbsServiceId missing in Tmgi".to_string())?,
            plmn_id: intermediate_rep
                .plmn_id
                .into_iter()
                .next()
                .ok_or_else(|| "plmnId missing in Tmgi".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Tmgi> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Tmgi>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Tmgi>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Tmgi - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Tmgi> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Tmgi as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Tmgi - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Range of TMGIs
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TmgiRange {
    #[serde(rename = "mbsServiceIdStart")]
    pub mbs_service_id_start: String,

    #[serde(rename = "mbsServiceIdEnd")]
    pub mbs_service_id_end: String,

    #[serde(rename = "plmnId")]
    pub plmn_id: models::PlmnId,

    /// This represents the Network Identifier, which together with a PLMN ID is used to identify an SNPN (see 3GPP TS 23.003 and 3GPP TS 23.501 clause 5.30.2.1).
    #[serde(rename = "nid")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nid: Option<String>,
}

impl TmgiRange {
    #[allow(clippy::new_without_default)]
    pub fn new(
        mbs_service_id_start: String,
        mbs_service_id_end: String,
        plmn_id: models::PlmnId,
    ) -> TmgiRange {
        TmgiRange {
            mbs_service_id_start,
            mbs_service_id_end,
            plmn_id,
            nid: None,
        }
    }
}

/// Converts the TmgiRange value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TmgiRange {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("mbsServiceIdStart".to_string()),
            Some(self.mbs_service_id_start.to_string()),
            Some("mbsServiceIdEnd".to_string()),
            Some(self.mbs_service_id_end.to_string()),
            // Skipping plmnId in query parameter serialization
            self.nid
                .as_ref()
                .map(|nid| vec!["nid".to_string(), nid.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TmgiRange value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TmgiRange {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub mbs_service_id_start: Vec<String>,
            pub mbs_service_id_end: Vec<String>,
            pub plmn_id: Vec<models::PlmnId>,
            pub nid: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TmgiRange".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "mbsServiceIdStart" => intermediate_rep.mbs_service_id_start.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "mbsServiceIdEnd" => intermediate_rep.mbs_service_id_end.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "plmnId" => intermediate_rep.plmn_id.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nid" => intermediate_rep.nid.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing TmgiRange".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TmgiRange {
            mbs_service_id_start: intermediate_rep
                .mbs_service_id_start
                .into_iter()
                .next()
                .ok_or_else(|| "mbsServiceIdStart missing in TmgiRange".to_string())?,
            mbs_service_id_end: intermediate_rep
                .mbs_service_id_end
                .into_iter()
                .next()
                .ok_or_else(|| "mbsServiceIdEnd missing in TmgiRange".to_string())?,
            plmn_id: intermediate_rep
                .plmn_id
                .into_iter()
                .next()
                .ok_or_else(|| "plmnId missing in TmgiRange".to_string())?,
            nid: intermediate_rep.nid.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TmgiRange> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TmgiRange>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TmgiRange>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TmgiRange - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TmgiRange> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TmgiRange as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TmgiRange - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Infomation of the TNGF endpoints
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TngfInfo {
    #[serde(rename = "ipv4EndpointAddresses")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv4_endpoint_addresses: Option<Vec<models::Ipv4Addr>>,

    #[serde(rename = "ipv6EndpointAddresses")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_endpoint_addresses: Option<Vec<models::Ipv6Addr>>,

    /// Fully Qualified Domain Name
    #[serde(rename = "endpointFqdn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub endpoint_fqdn: Option<String>,
}

impl TngfInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TngfInfo {
        TngfInfo {
            ipv4_endpoint_addresses: None,
            ipv6_endpoint_addresses: None,
            endpoint_fqdn: None,
        }
    }
}

/// Converts the TngfInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TngfInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.ipv4_endpoint_addresses
                .as_ref()
                .map(|ipv4_endpoint_addresses| {
                    vec![
                        "ipv4EndpointAddresses".to_string(),
                        ipv4_endpoint_addresses
                            .iter()
                            .map(|x| x.to_string())
                            .collect::<Vec<_>>()
                            .join(","),
                    ]
                    .join(",")
                }),
            // Skipping ipv6EndpointAddresses in query parameter serialization
            self.endpoint_fqdn.as_ref().map(|endpoint_fqdn| {
                vec!["endpointFqdn".to_string(), endpoint_fqdn.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TngfInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TngfInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ipv4_endpoint_addresses: Vec<Vec<models::Ipv4Addr>>,
            pub ipv6_endpoint_addresses: Vec<Vec<models::Ipv6Addr>>,
            pub endpoint_fqdn: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TngfInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "ipv4EndpointAddresses" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in TngfInfo"
                                .to_string(),
                        )
                    }
                    "ipv6EndpointAddresses" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in TngfInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "endpointFqdn" => intermediate_rep.endpoint_fqdn.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing TngfInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TngfInfo {
            ipv4_endpoint_addresses: intermediate_rep.ipv4_endpoint_addresses.into_iter().next(),
            ipv6_endpoint_addresses: intermediate_rep.ipv6_endpoint_addresses.into_iter().next(),
            endpoint_fqdn: intermediate_rep.endpoint_fqdn.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TngfInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TngfInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TngfInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TngfInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TngfInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TngfInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TngfInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Types of transport protocol used in a given IP endpoint of an NF Service Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TransportProtocol {}

impl TransportProtocol {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TransportProtocol {
        TransportProtocol {}
    }
}

/// Converts the TransportProtocol value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TransportProtocol {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TransportProtocol value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TransportProtocol {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TransportProtocol".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing TransportProtocol".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TransportProtocol {})
    }
}

// Methods for converting between header::IntoHeaderValue<TransportProtocol> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TransportProtocol>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TransportProtocol>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TransportProtocol - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<TransportProtocol>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TransportProtocol as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TransportProtocol - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum TransportProtocolAnyOf {
    #[serde(rename = "TCP")]
    Tcp,
}

impl std::fmt::Display for TransportProtocolAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            TransportProtocolAnyOf::Tcp => write!(f, "TCP"),
        }
    }
}

impl std::str::FromStr for TransportProtocolAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "TCP" => std::result::Result::Ok(TransportProtocolAnyOf::Tcp),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Information of a trusted AF Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TrustAfInfo {
    #[serde(rename = "sNssaiInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub s_nssai_info_list: Option<Vec<models::SnssaiInfoItem>>,

    #[serde(rename = "afEvents")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub af_events: Option<Vec<models::AfEvent>>,

    #[serde(rename = "appIds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub app_ids: Option<Vec<String>>,

    #[serde(rename = "internalGroupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub internal_group_id: Option<Vec<models::GroupId>>,

    #[serde(rename = "mappingInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mapping_ind: Option<bool>,
}

impl TrustAfInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TrustAfInfo {
        TrustAfInfo {
            s_nssai_info_list: None,
            af_events: None,
            app_ids: None,
            internal_group_id: None,
            mapping_ind: Some(false),
        }
    }
}

/// Converts the TrustAfInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TrustAfInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping sNssaiInfoList in query parameter serialization

            // Skipping afEvents in query parameter serialization
            self.app_ids.as_ref().map(|app_ids| {
                vec![
                    "appIds".to_string(),
                    app_ids
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.internal_group_id.as_ref().map(|internal_group_id| {
                vec![
                    "internalGroupId".to_string(),
                    internal_group_id
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.mapping_ind.as_ref().map(|mapping_ind| {
                vec!["mappingInd".to_string(), mapping_ind.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TrustAfInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TrustAfInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub s_nssai_info_list: Vec<Vec<models::SnssaiInfoItem>>,
            pub af_events: Vec<Vec<models::AfEvent>>,
            pub app_ids: Vec<Vec<String>>,
            pub internal_group_id: Vec<Vec<models::GroupId>>,
            pub mapping_ind: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TrustAfInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "sNssaiInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in TrustAfInfo"
                                .to_string(),
                        )
                    }
                    "afEvents" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in TrustAfInfo"
                                .to_string(),
                        )
                    }
                    "appIds" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in TrustAfInfo"
                                .to_string(),
                        )
                    }
                    "internalGroupId" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in TrustAfInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "mappingInd" => intermediate_rep.mapping_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing TrustAfInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TrustAfInfo {
            s_nssai_info_list: intermediate_rep.s_nssai_info_list.into_iter().next(),
            af_events: intermediate_rep.af_events.into_iter().next(),
            app_ids: intermediate_rep.app_ids.into_iter().next(),
            internal_group_id: intermediate_rep.internal_group_id.into_iter().next(),
            mapping_ind: intermediate_rep.mapping_ind.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TrustAfInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TrustAfInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TrustAfInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TrustAfInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TrustAfInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TrustAfInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TrustAfInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Information of a TSCTSF NF Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TsctsfInfo {
    /// A map (list of key-value pairs) where a valid JSON string serves as key
    #[serde(rename = "sNssaiInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub s_nssai_info_list: Option<std::collections::HashMap<String, models::SnssaiTsctsfInfoItem>>,

    #[serde(rename = "externalGroupIdentifiersRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub external_group_identifiers_ranges: Option<Vec<models::IdentityRange>>,

    #[serde(rename = "supiRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supi_ranges: Option<Vec<models::SupiRange>>,

    #[serde(rename = "gpsiRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gpsi_ranges: Option<Vec<models::IdentityRange>>,

    #[serde(rename = "internalGroupIdentifiersRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub internal_group_identifiers_ranges: Option<Vec<models::InternalGroupIdRange>>,
}

impl TsctsfInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TsctsfInfo {
        TsctsfInfo {
            s_nssai_info_list: None,
            external_group_identifiers_ranges: None,
            supi_ranges: None,
            gpsi_ranges: None,
            internal_group_identifiers_ranges: None,
        }
    }
}

/// Converts the TsctsfInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TsctsfInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping sNssaiInfoList in query parameter serialization
            // Skipping sNssaiInfoList in query parameter serialization

            // Skipping externalGroupIdentifiersRanges in query parameter serialization

            // Skipping supiRanges in query parameter serialization

            // Skipping gpsiRanges in query parameter serialization

            // Skipping internalGroupIdentifiersRanges in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TsctsfInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TsctsfInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub s_nssai_info_list:
                Vec<std::collections::HashMap<String, models::SnssaiTsctsfInfoItem>>,
            pub external_group_identifiers_ranges: Vec<Vec<models::IdentityRange>>,
            pub supi_ranges: Vec<Vec<models::SupiRange>>,
            pub gpsi_ranges: Vec<Vec<models::IdentityRange>>,
            pub internal_group_identifiers_ranges: Vec<Vec<models::InternalGroupIdRange>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TsctsfInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "sNssaiInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in TsctsfInfo"
                                .to_string(),
                        )
                    }
                    "externalGroupIdentifiersRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in TsctsfInfo"
                                .to_string(),
                        )
                    }
                    "supiRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in TsctsfInfo"
                                .to_string(),
                        )
                    }
                    "gpsiRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in TsctsfInfo"
                                .to_string(),
                        )
                    }
                    "internalGroupIdentifiersRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in TsctsfInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing TsctsfInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TsctsfInfo {
            s_nssai_info_list: intermediate_rep.s_nssai_info_list.into_iter().next(),
            external_group_identifiers_ranges: intermediate_rep
                .external_group_identifiers_ranges
                .into_iter()
                .next(),
            supi_ranges: intermediate_rep.supi_ranges.into_iter().next(),
            gpsi_ranges: intermediate_rep.gpsi_ranges.into_iter().next(),
            internal_group_identifiers_ranges: intermediate_rep
                .internal_group_identifiers_ranges
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TsctsfInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TsctsfInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TsctsfInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TsctsfInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TsctsfInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TsctsfInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TsctsfInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Addressing information (IP addresses, FQDN) of the TWIF
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TwifInfo {
    #[serde(rename = "ipv4EndpointAddresses")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv4_endpoint_addresses: Option<Vec<models::Ipv4Addr>>,

    #[serde(rename = "ipv6EndpointAddresses")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_endpoint_addresses: Option<Vec<models::Ipv6Addr>>,

    /// Fully Qualified Domain Name
    #[serde(rename = "endpointFqdn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub endpoint_fqdn: Option<String>,
}

impl TwifInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TwifInfo {
        TwifInfo {
            ipv4_endpoint_addresses: None,
            ipv6_endpoint_addresses: None,
            endpoint_fqdn: None,
        }
    }
}

/// Converts the TwifInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TwifInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.ipv4_endpoint_addresses
                .as_ref()
                .map(|ipv4_endpoint_addresses| {
                    vec![
                        "ipv4EndpointAddresses".to_string(),
                        ipv4_endpoint_addresses
                            .iter()
                            .map(|x| x.to_string())
                            .collect::<Vec<_>>()
                            .join(","),
                    ]
                    .join(",")
                }),
            // Skipping ipv6EndpointAddresses in query parameter serialization
            self.endpoint_fqdn.as_ref().map(|endpoint_fqdn| {
                vec!["endpointFqdn".to_string(), endpoint_fqdn.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TwifInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TwifInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ipv4_endpoint_addresses: Vec<Vec<models::Ipv4Addr>>,
            pub ipv6_endpoint_addresses: Vec<Vec<models::Ipv6Addr>>,
            pub endpoint_fqdn: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TwifInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "ipv4EndpointAddresses" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in TwifInfo"
                                .to_string(),
                        )
                    }
                    "ipv6EndpointAddresses" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in TwifInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "endpointFqdn" => intermediate_rep.endpoint_fqdn.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing TwifInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TwifInfo {
            ipv4_endpoint_addresses: intermediate_rep.ipv4_endpoint_addresses.into_iter().next(),
            ipv6_endpoint_addresses: intermediate_rep.ipv6_endpoint_addresses.into_iter().next(),
            endpoint_fqdn: intermediate_rep.endpoint_fqdn.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TwifInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TwifInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TwifInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TwifInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TwifInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TwifInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TwifInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Information of an UDM NF Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UdmInfo {
    /// Identifier of a group of NFs.
    #[serde(rename = "groupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub group_id: Option<String>,

    #[serde(rename = "supiRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supi_ranges: Option<Vec<models::SupiRange>>,

    #[serde(rename = "gpsiRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gpsi_ranges: Option<Vec<models::IdentityRange>>,

    #[serde(rename = "externalGroupIdentifiersRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub external_group_identifiers_ranges: Option<Vec<models::IdentityRange>>,

    #[serde(rename = "routingIndicators")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub routing_indicators: Option<Vec<String>>,

    #[serde(rename = "internalGroupIdentifiersRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub internal_group_identifiers_ranges: Option<Vec<models::InternalGroupIdRange>>,

    #[serde(rename = "suciInfos")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suci_infos: Option<Vec<models::SuciInfo>>,
}

impl UdmInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UdmInfo {
        UdmInfo {
            group_id: None,
            supi_ranges: None,
            gpsi_ranges: None,
            external_group_identifiers_ranges: None,
            routing_indicators: None,
            internal_group_identifiers_ranges: None,
            suci_infos: None,
        }
    }
}

/// Converts the UdmInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UdmInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.group_id
                .as_ref()
                .map(|group_id| vec!["groupId".to_string(), group_id.to_string()].join(",")),
            // Skipping supiRanges in query parameter serialization

            // Skipping gpsiRanges in query parameter serialization

            // Skipping externalGroupIdentifiersRanges in query parameter serialization
            self.routing_indicators.as_ref().map(|routing_indicators| {
                vec![
                    "routingIndicators".to_string(),
                    routing_indicators
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping internalGroupIdentifiersRanges in query parameter serialization

            // Skipping suciInfos in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UdmInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UdmInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub group_id: Vec<String>,
            pub supi_ranges: Vec<Vec<models::SupiRange>>,
            pub gpsi_ranges: Vec<Vec<models::IdentityRange>>,
            pub external_group_identifiers_ranges: Vec<Vec<models::IdentityRange>>,
            pub routing_indicators: Vec<Vec<String>>,
            pub internal_group_identifiers_ranges: Vec<Vec<models::InternalGroupIdRange>>,
            pub suci_infos: Vec<Vec<models::SuciInfo>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UdmInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "groupId" => intermediate_rep.group_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "supiRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in UdmInfo"
                                .to_string(),
                        )
                    }
                    "gpsiRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in UdmInfo"
                                .to_string(),
                        )
                    }
                    "externalGroupIdentifiersRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in UdmInfo"
                                .to_string(),
                        )
                    }
                    "routingIndicators" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in UdmInfo"
                                .to_string(),
                        )
                    }
                    "internalGroupIdentifiersRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in UdmInfo"
                                .to_string(),
                        )
                    }
                    "suciInfos" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in UdmInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UdmInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UdmInfo {
            group_id: intermediate_rep.group_id.into_iter().next(),
            supi_ranges: intermediate_rep.supi_ranges.into_iter().next(),
            gpsi_ranges: intermediate_rep.gpsi_ranges.into_iter().next(),
            external_group_identifiers_ranges: intermediate_rep
                .external_group_identifiers_ranges
                .into_iter()
                .next(),
            routing_indicators: intermediate_rep.routing_indicators.into_iter().next(),
            internal_group_identifiers_ranges: intermediate_rep
                .internal_group_identifiers_ranges
                .into_iter()
                .next(),
            suci_infos: intermediate_rep.suci_infos.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UdmInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UdmInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UdmInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UdmInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UdmInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UdmInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UdmInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Information of an UDR NF Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UdrInfo {
    /// Identifier of a group of NFs.
    #[serde(rename = "groupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub group_id: Option<String>,

    #[serde(rename = "supiRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supi_ranges: Option<Vec<models::SupiRange>>,

    #[serde(rename = "gpsiRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gpsi_ranges: Option<Vec<models::IdentityRange>>,

    #[serde(rename = "externalGroupIdentifiersRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub external_group_identifiers_ranges: Option<Vec<models::IdentityRange>>,

    #[serde(rename = "supportedDataSets")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_data_sets: Option<Vec<models::DataSetId>>,

    #[serde(rename = "sharedDataIdRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shared_data_id_ranges: Option<Vec<models::SharedDataIdRange>>,
}

impl UdrInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UdrInfo {
        UdrInfo {
            group_id: None,
            supi_ranges: None,
            gpsi_ranges: None,
            external_group_identifiers_ranges: None,
            supported_data_sets: None,
            shared_data_id_ranges: None,
        }
    }
}

/// Converts the UdrInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UdrInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.group_id
                .as_ref()
                .map(|group_id| vec!["groupId".to_string(), group_id.to_string()].join(",")),
            // Skipping supiRanges in query parameter serialization

            // Skipping gpsiRanges in query parameter serialization

            // Skipping externalGroupIdentifiersRanges in query parameter serialization

            // Skipping supportedDataSets in query parameter serialization

            // Skipping sharedDataIdRanges in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UdrInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UdrInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub group_id: Vec<String>,
            pub supi_ranges: Vec<Vec<models::SupiRange>>,
            pub gpsi_ranges: Vec<Vec<models::IdentityRange>>,
            pub external_group_identifiers_ranges: Vec<Vec<models::IdentityRange>>,
            pub supported_data_sets: Vec<Vec<models::DataSetId>>,
            pub shared_data_id_ranges: Vec<Vec<models::SharedDataIdRange>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UdrInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "groupId" => intermediate_rep.group_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "supiRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in UdrInfo"
                                .to_string(),
                        )
                    }
                    "gpsiRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in UdrInfo"
                                .to_string(),
                        )
                    }
                    "externalGroupIdentifiersRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in UdrInfo"
                                .to_string(),
                        )
                    }
                    "supportedDataSets" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in UdrInfo"
                                .to_string(),
                        )
                    }
                    "sharedDataIdRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in UdrInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UdrInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UdrInfo {
            group_id: intermediate_rep.group_id.into_iter().next(),
            supi_ranges: intermediate_rep.supi_ranges.into_iter().next(),
            gpsi_ranges: intermediate_rep.gpsi_ranges.into_iter().next(),
            external_group_identifiers_ranges: intermediate_rep
                .external_group_identifiers_ranges
                .into_iter()
                .next(),
            supported_data_sets: intermediate_rep.supported_data_sets.into_iter().next(),
            shared_data_id_ranges: intermediate_rep.shared_data_id_ranges.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UdrInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UdrInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UdrInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UdrInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UdrInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UdrInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UdrInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Information related to UDSF
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UdsfInfo {
    /// Identifier of a group of NFs.
    #[serde(rename = "groupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub group_id: Option<String>,

    #[serde(rename = "supiRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supi_ranges: Option<Vec<models::SupiRange>>,

    /// A map (list of key-value pairs) where realmId serves as key and each value in the map is an array of IdentityRanges. Each IdentityRange is a range of storageIds.
    #[serde(rename = "storageIdRanges")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub storage_id_ranges: Option<std::collections::HashMap<String, Vec<models::IdentityRange>>>,
}

impl UdsfInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UdsfInfo {
        UdsfInfo {
            group_id: None,
            supi_ranges: None,
            storage_id_ranges: None,
        }
    }
}

/// Converts the UdsfInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UdsfInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.group_id
                .as_ref()
                .map(|group_id| vec!["groupId".to_string(), group_id.to_string()].join(",")),
            // Skipping supiRanges in query parameter serialization

            // Skipping storageIdRanges in query parameter serialization
            // Skipping storageIdRanges in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UdsfInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UdsfInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub group_id: Vec<String>,
            pub supi_ranges: Vec<Vec<models::SupiRange>>,
            pub storage_id_ranges:
                Vec<std::collections::HashMap<String, Vec<models::IdentityRange>>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UdsfInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "groupId" => intermediate_rep.group_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "supiRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in UdsfInfo"
                                .to_string(),
                        )
                    }
                    "storageIdRanges" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in UdsfInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UdsfInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UdsfInfo {
            group_id: intermediate_rep.group_id.into_iter().next(),
            supi_ranges: intermediate_rep.supi_ranges.into_iter().next(),
            storage_id_ranges: intermediate_rep.storage_id_ranges.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UdsfInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UdsfInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UdsfInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UdsfInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UdsfInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UdsfInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UdsfInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Integer where the allowed values correspond to the value range of an unsigned 16-bit integer.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Uint16(i32);

impl std::convert::From<i32> for Uint16 {
    fn from(x: i32) -> Self {
        Uint16(x)
    }
}

impl std::convert::From<Uint16> for i32 {
    fn from(x: Uint16) -> Self {
        x.0
    }
}

impl std::ops::Deref for Uint16 {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for Uint16 {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// Integer where the allowed values correspond to the value range of an unsigned 32-bit integer.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Uint32(i32);

impl std::convert::From<i32> for Uint32 {
    fn from(x: i32) -> Self {
        Uint32(x)
    }
}

impl std::convert::From<Uint32> for i32 {
    fn from(x: Uint32) -> Self {
        x.0
    }
}

impl std::ops::Deref for Uint32 {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for Uint32 {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// Information of a untrusted AF Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UnTrustAfInfo {
    #[serde(rename = "afId")]
    pub af_id: String,

    #[serde(rename = "sNssaiInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub s_nssai_info_list: Option<Vec<models::SnssaiInfoItem>>,

    #[serde(rename = "mappingInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mapping_ind: Option<bool>,
}

impl UnTrustAfInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(af_id: String) -> UnTrustAfInfo {
        UnTrustAfInfo {
            af_id,
            s_nssai_info_list: None,
            mapping_ind: Some(false),
        }
    }
}

/// Converts the UnTrustAfInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UnTrustAfInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("afId".to_string()),
            Some(self.af_id.to_string()),
            // Skipping sNssaiInfoList in query parameter serialization
            self.mapping_ind.as_ref().map(|mapping_ind| {
                vec!["mappingInd".to_string(), mapping_ind.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UnTrustAfInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UnTrustAfInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub af_id: Vec<String>,
            pub s_nssai_info_list: Vec<Vec<models::SnssaiInfoItem>>,
            pub mapping_ind: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UnTrustAfInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "afId" => intermediate_rep.af_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "sNssaiInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in UnTrustAfInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "mappingInd" => intermediate_rep.mapping_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UnTrustAfInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UnTrustAfInfo {
            af_id: intermediate_rep
                .af_id
                .into_iter()
                .next()
                .ok_or_else(|| "afId missing in UnTrustAfInfo".to_string())?,
            s_nssai_info_list: intermediate_rep.s_nssai_info_list.into_iter().next(),
            mapping_ind: intermediate_rep.mapping_ind.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UnTrustAfInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UnTrustAfInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UnTrustAfInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UnTrustAfInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UnTrustAfInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UnTrustAfInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UnTrustAfInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Types of User-Plane interfaces of the UPF
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpInterfaceType {}

impl UpInterfaceType {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpInterfaceType {
        UpInterfaceType {}
    }
}

/// Converts the UpInterfaceType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpInterfaceType {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpInterfaceType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpInterfaceType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UpInterfaceType".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UpInterfaceType".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpInterfaceType {})
    }
}

// Methods for converting between header::IntoHeaderValue<UpInterfaceType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpInterfaceType>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UpInterfaceType>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UpInterfaceType - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<UpInterfaceType>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UpInterfaceType as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UpInterfaceType - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum UpInterfaceTypeAnyOf {
    #[serde(rename = "N3")]
    N3,
    #[serde(rename = "N6")]
    N6,
    #[serde(rename = "N9")]
    N9,
    #[serde(rename = "DATA_FORWARDING")]
    DataForwarding,
    #[serde(rename = "N3MB")]
    N3Mb,
    #[serde(rename = "N6MB")]
    N6Mb,
    #[serde(rename = "N19MB")]
    N19Mb,
    #[serde(rename = "NMB9")]
    Nmb9,
}

impl std::fmt::Display for UpInterfaceTypeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            UpInterfaceTypeAnyOf::N3 => write!(f, "N3"),
            UpInterfaceTypeAnyOf::N6 => write!(f, "N6"),
            UpInterfaceTypeAnyOf::N9 => write!(f, "N9"),
            UpInterfaceTypeAnyOf::DataForwarding => write!(f, "DATA_FORWARDING"),
            UpInterfaceTypeAnyOf::N3Mb => write!(f, "N3MB"),
            UpInterfaceTypeAnyOf::N6Mb => write!(f, "N6MB"),
            UpInterfaceTypeAnyOf::N19Mb => write!(f, "N19MB"),
            UpInterfaceTypeAnyOf::Nmb9 => write!(f, "NMB9"),
        }
    }
}

impl std::str::FromStr for UpInterfaceTypeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "N3" => std::result::Result::Ok(UpInterfaceTypeAnyOf::N3),
            "N6" => std::result::Result::Ok(UpInterfaceTypeAnyOf::N6),
            "N9" => std::result::Result::Ok(UpInterfaceTypeAnyOf::N9),
            "DATA_FORWARDING" => std::result::Result::Ok(UpInterfaceTypeAnyOf::DataForwarding),
            "N3MB" => std::result::Result::Ok(UpInterfaceTypeAnyOf::N3Mb),
            "N6MB" => std::result::Result::Ok(UpInterfaceTypeAnyOf::N6Mb),
            "N19MB" => std::result::Result::Ok(UpInterfaceTypeAnyOf::N19Mb),
            "NMB9" => std::result::Result::Ok(UpInterfaceTypeAnyOf::Nmb9),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Information of an UPF NF Instance
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpfInfo {
    #[serde(rename = "sNssaiUpfInfoList")]
    pub s_nssai_upf_info_list: Vec<models::SnssaiUpfInfoItem>,

    #[serde(rename = "smfServingArea")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub smf_serving_area: Option<Vec<String>>,

    #[serde(rename = "interfaceUpfInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub interface_upf_info_list: Option<Vec<models::InterfaceUpfInfoItem>>,

    #[serde(rename = "iwkEpsInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub iwk_eps_ind: Option<bool>,

    #[serde(rename = "pduSessionTypes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pdu_session_types: Option<Vec<models::PduSessionType>>,

    #[serde(rename = "atsssCapability")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub atsss_capability: Option<models::AtsssCapability>,

    #[serde(rename = "ueIpAddrInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_ip_addr_ind: Option<bool>,

    #[serde(rename = "taiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tai_list: Option<Vec<models::Tai>>,

    #[serde(rename = "taiRangeList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tai_range_list: Option<Vec<models::TaiRange>>,

    #[serde(rename = "wAgfInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub w_agf_info: Option<models::WAgfInfo>,

    #[serde(rename = "tngfInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tngf_info: Option<models::TngfInfo>,

    #[serde(rename = "twifInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub twif_info: Option<models::TwifInfo>,

    #[serde(rename = "priority")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority: Option<u16>,

    #[serde(rename = "redundantGtpu")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub redundant_gtpu: Option<bool>,

    #[serde(rename = "ipups")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipups: Option<bool>,

    #[serde(rename = "dataForwarding")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data_forwarding: Option<bool>,

    #[serde(rename = "supportedPfcpFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_pfcp_features: Option<String>,
}

impl UpfInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(s_nssai_upf_info_list: Vec<models::SnssaiUpfInfoItem>) -> UpfInfo {
        UpfInfo {
            s_nssai_upf_info_list,
            smf_serving_area: None,
            interface_upf_info_list: None,
            iwk_eps_ind: Some(false),
            pdu_session_types: None,
            atsss_capability: None,
            ue_ip_addr_ind: Some(false),
            tai_list: None,
            tai_range_list: None,
            w_agf_info: None,
            tngf_info: None,
            twif_info: None,
            priority: None,
            redundant_gtpu: Some(false),
            ipups: Some(false),
            data_forwarding: Some(false),
            supported_pfcp_features: None,
        }
    }
}

/// Converts the UpfInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpfInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping sNssaiUpfInfoList in query parameter serialization
            self.smf_serving_area.as_ref().map(|smf_serving_area| {
                vec![
                    "smfServingArea".to_string(),
                    smf_serving_area
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping interfaceUpfInfoList in query parameter serialization
            self.iwk_eps_ind.as_ref().map(|iwk_eps_ind| {
                vec!["iwkEpsInd".to_string(), iwk_eps_ind.to_string()].join(",")
            }),
            // Skipping pduSessionTypes in query parameter serialization

            // Skipping atsssCapability in query parameter serialization
            self.ue_ip_addr_ind.as_ref().map(|ue_ip_addr_ind| {
                vec!["ueIpAddrInd".to_string(), ue_ip_addr_ind.to_string()].join(",")
            }),
            // Skipping taiList in query parameter serialization

            // Skipping taiRangeList in query parameter serialization

            // Skipping wAgfInfo in query parameter serialization

            // Skipping tngfInfo in query parameter serialization

            // Skipping twifInfo in query parameter serialization
            self.priority
                .as_ref()
                .map(|priority| vec!["priority".to_string(), priority.to_string()].join(",")),
            self.redundant_gtpu.as_ref().map(|redundant_gtpu| {
                vec!["redundantGtpu".to_string(), redundant_gtpu.to_string()].join(",")
            }),
            self.ipups
                .as_ref()
                .map(|ipups| vec!["ipups".to_string(), ipups.to_string()].join(",")),
            self.data_forwarding.as_ref().map(|data_forwarding| {
                vec!["dataForwarding".to_string(), data_forwarding.to_string()].join(",")
            }),
            self.supported_pfcp_features
                .as_ref()
                .map(|supported_pfcp_features| {
                    vec![
                        "supportedPfcpFeatures".to_string(),
                        supported_pfcp_features.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpfInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpfInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub s_nssai_upf_info_list: Vec<Vec<models::SnssaiUpfInfoItem>>,
            pub smf_serving_area: Vec<Vec<String>>,
            pub interface_upf_info_list: Vec<Vec<models::InterfaceUpfInfoItem>>,
            pub iwk_eps_ind: Vec<bool>,
            pub pdu_session_types: Vec<Vec<models::PduSessionType>>,
            pub atsss_capability: Vec<models::AtsssCapability>,
            pub ue_ip_addr_ind: Vec<bool>,
            pub tai_list: Vec<Vec<models::Tai>>,
            pub tai_range_list: Vec<Vec<models::TaiRange>>,
            pub w_agf_info: Vec<models::WAgfInfo>,
            pub tngf_info: Vec<models::TngfInfo>,
            pub twif_info: Vec<models::TwifInfo>,
            pub priority: Vec<u16>,
            pub redundant_gtpu: Vec<bool>,
            pub ipups: Vec<bool>,
            pub data_forwarding: Vec<bool>,
            pub supported_pfcp_features: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UpfInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "sNssaiUpfInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in UpfInfo"
                                .to_string(),
                        )
                    }
                    "smfServingArea" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in UpfInfo"
                                .to_string(),
                        )
                    }
                    "interfaceUpfInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in UpfInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "iwkEpsInd" => intermediate_rep.iwk_eps_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "pduSessionTypes" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in UpfInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "atsssCapability" => intermediate_rep.atsss_capability.push(
                        <models::AtsssCapability as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ueIpAddrInd" => intermediate_rep.ue_ip_addr_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "taiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in UpfInfo"
                                .to_string(),
                        )
                    }
                    "taiRangeList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in UpfInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "wAgfInfo" => intermediate_rep.w_agf_info.push(
                        <models::WAgfInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "tngfInfo" => intermediate_rep.tngf_info.push(
                        <models::TngfInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "twifInfo" => intermediate_rep.twif_info.push(
                        <models::TwifInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "priority" => intermediate_rep.priority.push(
                        <u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "redundantGtpu" => intermediate_rep.redundant_gtpu.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ipups" => intermediate_rep.ipups.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "dataForwarding" => intermediate_rep.data_forwarding.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "supportedPfcpFeatures" => intermediate_rep.supported_pfcp_features.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UpfInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpfInfo {
            s_nssai_upf_info_list: intermediate_rep
                .s_nssai_upf_info_list
                .into_iter()
                .next()
                .ok_or_else(|| "sNssaiUpfInfoList missing in UpfInfo".to_string())?,
            smf_serving_area: intermediate_rep.smf_serving_area.into_iter().next(),
            interface_upf_info_list: intermediate_rep.interface_upf_info_list.into_iter().next(),
            iwk_eps_ind: intermediate_rep.iwk_eps_ind.into_iter().next(),
            pdu_session_types: intermediate_rep.pdu_session_types.into_iter().next(),
            atsss_capability: intermediate_rep.atsss_capability.into_iter().next(),
            ue_ip_addr_ind: intermediate_rep.ue_ip_addr_ind.into_iter().next(),
            tai_list: intermediate_rep.tai_list.into_iter().next(),
            tai_range_list: intermediate_rep.tai_range_list.into_iter().next(),
            w_agf_info: intermediate_rep.w_agf_info.into_iter().next(),
            tngf_info: intermediate_rep.tngf_info.into_iter().next(),
            twif_info: intermediate_rep.twif_info.into_iter().next(),
            priority: intermediate_rep.priority.into_iter().next(),
            redundant_gtpu: intermediate_rep.redundant_gtpu.into_iter().next(),
            ipups: intermediate_rep.ipups.into_iter().next(),
            data_forwarding: intermediate_rep.data_forwarding.into_iter().next(),
            supported_pfcp_features: intermediate_rep.supported_pfcp_features.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpfInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpfInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UpfInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UpfInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpfInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UpfInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UpfInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// String providing an URI formatted according to RFC 3986.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Uri(String);

impl std::convert::From<String> for Uri {
    fn from(x: String) -> Self {
        Uri(x)
    }
}

impl std::string::ToString for Uri {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Uri {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Uri(x.to_string()))
    }
}

impl std::convert::From<Uri> for String {
    fn from(x: Uri) -> Self {
        x.0
    }
}

impl std::ops::Deref for Uri {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Uri {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// HTTP and HTTPS URI scheme.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UriScheme(String);

impl UriScheme {
    #[allow(clippy::new_without_default)]
    pub fn new(s: String) -> UriScheme {
        UriScheme(s)
    }
}

/// Converts the UriScheme value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UriScheme {
    fn to_string(&self) -> String {
        self.0.clone()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UriScheme value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UriScheme {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(UriScheme(s.to_string()))
    }
}

// Methods for converting between header::IntoHeaderValue<UriScheme> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UriScheme>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UriScheme>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UriScheme - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UriScheme> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UriScheme as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UriScheme - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum UriSchemeAnyOf {
    #[serde(rename = "http")]
    Http,
    #[serde(rename = "https")]
    Https,
}

impl std::fmt::Display for UriSchemeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            UriSchemeAnyOf::Http => write!(f, "http"),
            UriSchemeAnyOf::Https => write!(f, "https"),
        }
    }
}

impl std::str::FromStr for UriSchemeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "http" => std::result::Result::Ok(UriSchemeAnyOf::Http),
            "https" => std::result::Result::Ok(UriSchemeAnyOf::Https),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Indicate the supported V2X Capability by the PCF.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct V2xCapability {
    #[serde(rename = "lteV2x")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lte_v2x: Option<bool>,

    #[serde(rename = "nrV2x")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nr_v2x: Option<bool>,
}

impl V2xCapability {
    #[allow(clippy::new_without_default)]
    pub fn new() -> V2xCapability {
        V2xCapability {
            lte_v2x: Some(false),
            nr_v2x: Some(false),
        }
    }
}

/// Converts the V2xCapability value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for V2xCapability {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.lte_v2x
                .as_ref()
                .map(|lte_v2x| vec!["lteV2x".to_string(), lte_v2x.to_string()].join(",")),
            self.nr_v2x
                .as_ref()
                .map(|nr_v2x| vec!["nrV2x".to_string(), nr_v2x.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a V2xCapability value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for V2xCapability {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub lte_v2x: Vec<bool>,
            pub nr_v2x: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing V2xCapability".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "lteV2x" => intermediate_rep.lte_v2x.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nrV2x" => intermediate_rep.nr_v2x.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing V2xCapability".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(V2xCapability {
            lte_v2x: intermediate_rep.lte_v2x.into_iter().next(),
            nr_v2x: intermediate_rep.nr_v2x.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<V2xCapability> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<V2xCapability>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<V2xCapability>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for V2xCapability - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<V2xCapability> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <V2xCapability as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into V2xCapability - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Vendor ID of the NF Service instance (Private Enterprise Number assigned by IANA)
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VendorId(String);

impl std::convert::From<String> for VendorId {
    fn from(x: String) -> Self {
        VendorId(x)
    }
}

impl std::string::ToString for VendorId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for VendorId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(VendorId(x.to_string()))
    }
}

impl std::convert::From<VendorId> for String {
    fn from(x: VendorId) -> Self {
        x.0
    }
}

impl std::ops::Deref for VendorId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for VendorId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Information about a vendor-specific feature
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VendorSpecificFeature {
    #[serde(rename = "featureName")]
    pub feature_name: String,

    #[serde(rename = "featureVersion")]
    pub feature_version: String,
}

impl VendorSpecificFeature {
    #[allow(clippy::new_without_default)]
    pub fn new(feature_name: String, feature_version: String) -> VendorSpecificFeature {
        VendorSpecificFeature {
            feature_name,
            feature_version,
        }
    }
}

/// Converts the VendorSpecificFeature value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for VendorSpecificFeature {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("featureName".to_string()),
            Some(self.feature_name.to_string()),
            Some("featureVersion".to_string()),
            Some(self.feature_version.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VendorSpecificFeature value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VendorSpecificFeature {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub feature_name: Vec<String>,
            pub feature_version: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing VendorSpecificFeature".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "featureName" => intermediate_rep.feature_name.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "featureVersion" => intermediate_rep.feature_version.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing VendorSpecificFeature".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VendorSpecificFeature {
            feature_name: intermediate_rep
                .feature_name
                .into_iter()
                .next()
                .ok_or_else(|| "featureName missing in VendorSpecificFeature".to_string())?,
            feature_version: intermediate_rep
                .feature_version
                .into_iter()
                .next()
                .ok_or_else(|| "featureVersion missing in VendorSpecificFeature".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VendorSpecificFeature> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<VendorSpecificFeature>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<VendorSpecificFeature>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for VendorSpecificFeature - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<VendorSpecificFeature>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <VendorSpecificFeature as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into VendorSpecificFeature - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Information of the W-AGF end-points
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct WAgfInfo {
    #[serde(rename = "ipv4EndpointAddresses")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv4_endpoint_addresses: Option<Vec<models::Ipv4Addr>>,

    #[serde(rename = "ipv6EndpointAddresses")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_endpoint_addresses: Option<Vec<models::Ipv6Addr>>,

    /// Fully Qualified Domain Name
    #[serde(rename = "endpointFqdn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub endpoint_fqdn: Option<String>,
}

impl WAgfInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> WAgfInfo {
        WAgfInfo {
            ipv4_endpoint_addresses: None,
            ipv6_endpoint_addresses: None,
            endpoint_fqdn: None,
        }
    }
}

/// Converts the WAgfInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for WAgfInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.ipv4_endpoint_addresses
                .as_ref()
                .map(|ipv4_endpoint_addresses| {
                    vec![
                        "ipv4EndpointAddresses".to_string(),
                        ipv4_endpoint_addresses
                            .iter()
                            .map(|x| x.to_string())
                            .collect::<Vec<_>>()
                            .join(","),
                    ]
                    .join(",")
                }),
            // Skipping ipv6EndpointAddresses in query parameter serialization
            self.endpoint_fqdn.as_ref().map(|endpoint_fqdn| {
                vec!["endpointFqdn".to_string(), endpoint_fqdn.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a WAgfInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for WAgfInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ipv4_endpoint_addresses: Vec<Vec<models::Ipv4Addr>>,
            pub ipv6_endpoint_addresses: Vec<Vec<models::Ipv6Addr>>,
            pub endpoint_fqdn: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing WAgfInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "ipv4EndpointAddresses" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in WAgfInfo"
                                .to_string(),
                        )
                    }
                    "ipv6EndpointAddresses" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in WAgfInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "endpointFqdn" => intermediate_rep.endpoint_fqdn.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing WAgfInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(WAgfInfo {
            ipv4_endpoint_addresses: intermediate_rep.ipv4_endpoint_addresses.into_iter().next(),
            ipv6_endpoint_addresses: intermediate_rep.ipv6_endpoint_addresses.into_iter().next(),
            endpoint_fqdn: intermediate_rep.endpoint_fqdn.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<WAgfInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<WAgfInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<WAgfInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for WAgfInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<WAgfInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <WAgfInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into WAgfInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Wildcard DNAI
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct WildcardDnai(String);

impl std::convert::From<String> for WildcardDnai {
    fn from(x: String) -> Self {
        WildcardDnai(x)
    }
}

impl std::string::ToString for WildcardDnai {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for WildcardDnai {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(WildcardDnai(x.to_string()))
    }
}

impl std::convert::From<WildcardDnai> for String {
    fn from(x: WildcardDnai) -> Self {
        x.0
    }
}

impl std::ops::Deref for WildcardDnai {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for WildcardDnai {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// String representing the Wildcard DNN. It shall contain the string \"*\".
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct WildcardDnn(String);

impl std::convert::From<String> for WildcardDnn {
    fn from(x: String) -> Self {
        WildcardDnn(x)
    }
}

impl std::string::ToString for WildcardDnn {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for WildcardDnn {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(WildcardDnn(x.to_string()))
    }
}

impl std::convert::From<WildcardDnn> for String {
    fn from(x: WildcardDnn) -> Self {
        x.0
    }
}

impl std::ops::Deref for WildcardDnn {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for WildcardDnn {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}
