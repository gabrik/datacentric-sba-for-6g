#![allow(unused_qualifications)]

use std::str::FromStr;

#[cfg(any(feature = "client", feature = "server"))]
use crate::header;
use crate::models;

/// Error returned in the access token response message
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AccessTokenErr {
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "error")]
    pub error: String,

    #[serde(rename = "error_description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_description: Option<String>,

    #[serde(rename = "error_uri")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_uri: Option<String>,
}

impl AccessTokenErr {
    #[allow(clippy::new_without_default)]
    pub fn new(error: String) -> AccessTokenErr {
        AccessTokenErr {
            error,
            error_description: None,
            error_uri: None,
        }
    }
}

/// Converts the AccessTokenErr value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AccessTokenErr {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("error".to_string()),
            Some(self.error.to_string()),
            self.error_description.as_ref().map(|error_description| {
                vec![
                    "error_description".to_string(),
                    error_description.to_string(),
                ]
                .join(",")
            }),
            self.error_uri
                .as_ref()
                .map(|error_uri| vec!["error_uri".to_string(), error_uri.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AccessTokenErr value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AccessTokenErr {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub error: Vec<String>,
            pub error_description: Vec<String>,
            pub error_uri: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AccessTokenErr".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "error" => intermediate_rep.error.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "error_description" => intermediate_rep.error_description.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "error_uri" => intermediate_rep.error_uri.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AccessTokenErr".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AccessTokenErr {
            error: intermediate_rep
                .error
                .into_iter()
                .next()
                .ok_or_else(|| "error missing in AccessTokenErr".to_string())?,
            error_description: intermediate_rep.error_description.into_iter().next(),
            error_uri: intermediate_rep.error_uri.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AccessTokenErr> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AccessTokenErr>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AccessTokenErr>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AccessTokenErr - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AccessTokenErr> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AccessTokenErr as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AccessTokenErr - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains information related to the access token request
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AccessTokenReq {
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "grant_type")]
    pub grant_type: String,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "nfInstanceId")]
    pub nf_instance_id: uuid::Uuid,

    #[serde(rename = "nfType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nf_type: Option<models::NfType>,

    #[serde(rename = "targetNfType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_nf_type: Option<models::NfType>,

    #[serde(rename = "scope")]
    pub scope: String,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "targetNfInstanceId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_nf_instance_id: Option<uuid::Uuid>,

    #[serde(rename = "requesterPlmn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requester_plmn: Option<models::PlmnId>,

    #[serde(rename = "requesterPlmnList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requester_plmn_list: Option<Vec<models::PlmnId>>,

    #[serde(rename = "requesterSnssaiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requester_snssai_list: Option<Vec<models::Snssai>>,

    /// Fully Qualified Domain Name
    #[serde(rename = "requesterFqdn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requester_fqdn: Option<String>,

    #[serde(rename = "requesterSnpnList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requester_snpn_list: Option<Vec<models::PlmnIdNid>>,

    #[serde(rename = "targetPlmn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_plmn: Option<models::PlmnId>,

    #[serde(rename = "targetSnpn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_snpn: Option<models::PlmnIdNid>,

    #[serde(rename = "targetSnssaiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_snssai_list: Option<Vec<models::Snssai>>,

    #[serde(rename = "targetNsiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_nsi_list: Option<Vec<String>>,

    /// NF Set Identifier (see clause 28.12 of 3GPP TS 23.003), formatted as the following string \"set<Set ID>.<nftype>set.5gc.mnc<MNC>.mcc<MCC>\", or  \"set<SetID>.<NFType>set.5gc.nid<NID>.mnc<MNC>.mcc<MCC>\" with  <MCC> encoded as defined in clause 5.4.2 (\"Mcc\" data type definition)  <MNC> encoding the Mobile Network Code part of the PLMN, comprising 3 digits.    If there are only 2 significant digits in the MNC, one \"0\" digit shall be inserted    at the left side to fill the 3 digits coding of MNC.  Pattern: '^[0-9]{3}$' <NFType> encoded as a value defined in Table 6.1.6.3.3-1 of 3GPP TS 29.510 but    with lower case characters <Set ID> encoded as a string of characters consisting of    alphabetic characters (A-Z and a-z), digits (0-9) and/or the hyphen (-) and that    shall end with either an alphabetic character or a digit.
    #[serde(rename = "targetNfSetId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_nf_set_id: Option<String>,

    /// NF Service Set Identifier (see clause 28.12 of 3GPP TS 23.003) formatted as the following  string \"set<Set ID>.sn<Service Name>.nfi<NF Instance ID>.5gc.mnc<MNC>.mcc<MCC>\", or  \"set<SetID>.sn<ServiceName>.nfi<NFInstanceID>.5gc.nid<NID>.mnc<MNC>.mcc<MCC>\" with  <MCC> encoded as defined in clause 5.4.2 (\"Mcc\" data type definition)   <MNC> encoding the Mobile Network Code part of the PLMN, comprising 3 digits.    If there are only 2 significant digits in the MNC, one \"0\" digit shall be inserted    at the left side to fill the 3 digits coding of MNC.  Pattern: '^[0-9]{3}$' <NID> encoded as defined in clause 5.4.2 (\"Nid\" data type definition)  <NFInstanceId> encoded as defined in clause 5.3.2  <ServiceName> encoded as defined in 3GPP TS 29.510  <Set ID> encoded as a string of characters consisting of alphabetic    characters (A-Z and a-z), digits (0-9) and/or the hyphen (-) and that shall end    with either an alphabetic character or a digit.
    #[serde(rename = "targetNfServiceSetId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_nf_service_set_id: Option<String>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "hnrfAccessTokenUri")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hnrf_access_token_uri: Option<String>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "sourceNfInstanceId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source_nf_instance_id: Option<uuid::Uuid>,
}

impl AccessTokenReq {
    #[allow(clippy::new_without_default)]
    pub fn new(grant_type: String, nf_instance_id: uuid::Uuid, scope: String) -> AccessTokenReq {
        AccessTokenReq {
            grant_type,
            nf_instance_id,
            nf_type: None,
            target_nf_type: None,
            scope,
            target_nf_instance_id: None,
            requester_plmn: None,
            requester_plmn_list: None,
            requester_snssai_list: None,
            requester_fqdn: None,
            requester_snpn_list: None,
            target_plmn: None,
            target_snpn: None,
            target_snssai_list: None,
            target_nsi_list: None,
            target_nf_set_id: None,
            target_nf_service_set_id: None,
            hnrf_access_token_uri: None,
            source_nf_instance_id: None,
        }
    }
}

/// Converts the AccessTokenReq value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AccessTokenReq {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("grant_type".to_string()),
            Some(self.grant_type.to_string()),
            // Skipping nfInstanceId in query parameter serialization

            // Skipping nfType in query parameter serialization

            // Skipping targetNfType in query parameter serialization
            Some("scope".to_string()),
            Some(self.scope.to_string()),
            // Skipping targetNfInstanceId in query parameter serialization

            // Skipping requesterPlmn in query parameter serialization

            // Skipping requesterPlmnList in query parameter serialization

            // Skipping requesterSnssaiList in query parameter serialization
            self.requester_fqdn.as_ref().map(|requester_fqdn| {
                vec!["requesterFqdn".to_string(), requester_fqdn.to_string()].join(",")
            }),
            // Skipping requesterSnpnList in query parameter serialization

            // Skipping targetPlmn in query parameter serialization

            // Skipping targetSnpn in query parameter serialization

            // Skipping targetSnssaiList in query parameter serialization
            self.target_nsi_list.as_ref().map(|target_nsi_list| {
                vec![
                    "targetNsiList".to_string(),
                    target_nsi_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.target_nf_set_id.as_ref().map(|target_nf_set_id| {
                vec!["targetNfSetId".to_string(), target_nf_set_id.to_string()].join(",")
            }),
            self.target_nf_service_set_id
                .as_ref()
                .map(|target_nf_service_set_id| {
                    vec![
                        "targetNfServiceSetId".to_string(),
                        target_nf_service_set_id.to_string(),
                    ]
                    .join(",")
                }),
            self.hnrf_access_token_uri
                .as_ref()
                .map(|hnrf_access_token_uri| {
                    vec![
                        "hnrfAccessTokenUri".to_string(),
                        hnrf_access_token_uri.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping sourceNfInstanceId in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AccessTokenReq value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AccessTokenReq {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub grant_type: Vec<String>,
            pub nf_instance_id: Vec<uuid::Uuid>,
            pub nf_type: Vec<models::NfType>,
            pub target_nf_type: Vec<models::NfType>,
            pub scope: Vec<String>,
            pub target_nf_instance_id: Vec<uuid::Uuid>,
            pub requester_plmn: Vec<models::PlmnId>,
            pub requester_plmn_list: Vec<Vec<models::PlmnId>>,
            pub requester_snssai_list: Vec<Vec<models::Snssai>>,
            pub requester_fqdn: Vec<String>,
            pub requester_snpn_list: Vec<Vec<models::PlmnIdNid>>,
            pub target_plmn: Vec<models::PlmnId>,
            pub target_snpn: Vec<models::PlmnIdNid>,
            pub target_snssai_list: Vec<Vec<models::Snssai>>,
            pub target_nsi_list: Vec<Vec<String>>,
            pub target_nf_set_id: Vec<String>,
            pub target_nf_service_set_id: Vec<String>,
            pub hnrf_access_token_uri: Vec<String>,
            pub source_nf_instance_id: Vec<uuid::Uuid>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AccessTokenReq".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "grant_type" => intermediate_rep.grant_type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nfInstanceId" => intermediate_rep.nf_instance_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nfType" => intermediate_rep.nf_type.push(
                        <models::NfType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "targetNfType" => intermediate_rep.target_nf_type.push(
                        <models::NfType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "scope" => intermediate_rep.scope.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "targetNfInstanceId" => intermediate_rep.target_nf_instance_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "requesterPlmn" => intermediate_rep.requester_plmn.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "requesterPlmnList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AccessTokenReq"
                                .to_string(),
                        )
                    }
                    "requesterSnssaiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AccessTokenReq"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "requesterFqdn" => intermediate_rep.requester_fqdn.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "requesterSnpnList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AccessTokenReq"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "targetPlmn" => intermediate_rep.target_plmn.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "targetSnpn" => intermediate_rep.target_snpn.push(
                        <models::PlmnIdNid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "targetSnssaiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AccessTokenReq"
                                .to_string(),
                        )
                    }
                    "targetNsiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AccessTokenReq"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "targetNfSetId" => intermediate_rep.target_nf_set_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "targetNfServiceSetId" => intermediate_rep.target_nf_service_set_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "hnrfAccessTokenUri" => intermediate_rep.hnrf_access_token_uri.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "sourceNfInstanceId" => intermediate_rep.source_nf_instance_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AccessTokenReq".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AccessTokenReq {
            grant_type: intermediate_rep
                .grant_type
                .into_iter()
                .next()
                .ok_or_else(|| "grant_type missing in AccessTokenReq".to_string())?,
            nf_instance_id: intermediate_rep
                .nf_instance_id
                .into_iter()
                .next()
                .ok_or_else(|| "nfInstanceId missing in AccessTokenReq".to_string())?,
            nf_type: intermediate_rep.nf_type.into_iter().next(),
            target_nf_type: intermediate_rep.target_nf_type.into_iter().next(),
            scope: intermediate_rep
                .scope
                .into_iter()
                .next()
                .ok_or_else(|| "scope missing in AccessTokenReq".to_string())?,
            target_nf_instance_id: intermediate_rep.target_nf_instance_id.into_iter().next(),
            requester_plmn: intermediate_rep.requester_plmn.into_iter().next(),
            requester_plmn_list: intermediate_rep.requester_plmn_list.into_iter().next(),
            requester_snssai_list: intermediate_rep.requester_snssai_list.into_iter().next(),
            requester_fqdn: intermediate_rep.requester_fqdn.into_iter().next(),
            requester_snpn_list: intermediate_rep.requester_snpn_list.into_iter().next(),
            target_plmn: intermediate_rep.target_plmn.into_iter().next(),
            target_snpn: intermediate_rep.target_snpn.into_iter().next(),
            target_snssai_list: intermediate_rep.target_snssai_list.into_iter().next(),
            target_nsi_list: intermediate_rep.target_nsi_list.into_iter().next(),
            target_nf_set_id: intermediate_rep.target_nf_set_id.into_iter().next(),
            target_nf_service_set_id: intermediate_rep.target_nf_service_set_id.into_iter().next(),
            hnrf_access_token_uri: intermediate_rep.hnrf_access_token_uri.into_iter().next(),
            source_nf_instance_id: intermediate_rep.source_nf_instance_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AccessTokenReq> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AccessTokenReq>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AccessTokenReq>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AccessTokenReq - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AccessTokenReq> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AccessTokenReq as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AccessTokenReq - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Indicates whether the access is  via 3GPP or via non-3GPP.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum AccessType {
    #[serde(rename = "3GPP_ACCESS")]
    Variant3GppAccess,
    #[serde(rename = "NON_3GPP_ACCESS")]
    Non3GppAccess,
}

impl std::fmt::Display for AccessType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            AccessType::Variant3GppAccess => write!(f, "3GPP_ACCESS"),
            AccessType::Non3GppAccess => write!(f, "NON_3GPP_ACCESS"),
        }
    }
}

impl std::str::FromStr for AccessType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "3GPP_ACCESS" => std::result::Result::Ok(AccessType::Variant3GppAccess),
            "NON_3GPP_ACCESS" => std::result::Result::Ok(AccessType::Non3GppAccess),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// The enumeration AdditionalQosFlowInfo provides additional QoS flow information (see clause  9.3.1.12 3GPP TS 38.413 [11]). It shall comply with the provisions defined in table 5.5.3.12-1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdditionalQosFlowInfo {}

impl AdditionalQosFlowInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AdditionalQosFlowInfo {
        AdditionalQosFlowInfo {}
    }
}

/// Converts the AdditionalQosFlowInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AdditionalQosFlowInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdditionalQosFlowInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdditionalQosFlowInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AdditionalQosFlowInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AdditionalQosFlowInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdditionalQosFlowInfo {})
    }
}

// Methods for converting between header::IntoHeaderValue<AdditionalQosFlowInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AdditionalQosFlowInfo>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AdditionalQosFlowInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AdditionalQosFlowInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<AdditionalQosFlowInfo>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AdditionalQosFlowInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AdditionalQosFlowInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// indicates first, second or third additional indirect data forwarding tunnel
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdditionalTnlNb(i32);

impl std::convert::From<i32> for AdditionalTnlNb {
    fn from(x: i32) -> Self {
        AdditionalTnlNb(x)
    }
}

impl std::convert::From<AdditionalTnlNb> for i32 {
    fn from(x: AdditionalTnlNb) -> Self {
        x.0
    }
}

impl std::ops::Deref for AdditionalTnlNb {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for AdditionalTnlNb {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// AF Coordination Information
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AfCoordinationInfo {
    /// DNAI (Data network access identifier), see clause 5.6.7 of 3GPP TS 23.501.
    #[serde(rename = "sourceDnai")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source_dnai: Option<String>,

    /// String identifying a IPv4 address formatted in the 'dotted decimal' notation as defined in RFC 1166.
    #[serde(rename = "sourceUeIpv4Addr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source_ue_ipv4_addr: Option<String>,

    #[serde(rename = "sourceUeIpv6Prefix")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source_ue_ipv6_prefix: Option<models::Ipv6Prefix>,

    #[serde(rename = "notificationInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notification_info_list: Option<Vec<models::NotificationInfo>>,
}

impl AfCoordinationInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AfCoordinationInfo {
        AfCoordinationInfo {
            source_dnai: None,
            source_ue_ipv4_addr: None,
            source_ue_ipv6_prefix: None,
            notification_info_list: None,
        }
    }
}

/// Converts the AfCoordinationInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AfCoordinationInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.source_dnai.as_ref().map(|source_dnai| {
                vec!["sourceDnai".to_string(), source_dnai.to_string()].join(",")
            }),
            self.source_ue_ipv4_addr
                .as_ref()
                .map(|source_ue_ipv4_addr| {
                    vec![
                        "sourceUeIpv4Addr".to_string(),
                        source_ue_ipv4_addr.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping sourceUeIpv6Prefix in query parameter serialization

            // Skipping notificationInfoList in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AfCoordinationInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AfCoordinationInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub source_dnai: Vec<String>,
            pub source_ue_ipv4_addr: Vec<String>,
            pub source_ue_ipv6_prefix: Vec<models::Ipv6Prefix>,
            pub notification_info_list: Vec<Vec<models::NotificationInfo>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AfCoordinationInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "sourceDnai" => intermediate_rep.source_dnai.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "sourceUeIpv4Addr" => intermediate_rep.source_ue_ipv4_addr.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "sourceUeIpv6Prefix" => intermediate_rep.source_ue_ipv6_prefix.push(
                        <models::Ipv6Prefix as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "notificationInfoList" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in AfCoordinationInfo"
                            .to_string(),
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AfCoordinationInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AfCoordinationInfo {
            source_dnai: intermediate_rep.source_dnai.into_iter().next(),
            source_ue_ipv4_addr: intermediate_rep.source_ue_ipv4_addr.into_iter().next(),
            source_ue_ipv6_prefix: intermediate_rep.source_ue_ipv6_prefix.into_iter().next(),
            notification_info_list: intermediate_rep.notification_info_list.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AfCoordinationInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AfCoordinationInfo>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AfCoordinationInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AfCoordinationInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<AfCoordinationInfo>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AfCoordinationInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AfCoordinationInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Alternative QoS Profile
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AlternativeQosProfile {
    #[serde(rename = "index")]
    pub index: u8,

    /// String representing a bit rate; the prefixes follow the standard symbols from The International System of Units, and represent x1000 multipliers, with the exception that prefix \"K\" is used to represent the standard symbol \"k\".
    #[serde(rename = "guaFbrDl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gua_fbr_dl: Option<String>,

    /// String representing a bit rate; the prefixes follow the standard symbols from The International System of Units, and represent x1000 multipliers, with the exception that prefix \"K\" is used to represent the standard symbol \"k\".
    #[serde(rename = "guaFbrUl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gua_fbr_ul: Option<String>,

    /// Unsigned integer indicating Packet Delay Budget (see clauses 5.7.3.4 and 5.7.4 of 3GPP TS 23.501), expressed in milliseconds.
    #[serde(rename = "packetDelayBudget")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub packet_delay_budget: Option<u32>,

    /// String representing Packet Error Rate (see clause 5.7.3.5 and 5.7.4 of 3GPP TS 23.501, expressed as a \"scalar x 10-k\" where the scalar and the exponent k are each encoded as one decimal digit.
    #[serde(rename = "packetErrRate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub packet_err_rate: Option<String>,
}

impl AlternativeQosProfile {
    #[allow(clippy::new_without_default)]
    pub fn new(index: u8) -> AlternativeQosProfile {
        AlternativeQosProfile {
            index,
            gua_fbr_dl: None,
            gua_fbr_ul: None,
            packet_delay_budget: None,
            packet_err_rate: None,
        }
    }
}

/// Converts the AlternativeQosProfile value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AlternativeQosProfile {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("index".to_string()),
            Some(self.index.to_string()),
            self.gua_fbr_dl
                .as_ref()
                .map(|gua_fbr_dl| vec!["guaFbrDl".to_string(), gua_fbr_dl.to_string()].join(",")),
            self.gua_fbr_ul
                .as_ref()
                .map(|gua_fbr_ul| vec!["guaFbrUl".to_string(), gua_fbr_ul.to_string()].join(",")),
            self.packet_delay_budget
                .as_ref()
                .map(|packet_delay_budget| {
                    vec![
                        "packetDelayBudget".to_string(),
                        packet_delay_budget.to_string(),
                    ]
                    .join(",")
                }),
            self.packet_err_rate.as_ref().map(|packet_err_rate| {
                vec!["packetErrRate".to_string(), packet_err_rate.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AlternativeQosProfile value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AlternativeQosProfile {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub index: Vec<u8>,
            pub gua_fbr_dl: Vec<String>,
            pub gua_fbr_ul: Vec<String>,
            pub packet_delay_budget: Vec<u32>,
            pub packet_err_rate: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AlternativeQosProfile".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep
                        .index
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "guaFbrDl" => intermediate_rep.gua_fbr_dl.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "guaFbrUl" => intermediate_rep.gua_fbr_ul.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "packetDelayBudget" => intermediate_rep.packet_delay_budget.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "packetErrRate" => intermediate_rep.packet_err_rate.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AlternativeQosProfile".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AlternativeQosProfile {
            index: intermediate_rep
                .index
                .into_iter()
                .next()
                .ok_or_else(|| "index missing in AlternativeQosProfile".to_string())?,
            gua_fbr_dl: intermediate_rep.gua_fbr_dl.into_iter().next(),
            gua_fbr_ul: intermediate_rep.gua_fbr_ul.into_iter().next(),
            packet_delay_budget: intermediate_rep.packet_delay_budget.into_iter().next(),
            packet_err_rate: intermediate_rep.packet_err_rate.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AlternativeQosProfile> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AlternativeQosProfile>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AlternativeQosProfile>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AlternativeQosProfile - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<AlternativeQosProfile>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AlternativeQosProfile as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AlternativeQosProfile - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains the maximum aggregated uplink and downlink bit rates.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Ambr {
    /// String representing a bit rate; the prefixes follow the standard symbols from The International System of Units, and represent x1000 multipliers, with the exception that prefix \"K\" is used to represent the standard symbol \"k\".
    #[serde(rename = "uplink")]
    pub uplink: String,

    /// String representing a bit rate; the prefixes follow the standard symbols from The International System of Units, and represent x1000 multipliers, with the exception that prefix \"K\" is used to represent the standard symbol \"k\".
    #[serde(rename = "downlink")]
    pub downlink: String,
}

impl Ambr {
    #[allow(clippy::new_without_default)]
    pub fn new(uplink: String, downlink: String) -> Ambr {
        Ambr { uplink, downlink }
    }
}

/// Converts the Ambr value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Ambr {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("uplink".to_string()),
            Some(self.uplink.to_string()),
            Some("downlink".to_string()),
            Some(self.downlink.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Ambr value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Ambr {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub uplink: Vec<String>,
            pub downlink: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err("Missing value while parsing Ambr".to_string())
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "uplink" => intermediate_rep.uplink.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "downlink" => intermediate_rep.downlink.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Ambr".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Ambr {
            uplink: intermediate_rep
                .uplink
                .into_iter()
                .next()
                .ok_or_else(|| "uplink missing in Ambr".to_string())?,
            downlink: intermediate_rep
                .downlink
                .into_iter()
                .next()
                .ok_or_else(|| "downlink missing in Ambr".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Ambr> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Ambr>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Ambr>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Ambr - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Ambr> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Ambr as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Ambr - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// String identifying the AMF ID composed of AMF Region ID (8 bits), AMF Set ID (10 bits) and AMF  Pointer (6 bits) as specified in clause 2.10.1 of 3GPP TS 23.003. It is encoded as a string of  6 hexadecimal characters (i.e., 24 bits).
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AmfId(String);

impl std::convert::From<String> for AmfId {
    fn from(x: String) -> Self {
        AmfId(x)
    }
}

impl std::string::ToString for AmfId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for AmfId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(AmfId(x.to_string()))
    }
}

impl std::convert::From<AmfId> for String {
    fn from(x: AmfId) -> Self {
        x.0
    }
}

impl std::ops::Deref for AmfId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for AmfId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Fully Qualified Domain Name
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AmfName {}

impl AmfName {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AmfName {
        AmfName {}
    }
}

/// Converts the AmfName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AmfName {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AmfName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AmfName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AmfName".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AmfName".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AmfName {})
    }
}

// Methods for converting between header::IntoHeaderValue<AmfName> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AmfName>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AmfName>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AmfName - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AmfName> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AmfName as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AmfName - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Anchor SMF supported features
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AnchorSmfFeatures {
    #[serde(rename = "psetrSupportInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub psetr_support_ind: Option<bool>,
}

impl AnchorSmfFeatures {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AnchorSmfFeatures {
        AnchorSmfFeatures {
            psetr_support_ind: None,
        }
    }
}

/// Converts the AnchorSmfFeatures value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AnchorSmfFeatures {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> =
            vec![self.psetr_support_ind.as_ref().map(|psetr_support_ind| {
                vec!["psetrSupportInd".to_string(), psetr_support_ind.to_string()].join(",")
            })];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AnchorSmfFeatures value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AnchorSmfFeatures {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub psetr_support_ind: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AnchorSmfFeatures".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "psetrSupportInd" => intermediate_rep.psetr_support_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AnchorSmfFeatures".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AnchorSmfFeatures {
            psetr_support_ind: intermediate_rep.psetr_support_ind.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AnchorSmfFeatures> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AnchorSmfFeatures>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AnchorSmfFeatures>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AnchorSmfFeatures - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<AnchorSmfFeatures>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AnchorSmfFeatures as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AnchorSmfFeatures - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains the APN rate control status e.g. of the AMF.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ApnRateStatus {
    /// When present, it shall contain the number of packets the UE is allowed to send uplink in the given time unit for the given APN (all PDN connections of the UE to this APN see clause 4.7.7.3 in 3GPP TS 23.401.
    #[serde(rename = "remainPacketsUl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remain_packets_ul: Option<u32>,

    /// When present, it shall contain the number of packets the UE is allowed to send uplink in the given time unit for the given APN (all PDN connections of the UE to this APN see clause 4.7.7.3 in 3GPP TS 23.401.
    #[serde(rename = "remainPacketsDl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remain_packets_dl: Option<u32>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "validityTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub validity_time: Option<chrono::DateTime<chrono::Utc>>,

    /// When present, it shall indicate the number of additional exception reports the UE is allowed to send uplink in the given time unit for the given APN (all PDN connections of the UE to this APN, see clause 4.7.7.3 in 3GPP TS 23.401.
    #[serde(rename = "remainExReportsUl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remain_ex_reports_ul: Option<u32>,

    /// When present, it shall indicate the number of additional exception reports the AF is allowed to send downlink in the  given time unit for the given APN (all PDN connections of the UE to this APN, see clause 4.7.7.3 in 3GPP TS 23.401.
    #[serde(rename = "remainExReportsDl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remain_ex_reports_dl: Option<u32>,
}

impl ApnRateStatus {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ApnRateStatus {
        ApnRateStatus {
            remain_packets_ul: None,
            remain_packets_dl: None,
            validity_time: None,
            remain_ex_reports_ul: None,
            remain_ex_reports_dl: None,
        }
    }
}

/// Converts the ApnRateStatus value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ApnRateStatus {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.remain_packets_ul.as_ref().map(|remain_packets_ul| {
                vec!["remainPacketsUl".to_string(), remain_packets_ul.to_string()].join(",")
            }),
            self.remain_packets_dl.as_ref().map(|remain_packets_dl| {
                vec!["remainPacketsDl".to_string(), remain_packets_dl.to_string()].join(",")
            }),
            // Skipping validityTime in query parameter serialization
            self.remain_ex_reports_ul
                .as_ref()
                .map(|remain_ex_reports_ul| {
                    vec![
                        "remainExReportsUl".to_string(),
                        remain_ex_reports_ul.to_string(),
                    ]
                    .join(",")
                }),
            self.remain_ex_reports_dl
                .as_ref()
                .map(|remain_ex_reports_dl| {
                    vec![
                        "remainExReportsDl".to_string(),
                        remain_ex_reports_dl.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ApnRateStatus value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ApnRateStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub remain_packets_ul: Vec<u32>,
            pub remain_packets_dl: Vec<u32>,
            pub validity_time: Vec<chrono::DateTime<chrono::Utc>>,
            pub remain_ex_reports_ul: Vec<u32>,
            pub remain_ex_reports_dl: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ApnRateStatus".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "remainPacketsUl" => intermediate_rep.remain_packets_ul.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "remainPacketsDl" => intermediate_rep.remain_packets_dl.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "validityTime" => intermediate_rep.validity_time.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "remainExReportsUl" => intermediate_rep.remain_ex_reports_ul.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "remainExReportsDl" => intermediate_rep.remain_ex_reports_dl.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ApnRateStatus".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ApnRateStatus {
            remain_packets_ul: intermediate_rep.remain_packets_ul.into_iter().next(),
            remain_packets_dl: intermediate_rep.remain_packets_dl.into_iter().next(),
            validity_time: intermediate_rep.validity_time.into_iter().next(),
            remain_ex_reports_ul: intermediate_rep.remain_ex_reports_ul.into_iter().next(),
            remain_ex_reports_dl: intermediate_rep.remain_ex_reports_dl.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ApnRateStatus> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ApnRateStatus>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ApnRateStatus>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ApnRateStatus - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ApnRateStatus> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ApnRateStatus as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ApnRateStatus - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains Allocation and Retention Priority information.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Arp {
    /// nullable true shall not be used for this attribute. Unsigned integer indicating the ARP Priority Level (see clause 5.7.2.2 of 3GPP TS 23.501, within the range 1 to 15.Values are ordered in decreasing order of priority, i.e. with 1 as the highest priority and 15 as the lowest priority.
    #[serde(rename = "priorityLevel")]
    pub priority_level: swagger::Nullable<u8>,

    #[serde(rename = "preemptCap")]
    pub preempt_cap: models::PreemptionCapability,

    #[serde(rename = "preemptVuln")]
    pub preempt_vuln: models::PreemptionVulnerability,
}

impl Arp {
    #[allow(clippy::new_without_default)]
    pub fn new(
        priority_level: swagger::Nullable<u8>,
        preempt_cap: models::PreemptionCapability,
        preempt_vuln: models::PreemptionVulnerability,
    ) -> Arp {
        Arp {
            priority_level,
            preempt_cap,
            preempt_vuln,
        }
    }
}

/// Converts the Arp value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Arp {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("priorityLevel".to_string()),
            Some(
                self.priority_level
                    .as_ref()
                    .map_or("null".to_string(), |x| x.to_string()),
            ),
            // Skipping preemptCap in query parameter serialization

            // Skipping preemptVuln in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Arp value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Arp {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub priority_level: Vec<u8>,
            pub preempt_cap: Vec<models::PreemptionCapability>,
            pub preempt_vuln: Vec<models::PreemptionVulnerability>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err("Missing value while parsing Arp".to_string())
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "priorityLevel" => {
                        return std::result::Result::Err(
                            "Parsing a nullable type in this style is not supported in Arp"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "preemptCap" => intermediate_rep.preempt_cap.push(
                        <models::PreemptionCapability as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "preemptVuln" => intermediate_rep.preempt_vuln.push(
                        <models::PreemptionVulnerability as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Arp".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Arp {
            priority_level: std::result::Result::Err(
                "Nullable types not supported in Arp".to_string(),
            )?,
            preempt_cap: intermediate_rep
                .preempt_cap
                .into_iter()
                .next()
                .ok_or_else(|| "preemptCap missing in Arp".to_string())?,
            preempt_vuln: intermediate_rep
                .preempt_vuln
                .into_iter()
                .next()
                .ok_or_else(|| "preemptVuln missing in Arp".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Arp> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Arp>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Arp>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Arp - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Arp> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Arp as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Arp - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// nullable true shall not be used for this attribute. Unsigned integer indicating the ARP Priority Level (see clause 5.7.2.2 of 3GPP TS 23.501, within the range 1 to 15.Values are ordered in decreasing order of priority, i.e. with 1 as the highest priority and 15 as the lowest priority.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ArpPriorityLevel(i32);

impl std::convert::From<i32> for ArpPriorityLevel {
    fn from(x: i32) -> Self {
        ArpPriorityLevel(x)
    }
}

impl std::convert::From<ArpPriorityLevel> for i32 {
    fn from(x: ArpPriorityLevel) -> Self {
        x.0
    }
}

impl std::ops::Deref for ArpPriorityLevel {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for ArpPriorityLevel {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// Unsigned integer indicating Averaging Window (see clause 5.7.3.6 and 5.7.4 of 3GPP TS 23.501), expressed in milliseconds.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AverWindow(i32);

impl std::convert::From<i32> for AverWindow {
    fn from(x: i32) -> Self {
        AverWindow(x)
    }
}

impl std::convert::From<AverWindow> for i32 {
    fn from(x: AverWindow) -> Self {
        x.0
    }
}

impl std::ops::Deref for AverWindow {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for AverWindow {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// Provides details of the Backup AMF.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BackupAmfInfo {
    /// Fully Qualified Domain Name
    #[serde(rename = "backupAmf")]
    pub backup_amf: String,

    /// If present, this IE shall contain the list of GUAMI(s) (supported by the AMF) for which the backupAmf IE applies.
    #[serde(rename = "guamiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub guami_list: Option<Vec<models::Guami>>,
}

impl BackupAmfInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(backup_amf: String) -> BackupAmfInfo {
        BackupAmfInfo {
            backup_amf,
            guami_list: None,
        }
    }
}

/// Converts the BackupAmfInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for BackupAmfInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("backupAmf".to_string()),
            Some(self.backup_amf.to_string()),
            // Skipping guamiList in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BackupAmfInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BackupAmfInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub backup_amf: Vec<String>,
            pub guami_list: Vec<Vec<models::Guami>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing BackupAmfInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "backupAmf" => intermediate_rep.backup_amf.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "guamiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in BackupAmfInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing BackupAmfInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BackupAmfInfo {
            backup_amf: intermediate_rep
                .backup_amf
                .into_iter()
                .next()
                .ok_or_else(|| "backupAmf missing in BackupAmfInfo".to_string())?,
            guami_list: intermediate_rep.guami_list.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BackupAmfInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<BackupAmfInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<BackupAmfInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for BackupAmfInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<BackupAmfInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <BackupAmfInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into BackupAmfInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Parameters \"replaceableInd\" and \"rechargeableInd\" are only included if the value of Parameter \"batteryInd\" is true.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BatteryIndication {
    /// This IE shall indicate whether the UE is battery powered or not. true: the UE is battery powered; false or absent: the UE is not battery powered
    #[serde(rename = "batteryInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub battery_ind: Option<bool>,

    /// This IE shall indicate whether the battery of the UE is replaceable or not. true: the battery of the UE is replaceable; false or absent: the battery of the UE is not replaceable.
    #[serde(rename = "replaceableInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaceable_ind: Option<bool>,

    /// This IE shall indicate whether the battery of the UE is rechargeable or not. true: the battery of UE is rechargeable; false or absent: the battery of the UE is not rechargeable.
    #[serde(rename = "rechargeableInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rechargeable_ind: Option<bool>,
}

impl BatteryIndication {
    #[allow(clippy::new_without_default)]
    pub fn new() -> BatteryIndication {
        BatteryIndication {
            battery_ind: None,
            replaceable_ind: None,
            rechargeable_ind: None,
        }
    }
}

/// Converts the BatteryIndication value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for BatteryIndication {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.battery_ind.as_ref().map(|battery_ind| {
                vec!["batteryInd".to_string(), battery_ind.to_string()].join(",")
            }),
            self.replaceable_ind.as_ref().map(|replaceable_ind| {
                vec!["replaceableInd".to_string(), replaceable_ind.to_string()].join(",")
            }),
            self.rechargeable_ind.as_ref().map(|rechargeable_ind| {
                vec!["rechargeableInd".to_string(), rechargeable_ind.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BatteryIndication value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BatteryIndication {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub battery_ind: Vec<bool>,
            pub replaceable_ind: Vec<bool>,
            pub rechargeable_ind: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing BatteryIndication".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "batteryInd" => intermediate_rep.battery_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "replaceableInd" => intermediate_rep.replaceable_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "rechargeableInd" => intermediate_rep.rechargeable_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing BatteryIndication".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BatteryIndication {
            battery_ind: intermediate_rep.battery_ind.into_iter().next(),
            replaceable_ind: intermediate_rep.replaceable_ind.into_iter().next(),
            rechargeable_ind: intermediate_rep.rechargeable_ind.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BatteryIndication> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<BatteryIndication>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<BatteryIndication>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for BatteryIndication - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<BatteryIndication>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <BatteryIndication as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into BatteryIndication - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// String representing a bit rate; the prefixes follow the standard symbols from The International System of Units, and represent x1000 multipliers, with the exception that prefix \"K\" is used to represent the standard symbol \"k\".
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BitRate(String);

impl std::convert::From<String> for BitRate {
    fn from(x: String) -> Self {
        BitRate(x)
    }
}

impl std::string::ToString for BitRate {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for BitRate {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(BitRate(x.to_string()))
    }
}

impl std::convert::From<BitRate> for String {
    fn from(x: BitRate) -> Self {
        x.0
    }
}

impl std::ops::Deref for BitRate {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for BitRate {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// string with format 'bytes' as defined in OpenAPI
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Bytes(swagger::ByteArray);

impl std::convert::From<swagger::ByteArray> for Bytes {
    fn from(x: swagger::ByteArray) -> Self {
        Bytes(x)
    }
}

impl std::convert::From<Bytes> for swagger::ByteArray {
    fn from(x: Bytes) -> Self {
        x.0
    }
}

impl std::ops::Deref for Bytes {
    type Target = swagger::ByteArray;
    fn deref(&self) -> &swagger::ByteArray {
        &self.0
    }
}

impl std::ops::DerefMut for Bytes {
    fn deref_mut(&mut self) -> &mut swagger::ByteArray {
        &mut self.0
    }
}

/// Cause information. Possible values are - REL_DUE_TO_HO - EPS_FALLBACK - REL_DUE_TO_UP_SEC - DNN_CONGESTION - S_NSSAI_CONGESTION - REL_DUE_TO_REACTIVATION - 5G_AN_NOT_RESPONDING - REL_DUE_TO_SLICE_NOT_AVAILABLE - REL_DUE_TO_DUPLICATE_SESSION_ID - PDU_SESSION_STATUS_MISMATCH - HO_FAILURE - INSUFFICIENT_UP_RESOURCES - PDU_SESSION_HANDED_OVER - PDU_SESSION_RESUMED - CN_ASSISTED_RAN_PARAMETER_TUNING - ISMF_CONTEXT_TRANSFER - SMF_CONTEXT_TRANSFER - REL_DUE_TO_PS_TO_CS_HO - REL_DUE_TO_SUBSCRIPTION_CHANGE - HO_CANCEL - REL_DUE_TO_SLICE_NOT_AUTHORIZED - PDU_SESSION_HAND_OVER_FAILURE - DDN_FAILURE_STATUS - REL_DUE_TO_CP_ONLY_NOT_APPLICABLE - NOT_SUPPORTED_WITH_ISMF - CHANGED_ANCHOR_SMF - CHANGED_INTERMEDIATE_SMF - TARGET_DNAI_NOTIFICATION - REL_DUE_TO_VPLMN_QOS_FAILURE - REL_DUE_TO_SMF_NOT_SUPPORT_PSETR - REL_DUE_TO_SNPN_SNPN_MOBILITY - REL_DUE_TO_NO_HR_AGREEMENT - REL_DUE_TO_UNSPECIFIED_REASON
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Cause {}

impl Cause {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Cause {
        Cause {}
    }
}

/// Converts the Cause value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Cause {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Cause value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Cause {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Cause".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Cause".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Cause {})
    }
}

// Methods for converting between header::IntoHeaderValue<Cause> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Cause>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Cause>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Cause - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Cause> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Cause as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Cause - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum CauseAnyOf {
    #[serde(rename = "REL_DUE_TO_HO")]
    RelDueToHo,
    #[serde(rename = "EPS_FALLBACK")]
    EpsFallback,
    #[serde(rename = "REL_DUE_TO_UP_SEC")]
    RelDueToUpSec,
    #[serde(rename = "DNN_CONGESTION")]
    DnnCongestion,
    #[serde(rename = "S_NSSAI_CONGESTION")]
    SNssaiCongestion,
    #[serde(rename = "REL_DUE_TO_REACTIVATION")]
    RelDueToReactivation,
    #[serde(rename = "5G_AN_NOT_RESPONDING")]
    Variant5GanNotResponding,
    #[serde(rename = "REL_DUE_TO_SLICE_NOT_AVAILABLE")]
    RelDueToSliceNotAvailable,
    #[serde(rename = "REL_DUE_TO_DUPLICATE_SESSION_ID")]
    RelDueToDuplicateSessionId,
    #[serde(rename = "PDU_SESSION_STATUS_MISMATCH")]
    PduSessionStatusMismatch,
    #[serde(rename = "HO_FAILURE")]
    HoFailure,
    #[serde(rename = "INSUFFICIENT_UP_RESOURCES")]
    InsufficientUpResources,
    #[serde(rename = "PDU_SESSION_HANDED_OVER")]
    PduSessionHandedOver,
    #[serde(rename = "PDU_SESSION_RESUMED")]
    PduSessionResumed,
    #[serde(rename = "CN_ASSISTED_RAN_PARAMETER_TUNING")]
    CnAssistedRanParameterTuning,
    #[serde(rename = "ISMF_CONTEXT_TRANSFER")]
    IsmfContextTransfer,
    #[serde(rename = "SMF_CONTEXT_TRANSFER")]
    SmfContextTransfer,
    #[serde(rename = "REL_DUE_TO_PS_TO_CS_HO")]
    RelDueToPsToCsHo,
    #[serde(rename = "REL_DUE_TO_SUBSCRIPTION_CHANGE")]
    RelDueToSubscriptionChange,
    #[serde(rename = "HO_CANCEL")]
    HoCancel,
    #[serde(rename = "REL_DUE_TO_SLICE_NOT_AUTHORIZED")]
    RelDueToSliceNotAuthorized,
    #[serde(rename = "PDU_SESSION_HAND_OVER_FAILURE")]
    PduSessionHandOverFailure,
    #[serde(rename = "DDN_FAILURE_STATUS")]
    DdnFailureStatus,
    #[serde(rename = "REL_DUE_TO_CP_ONLY_NOT_APPLICABLE")]
    RelDueToCpOnlyNotApplicable,
    #[serde(rename = "NOT_SUPPORTED_WITH_ISMF")]
    NotSupportedWithIsmf,
    #[serde(rename = "CHANGED_ANCHOR_SMF")]
    ChangedAnchorSmf,
    #[serde(rename = "CHANGED_INTERMEDIATE_SMF")]
    ChangedIntermediateSmf,
    #[serde(rename = "TARGET_DNAI_NOTIFICATION")]
    TargetDnaiNotification,
    #[serde(rename = "REL_DUE_TO_VPLMN_QOS_FAILURE")]
    RelDueToVplmnQosFailure,
    #[serde(rename = "REL_DUE_TO_SMF_NOT_SUPPORT_PSETR")]
    RelDueToSmfNotSupportPsetr,
    #[serde(rename = "REL_DUE_TO_SNPN_SNPN_MOBILITY")]
    RelDueToSnpnSnpnMobility,
    #[serde(rename = "REL_DUE_TO_NO_HR_AGREEMENT")]
    RelDueToNoHrAgreement,
    #[serde(rename = "REL_DUE_TO_UNSPECIFIED_REASON")]
    RelDueToUnspecifiedReason,
}

impl std::fmt::Display for CauseAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            CauseAnyOf::RelDueToHo => write!(f, "REL_DUE_TO_HO"),
            CauseAnyOf::EpsFallback => write!(f, "EPS_FALLBACK"),
            CauseAnyOf::RelDueToUpSec => write!(f, "REL_DUE_TO_UP_SEC"),
            CauseAnyOf::DnnCongestion => write!(f, "DNN_CONGESTION"),
            CauseAnyOf::SNssaiCongestion => write!(f, "S_NSSAI_CONGESTION"),
            CauseAnyOf::RelDueToReactivation => write!(f, "REL_DUE_TO_REACTIVATION"),
            CauseAnyOf::Variant5GanNotResponding => write!(f, "5G_AN_NOT_RESPONDING"),
            CauseAnyOf::RelDueToSliceNotAvailable => write!(f, "REL_DUE_TO_SLICE_NOT_AVAILABLE"),
            CauseAnyOf::RelDueToDuplicateSessionId => write!(f, "REL_DUE_TO_DUPLICATE_SESSION_ID"),
            CauseAnyOf::PduSessionStatusMismatch => write!(f, "PDU_SESSION_STATUS_MISMATCH"),
            CauseAnyOf::HoFailure => write!(f, "HO_FAILURE"),
            CauseAnyOf::InsufficientUpResources => write!(f, "INSUFFICIENT_UP_RESOURCES"),
            CauseAnyOf::PduSessionHandedOver => write!(f, "PDU_SESSION_HANDED_OVER"),
            CauseAnyOf::PduSessionResumed => write!(f, "PDU_SESSION_RESUMED"),
            CauseAnyOf::CnAssistedRanParameterTuning => {
                write!(f, "CN_ASSISTED_RAN_PARAMETER_TUNING")
            }
            CauseAnyOf::IsmfContextTransfer => write!(f, "ISMF_CONTEXT_TRANSFER"),
            CauseAnyOf::SmfContextTransfer => write!(f, "SMF_CONTEXT_TRANSFER"),
            CauseAnyOf::RelDueToPsToCsHo => write!(f, "REL_DUE_TO_PS_TO_CS_HO"),
            CauseAnyOf::RelDueToSubscriptionChange => write!(f, "REL_DUE_TO_SUBSCRIPTION_CHANGE"),
            CauseAnyOf::HoCancel => write!(f, "HO_CANCEL"),
            CauseAnyOf::RelDueToSliceNotAuthorized => write!(f, "REL_DUE_TO_SLICE_NOT_AUTHORIZED"),
            CauseAnyOf::PduSessionHandOverFailure => write!(f, "PDU_SESSION_HAND_OVER_FAILURE"),
            CauseAnyOf::DdnFailureStatus => write!(f, "DDN_FAILURE_STATUS"),
            CauseAnyOf::RelDueToCpOnlyNotApplicable => {
                write!(f, "REL_DUE_TO_CP_ONLY_NOT_APPLICABLE")
            }
            CauseAnyOf::NotSupportedWithIsmf => write!(f, "NOT_SUPPORTED_WITH_ISMF"),
            CauseAnyOf::ChangedAnchorSmf => write!(f, "CHANGED_ANCHOR_SMF"),
            CauseAnyOf::ChangedIntermediateSmf => write!(f, "CHANGED_INTERMEDIATE_SMF"),
            CauseAnyOf::TargetDnaiNotification => write!(f, "TARGET_DNAI_NOTIFICATION"),
            CauseAnyOf::RelDueToVplmnQosFailure => write!(f, "REL_DUE_TO_VPLMN_QOS_FAILURE"),
            CauseAnyOf::RelDueToSmfNotSupportPsetr => write!(f, "REL_DUE_TO_SMF_NOT_SUPPORT_PSETR"),
            CauseAnyOf::RelDueToSnpnSnpnMobility => write!(f, "REL_DUE_TO_SNPN_SNPN_MOBILITY"),
            CauseAnyOf::RelDueToNoHrAgreement => write!(f, "REL_DUE_TO_NO_HR_AGREEMENT"),
            CauseAnyOf::RelDueToUnspecifiedReason => write!(f, "REL_DUE_TO_UNSPECIFIED_REASON"),
        }
    }
}

impl std::str::FromStr for CauseAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "REL_DUE_TO_HO" => std::result::Result::Ok(CauseAnyOf::RelDueToHo),
            "EPS_FALLBACK" => std::result::Result::Ok(CauseAnyOf::EpsFallback),
            "REL_DUE_TO_UP_SEC" => std::result::Result::Ok(CauseAnyOf::RelDueToUpSec),
            "DNN_CONGESTION" => std::result::Result::Ok(CauseAnyOf::DnnCongestion),
            "S_NSSAI_CONGESTION" => std::result::Result::Ok(CauseAnyOf::SNssaiCongestion),
            "REL_DUE_TO_REACTIVATION" => std::result::Result::Ok(CauseAnyOf::RelDueToReactivation),
            "5G_AN_NOT_RESPONDING" => std::result::Result::Ok(CauseAnyOf::Variant5GanNotResponding),
            "REL_DUE_TO_SLICE_NOT_AVAILABLE" => {
                std::result::Result::Ok(CauseAnyOf::RelDueToSliceNotAvailable)
            }
            "REL_DUE_TO_DUPLICATE_SESSION_ID" => {
                std::result::Result::Ok(CauseAnyOf::RelDueToDuplicateSessionId)
            }
            "PDU_SESSION_STATUS_MISMATCH" => {
                std::result::Result::Ok(CauseAnyOf::PduSessionStatusMismatch)
            }
            "HO_FAILURE" => std::result::Result::Ok(CauseAnyOf::HoFailure),
            "INSUFFICIENT_UP_RESOURCES" => {
                std::result::Result::Ok(CauseAnyOf::InsufficientUpResources)
            }
            "PDU_SESSION_HANDED_OVER" => std::result::Result::Ok(CauseAnyOf::PduSessionHandedOver),
            "PDU_SESSION_RESUMED" => std::result::Result::Ok(CauseAnyOf::PduSessionResumed),
            "CN_ASSISTED_RAN_PARAMETER_TUNING" => {
                std::result::Result::Ok(CauseAnyOf::CnAssistedRanParameterTuning)
            }
            "ISMF_CONTEXT_TRANSFER" => std::result::Result::Ok(CauseAnyOf::IsmfContextTransfer),
            "SMF_CONTEXT_TRANSFER" => std::result::Result::Ok(CauseAnyOf::SmfContextTransfer),
            "REL_DUE_TO_PS_TO_CS_HO" => std::result::Result::Ok(CauseAnyOf::RelDueToPsToCsHo),
            "REL_DUE_TO_SUBSCRIPTION_CHANGE" => {
                std::result::Result::Ok(CauseAnyOf::RelDueToSubscriptionChange)
            }
            "HO_CANCEL" => std::result::Result::Ok(CauseAnyOf::HoCancel),
            "REL_DUE_TO_SLICE_NOT_AUTHORIZED" => {
                std::result::Result::Ok(CauseAnyOf::RelDueToSliceNotAuthorized)
            }
            "PDU_SESSION_HAND_OVER_FAILURE" => {
                std::result::Result::Ok(CauseAnyOf::PduSessionHandOverFailure)
            }
            "DDN_FAILURE_STATUS" => std::result::Result::Ok(CauseAnyOf::DdnFailureStatus),
            "REL_DUE_TO_CP_ONLY_NOT_APPLICABLE" => {
                std::result::Result::Ok(CauseAnyOf::RelDueToCpOnlyNotApplicable)
            }
            "NOT_SUPPORTED_WITH_ISMF" => std::result::Result::Ok(CauseAnyOf::NotSupportedWithIsmf),
            "CHANGED_ANCHOR_SMF" => std::result::Result::Ok(CauseAnyOf::ChangedAnchorSmf),
            "CHANGED_INTERMEDIATE_SMF" => {
                std::result::Result::Ok(CauseAnyOf::ChangedIntermediateSmf)
            }
            "TARGET_DNAI_NOTIFICATION" => {
                std::result::Result::Ok(CauseAnyOf::TargetDnaiNotification)
            }
            "REL_DUE_TO_VPLMN_QOS_FAILURE" => {
                std::result::Result::Ok(CauseAnyOf::RelDueToVplmnQosFailure)
            }
            "REL_DUE_TO_SMF_NOT_SUPPORT_PSETR" => {
                std::result::Result::Ok(CauseAnyOf::RelDueToSmfNotSupportPsetr)
            }
            "REL_DUE_TO_SNPN_SNPN_MOBILITY" => {
                std::result::Result::Ok(CauseAnyOf::RelDueToSnpnSnpnMobility)
            }
            "REL_DUE_TO_NO_HR_AGREEMENT" => {
                std::result::Result::Ok(CauseAnyOf::RelDueToNoHrAgreement)
            }
            "REL_DUE_TO_UNSPECIFIED_REASON" => {
                std::result::Result::Ok(CauseAnyOf::RelDueToUnspecifiedReason)
            }
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Contains a Cell Global Identification as defined in 3GPP TS 23.003, clause 4.3.1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CellGlobalId {
    #[serde(rename = "plmnId")]
    pub plmn_id: models::PlmnId,

    #[serde(rename = "lac")]
    pub lac: String,

    #[serde(rename = "cellId")]
    pub cell_id: String,
}

impl CellGlobalId {
    #[allow(clippy::new_without_default)]
    pub fn new(plmn_id: models::PlmnId, lac: String, cell_id: String) -> CellGlobalId {
        CellGlobalId {
            plmn_id,
            lac,
            cell_id,
        }
    }
}

/// Converts the CellGlobalId value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CellGlobalId {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping plmnId in query parameter serialization
            Some("lac".to_string()),
            Some(self.lac.to_string()),
            Some("cellId".to_string()),
            Some(self.cell_id.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CellGlobalId value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CellGlobalId {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub plmn_id: Vec<models::PlmnId>,
            pub lac: Vec<String>,
            pub cell_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing CellGlobalId".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "plmnId" => intermediate_rep.plmn_id.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "lac" => intermediate_rep.lac.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "cellId" => intermediate_rep.cell_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing CellGlobalId".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CellGlobalId {
            plmn_id: intermediate_rep
                .plmn_id
                .into_iter()
                .next()
                .ok_or_else(|| "plmnId missing in CellGlobalId".to_string())?,
            lac: intermediate_rep
                .lac
                .into_iter()
                .next()
                .ok_or_else(|| "lac missing in CellGlobalId".to_string())?,
            cell_id: intermediate_rep
                .cell_id
                .into_iter()
                .next()
                .ok_or_else(|| "cellId missing in CellGlobalId".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CellGlobalId> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CellGlobalId>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<CellGlobalId>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for CellGlobalId - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CellGlobalId> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <CellGlobalId as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into CellGlobalId - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains the addresses of the charging functions.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChargingInformation {
    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "primaryChfAddress")]
    pub primary_chf_address: String,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "secondaryChfAddress")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub secondary_chf_address: Option<String>,

    /// NF Set Identifier (see clause 28.12 of 3GPP TS 23.003), formatted as the following string \"set<Set ID>.<nftype>set.5gc.mnc<MNC>.mcc<MCC>\", or  \"set<SetID>.<NFType>set.5gc.nid<NID>.mnc<MNC>.mcc<MCC>\" with  <MCC> encoded as defined in clause 5.4.2 (\"Mcc\" data type definition)  <MNC> encoding the Mobile Network Code part of the PLMN, comprising 3 digits.    If there are only 2 significant digits in the MNC, one \"0\" digit shall be inserted    at the left side to fill the 3 digits coding of MNC.  Pattern: '^[0-9]{3}$' <NFType> encoded as a value defined in Table 6.1.6.3.3-1 of 3GPP TS 29.510 but    with lower case characters <Set ID> encoded as a string of characters consisting of    alphabetic characters (A-Z and a-z), digits (0-9) and/or the hyphen (-) and that    shall end with either an alphabetic character or a digit.
    #[serde(rename = "primaryChfSetId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub primary_chf_set_id: Option<String>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "primaryChfInstanceId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub primary_chf_instance_id: Option<uuid::Uuid>,

    /// NF Set Identifier (see clause 28.12 of 3GPP TS 23.003), formatted as the following string \"set<Set ID>.<nftype>set.5gc.mnc<MNC>.mcc<MCC>\", or  \"set<SetID>.<NFType>set.5gc.nid<NID>.mnc<MNC>.mcc<MCC>\" with  <MCC> encoded as defined in clause 5.4.2 (\"Mcc\" data type definition)  <MNC> encoding the Mobile Network Code part of the PLMN, comprising 3 digits.    If there are only 2 significant digits in the MNC, one \"0\" digit shall be inserted    at the left side to fill the 3 digits coding of MNC.  Pattern: '^[0-9]{3}$' <NFType> encoded as a value defined in Table 6.1.6.3.3-1 of 3GPP TS 29.510 but    with lower case characters <Set ID> encoded as a string of characters consisting of    alphabetic characters (A-Z and a-z), digits (0-9) and/or the hyphen (-) and that    shall end with either an alphabetic character or a digit.
    #[serde(rename = "secondaryChfSetId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub secondary_chf_set_id: Option<String>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "secondaryChfInstanceId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub secondary_chf_instance_id: Option<uuid::Uuid>,
}

impl ChargingInformation {
    #[allow(clippy::new_without_default)]
    pub fn new(primary_chf_address: String) -> ChargingInformation {
        ChargingInformation {
            primary_chf_address,
            secondary_chf_address: None,
            primary_chf_set_id: None,
            primary_chf_instance_id: None,
            secondary_chf_set_id: None,
            secondary_chf_instance_id: None,
        }
    }
}

/// Converts the ChargingInformation value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ChargingInformation {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("primaryChfAddress".to_string()),
            Some(self.primary_chf_address.to_string()),
            self.secondary_chf_address
                .as_ref()
                .map(|secondary_chf_address| {
                    vec![
                        "secondaryChfAddress".to_string(),
                        secondary_chf_address.to_string(),
                    ]
                    .join(",")
                }),
            self.primary_chf_set_id.as_ref().map(|primary_chf_set_id| {
                vec![
                    "primaryChfSetId".to_string(),
                    primary_chf_set_id.to_string(),
                ]
                .join(",")
            }),
            // Skipping primaryChfInstanceId in query parameter serialization
            self.secondary_chf_set_id
                .as_ref()
                .map(|secondary_chf_set_id| {
                    vec![
                        "secondaryChfSetId".to_string(),
                        secondary_chf_set_id.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping secondaryChfInstanceId in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChargingInformation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChargingInformation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub primary_chf_address: Vec<String>,
            pub secondary_chf_address: Vec<String>,
            pub primary_chf_set_id: Vec<String>,
            pub primary_chf_instance_id: Vec<uuid::Uuid>,
            pub secondary_chf_set_id: Vec<String>,
            pub secondary_chf_instance_id: Vec<uuid::Uuid>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ChargingInformation".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "primaryChfAddress" => intermediate_rep.primary_chf_address.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "secondaryChfAddress" => intermediate_rep.secondary_chf_address.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "primaryChfSetId" => intermediate_rep.primary_chf_set_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "primaryChfInstanceId" => intermediate_rep.primary_chf_instance_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "secondaryChfSetId" => intermediate_rep.secondary_chf_set_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "secondaryChfInstanceId" => intermediate_rep.secondary_chf_instance_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ChargingInformation".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChargingInformation {
            primary_chf_address: intermediate_rep
                .primary_chf_address
                .into_iter()
                .next()
                .ok_or_else(|| "primaryChfAddress missing in ChargingInformation".to_string())?,
            secondary_chf_address: intermediate_rep.secondary_chf_address.into_iter().next(),
            primary_chf_set_id: intermediate_rep.primary_chf_set_id.into_iter().next(),
            primary_chf_instance_id: intermediate_rep.primary_chf_instance_id.into_iter().next(),
            secondary_chf_set_id: intermediate_rep.secondary_chf_set_id.into_iter().next(),
            secondary_chf_instance_id: intermediate_rep
                .secondary_chf_instance_id
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChargingInformation> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ChargingInformation>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ChargingInformation>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ChargingInformation - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ChargingInformation>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ChargingInformation as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ChargingInformation - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// SMF derived CN assisted RAN parameters tuning
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CnAssistedRanPara {
    #[serde(rename = "stationaryIndication")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stationary_indication: Option<models::StationaryIndication>,

    /// indicating a time in seconds.
    #[serde(rename = "communicationDurationTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub communication_duration_time: Option<i32>,

    /// indicating a time in seconds.
    #[serde(rename = "periodicTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub periodic_time: Option<i32>,

    #[serde(rename = "scheduledCommunicationTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scheduled_communication_time: Option<models::ScheduledCommunicationTime>,

    #[serde(rename = "scheduledCommunicationType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scheduled_communication_type: Option<models::ScheduledCommunicationType>,

    #[serde(rename = "trafficProfile")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub traffic_profile: Option<models::TrafficProfile>,

    #[serde(rename = "batteryIndication")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub battery_indication: Option<models::BatteryIndication>,
}

impl CnAssistedRanPara {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CnAssistedRanPara {
        CnAssistedRanPara {
            stationary_indication: None,
            communication_duration_time: None,
            periodic_time: None,
            scheduled_communication_time: None,
            scheduled_communication_type: None,
            traffic_profile: None,
            battery_indication: None,
        }
    }
}

/// Converts the CnAssistedRanPara value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CnAssistedRanPara {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping stationaryIndication in query parameter serialization
            self.communication_duration_time
                .as_ref()
                .map(|communication_duration_time| {
                    vec![
                        "communicationDurationTime".to_string(),
                        communication_duration_time.to_string(),
                    ]
                    .join(",")
                }),
            self.periodic_time.as_ref().map(|periodic_time| {
                vec!["periodicTime".to_string(), periodic_time.to_string()].join(",")
            }),
            // Skipping scheduledCommunicationTime in query parameter serialization

            // Skipping scheduledCommunicationType in query parameter serialization

            // Skipping trafficProfile in query parameter serialization

            // Skipping batteryIndication in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CnAssistedRanPara value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CnAssistedRanPara {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub stationary_indication: Vec<models::StationaryIndication>,
            pub communication_duration_time: Vec<i32>,
            pub periodic_time: Vec<i32>,
            pub scheduled_communication_time: Vec<models::ScheduledCommunicationTime>,
            pub scheduled_communication_type: Vec<models::ScheduledCommunicationType>,
            pub traffic_profile: Vec<models::TrafficProfile>,
            pub battery_indication: Vec<models::BatteryIndication>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing CnAssistedRanPara".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "stationaryIndication" => intermediate_rep.stationary_indication.push(
                        <models::StationaryIndication as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "communicationDurationTime" => {
                        intermediate_rep.communication_duration_time.push(
                            <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "periodicTime" => intermediate_rep.periodic_time.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "scheduledCommunicationTime" => {
                        intermediate_rep.scheduled_communication_time.push(
                            <models::ScheduledCommunicationTime as std::str::FromStr>::from_str(
                                val,
                            )
                            .map_err(|x| x.to_string())?,
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "scheduledCommunicationType" => {
                        intermediate_rep.scheduled_communication_type.push(
                            <models::ScheduledCommunicationType as std::str::FromStr>::from_str(
                                val,
                            )
                            .map_err(|x| x.to_string())?,
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "trafficProfile" => intermediate_rep.traffic_profile.push(
                        <models::TrafficProfile as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "batteryIndication" => intermediate_rep.battery_indication.push(
                        <models::BatteryIndication as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing CnAssistedRanPara".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CnAssistedRanPara {
            stationary_indication: intermediate_rep.stationary_indication.into_iter().next(),
            communication_duration_time: intermediate_rep
                .communication_duration_time
                .into_iter()
                .next(),
            periodic_time: intermediate_rep.periodic_time.into_iter().next(),
            scheduled_communication_time: intermediate_rep
                .scheduled_communication_time
                .into_iter()
                .next(),
            scheduled_communication_type: intermediate_rep
                .scheduled_communication_type
                .into_iter()
                .next(),
            traffic_profile: intermediate_rep.traffic_profile.into_iter().next(),
            battery_indication: intermediate_rep.battery_indication.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CnAssistedRanPara> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CnAssistedRanPara>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<CnAssistedRanPara>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for CnAssistedRanPara - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<CnAssistedRanPara>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <CnAssistedRanPara as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into CnAssistedRanPara - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// string with format 'date-time' as defined in OpenAPI.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DateTime(chrono::DateTime<chrono::Utc>);

impl std::convert::From<chrono::DateTime<chrono::Utc>> for DateTime {
    fn from(x: chrono::DateTime<chrono::Utc>) -> Self {
        DateTime(x)
    }
}

impl std::convert::From<DateTime> for chrono::DateTime<chrono::Utc> {
    fn from(x: DateTime) -> Self {
        x.0
    }
}

impl std::ops::Deref for DateTime {
    type Target = chrono::DateTime<chrono::Utc>;
    fn deref(&self) -> &chrono::DateTime<chrono::Utc> {
        &self.0
    }
}

impl std::ops::DerefMut for DateTime {
    fn deref_mut(&mut self) -> &mut chrono::DateTime<chrono::Utc> {
        &mut self.0
    }
}

/// integer between and including 1 and 7 denoting a weekday. 1 shall indicate Monday, and the subsequent weekdays  shall be indicated with the next higher numbers. 7 shall indicate Sunday.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DayOfWeek(i32);

impl std::convert::From<i32> for DayOfWeek {
    fn from(x: i32) -> Self {
        DayOfWeek(x)
    }
}

impl std::convert::From<DayOfWeek> for i32 {
    fn from(x: DayOfWeek) -> Self {
        x.0
    }
}

impl std::ops::Deref for DayOfWeek {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for DayOfWeek {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// Contains a Traffic Descriptor.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DddTrafficDescriptor {
    /// String identifying a IPv4 address formatted in the 'dotted decimal' notation as defined in RFC 1166.
    #[serde(rename = "ipv4Addr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv4_addr: Option<String>,

    #[serde(rename = "ipv6Addr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_addr: Option<models::Ipv6Addr>,

    /// Unsigned Integer, i.e. only value 0 and integers above 0 are permissible.
    #[serde(rename = "portNumber")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub port_number: Option<u32>,

    /// String identifying a MAC address formatted in the hexadecimal notation according to clause 1.1 and clause 2.1 of RFC 7042.
    #[serde(rename = "macAddr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mac_addr: Option<String>,
}

impl DddTrafficDescriptor {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DddTrafficDescriptor {
        DddTrafficDescriptor {
            ipv4_addr: None,
            ipv6_addr: None,
            port_number: None,
            mac_addr: None,
        }
    }
}

/// Converts the DddTrafficDescriptor value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DddTrafficDescriptor {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.ipv4_addr
                .as_ref()
                .map(|ipv4_addr| vec!["ipv4Addr".to_string(), ipv4_addr.to_string()].join(",")),
            // Skipping ipv6Addr in query parameter serialization
            self.port_number.as_ref().map(|port_number| {
                vec!["portNumber".to_string(), port_number.to_string()].join(",")
            }),
            self.mac_addr
                .as_ref()
                .map(|mac_addr| vec!["macAddr".to_string(), mac_addr.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DddTrafficDescriptor value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DddTrafficDescriptor {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ipv4_addr: Vec<String>,
            pub ipv6_addr: Vec<models::Ipv6Addr>,
            pub port_number: Vec<u32>,
            pub mac_addr: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing DddTrafficDescriptor".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ipv4Addr" => intermediate_rep.ipv4_addr.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ipv6Addr" => intermediate_rep.ipv6_addr.push(
                        <models::Ipv6Addr as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "portNumber" => intermediate_rep.port_number.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "macAddr" => intermediate_rep.mac_addr.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing DddTrafficDescriptor".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DddTrafficDescriptor {
            ipv4_addr: intermediate_rep.ipv4_addr.into_iter().next(),
            ipv6_addr: intermediate_rep.ipv6_addr.into_iter().next(),
            port_number: intermediate_rep.port_number.into_iter().next(),
            mac_addr: intermediate_rep.mac_addr.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DddTrafficDescriptor> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DddTrafficDescriptor>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<DddTrafficDescriptor>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for DddTrafficDescriptor - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<DddTrafficDescriptor>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <DddTrafficDescriptor as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into DddTrafficDescriptor - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// DDN Failure Subscription Information
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DdnFailureSubInfo {
    #[serde(rename = "notifyCorrelationId")]
    pub notify_correlation_id: String,

    #[serde(rename = "dddTrafficDescriptorList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ddd_traffic_descriptor_list: Option<Vec<models::DddTrafficDescriptor>>,
}

impl DdnFailureSubInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(notify_correlation_id: String) -> DdnFailureSubInfo {
        DdnFailureSubInfo {
            notify_correlation_id,
            ddd_traffic_descriptor_list: None,
        }
    }
}

/// Converts the DdnFailureSubInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DdnFailureSubInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("notifyCorrelationId".to_string()),
            Some(self.notify_correlation_id.to_string()),
            // Skipping dddTrafficDescriptorList in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DdnFailureSubInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DdnFailureSubInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub notify_correlation_id: Vec<String>,
            pub ddd_traffic_descriptor_list: Vec<Vec<models::DddTrafficDescriptor>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing DdnFailureSubInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "notifyCorrelationId" => intermediate_rep.notify_correlation_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "dddTrafficDescriptorList" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in DdnFailureSubInfo"
                            .to_string(),
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing DdnFailureSubInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DdnFailureSubInfo {
            notify_correlation_id: intermediate_rep
                .notify_correlation_id
                .into_iter()
                .next()
                .ok_or_else(|| "notifyCorrelationId missing in DdnFailureSubInfo".to_string())?,
            ddd_traffic_descriptor_list: intermediate_rep
                .ddd_traffic_descriptor_list
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DdnFailureSubInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DdnFailureSubInfo>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<DdnFailureSubInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for DdnFailureSubInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<DdnFailureSubInfo>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <DdnFailureSubInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into DdnFailureSubInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// DDN Failure Subscription
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DdnFailureSubs {
    #[serde(rename = "ddnFailureSubsInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ddn_failure_subs_ind: Option<bool>,

    #[serde(rename = "ddnFailureSubsInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ddn_failure_subs_info_list: Option<Vec<models::DdnFailureSubInfo>>,
}

impl DdnFailureSubs {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DdnFailureSubs {
        DdnFailureSubs {
            ddn_failure_subs_ind: Some(false),
            ddn_failure_subs_info_list: None,
        }
    }
}

/// Converts the DdnFailureSubs value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DdnFailureSubs {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.ddn_failure_subs_ind
                .as_ref()
                .map(|ddn_failure_subs_ind| {
                    vec![
                        "ddnFailureSubsInd".to_string(),
                        ddn_failure_subs_ind.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping ddnFailureSubsInfoList in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DdnFailureSubs value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DdnFailureSubs {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ddn_failure_subs_ind: Vec<bool>,
            pub ddn_failure_subs_info_list: Vec<Vec<models::DdnFailureSubInfo>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing DdnFailureSubs".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ddnFailureSubsInd" => intermediate_rep.ddn_failure_subs_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "ddnFailureSubsInfoList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in DdnFailureSubs"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing DdnFailureSubs".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DdnFailureSubs {
            ddn_failure_subs_ind: intermediate_rep.ddn_failure_subs_ind.into_iter().next(),
            ddn_failure_subs_info_list: intermediate_rep
                .ddn_failure_subs_info_list
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DdnFailureSubs> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DdnFailureSubs>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<DdnFailureSubs>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for DdnFailureSubs - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DdnFailureSubs> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <DdnFailureSubs as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into DdnFailureSubs - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// DNAI (Data network access identifier), see clause 5.6.7 of 3GPP TS 23.501.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Dnai(String);

impl std::convert::From<String> for Dnai {
    fn from(x: String) -> Self {
        Dnai(x)
    }
}

impl std::string::ToString for Dnai {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Dnai {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Dnai(x.to_string()))
    }
}

impl std::convert::From<Dnai> for String {
    fn from(x: Dnai) -> Self {
        x.0
    }
}

impl std::ops::Deref for Dnai {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Dnai {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// DNAI Information
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DnaiInformation {
    /// DNAI (Data network access identifier), see clause 5.6.7 of 3GPP TS 23.501.
    #[serde(rename = "dnai")]
    pub dnai: String,

    #[serde(rename = "noDnaiChangeInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub no_dnai_change_ind: Option<bool>,

    #[serde(rename = "noLocalPsaChangeInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub no_local_psa_change_ind: Option<bool>,
}

impl DnaiInformation {
    #[allow(clippy::new_without_default)]
    pub fn new(dnai: String) -> DnaiInformation {
        DnaiInformation {
            dnai,
            no_dnai_change_ind: None,
            no_local_psa_change_ind: None,
        }
    }
}

/// Converts the DnaiInformation value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DnaiInformation {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("dnai".to_string()),
            Some(self.dnai.to_string()),
            self.no_dnai_change_ind.as_ref().map(|no_dnai_change_ind| {
                vec![
                    "noDnaiChangeInd".to_string(),
                    no_dnai_change_ind.to_string(),
                ]
                .join(",")
            }),
            self.no_local_psa_change_ind
                .as_ref()
                .map(|no_local_psa_change_ind| {
                    vec![
                        "noLocalPsaChangeInd".to_string(),
                        no_local_psa_change_ind.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DnaiInformation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DnaiInformation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub dnai: Vec<String>,
            pub no_dnai_change_ind: Vec<bool>,
            pub no_local_psa_change_ind: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing DnaiInformation".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "dnai" => intermediate_rep.dnai.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "noDnaiChangeInd" => intermediate_rep.no_dnai_change_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "noLocalPsaChangeInd" => intermediate_rep.no_local_psa_change_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing DnaiInformation".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DnaiInformation {
            dnai: intermediate_rep
                .dnai
                .into_iter()
                .next()
                .ok_or_else(|| "dnai missing in DnaiInformation".to_string())?,
            no_dnai_change_ind: intermediate_rep.no_dnai_change_ind.into_iter().next(),
            no_local_psa_change_ind: intermediate_rep.no_local_psa_change_ind.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DnaiInformation> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DnaiInformation>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<DnaiInformation>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for DnaiInformation - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<DnaiInformation>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <DnaiInformation as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into DnaiInformation - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// String representing a Data Network as defined in clause 9A of 3GPP TS 23.003;  it shall contain either a DNN Network Identifier, or a full DNN with both the Network  Identifier and Operator Identifier, as specified in 3GPP TS 23.003 clause 9.1.1 and 9.1.2. It shall be coded as string in which the labels are separated by dots  (e.g. \"Label1.Label2.Label3\").
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Dnn(String);

impl std::convert::From<String> for Dnn {
    fn from(x: String) -> Self {
        Dnn(x)
    }
}

impl std::string::ToString for Dnn {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Dnn {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Dnn(x.to_string()))
    }
}

impl std::convert::From<Dnn> for String {
    fn from(x: Dnn) -> Self {
        x.0
    }
}

impl std::ops::Deref for Dnn {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Dnn {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// DNN Selection Mode. Possible values are - VERIFIED - UE_DNN_NOT_VERIFIED - NW_DNN_NOT_VERIFIED
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DnnSelectionMode {}

impl DnnSelectionMode {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DnnSelectionMode {
        DnnSelectionMode {}
    }
}

/// Converts the DnnSelectionMode value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DnnSelectionMode {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DnnSelectionMode value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DnnSelectionMode {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing DnnSelectionMode".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing DnnSelectionMode".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DnnSelectionMode {})
    }
}

// Methods for converting between header::IntoHeaderValue<DnnSelectionMode> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DnnSelectionMode>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<DnnSelectionMode>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for DnnSelectionMode - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<DnnSelectionMode>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <DnnSelectionMode as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into DnnSelectionMode - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum DnnSelectionModeAnyOf {
    #[serde(rename = "VERIFIED")]
    Verified,
    #[serde(rename = "UE_DNN_NOT_VERIFIED")]
    UeDnnNotVerified,
    #[serde(rename = "NW_DNN_NOT_VERIFIED")]
    NwDnnNotVerified,
}

impl std::fmt::Display for DnnSelectionModeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            DnnSelectionModeAnyOf::Verified => write!(f, "VERIFIED"),
            DnnSelectionModeAnyOf::UeDnnNotVerified => write!(f, "UE_DNN_NOT_VERIFIED"),
            DnnSelectionModeAnyOf::NwDnnNotVerified => write!(f, "NW_DNN_NOT_VERIFIED"),
        }
    }
}

impl std::str::FromStr for DnnSelectionModeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "VERIFIED" => std::result::Result::Ok(DnnSelectionModeAnyOf::Verified),
            "UE_DNN_NOT_VERIFIED" => {
                std::result::Result::Ok(DnnSelectionModeAnyOf::UeDnnNotVerified)
            }
            "NW_DNN_NOT_VERIFIED" => {
                std::result::Result::Ok(DnnSelectionModeAnyOf::NwDnnNotVerified)
            }
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Data Radio Bearer Identity
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DrbId(i32);

impl std::convert::From<i32> for DrbId {
    fn from(x: i32) -> Self {
        DrbId(x)
    }
}

impl std::convert::From<DrbId> for i32 {
    fn from(x: DrbId) -> Self {
        x.0
    }
}

impl std::ops::Deref for DrbId {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for DrbId {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// indicating a time in seconds.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DurationSec(i32);

impl std::convert::From<i32> for DurationSec {
    fn from(x: i32) -> Self {
        DurationSec(x)
    }
}

impl std::convert::From<DurationSec> for i32 {
    fn from(x: DurationSec) -> Self {
        x.0
    }
}

impl std::ops::Deref for DurationSec {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for DurationSec {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// It indicates the QoS Characteristics for a Non-standardised or not pre-configured 5QI for downlink and uplink.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Dynamic5Qi {
    #[serde(rename = "resourceType")]
    pub resource_type: models::QosResourceType,

    /// Unsigned integer indicating the 5QI Priority Level (see clauses 5.7.3.3 and 5.7.4 of 3GPP TS 23.501, within the range 1 to 127.Values are ordered in decreasing order of priority,  i.e. with 1 as the highest priority and 127 as the lowest priority.
    #[serde(rename = "priorityLevel")]
    pub priority_level: u8,

    /// Unsigned integer indicating Packet Delay Budget (see clauses 5.7.3.4 and 5.7.4 of 3GPP TS 23.501), expressed in milliseconds.
    #[serde(rename = "packetDelayBudget")]
    pub packet_delay_budget: u32,

    /// String representing Packet Error Rate (see clause 5.7.3.5 and 5.7.4 of 3GPP TS 23.501, expressed as a \"scalar x 10-k\" where the scalar and the exponent k are each encoded as one decimal digit.
    #[serde(rename = "packetErrRate")]
    pub packet_err_rate: String,

    /// Unsigned integer indicating Averaging Window (see clause 5.7.3.6 and 5.7.4 of 3GPP TS 23.501), expressed in milliseconds.
    #[serde(rename = "averWindow")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aver_window: Option<u16>,

    /// Unsigned integer indicating Maximum Data Burst Volume (see clauses 5.7.3.7 and 5.7.4 of 3GPP TS 23.501), expressed in Bytes.
    #[serde(rename = "maxDataBurstVol")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_data_burst_vol: Option<u16>,

    /// Unsigned integer indicating Maximum Data Burst Volume (see clauses 5.7.3.7 and 5.7.4 of 3GPP TS 23.501), expressed in Bytes.
    #[serde(rename = "extMaxDataBurstVol")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ext_max_data_burst_vol: Option<u32>,

    /// Unsigned integer indicating Packet Delay Budget (see clauses 5.7.3.4 and 5.7.4 of 3GPP TS 23.501 [8])), expressed in 0.01 milliseconds.
    #[serde(rename = "extPacketDelBudget")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ext_packet_del_budget: Option<u32>,

    /// Unsigned integer indicating Packet Delay Budget (see clauses 5.7.3.4 and 5.7.4 of 3GPP TS 23.501 [8])), expressed in 0.01 milliseconds.
    #[serde(rename = "cnPacketDelayBudgetDl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cn_packet_delay_budget_dl: Option<u32>,

    /// Unsigned integer indicating Packet Delay Budget (see clauses 5.7.3.4 and 5.7.4 of 3GPP TS 23.501 [8])), expressed in 0.01 milliseconds.
    #[serde(rename = "cnPacketDelayBudgetUl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cn_packet_delay_budget_ul: Option<u32>,
}

impl Dynamic5Qi {
    #[allow(clippy::new_without_default)]
    pub fn new(
        resource_type: models::QosResourceType,
        priority_level: u8,
        packet_delay_budget: u32,
        packet_err_rate: String,
    ) -> Dynamic5Qi {
        Dynamic5Qi {
            resource_type,
            priority_level,
            packet_delay_budget,
            packet_err_rate,
            aver_window: Some(2000),
            max_data_burst_vol: None,
            ext_max_data_burst_vol: None,
            ext_packet_del_budget: None,
            cn_packet_delay_budget_dl: None,
            cn_packet_delay_budget_ul: None,
        }
    }
}

/// Converts the Dynamic5Qi value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Dynamic5Qi {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping resourceType in query parameter serialization
            Some("priorityLevel".to_string()),
            Some(self.priority_level.to_string()),
            Some("packetDelayBudget".to_string()),
            Some(self.packet_delay_budget.to_string()),
            Some("packetErrRate".to_string()),
            Some(self.packet_err_rate.to_string()),
            self.aver_window.as_ref().map(|aver_window| {
                vec!["averWindow".to_string(), aver_window.to_string()].join(",")
            }),
            self.max_data_burst_vol.as_ref().map(|max_data_burst_vol| {
                vec![
                    "maxDataBurstVol".to_string(),
                    max_data_burst_vol.to_string(),
                ]
                .join(",")
            }),
            self.ext_max_data_burst_vol
                .as_ref()
                .map(|ext_max_data_burst_vol| {
                    vec![
                        "extMaxDataBurstVol".to_string(),
                        ext_max_data_burst_vol.to_string(),
                    ]
                    .join(",")
                }),
            self.ext_packet_del_budget
                .as_ref()
                .map(|ext_packet_del_budget| {
                    vec![
                        "extPacketDelBudget".to_string(),
                        ext_packet_del_budget.to_string(),
                    ]
                    .join(",")
                }),
            self.cn_packet_delay_budget_dl
                .as_ref()
                .map(|cn_packet_delay_budget_dl| {
                    vec![
                        "cnPacketDelayBudgetDl".to_string(),
                        cn_packet_delay_budget_dl.to_string(),
                    ]
                    .join(",")
                }),
            self.cn_packet_delay_budget_ul
                .as_ref()
                .map(|cn_packet_delay_budget_ul| {
                    vec![
                        "cnPacketDelayBudgetUl".to_string(),
                        cn_packet_delay_budget_ul.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Dynamic5Qi value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Dynamic5Qi {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub resource_type: Vec<models::QosResourceType>,
            pub priority_level: Vec<u8>,
            pub packet_delay_budget: Vec<u32>,
            pub packet_err_rate: Vec<String>,
            pub aver_window: Vec<u16>,
            pub max_data_burst_vol: Vec<u16>,
            pub ext_max_data_burst_vol: Vec<u32>,
            pub ext_packet_del_budget: Vec<u32>,
            pub cn_packet_delay_budget_dl: Vec<u32>,
            pub cn_packet_delay_budget_ul: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Dynamic5Qi".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "resourceType" => intermediate_rep.resource_type.push(
                        <models::QosResourceType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "priorityLevel" => intermediate_rep
                        .priority_level
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "packetDelayBudget" => intermediate_rep.packet_delay_budget.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "packetErrRate" => intermediate_rep.packet_err_rate.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "averWindow" => intermediate_rep.aver_window.push(
                        <u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "maxDataBurstVol" => intermediate_rep.max_data_burst_vol.push(
                        <u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "extMaxDataBurstVol" => intermediate_rep.ext_max_data_burst_vol.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "extPacketDelBudget" => intermediate_rep.ext_packet_del_budget.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "cnPacketDelayBudgetDl" => intermediate_rep.cn_packet_delay_budget_dl.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "cnPacketDelayBudgetUl" => intermediate_rep.cn_packet_delay_budget_ul.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Dynamic5Qi".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Dynamic5Qi {
            resource_type: intermediate_rep
                .resource_type
                .into_iter()
                .next()
                .ok_or_else(|| "resourceType missing in Dynamic5Qi".to_string())?,
            priority_level: intermediate_rep
                .priority_level
                .into_iter()
                .next()
                .ok_or_else(|| "priorityLevel missing in Dynamic5Qi".to_string())?,
            packet_delay_budget: intermediate_rep
                .packet_delay_budget
                .into_iter()
                .next()
                .ok_or_else(|| "packetDelayBudget missing in Dynamic5Qi".to_string())?,
            packet_err_rate: intermediate_rep
                .packet_err_rate
                .into_iter()
                .next()
                .ok_or_else(|| "packetErrRate missing in Dynamic5Qi".to_string())?,
            aver_window: intermediate_rep.aver_window.into_iter().next(),
            max_data_burst_vol: intermediate_rep.max_data_burst_vol.into_iter().next(),
            ext_max_data_burst_vol: intermediate_rep.ext_max_data_burst_vol.into_iter().next(),
            ext_packet_del_budget: intermediate_rep.ext_packet_del_budget.into_iter().next(),
            cn_packet_delay_budget_dl: intermediate_rep
                .cn_packet_delay_budget_dl
                .into_iter()
                .next(),
            cn_packet_delay_budget_ul: intermediate_rep
                .cn_packet_delay_budget_ul
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Dynamic5Qi> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Dynamic5Qi>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Dynamic5Qi>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Dynamic5Qi - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Dynamic5Qi> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <Dynamic5Qi as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into Dynamic5Qi - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// EBI to ARP mapping
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EbiArpMapping {
    /// EPS Bearer Identifier
    #[serde(rename = "epsBearerId")]
    pub eps_bearer_id: u8,

    #[serde(rename = "arp")]
    pub arp: models::Arp,
}

impl EbiArpMapping {
    #[allow(clippy::new_without_default)]
    pub fn new(eps_bearer_id: u8, arp: models::Arp) -> EbiArpMapping {
        EbiArpMapping { eps_bearer_id, arp }
    }
}

/// Converts the EbiArpMapping value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EbiArpMapping {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("epsBearerId".to_string()),
            Some(self.eps_bearer_id.to_string()),
            // Skipping arp in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EbiArpMapping value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EbiArpMapping {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub eps_bearer_id: Vec<u8>,
            pub arp: Vec<models::Arp>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing EbiArpMapping".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "epsBearerId" => intermediate_rep
                        .eps_bearer_id
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "arp" => intermediate_rep.arp.push(
                        <models::Arp as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing EbiArpMapping".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EbiArpMapping {
            eps_bearer_id: intermediate_rep
                .eps_bearer_id
                .into_iter()
                .next()
                .ok_or_else(|| "epsBearerId missing in EbiArpMapping".to_string())?,
            arp: intermediate_rep
                .arp
                .into_iter()
                .next()
                .ok_or_else(|| "arp missing in EbiArpMapping".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EbiArpMapping> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<EbiArpMapping>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<EbiArpMapping>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for EbiArpMapping - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<EbiArpMapping> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <EbiArpMapping as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into EbiArpMapping - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains the ECGI (E-UTRAN Cell Global Identity), as described in 3GPP 23.003
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Ecgi {
    #[serde(rename = "plmnId")]
    pub plmn_id: models::PlmnId,

    /// 28-bit string identifying an E-UTRA Cell Id as specified in clause 9.3.1.9 of  3GPP TS 38.413, in hexadecimal representation. Each character in the string shall take a  value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most  significant character representing the 4 most significant bits of the Cell Id shall appear  first in the string, and the character representing the 4 least significant bit of the  Cell Id shall appear last in the string.
    #[serde(rename = "eutraCellId")]
    pub eutra_cell_id: String,

    /// This represents the Network Identifier, which together with a PLMN ID is used to identify an SNPN (see 3GPP TS 23.003 and 3GPP TS 23.501 clause 5.30.2.1).
    #[serde(rename = "nid")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nid: Option<String>,
}

impl Ecgi {
    #[allow(clippy::new_without_default)]
    pub fn new(plmn_id: models::PlmnId, eutra_cell_id: String) -> Ecgi {
        Ecgi {
            plmn_id,
            eutra_cell_id,
            nid: None,
        }
    }
}

/// Converts the Ecgi value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Ecgi {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping plmnId in query parameter serialization
            Some("eutraCellId".to_string()),
            Some(self.eutra_cell_id.to_string()),
            self.nid
                .as_ref()
                .map(|nid| vec!["nid".to_string(), nid.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Ecgi value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Ecgi {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub plmn_id: Vec<models::PlmnId>,
            pub eutra_cell_id: Vec<String>,
            pub nid: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err("Missing value while parsing Ecgi".to_string())
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "plmnId" => intermediate_rep.plmn_id.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "eutraCellId" => intermediate_rep.eutra_cell_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nid" => intermediate_rep.nid.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Ecgi".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Ecgi {
            plmn_id: intermediate_rep
                .plmn_id
                .into_iter()
                .next()
                .ok_or_else(|| "plmnId missing in Ecgi".to_string())?,
            eutra_cell_id: intermediate_rep
                .eutra_cell_id
                .into_iter()
                .next()
                .ok_or_else(|| "eutraCellId missing in Ecgi".to_string())?,
            nid: intermediate_rep.nid.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Ecgi> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Ecgi>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Ecgi>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Ecgi - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Ecgi> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Ecgi as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Ecgi - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// This represents the identifier of the eNB ID as specified in clause 9.2.1.37 of  3GPP TS 36.413. The string shall be formatted with the following pattern  '^('MacroeNB-[A-Fa-f0-9]{5}|LMacroeNB-[A-Fa-f0-9]{6}|SMacroeNB-[A-Fa-f0-9]{5} |HomeeNB-[A-Fa-f0-9]{7})$'. The value of the eNB ID shall be encoded in hexadecimal representation. Each character in the  string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits.  The padding 0 shall be added to make multiple nibbles, so the most significant character  representing the padding 0 if required together with the 4 most significant bits of the eNB ID  shall appear first in the string, and the character representing the 4 least significant bit  of the eNB ID (to form a nibble) shall appear last in the string.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EnbId(String);

impl std::convert::From<String> for EnbId {
    fn from(x: String) -> Self {
        EnbId(x)
    }
}

impl std::string::ToString for EnbId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for EnbId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(EnbId(x.to_string()))
    }
}

impl std::convert::From<EnbId> for String {
    fn from(x: EnbId) -> Self {
        x.0
    }
}

impl std::ops::Deref for EnbId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for EnbId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// EPS Bearer container from SMF to AMF
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EpsBearerContainer(String);

impl std::convert::From<String> for EpsBearerContainer {
    fn from(x: String) -> Self {
        EpsBearerContainer(x)
    }
}

impl std::string::ToString for EpsBearerContainer {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for EpsBearerContainer {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(EpsBearerContainer(x.to_string()))
    }
}

impl std::convert::From<EpsBearerContainer> for String {
    fn from(x: EpsBearerContainer) -> Self {
        x.0
    }
}

impl std::ops::Deref for EpsBearerContainer {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for EpsBearerContainer {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// EPS bearer context status
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EpsBearerContextStatus(String);

impl std::convert::From<String> for EpsBearerContextStatus {
    fn from(x: String) -> Self {
        EpsBearerContextStatus(x)
    }
}

impl std::string::ToString for EpsBearerContextStatus {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for EpsBearerContextStatus {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(EpsBearerContextStatus(x.to_string()))
    }
}

impl std::convert::From<EpsBearerContextStatus> for String {
    fn from(x: EpsBearerContextStatus) -> Self {
        x.0
    }
}

impl std::ops::Deref for EpsBearerContextStatus {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for EpsBearerContextStatus {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// EPS Bearer Identifier
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EpsBearerId(i32);

impl std::convert::From<i32> for EpsBearerId {
    fn from(x: i32) -> Self {
        EpsBearerId(x)
    }
}

impl std::convert::From<EpsBearerId> for i32 {
    fn from(x: EpsBearerId) -> Self {
        x.0
    }
}

impl std::ops::Deref for EpsBearerId {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for EpsBearerId {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// EPS Bearer Information from H-SMF to V-SMF, or from SMF to I-SMF
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EpsBearerInfo {
    /// EPS Bearer Identifier
    #[serde(rename = "ebi")]
    pub ebi: u8,

    /// string with format 'bytes' as defined in OpenAPI
    #[serde(rename = "pgwS8uFteid")]
    pub pgw_s8u_fteid: swagger::ByteArray,

    /// string with format 'bytes' as defined in OpenAPI
    #[serde(rename = "bearerLevelQoS")]
    pub bearer_level_qo_s: swagger::ByteArray,
}

impl EpsBearerInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(
        ebi: u8,
        pgw_s8u_fteid: swagger::ByteArray,
        bearer_level_qo_s: swagger::ByteArray,
    ) -> EpsBearerInfo {
        EpsBearerInfo {
            ebi,
            pgw_s8u_fteid,
            bearer_level_qo_s,
        }
    }
}

/// Converts the EpsBearerInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EpsBearerInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("ebi".to_string()),
            Some(self.ebi.to_string()),
            // Skipping pgwS8uFteid in query parameter serialization
            // Skipping pgwS8uFteid in query parameter serialization

            // Skipping bearerLevelQoS in query parameter serialization
            // Skipping bearerLevelQoS in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EpsBearerInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EpsBearerInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ebi: Vec<u8>,
            pub pgw_s8u_fteid: Vec<swagger::ByteArray>,
            pub bearer_level_qo_s: Vec<swagger::ByteArray>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing EpsBearerInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ebi" => intermediate_rep
                        .ebi
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "pgwS8uFteid" => {
                        return std::result::Result::Err(
                            "Parsing binary data in this style is not supported in EpsBearerInfo"
                                .to_string(),
                        )
                    }
                    "bearerLevelQoS" => {
                        return std::result::Result::Err(
                            "Parsing binary data in this style is not supported in EpsBearerInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing EpsBearerInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EpsBearerInfo {
            ebi: intermediate_rep
                .ebi
                .into_iter()
                .next()
                .ok_or_else(|| "ebi missing in EpsBearerInfo".to_string())?,
            pgw_s8u_fteid: intermediate_rep
                .pgw_s8u_fteid
                .into_iter()
                .next()
                .ok_or_else(|| "pgwS8uFteid missing in EpsBearerInfo".to_string())?,
            bearer_level_qo_s: intermediate_rep
                .bearer_level_qo_s
                .into_iter()
                .next()
                .ok_or_else(|| "bearerLevelQoS missing in EpsBearerInfo".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EpsBearerInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<EpsBearerInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<EpsBearerInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for EpsBearerInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<EpsBearerInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <EpsBearerInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into EpsBearerInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// EPS Interworking Indication. Possible values are - NONE - WITH_N26 - WITHOUT_N26 - IWK_NON_3GPP
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EpsInterworkingIndication {}

impl EpsInterworkingIndication {
    #[allow(clippy::new_without_default)]
    pub fn new() -> EpsInterworkingIndication {
        EpsInterworkingIndication {}
    }
}

/// Converts the EpsInterworkingIndication value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EpsInterworkingIndication {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EpsInterworkingIndication value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EpsInterworkingIndication {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing EpsInterworkingIndication".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing EpsInterworkingIndication".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EpsInterworkingIndication {})
    }
}

// Methods for converting between header::IntoHeaderValue<EpsInterworkingIndication> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<EpsInterworkingIndication>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<EpsInterworkingIndication>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for EpsInterworkingIndication - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<EpsInterworkingIndication>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <EpsInterworkingIndication as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into EpsInterworkingIndication - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum EpsInterworkingIndicationAnyOf {
    #[serde(rename = "NONE")]
    None,
    #[serde(rename = "WITH_N26")]
    WithN26,
    #[serde(rename = "WITHOUT_N26")]
    WithoutN26,
    #[serde(rename = "IWK_NON_3GPP")]
    IwkNon3Gpp,
}

impl std::fmt::Display for EpsInterworkingIndicationAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            EpsInterworkingIndicationAnyOf::None => write!(f, "NONE"),
            EpsInterworkingIndicationAnyOf::WithN26 => write!(f, "WITH_N26"),
            EpsInterworkingIndicationAnyOf::WithoutN26 => write!(f, "WITHOUT_N26"),
            EpsInterworkingIndicationAnyOf::IwkNon3Gpp => write!(f, "IWK_NON_3GPP"),
        }
    }
}

impl std::str::FromStr for EpsInterworkingIndicationAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "NONE" => std::result::Result::Ok(EpsInterworkingIndicationAnyOf::None),
            "WITH_N26" => std::result::Result::Ok(EpsInterworkingIndicationAnyOf::WithN26),
            "WITHOUT_N26" => std::result::Result::Ok(EpsInterworkingIndicationAnyOf::WithoutN26),
            "IWK_NON_3GPP" => std::result::Result::Ok(EpsInterworkingIndicationAnyOf::IwkNon3Gpp),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// UE EPS PDN Connection container from SMF to AMF
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EpsPdnCnxContainer(String);

impl std::convert::From<String> for EpsPdnCnxContainer {
    fn from(x: String) -> Self {
        EpsPdnCnxContainer(x)
    }
}

impl std::string::ToString for EpsPdnCnxContainer {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for EpsPdnCnxContainer {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(EpsPdnCnxContainer(x.to_string()))
    }
}

impl std::convert::From<EpsPdnCnxContainer> for String {
    fn from(x: EpsPdnCnxContainer) -> Self {
        x.0
    }
}

impl std::ops::Deref for EpsPdnCnxContainer {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for EpsPdnCnxContainer {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// EPS PDN Connection Information from H-SMF to V-SMF, or from SMF to I-SMF
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EpsPdnCnxInfo {
    /// string with format 'bytes' as defined in OpenAPI
    #[serde(rename = "pgwS8cFteid")]
    pub pgw_s8c_fteid: swagger::ByteArray,

    /// string with format 'bytes' as defined in OpenAPI
    #[serde(rename = "pgwNodeName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pgw_node_name: Option<swagger::ByteArray>,

    /// EPS Bearer Identifier
    #[serde(rename = "linkedBearerId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub linked_bearer_id: Option<u8>,
}

impl EpsPdnCnxInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(pgw_s8c_fteid: swagger::ByteArray) -> EpsPdnCnxInfo {
        EpsPdnCnxInfo {
            pgw_s8c_fteid,
            pgw_node_name: None,
            linked_bearer_id: None,
        }
    }
}

/// Converts the EpsPdnCnxInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EpsPdnCnxInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping pgwS8cFteid in query parameter serialization
            // Skipping pgwS8cFteid in query parameter serialization

            // Skipping pgwNodeName in query parameter serialization
            // Skipping pgwNodeName in query parameter serialization
            self.linked_bearer_id.as_ref().map(|linked_bearer_id| {
                vec!["linkedBearerId".to_string(), linked_bearer_id.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EpsPdnCnxInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EpsPdnCnxInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub pgw_s8c_fteid: Vec<swagger::ByteArray>,
            pub pgw_node_name: Vec<swagger::ByteArray>,
            pub linked_bearer_id: Vec<u8>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing EpsPdnCnxInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "pgwS8cFteid" => {
                        return std::result::Result::Err(
                            "Parsing binary data in this style is not supported in EpsPdnCnxInfo"
                                .to_string(),
                        )
                    }
                    "pgwNodeName" => {
                        return std::result::Result::Err(
                            "Parsing binary data in this style is not supported in EpsPdnCnxInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "linkedBearerId" => intermediate_rep
                        .linked_bearer_id
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing EpsPdnCnxInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EpsPdnCnxInfo {
            pgw_s8c_fteid: intermediate_rep
                .pgw_s8c_fteid
                .into_iter()
                .next()
                .ok_or_else(|| "pgwS8cFteid missing in EpsPdnCnxInfo".to_string())?,
            pgw_node_name: intermediate_rep.pgw_node_name.into_iter().next(),
            linked_bearer_id: intermediate_rep.linked_bearer_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EpsPdnCnxInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<EpsPdnCnxInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<EpsPdnCnxInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for EpsPdnCnxInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<EpsPdnCnxInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <EpsPdnCnxInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into EpsPdnCnxInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// 28-bit string identifying an E-UTRA Cell Id as specified in clause 9.3.1.9 of  3GPP TS 38.413, in hexadecimal representation. Each character in the string shall take a  value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most  significant character representing the 4 most significant bits of the Cell Id shall appear  first in the string, and the character representing the 4 least significant bit of the  Cell Id shall appear last in the string.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EutraCellId(String);

impl std::convert::From<String> for EutraCellId {
    fn from(x: String) -> Self {
        EutraCellId(x)
    }
}

impl std::string::ToString for EutraCellId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for EutraCellId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(EutraCellId(x.to_string()))
    }
}

impl std::convert::From<EutraCellId> for String {
    fn from(x: EutraCellId) -> Self {
        x.0
    }
}

impl std::ops::Deref for EutraCellId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for EutraCellId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Contains the E-UTRA user location.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EutraLocation {
    #[serde(rename = "tai")]
    pub tai: models::Tai,

    #[serde(rename = "ignoreTai")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ignore_tai: Option<bool>,

    #[serde(rename = "ecgi")]
    pub ecgi: models::Ecgi,

    /// This flag when present shall indicate that the Ecgi shall be ignored When present, it shall be set as follows: - true: ecgi shall be ignored. - false (default): ecgi shall not be ignored.
    #[serde(rename = "ignoreEcgi")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ignore_ecgi: Option<bool>,

    /// The value represents the elapsed time in minutes since the last network contact of the mobile station.  Value \"0\" indicates that the location information was obtained after a successful paging procedure for Active Location Retrieval when the UE is in idle mode or after a successful NG-RAN location reporting procedure with the eNB when the UE is in connected mode.  Any other value than \"0\" indicates that the location information is the last known one.  See 3GPP TS 29.002 clause 17.7.8.
    #[serde(rename = "ageOfLocationInformation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub age_of_location_information: Option<u16>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "ueLocationTimestamp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_location_timestamp: Option<chrono::DateTime<chrono::Utc>>,

    /// Refer to geographical Information. See 3GPP TS 23.032 clause 7.3.2. Only the description of an ellipsoid point with uncertainty circle is allowed to be used.
    #[serde(rename = "geographicalInformation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub geographical_information: Option<String>,

    /// Refers to Calling Geodetic Location. See ITU-T Recommendation Q.763 (1999) [24] clause 3.88.2. Only the description of an ellipsoid point with uncertainty circle is allowed to be used.
    #[serde(rename = "geodeticInformation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub geodetic_information: Option<String>,

    #[serde(rename = "globalNgenbId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub global_ngenb_id: Option<models::GlobalRanNodeId>,

    #[serde(rename = "globalENbId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub global_enb_id: Option<models::GlobalRanNodeId>,
}

impl EutraLocation {
    #[allow(clippy::new_without_default)]
    pub fn new(tai: models::Tai, ecgi: models::Ecgi) -> EutraLocation {
        EutraLocation {
            tai,
            ignore_tai: Some(false),
            ecgi,
            ignore_ecgi: Some(false),
            age_of_location_information: None,
            ue_location_timestamp: None,
            geographical_information: None,
            geodetic_information: None,
            global_ngenb_id: None,
            global_enb_id: None,
        }
    }
}

/// Converts the EutraLocation value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EutraLocation {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping tai in query parameter serialization
            self.ignore_tai
                .as_ref()
                .map(|ignore_tai| vec!["ignoreTai".to_string(), ignore_tai.to_string()].join(",")),
            // Skipping ecgi in query parameter serialization
            self.ignore_ecgi.as_ref().map(|ignore_ecgi| {
                vec!["ignoreEcgi".to_string(), ignore_ecgi.to_string()].join(",")
            }),
            self.age_of_location_information
                .as_ref()
                .map(|age_of_location_information| {
                    vec![
                        "ageOfLocationInformation".to_string(),
                        age_of_location_information.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping ueLocationTimestamp in query parameter serialization
            self.geographical_information
                .as_ref()
                .map(|geographical_information| {
                    vec![
                        "geographicalInformation".to_string(),
                        geographical_information.to_string(),
                    ]
                    .join(",")
                }),
            self.geodetic_information
                .as_ref()
                .map(|geodetic_information| {
                    vec![
                        "geodeticInformation".to_string(),
                        geodetic_information.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping globalNgenbId in query parameter serialization

            // Skipping globalENbId in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EutraLocation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EutraLocation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub tai: Vec<models::Tai>,
            pub ignore_tai: Vec<bool>,
            pub ecgi: Vec<models::Ecgi>,
            pub ignore_ecgi: Vec<bool>,
            pub age_of_location_information: Vec<u16>,
            pub ue_location_timestamp: Vec<chrono::DateTime<chrono::Utc>>,
            pub geographical_information: Vec<String>,
            pub geodetic_information: Vec<String>,
            pub global_ngenb_id: Vec<models::GlobalRanNodeId>,
            pub global_enb_id: Vec<models::GlobalRanNodeId>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing EutraLocation".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "tai" => intermediate_rep.tai.push(
                        <models::Tai as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ignoreTai" => intermediate_rep.ignore_tai.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ecgi" => intermediate_rep.ecgi.push(
                        <models::Ecgi as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ignoreEcgi" => intermediate_rep.ignore_ecgi.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ageOfLocationInformation" => {
                        intermediate_rep.age_of_location_information.push(
                            <u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "ueLocationTimestamp" => intermediate_rep.ue_location_timestamp.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "geographicalInformation" => intermediate_rep.geographical_information.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "geodeticInformation" => intermediate_rep.geodetic_information.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "globalNgenbId" => intermediate_rep.global_ngenb_id.push(
                        <models::GlobalRanNodeId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "globalENbId" => intermediate_rep.global_enb_id.push(
                        <models::GlobalRanNodeId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing EutraLocation".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EutraLocation {
            tai: intermediate_rep
                .tai
                .into_iter()
                .next()
                .ok_or_else(|| "tai missing in EutraLocation".to_string())?,
            ignore_tai: intermediate_rep.ignore_tai.into_iter().next(),
            ecgi: intermediate_rep
                .ecgi
                .into_iter()
                .next()
                .ok_or_else(|| "ecgi missing in EutraLocation".to_string())?,
            ignore_ecgi: intermediate_rep.ignore_ecgi.into_iter().next(),
            age_of_location_information: intermediate_rep
                .age_of_location_information
                .into_iter()
                .next(),
            ue_location_timestamp: intermediate_rep.ue_location_timestamp.into_iter().next(),
            geographical_information: intermediate_rep.geographical_information.into_iter().next(),
            geodetic_information: intermediate_rep.geodetic_information.into_iter().next(),
            global_ngenb_id: intermediate_rep.global_ngenb_id.into_iter().next(),
            global_enb_id: intermediate_rep.global_enb_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EutraLocation> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<EutraLocation>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<EutraLocation>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for EutraLocation - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<EutraLocation> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <EutraLocation as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into EutraLocation - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Exemption Indication
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ExemptionInd {
    #[serde(rename = "dnnCongestion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dnn_congestion: Option<bool>,

    #[serde(rename = "snssaiOnlyCongestion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub snssai_only_congestion: Option<bool>,

    #[serde(rename = "snssaiDnnCongestion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub snssai_dnn_congestion: Option<bool>,
}

impl ExemptionInd {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ExemptionInd {
        ExemptionInd {
            dnn_congestion: Some(false),
            snssai_only_congestion: Some(false),
            snssai_dnn_congestion: Some(false),
        }
    }
}

/// Converts the ExemptionInd value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ExemptionInd {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.dnn_congestion.as_ref().map(|dnn_congestion| {
                vec!["dnnCongestion".to_string(), dnn_congestion.to_string()].join(",")
            }),
            self.snssai_only_congestion
                .as_ref()
                .map(|snssai_only_congestion| {
                    vec![
                        "snssaiOnlyCongestion".to_string(),
                        snssai_only_congestion.to_string(),
                    ]
                    .join(",")
                }),
            self.snssai_dnn_congestion
                .as_ref()
                .map(|snssai_dnn_congestion| {
                    vec![
                        "snssaiDnnCongestion".to_string(),
                        snssai_dnn_congestion.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ExemptionInd value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ExemptionInd {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub dnn_congestion: Vec<bool>,
            pub snssai_only_congestion: Vec<bool>,
            pub snssai_dnn_congestion: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ExemptionInd".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "dnnCongestion" => intermediate_rep.dnn_congestion.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "snssaiOnlyCongestion" => intermediate_rep.snssai_only_congestion.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "snssaiDnnCongestion" => intermediate_rep.snssai_dnn_congestion.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ExemptionInd".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ExemptionInd {
            dnn_congestion: intermediate_rep.dnn_congestion.into_iter().next(),
            snssai_only_congestion: intermediate_rep.snssai_only_congestion.into_iter().next(),
            snssai_dnn_congestion: intermediate_rep.snssai_dnn_congestion.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ExemptionInd> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ExemptionInd>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ExemptionInd>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ExemptionInd - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ExemptionInd> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ExemptionInd as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ExemptionInd - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Unsigned integer indicating Maximum Data Burst Volume (see clauses 5.7.3.7 and 5.7.4 of 3GPP TS 23.501), expressed in Bytes.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ExtMaxDataBurstVol(i32);

impl std::convert::From<i32> for ExtMaxDataBurstVol {
    fn from(x: i32) -> Self {
        ExtMaxDataBurstVol(x)
    }
}

impl std::convert::From<ExtMaxDataBurstVol> for i32 {
    fn from(x: ExtMaxDataBurstVol) -> Self {
        x.0
    }
}

impl std::ops::Deref for ExtMaxDataBurstVol {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for ExtMaxDataBurstVol {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// Unsigned integer indicating Packet Delay Budget (see clauses 5.7.3.4 and 5.7.4 of 3GPP TS 23.501 [8])), expressed in 0.01 milliseconds.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ExtPacketDelBudget(i32);

impl std::convert::From<i32> for ExtPacketDelBudget {
    fn from(x: i32) -> Self {
        ExtPacketDelBudget(x)
    }
}

impl std::convert::From<ExtPacketDelBudget> for i32 {
    fn from(x: ExtPacketDelBudget) -> Self {
        x.0
    }
}

impl std::ops::Deref for ExtPacketDelBudget {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for ExtPacketDelBudget {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// Extended Problem Details
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ExtProblemDetails {
    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub r#type: Option<String>,

    #[serde(rename = "title")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<i32>,

    /// A human-readable explanation specific to this occurrence of the problem.
    #[serde(rename = "detail")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub detail: Option<String>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "instance")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub instance: Option<String>,

    /// A machine-readable application error cause specific to this occurrence of the problem.  This IE should be present and provide application-related error information, if available.
    #[serde(rename = "cause")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cause: Option<String>,

    #[serde(rename = "invalidParams")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub invalid_params: Option<Vec<models::InvalidParam>>,

    /// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  table 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.
    #[serde(rename = "supportedFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_features: Option<String>,

    #[serde(rename = "accessTokenError")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub access_token_error: Option<models::AccessTokenErr>,

    #[serde(rename = "accessTokenRequest")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub access_token_request: Option<models::AccessTokenReq>,

    /// Fully Qualified Domain Name
    #[serde(rename = "nrfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nrf_id: Option<String>,

    #[serde(rename = "remoteError")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remote_error: Option<bool>,
}

impl ExtProblemDetails {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ExtProblemDetails {
        ExtProblemDetails {
            r#type: None,
            title: None,
            status: None,
            detail: None,
            instance: None,
            cause: None,
            invalid_params: None,
            supported_features: None,
            access_token_error: None,
            access_token_request: None,
            nrf_id: None,
            remote_error: None,
        }
    }
}

/// Converts the ExtProblemDetails value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ExtProblemDetails {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.r#type
                .as_ref()
                .map(|r#type| vec!["type".to_string(), r#type.to_string()].join(",")),
            self.title
                .as_ref()
                .map(|title| vec!["title".to_string(), title.to_string()].join(",")),
            self.status
                .as_ref()
                .map(|status| vec!["status".to_string(), status.to_string()].join(",")),
            self.detail
                .as_ref()
                .map(|detail| vec!["detail".to_string(), detail.to_string()].join(",")),
            self.instance
                .as_ref()
                .map(|instance| vec!["instance".to_string(), instance.to_string()].join(",")),
            self.cause
                .as_ref()
                .map(|cause| vec!["cause".to_string(), cause.to_string()].join(",")),
            // Skipping invalidParams in query parameter serialization
            self.supported_features.as_ref().map(|supported_features| {
                vec![
                    "supportedFeatures".to_string(),
                    supported_features.to_string(),
                ]
                .join(",")
            }),
            // Skipping accessTokenError in query parameter serialization

            // Skipping accessTokenRequest in query parameter serialization
            self.nrf_id
                .as_ref()
                .map(|nrf_id| vec!["nrfId".to_string(), nrf_id.to_string()].join(",")),
            self.remote_error.as_ref().map(|remote_error| {
                vec!["remoteError".to_string(), remote_error.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ExtProblemDetails value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ExtProblemDetails {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
            pub title: Vec<String>,
            pub status: Vec<i32>,
            pub detail: Vec<String>,
            pub instance: Vec<String>,
            pub cause: Vec<String>,
            pub invalid_params: Vec<Vec<models::InvalidParam>>,
            pub supported_features: Vec<String>,
            pub access_token_error: Vec<models::AccessTokenErr>,
            pub access_token_request: Vec<models::AccessTokenReq>,
            pub nrf_id: Vec<String>,
            pub remote_error: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ExtProblemDetails".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "title" => intermediate_rep.title.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "detail" => intermediate_rep.detail.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "instance" => intermediate_rep.instance.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "cause" => intermediate_rep.cause.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "invalidParams" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in ExtProblemDetails"
                            .to_string(),
                    ),
                    #[allow(clippy::redundant_clone)]
                    "supportedFeatures" => intermediate_rep.supported_features.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "accessTokenError" => intermediate_rep.access_token_error.push(
                        <models::AccessTokenErr as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "accessTokenRequest" => intermediate_rep.access_token_request.push(
                        <models::AccessTokenReq as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nrfId" => intermediate_rep.nrf_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "remoteError" => intermediate_rep.remote_error.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ExtProblemDetails".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ExtProblemDetails {
            r#type: intermediate_rep.r#type.into_iter().next(),
            title: intermediate_rep.title.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            detail: intermediate_rep.detail.into_iter().next(),
            instance: intermediate_rep.instance.into_iter().next(),
            cause: intermediate_rep.cause.into_iter().next(),
            invalid_params: intermediate_rep.invalid_params.into_iter().next(),
            supported_features: intermediate_rep.supported_features.into_iter().next(),
            access_token_error: intermediate_rep.access_token_error.into_iter().next(),
            access_token_request: intermediate_rep.access_token_request.into_iter().next(),
            nrf_id: intermediate_rep.nrf_id.into_iter().next(),
            remote_error: intermediate_rep.remote_error.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ExtProblemDetails> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ExtProblemDetails>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ExtProblemDetails>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ExtProblemDetails - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ExtProblemDetails>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ExtProblemDetails as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ExtProblemDetails - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Forwarding Bearer Container
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ForwardingBearerContainer(String);

impl std::convert::From<String> for ForwardingBearerContainer {
    fn from(x: String) -> Self {
        ForwardingBearerContainer(x)
    }
}

impl std::string::ToString for ForwardingBearerContainer {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for ForwardingBearerContainer {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(ForwardingBearerContainer(x.to_string()))
    }
}

impl std::convert::From<ForwardingBearerContainer> for String {
    fn from(x: ForwardingBearerContainer) -> Self {
        x.0
    }
}

impl std::ops::Deref for ForwardingBearerContainer {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for ForwardingBearerContainer {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Fully Qualified Domain Name
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Fqdn(String);

impl std::convert::From<String> for Fqdn {
    fn from(x: String) -> Self {
        Fqdn(x)
    }
}

impl std::string::ToString for Fqdn {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Fqdn {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Fqdn(x.to_string()))
    }
}

impl std::convert::From<Fqdn> for String {
    fn from(x: Fqdn) -> Self {
        x.0
    }
}

impl std::ops::Deref for Fqdn {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Fqdn {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// GBR QoS flow information
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GbrQosFlowInformation {
    /// String representing a bit rate; the prefixes follow the standard symbols from The International System of Units, and represent x1000 multipliers, with the exception that prefix \"K\" is used to represent the standard symbol \"k\".
    #[serde(rename = "maxFbrDl")]
    pub max_fbr_dl: String,

    /// String representing a bit rate; the prefixes follow the standard symbols from The International System of Units, and represent x1000 multipliers, with the exception that prefix \"K\" is used to represent the standard symbol \"k\".
    #[serde(rename = "maxFbrUl")]
    pub max_fbr_ul: String,

    /// String representing a bit rate; the prefixes follow the standard symbols from The International System of Units, and represent x1000 multipliers, with the exception that prefix \"K\" is used to represent the standard symbol \"k\".
    #[serde(rename = "guaFbrDl")]
    pub gua_fbr_dl: String,

    /// String representing a bit rate; the prefixes follow the standard symbols from The International System of Units, and represent x1000 multipliers, with the exception that prefix \"K\" is used to represent the standard symbol \"k\".
    #[serde(rename = "guaFbrUl")]
    pub gua_fbr_ul: String,

    #[serde(rename = "notifControl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notif_control: Option<models::NotificationControl>,

    /// Unsigned integer indicating Packet Loss Rate (see clauses 5.7.2.8 and 5.7.4 of 3GPP TS 23.501), expressed in tenth of percent.
    #[serde(rename = "maxPacketLossRateDl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_packet_loss_rate_dl: Option<u16>,

    /// Unsigned integer indicating Packet Loss Rate (see clauses 5.7.2.8 and 5.7.4 of 3GPP TS 23.501), expressed in tenth of percent.
    #[serde(rename = "maxPacketLossRateUl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_packet_loss_rate_ul: Option<u16>,

    #[serde(rename = "alternativeQosProfileList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub alternative_qos_profile_list: Option<Vec<models::AlternativeQosProfile>>,
}

impl GbrQosFlowInformation {
    #[allow(clippy::new_without_default)]
    pub fn new(
        max_fbr_dl: String,
        max_fbr_ul: String,
        gua_fbr_dl: String,
        gua_fbr_ul: String,
    ) -> GbrQosFlowInformation {
        GbrQosFlowInformation {
            max_fbr_dl,
            max_fbr_ul,
            gua_fbr_dl,
            gua_fbr_ul,
            notif_control: None,
            max_packet_loss_rate_dl: None,
            max_packet_loss_rate_ul: None,
            alternative_qos_profile_list: None,
        }
    }
}

/// Converts the GbrQosFlowInformation value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GbrQosFlowInformation {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("maxFbrDl".to_string()),
            Some(self.max_fbr_dl.to_string()),
            Some("maxFbrUl".to_string()),
            Some(self.max_fbr_ul.to_string()),
            Some("guaFbrDl".to_string()),
            Some(self.gua_fbr_dl.to_string()),
            Some("guaFbrUl".to_string()),
            Some(self.gua_fbr_ul.to_string()),
            // Skipping notifControl in query parameter serialization
            self.max_packet_loss_rate_dl
                .as_ref()
                .map(|max_packet_loss_rate_dl| {
                    vec![
                        "maxPacketLossRateDl".to_string(),
                        max_packet_loss_rate_dl.to_string(),
                    ]
                    .join(",")
                }),
            self.max_packet_loss_rate_ul
                .as_ref()
                .map(|max_packet_loss_rate_ul| {
                    vec![
                        "maxPacketLossRateUl".to_string(),
                        max_packet_loss_rate_ul.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping alternativeQosProfileList in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GbrQosFlowInformation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GbrQosFlowInformation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub max_fbr_dl: Vec<String>,
            pub max_fbr_ul: Vec<String>,
            pub gua_fbr_dl: Vec<String>,
            pub gua_fbr_ul: Vec<String>,
            pub notif_control: Vec<models::NotificationControl>,
            pub max_packet_loss_rate_dl: Vec<u16>,
            pub max_packet_loss_rate_ul: Vec<u16>,
            pub alternative_qos_profile_list: Vec<Vec<models::AlternativeQosProfile>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GbrQosFlowInformation".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "maxFbrDl" => intermediate_rep.max_fbr_dl.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maxFbrUl" => intermediate_rep.max_fbr_ul.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "guaFbrDl" => intermediate_rep.gua_fbr_dl.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "guaFbrUl" => intermediate_rep.gua_fbr_ul.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "notifControl" => intermediate_rep.notif_control.push(<models::NotificationControl as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maxPacketLossRateDl" => intermediate_rep.max_packet_loss_rate_dl.push(<u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maxPacketLossRateUl" => intermediate_rep.max_packet_loss_rate_ul.push(<u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "alternativeQosProfileList" => return std::result::Result::Err("Parsing a container in this style is not supported in GbrQosFlowInformation".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GbrQosFlowInformation".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GbrQosFlowInformation {
            max_fbr_dl: intermediate_rep
                .max_fbr_dl
                .into_iter()
                .next()
                .ok_or_else(|| "maxFbrDl missing in GbrQosFlowInformation".to_string())?,
            max_fbr_ul: intermediate_rep
                .max_fbr_ul
                .into_iter()
                .next()
                .ok_or_else(|| "maxFbrUl missing in GbrQosFlowInformation".to_string())?,
            gua_fbr_dl: intermediate_rep
                .gua_fbr_dl
                .into_iter()
                .next()
                .ok_or_else(|| "guaFbrDl missing in GbrQosFlowInformation".to_string())?,
            gua_fbr_ul: intermediate_rep
                .gua_fbr_ul
                .into_iter()
                .next()
                .ok_or_else(|| "guaFbrUl missing in GbrQosFlowInformation".to_string())?,
            notif_control: intermediate_rep.notif_control.into_iter().next(),
            max_packet_loss_rate_dl: intermediate_rep.max_packet_loss_rate_dl.into_iter().next(),
            max_packet_loss_rate_ul: intermediate_rep.max_packet_loss_rate_ul.into_iter().next(),
            alternative_qos_profile_list: intermediate_rep
                .alternative_qos_profile_list
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GbrQosFlowInformation> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GbrQosFlowInformation>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GbrQosFlowInformation>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GbrQosFlowInformation - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<GbrQosFlowInformation>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GbrQosFlowInformation as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GbrQosFlowInformation - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Global Cable Identifier uniquely identifying the connection between the 5G-CRG or FN-CRG to the 5GS. See clause 28.15.4 of 3GPP TS 23.003. This shall be encoded as a string per clause 28.15.4 of 3GPP TS 23.003, and compliant with the syntax specified  in clause 2.2  of IETF RFC 7542 for the username part of a NAI. The GCI value is specified in CableLabs WR-TR-5WWC-ARCH.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Gci(String);

impl std::convert::From<String> for Gci {
    fn from(x: String) -> Self {
        Gci(x)
    }
}

impl std::string::ToString for Gci {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Gci {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Gci(x.to_string()))
    }
}

impl std::convert::From<Gci> for String {
    fn from(x: Gci) -> Self {
        x.0
    }
}

impl std::ops::Deref for Gci {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Gci {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Exactly one of cgi, sai or lai shall be present.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GeraLocation {
    /// Location number within the PLMN. See 3GPP TS 23.003, clause 4.5.
    #[serde(rename = "locationNumber")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub location_number: Option<String>,

    #[serde(rename = "cgi")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cgi: Option<models::CellGlobalId>,

    #[serde(rename = "rai")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rai: Option<models::RoutingAreaId>,

    #[serde(rename = "sai")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sai: Option<models::ServiceAreaId>,

    #[serde(rename = "lai")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lai: Option<models::LocationAreaId>,

    /// VLR number. See 3GPP TS 23.003 clause 5.1.
    #[serde(rename = "vlrNumber")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub vlr_number: Option<String>,

    /// MSC number. See 3GPP TS 23.003 clause 5.1.
    #[serde(rename = "mscNumber")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub msc_number: Option<String>,

    /// The value represents the elapsed time in minutes since the last network contact of the mobile station. Value \"0\" indicates that the location information was obtained after a successful paging procedure for  Active Location Retrieval when the UE is in idle mode or after a successful location reporting procedure the UE is in connected mode. Any other value than \"0\" indicates that the location information is the last known one. See 3GPP TS 29.002 clause 17.7.8.
    #[serde(rename = "ageOfLocationInformation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub age_of_location_information: Option<u16>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "ueLocationTimestamp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_location_timestamp: Option<chrono::DateTime<chrono::Utc>>,

    /// Refer to geographical Information.See 3GPP TS 23.032 clause 7.3.2. Only the description of an ellipsoid point with uncertainty circle is allowed to be used.
    #[serde(rename = "geographicalInformation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub geographical_information: Option<String>,

    /// Refers to Calling Geodetic Location.See ITU-T Recommendation Q.763 (1999) clause 3.88.2.  Only the description of an ellipsoid point with uncertainty circle is allowed to be used.
    #[serde(rename = "geodeticInformation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub geodetic_information: Option<String>,
}

impl GeraLocation {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GeraLocation {
        GeraLocation {
            location_number: None,
            cgi: None,
            rai: None,
            sai: None,
            lai: None,
            vlr_number: None,
            msc_number: None,
            age_of_location_information: None,
            ue_location_timestamp: None,
            geographical_information: None,
            geodetic_information: None,
        }
    }
}

/// Converts the GeraLocation value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GeraLocation {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.location_number.as_ref().map(|location_number| {
                vec!["locationNumber".to_string(), location_number.to_string()].join(",")
            }),
            // Skipping cgi in query parameter serialization

            // Skipping rai in query parameter serialization

            // Skipping sai in query parameter serialization

            // Skipping lai in query parameter serialization
            self.vlr_number
                .as_ref()
                .map(|vlr_number| vec!["vlrNumber".to_string(), vlr_number.to_string()].join(",")),
            self.msc_number
                .as_ref()
                .map(|msc_number| vec!["mscNumber".to_string(), msc_number.to_string()].join(",")),
            self.age_of_location_information
                .as_ref()
                .map(|age_of_location_information| {
                    vec![
                        "ageOfLocationInformation".to_string(),
                        age_of_location_information.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping ueLocationTimestamp in query parameter serialization
            self.geographical_information
                .as_ref()
                .map(|geographical_information| {
                    vec![
                        "geographicalInformation".to_string(),
                        geographical_information.to_string(),
                    ]
                    .join(",")
                }),
            self.geodetic_information
                .as_ref()
                .map(|geodetic_information| {
                    vec![
                        "geodeticInformation".to_string(),
                        geodetic_information.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GeraLocation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GeraLocation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub location_number: Vec<String>,
            pub cgi: Vec<models::CellGlobalId>,
            pub rai: Vec<models::RoutingAreaId>,
            pub sai: Vec<models::ServiceAreaId>,
            pub lai: Vec<models::LocationAreaId>,
            pub vlr_number: Vec<String>,
            pub msc_number: Vec<String>,
            pub age_of_location_information: Vec<u16>,
            pub ue_location_timestamp: Vec<chrono::DateTime<chrono::Utc>>,
            pub geographical_information: Vec<String>,
            pub geodetic_information: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GeraLocation".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "locationNumber" => intermediate_rep.location_number.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "cgi" => intermediate_rep.cgi.push(
                        <models::CellGlobalId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "rai" => intermediate_rep.rai.push(
                        <models::RoutingAreaId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "sai" => intermediate_rep.sai.push(
                        <models::ServiceAreaId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "lai" => intermediate_rep.lai.push(
                        <models::LocationAreaId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "vlrNumber" => intermediate_rep.vlr_number.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "mscNumber" => intermediate_rep.msc_number.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ageOfLocationInformation" => {
                        intermediate_rep.age_of_location_information.push(
                            <u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "ueLocationTimestamp" => intermediate_rep.ue_location_timestamp.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "geographicalInformation" => intermediate_rep.geographical_information.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "geodeticInformation" => intermediate_rep.geodetic_information.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GeraLocation".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GeraLocation {
            location_number: intermediate_rep.location_number.into_iter().next(),
            cgi: intermediate_rep.cgi.into_iter().next(),
            rai: intermediate_rep.rai.into_iter().next(),
            sai: intermediate_rep.sai.into_iter().next(),
            lai: intermediate_rep.lai.into_iter().next(),
            vlr_number: intermediate_rep.vlr_number.into_iter().next(),
            msc_number: intermediate_rep.msc_number.into_iter().next(),
            age_of_location_information: intermediate_rep
                .age_of_location_information
                .into_iter()
                .next(),
            ue_location_timestamp: intermediate_rep.ue_location_timestamp.into_iter().next(),
            geographical_information: intermediate_rep.geographical_information.into_iter().next(),
            geodetic_information: intermediate_rep.geodetic_information.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GeraLocation> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GeraLocation>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GeraLocation>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GeraLocation - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GeraLocation> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GeraLocation as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GeraLocation - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// string with format 'bytes' as defined in OpenAPI
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Gli {}

impl Gli {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Gli {
        Gli {}
    }
}

/// Converts the Gli value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Gli {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Gli value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Gli {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err("Missing value while parsing Gli".to_string())
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Gli".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Gli {})
    }
}

// Methods for converting between header::IntoHeaderValue<Gli> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Gli>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Gli>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Gli - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Gli> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Gli as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Gli - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// One of the six attributes n3IwfId, gNbIdm, ngeNbId, wagfId, tngfId, eNbId shall be present.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GlobalRanNodeId {
    #[serde(rename = "plmnId")]
    pub plmn_id: models::PlmnId,

    /// This represents the identifier of the N3IWF ID as specified in clause 9.3.1.57 of  3GPP TS 38.413 in hexadecimal representation. Each character in the string shall take a value  of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant  character representing the 4 most significant bits of the N3IWF ID shall appear first in the  string, and the character representing the 4 least significant bit of the N3IWF ID shall  appear last in the string.
    #[serde(rename = "n3IwfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n3_iwf_id: Option<String>,

    #[serde(rename = "gNbId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub g_nb_id: Option<models::GnbId>,

    /// This represents the identifier of the ng-eNB ID as specified in clause 9.3.1.8 of  3GPP TS 38.413. The value of the ng-eNB ID shall be encoded in hexadecimal representation.  Each character in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and  shall represent 4 bits. The padding 0 shall be added to make multiple nibbles, so the most  significant character representing the padding 0 if required together with the 4 most  significant bits of the ng-eNB ID shall appear first in the string, and the character  representing the 4 least significant bit of the ng-eNB ID (to form a nibble) shall appear last  in the string.
    #[serde(rename = "ngeNbId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nge_nb_id: Option<String>,

    /// This represents the identifier of the W-AGF ID as specified in clause 9.3.1.162 of  3GPP TS 38.413 in hexadecimal representation. Each character in the string shall take a value  of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant  character representing the 4 most significant bits of the W-AGF ID shall appear first in the  string, and the character representing the 4 least significant bit of the W-AGF ID shall  appear last in the string.
    #[serde(rename = "wagfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub wagf_id: Option<String>,

    /// This represents the identifier of the TNGF ID as specified in clause 9.3.1.161 of  3GPP TS 38.413  in hexadecimal representation. Each character in the string shall take a value of \"0\" to \"9\", \"a\"  to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character representing the  4 most significant bits of the TNGF ID shall appear first in the string, and the character  representing the 4 least significant bit of the TNGF ID shall appear last in the string.
    #[serde(rename = "tngfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tngf_id: Option<String>,

    /// This represents the Network Identifier, which together with a PLMN ID is used to identify an SNPN (see 3GPP TS 23.003 and 3GPP TS 23.501 clause 5.30.2.1).
    #[serde(rename = "nid")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nid: Option<String>,

    /// This represents the identifier of the eNB ID as specified in clause 9.2.1.37 of  3GPP TS 36.413. The string shall be formatted with the following pattern  '^('MacroeNB-[A-Fa-f0-9]{5}|LMacroeNB-[A-Fa-f0-9]{6}|SMacroeNB-[A-Fa-f0-9]{5} |HomeeNB-[A-Fa-f0-9]{7})$'. The value of the eNB ID shall be encoded in hexadecimal representation. Each character in the  string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits.  The padding 0 shall be added to make multiple nibbles, so the most significant character  representing the padding 0 if required together with the 4 most significant bits of the eNB ID  shall appear first in the string, and the character representing the 4 least significant bit  of the eNB ID (to form a nibble) shall appear last in the string.
    #[serde(rename = "eNbId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub e_nb_id: Option<String>,
}

impl GlobalRanNodeId {
    #[allow(clippy::new_without_default)]
    pub fn new(plmn_id: models::PlmnId) -> GlobalRanNodeId {
        GlobalRanNodeId {
            plmn_id,
            n3_iwf_id: None,
            g_nb_id: None,
            nge_nb_id: None,
            wagf_id: None,
            tngf_id: None,
            nid: None,
            e_nb_id: None,
        }
    }
}

/// Converts the GlobalRanNodeId value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GlobalRanNodeId {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping plmnId in query parameter serialization
            self.n3_iwf_id
                .as_ref()
                .map(|n3_iwf_id| vec!["n3IwfId".to_string(), n3_iwf_id.to_string()].join(",")),
            // Skipping gNbId in query parameter serialization
            self.nge_nb_id
                .as_ref()
                .map(|nge_nb_id| vec!["ngeNbId".to_string(), nge_nb_id.to_string()].join(",")),
            self.wagf_id
                .as_ref()
                .map(|wagf_id| vec!["wagfId".to_string(), wagf_id.to_string()].join(",")),
            self.tngf_id
                .as_ref()
                .map(|tngf_id| vec!["tngfId".to_string(), tngf_id.to_string()].join(",")),
            self.nid
                .as_ref()
                .map(|nid| vec!["nid".to_string(), nid.to_string()].join(",")),
            self.e_nb_id
                .as_ref()
                .map(|e_nb_id| vec!["eNbId".to_string(), e_nb_id.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GlobalRanNodeId value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GlobalRanNodeId {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub plmn_id: Vec<models::PlmnId>,
            pub n3_iwf_id: Vec<String>,
            pub g_nb_id: Vec<models::GnbId>,
            pub nge_nb_id: Vec<String>,
            pub wagf_id: Vec<String>,
            pub tngf_id: Vec<String>,
            pub nid: Vec<String>,
            pub e_nb_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GlobalRanNodeId".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "plmnId" => intermediate_rep.plmn_id.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n3IwfId" => intermediate_rep.n3_iwf_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "gNbId" => intermediate_rep.g_nb_id.push(
                        <models::GnbId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ngeNbId" => intermediate_rep.nge_nb_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "wagfId" => intermediate_rep.wagf_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "tngfId" => intermediate_rep.tngf_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nid" => intermediate_rep.nid.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "eNbId" => intermediate_rep.e_nb_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GlobalRanNodeId".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GlobalRanNodeId {
            plmn_id: intermediate_rep
                .plmn_id
                .into_iter()
                .next()
                .ok_or_else(|| "plmnId missing in GlobalRanNodeId".to_string())?,
            n3_iwf_id: intermediate_rep.n3_iwf_id.into_iter().next(),
            g_nb_id: intermediate_rep.g_nb_id.into_iter().next(),
            nge_nb_id: intermediate_rep.nge_nb_id.into_iter().next(),
            wagf_id: intermediate_rep.wagf_id.into_iter().next(),
            tngf_id: intermediate_rep.tngf_id.into_iter().next(),
            nid: intermediate_rep.nid.into_iter().next(),
            e_nb_id: intermediate_rep.e_nb_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GlobalRanNodeId> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GlobalRanNodeId>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GlobalRanNodeId>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GlobalRanNodeId - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<GlobalRanNodeId>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GlobalRanNodeId as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GlobalRanNodeId - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Provides the G-NB identifier.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GnbId {
    /// Unsigned integer representing the bit length of the gNB ID as defined in clause 9.3.1.6 of 3GPP TS 38.413 [11], within the range 22 to 32.
    #[serde(rename = "bitLength")]
    pub bit_length: u8,

    /// This represents the identifier of the gNB. The value of the gNB ID shall be encoded in hexadecimal representation. Each character in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The padding 0 shall be added to make multiple nibbles,  the most significant character representing the padding 0 if required together with the 4 most significant bits of the gNB ID shall appear first in the string, and the character representing the 4 least significant bit of the gNB ID shall appear last in the string.
    #[serde(rename = "gNBValue")]
    pub g_nb_value: String,
}

impl GnbId {
    #[allow(clippy::new_without_default)]
    pub fn new(bit_length: u8, g_nb_value: String) -> GnbId {
        GnbId {
            bit_length,
            g_nb_value,
        }
    }
}

/// Converts the GnbId value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GnbId {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("bitLength".to_string()),
            Some(self.bit_length.to_string()),
            Some("gNBValue".to_string()),
            Some(self.g_nb_value.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GnbId value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GnbId {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub bit_length: Vec<u8>,
            pub g_nb_value: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GnbId".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "bitLength" => intermediate_rep
                        .bit_length
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "gNBValue" => intermediate_rep.g_nb_value.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GnbId".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GnbId {
            bit_length: intermediate_rep
                .bit_length
                .into_iter()
                .next()
                .ok_or_else(|| "bitLength missing in GnbId".to_string())?,
            g_nb_value: intermediate_rep
                .g_nb_value
                .into_iter()
                .next()
                .ok_or_else(|| "gNBValue missing in GnbId".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GnbId> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GnbId>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GnbId>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GnbId - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GnbId> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <GnbId as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into GnbId - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// String identifying a Gpsi shall contain either an External Id or an MSISDN.  It shall be formatted as follows -External Identifier= \"extid-'extid', where 'extid'  shall be formatted according to clause 19.7.2 of 3GPP TS 23.003 that describes an  External Identifier.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Gpsi(String);

impl std::convert::From<String> for Gpsi {
    fn from(x: String) -> Self {
        Gpsi(x)
    }
}

impl std::string::ToString for Gpsi {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Gpsi {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Gpsi(x.to_string()))
    }
}

impl std::convert::From<Gpsi> for String {
    fn from(x: Gpsi) -> Self {
        x.0
    }
}

impl std::ops::Deref for Gpsi {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Gpsi {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Globally Unique AMF Identifier constructed out of PLMN, Network and AMF identity.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Guami {
    #[serde(rename = "plmnId")]
    pub plmn_id: models::PlmnIdNid,

    /// String identifying the AMF ID composed of AMF Region ID (8 bits), AMF Set ID (10 bits) and AMF  Pointer (6 bits) as specified in clause 2.10.1 of 3GPP TS 23.003. It is encoded as a string of  6 hexadecimal characters (i.e., 24 bits).
    #[serde(rename = "amfId")]
    pub amf_id: String,
}

impl Guami {
    #[allow(clippy::new_without_default)]
    pub fn new(plmn_id: models::PlmnIdNid, amf_id: String) -> Guami {
        Guami { plmn_id, amf_id }
    }
}

/// Converts the Guami value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Guami {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping plmnId in query parameter serialization
            Some("amfId".to_string()),
            Some(self.amf_id.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Guami value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Guami {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub plmn_id: Vec<models::PlmnIdNid>,
            pub amf_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Guami".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "plmnId" => intermediate_rep.plmn_id.push(
                        <models::PlmnIdNid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "amfId" => intermediate_rep.amf_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Guami".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Guami {
            plmn_id: intermediate_rep
                .plmn_id
                .into_iter()
                .next()
                .ok_or_else(|| "plmnId missing in Guami".to_string())?,
            amf_id: intermediate_rep
                .amf_id
                .into_iter()
                .next()
                .ok_or_else(|| "amfId missing in Guami".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Guami> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Guami>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Guami>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Guami - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Guami> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Guami as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Guami - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// This IE represents the identifier of the HFC node Id as specified in CableLabs WR-TR-5WWC-ARCH. It is provisioned by the wireline operator as part of wireline operations and may contain up to six characters.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct HfcNid(String);

impl std::convert::From<String> for HfcNid {
    fn from(x: String) -> Self {
        HfcNid(x)
    }
}

impl std::string::ToString for HfcNid {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for HfcNid {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(HfcNid(x.to_string()))
    }
}

impl std::convert::From<HfcNid> for String {
    fn from(x: HfcNid) -> Self {
        x.0
    }
}

impl std::ops::Deref for HfcNid {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for HfcNid {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// REpresents the HFC Node Identifer received over NGAP.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct HfcNodeId {
    /// This IE represents the identifier of the HFC node Id as specified in CableLabs WR-TR-5WWC-ARCH. It is provisioned by the wireline operator as part of wireline operations and may contain up to six characters.
    #[serde(rename = "hfcNId")]
    pub hfc_nid: String,
}

impl HfcNodeId {
    #[allow(clippy::new_without_default)]
    pub fn new(hfc_nid: String) -> HfcNodeId {
        HfcNodeId { hfc_nid }
    }
}

/// Converts the HfcNodeId value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for HfcNodeId {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> =
            vec![Some("hfcNId".to_string()), Some(self.hfc_nid.to_string())];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a HfcNodeId value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for HfcNodeId {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub hfc_nid: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing HfcNodeId".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "hfcNId" => intermediate_rep.hfc_nid.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing HfcNodeId".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(HfcNodeId {
            hfc_nid: intermediate_rep
                .hfc_nid
                .into_iter()
                .next()
                .ok_or_else(|| "hfcNId missing in HfcNodeId".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<HfcNodeId> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<HfcNodeId>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<HfcNodeId>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for HfcNodeId - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<HfcNodeId> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <HfcNodeId as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into HfcNodeId - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Handover state. Possible values are - NONE - PREPARING - PREPARED - COMPLETED - CANCELLED
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct HoState {}

impl HoState {
    #[allow(clippy::new_without_default)]
    pub fn new() -> HoState {
        HoState {}
    }
}

/// Converts the HoState value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for HoState {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a HoState value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for HoState {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing HoState".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing HoState".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(HoState {})
    }
}

// Methods for converting between header::IntoHeaderValue<HoState> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<HoState>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<HoState>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for HoState - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<HoState> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <HoState as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into HoState - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum HoStateAnyOf {
    #[serde(rename = "NONE")]
    None,
    #[serde(rename = "PREPARING")]
    Preparing,
    #[serde(rename = "PREPARED")]
    Prepared,
    #[serde(rename = "COMPLETED")]
    Completed,
    #[serde(rename = "CANCELLED")]
    Cancelled,
}

impl std::fmt::Display for HoStateAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            HoStateAnyOf::None => write!(f, "NONE"),
            HoStateAnyOf::Preparing => write!(f, "PREPARING"),
            HoStateAnyOf::Prepared => write!(f, "PREPARED"),
            HoStateAnyOf::Completed => write!(f, "COMPLETED"),
            HoStateAnyOf::Cancelled => write!(f, "CANCELLED"),
        }
    }
}

impl std::str::FromStr for HoStateAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "NONE" => std::result::Result::Ok(HoStateAnyOf::None),
            "PREPARING" => std::result::Result::Ok(HoStateAnyOf::Preparing),
            "PREPARED" => std::result::Result::Ok(HoStateAnyOf::Prepared),
            "COMPLETED" => std::result::Result::Ok(HoStateAnyOf::Completed),
            "CANCELLED" => std::result::Result::Ok(HoStateAnyOf::Cancelled),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Data within Update Request towards H-SMF, or from I-SMF to SMF
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct HsmfUpdateData {
    #[serde(rename = "requestIndication")]
    pub request_indication: models::RequestIndication,

    /// String representing a Permanent Equipment Identifier that may contain - an IMEI or IMEISV, as  specified in clause 6.2 of 3GPP TS 23.003; a MAC address for a 5G-RG or FN-RG via  wireline  access, with an indication that this address cannot be trusted for regulatory purpose if this  address cannot be used as an Equipment Identifier of the FN-RG, as specified in clause 4.7.7  of 3GPP TS23.316. Examples are imei-012345678901234 or imeisv-0123456789012345.
    #[serde(rename = "pei")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pei: Option<String>,

    #[serde(rename = "vcnTunnelInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub vcn_tunnel_info: Option<models::TunnelInfo>,

    #[serde(rename = "icnTunnelInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icn_tunnel_info: Option<models::TunnelInfo>,

    #[serde(rename = "additionalCnTunnelInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_cn_tunnel_info: Option<models::TunnelInfo>,

    #[serde(rename = "servingNetwork")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub serving_network: Option<models::PlmnIdNid>,

    #[serde(rename = "anType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub an_type: Option<models::AccessType>,

    #[serde(rename = "additionalAnType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_an_type: Option<models::AccessType>,

    #[serde(rename = "ratType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rat_type: Option<models::RatType>,

    #[serde(rename = "ueLocation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_location: Option<models::UserLocation>,

    /// String with format \"time-numoffset\" optionally appended by \"daylightSavingTime\", where  - \"time-numoffset\" shall represent the time zone adjusted for daylight saving time and be    encoded as time-numoffset as defined in clause 5.6 of IETF RFC 3339;  - \"daylightSavingTime\" shall represent the adjustment that has been made and shall be    encoded as \"+1\" or \"+2\" for a +1 or +2 hours adjustment.   The example is for 8 hours behind UTC, +1 hour adjustment for Daylight Saving Time.
    #[serde(rename = "ueTimeZone")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_time_zone: Option<String>,

    #[serde(rename = "addUeLocation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub add_ue_location: Option<models::UserLocation>,

    #[serde(rename = "pauseCharging")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pause_charging: Option<bool>,

    /// Procedure Transaction Identifier
    #[serde(rename = "pti")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pti: Option<u8>,

    #[serde(rename = "n1SmInfoFromUe")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n1_sm_info_from_ue: Option<models::RefToBinaryData>,

    #[serde(rename = "unknownN1SmInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unknown_n1_sm_info: Option<models::RefToBinaryData>,

    #[serde(rename = "qosFlowsRelNotifyList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub qos_flows_rel_notify_list: Option<Vec<models::QosFlowItem>>,

    #[serde(rename = "qosFlowsNotifyList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub qos_flows_notify_list: Option<Vec<models::QosFlowNotifyItem>>,

    #[serde(rename = "NotifyList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notify_list: Option<Vec<models::PduSessionNotifyItem>>,

    #[serde(rename = "epsBearerId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub eps_bearer_id: Option<Vec<models::EpsBearerId>>,

    #[serde(rename = "hoPreparationIndication")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ho_preparation_indication: Option<bool>,

    #[serde(rename = "revokeEbiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub revoke_ebi_list: Option<Vec<models::EpsBearerId>>,

    #[serde(rename = "cause")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cause: Option<models::Cause>,

    #[serde(rename = "ngApCause")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ng_ap_cause: Option<models::NgApCause>,

    /// Unsigned Integer, i.e. only value 0 and integers above 0 are permissible.
    #[serde(rename = "5gMmCauseValue")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub param_5g_mm_cause_value: Option<u32>,

    #[serde(rename = "alwaysOnRequested")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub always_on_requested: Option<bool>,

    #[serde(rename = "epsInterworkingInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub eps_interworking_ind: Option<models::EpsInterworkingIndication>,

    #[serde(rename = "secondaryRatUsageReport")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub secondary_rat_usage_report: Option<Vec<models::SecondaryRatUsageReport>>,

    #[serde(rename = "secondaryRatUsageInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub secondary_rat_usage_info: Option<Vec<models::SecondaryRatUsageInfo>>,

    #[serde(rename = "anTypeCanBeChanged")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub an_type_can_be_changed: Option<bool>,

    #[serde(rename = "maReleaseInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ma_release_ind: Option<models::MaReleaseIndication>,

    #[serde(rename = "maNwUpgradeInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ma_nw_upgrade_ind: Option<bool>,

    #[serde(rename = "maRequestInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ma_request_ind: Option<bool>,

    #[serde(rename = "unavailableAccessInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unavailable_access_ind: Option<models::UnavailableAccessIndication>,

    #[serde(rename = "psaInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub psa_info: Option<Vec<models::PsaInformation>>,

    #[serde(rename = "ulclBpInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ulcl_bp_info: Option<models::UlclBpInformation>,

    #[serde(rename = "n4Info")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n4_info: Option<models::N4Information>,

    #[serde(rename = "n4InfoExt1")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n4_info_ext1: Option<models::N4Information>,

    #[serde(rename = "n4InfoExt2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n4_info_ext2: Option<models::N4Information>,

    #[serde(rename = "presenceInLadn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub presence_in_ladn: Option<models::PresenceState>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "vsmfPduSessionUri")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub vsmf_pdu_session_uri: Option<String>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "vsmfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub vsmf_id: Option<uuid::Uuid>,

    #[serde(rename = "vSmfServiceInstanceId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub v_smf_service_instance_id: Option<String>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "ismfPduSessionUri")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ismf_pdu_session_uri: Option<String>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "ismfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ismf_id: Option<uuid::Uuid>,

    #[serde(rename = "iSmfServiceInstanceId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub i_smf_service_instance_id: Option<String>,

    #[serde(rename = "dlServingPlmnRateCtl")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dl_serving_plmn_rate_ctl: Option<swagger::Nullable<u32>>,

    #[serde(rename = "dnaiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dnai_list: Option<Vec<models::Dnai>>,

    /// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  table 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.
    #[serde(rename = "supportedFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_features: Option<String>,

    #[serde(rename = "roamingChargingProfile")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub roaming_charging_profile: Option<models::RoamingChargingProfile>,

    #[serde(rename = "moExpDataCounter")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mo_exp_data_counter: Option<models::MoExpDataCounter>,

    #[serde(rename = "vplmnQos")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub vplmn_qos: Option<models::VplmnQos>,

    #[serde(rename = "securityResult")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_result: Option<models::SecurityResult>,

    #[serde(rename = "upSecurityInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub up_security_info: Option<models::UpSecurityInfo>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "amfNfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub amf_nf_id: Option<uuid::Uuid>,

    #[serde(rename = "guami")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub guami: Option<models::Guami>,

    #[serde(rename = "secondaryRatUsageDataReportContainer")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub secondary_rat_usage_data_report_container:
        Option<Vec<models::SecondaryRatUsageDataReportContainer>>,

    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "smPolicyNotifyInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sm_policy_notify_ind: Option<bool>,

    #[serde(rename = "pcfUeCallbackInfo")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pcf_ue_callback_info: Option<swagger::Nullable<models::PcfUeCallbackInfo>>,

    #[serde(rename = "satelliteBackhaulCat")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub satellite_backhaul_cat: Option<models::SatelliteBackhaulCategory>,

    #[serde(rename = "maxIntegrityProtectedDataRateUl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_integrity_protected_data_rate_ul: Option<models::MaxIntegrityProtectedDataRate>,

    #[serde(rename = "maxIntegrityProtectedDataRateDl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_integrity_protected_data_rate_dl: Option<models::MaxIntegrityProtectedDataRate>,

    #[serde(rename = "upCnxState")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub up_cnx_state: Option<models::UpCnxState>,
}

impl HsmfUpdateData {
    #[allow(clippy::new_without_default)]
    pub fn new(request_indication: models::RequestIndication) -> HsmfUpdateData {
        HsmfUpdateData {
            request_indication,
            pei: None,
            vcn_tunnel_info: None,
            icn_tunnel_info: None,
            additional_cn_tunnel_info: None,
            serving_network: None,
            an_type: None,
            additional_an_type: None,
            rat_type: None,
            ue_location: None,
            ue_time_zone: None,
            add_ue_location: None,
            pause_charging: None,
            pti: None,
            n1_sm_info_from_ue: None,
            unknown_n1_sm_info: None,
            qos_flows_rel_notify_list: None,
            qos_flows_notify_list: None,
            notify_list: None,
            eps_bearer_id: None,
            ho_preparation_indication: None,
            revoke_ebi_list: None,
            cause: None,
            ng_ap_cause: None,
            param_5g_mm_cause_value: None,
            always_on_requested: Some(false),
            eps_interworking_ind: None,
            secondary_rat_usage_report: None,
            secondary_rat_usage_info: None,
            an_type_can_be_changed: Some(false),
            ma_release_ind: None,
            ma_nw_upgrade_ind: Some(false),
            ma_request_ind: Some(false),
            unavailable_access_ind: None,
            psa_info: None,
            ulcl_bp_info: None,
            n4_info: None,
            n4_info_ext1: None,
            n4_info_ext2: None,
            presence_in_ladn: None,
            vsmf_pdu_session_uri: None,
            vsmf_id: None,
            v_smf_service_instance_id: None,
            ismf_pdu_session_uri: None,
            ismf_id: None,
            i_smf_service_instance_id: None,
            dl_serving_plmn_rate_ctl: None,
            dnai_list: None,
            supported_features: None,
            roaming_charging_profile: None,
            mo_exp_data_counter: None,
            vplmn_qos: None,
            security_result: None,
            up_security_info: None,
            amf_nf_id: None,
            guami: None,
            secondary_rat_usage_data_report_container: None,
            sm_policy_notify_ind: None,
            pcf_ue_callback_info: None,
            satellite_backhaul_cat: None,
            max_integrity_protected_data_rate_ul: None,
            max_integrity_protected_data_rate_dl: None,
            up_cnx_state: None,
        }
    }
}

/// Converts the HsmfUpdateData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for HsmfUpdateData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping requestIndication in query parameter serialization
            self.pei
                .as_ref()
                .map(|pei| vec!["pei".to_string(), pei.to_string()].join(",")),
            // Skipping vcnTunnelInfo in query parameter serialization

            // Skipping icnTunnelInfo in query parameter serialization

            // Skipping additionalCnTunnelInfo in query parameter serialization

            // Skipping servingNetwork in query parameter serialization

            // Skipping anType in query parameter serialization

            // Skipping additionalAnType in query parameter serialization

            // Skipping ratType in query parameter serialization

            // Skipping ueLocation in query parameter serialization
            self.ue_time_zone.as_ref().map(|ue_time_zone| {
                vec!["ueTimeZone".to_string(), ue_time_zone.to_string()].join(",")
            }),
            // Skipping addUeLocation in query parameter serialization
            self.pause_charging.as_ref().map(|pause_charging| {
                vec!["pauseCharging".to_string(), pause_charging.to_string()].join(",")
            }),
            self.pti
                .as_ref()
                .map(|pti| vec!["pti".to_string(), pti.to_string()].join(",")),
            // Skipping n1SmInfoFromUe in query parameter serialization

            // Skipping unknownN1SmInfo in query parameter serialization

            // Skipping qosFlowsRelNotifyList in query parameter serialization

            // Skipping qosFlowsNotifyList in query parameter serialization

            // Skipping NotifyList in query parameter serialization
            self.eps_bearer_id.as_ref().map(|eps_bearer_id| {
                vec![
                    "epsBearerId".to_string(),
                    eps_bearer_id
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.ho_preparation_indication
                .as_ref()
                .map(|ho_preparation_indication| {
                    vec![
                        "hoPreparationIndication".to_string(),
                        ho_preparation_indication.to_string(),
                    ]
                    .join(",")
                }),
            self.revoke_ebi_list.as_ref().map(|revoke_ebi_list| {
                vec![
                    "revokeEbiList".to_string(),
                    revoke_ebi_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping cause in query parameter serialization

            // Skipping ngApCause in query parameter serialization
            self.param_5g_mm_cause_value
                .as_ref()
                .map(|param_5g_mm_cause_value| {
                    vec![
                        "5gMmCauseValue".to_string(),
                        param_5g_mm_cause_value.to_string(),
                    ]
                    .join(",")
                }),
            self.always_on_requested
                .as_ref()
                .map(|always_on_requested| {
                    vec![
                        "alwaysOnRequested".to_string(),
                        always_on_requested.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping epsInterworkingInd in query parameter serialization

            // Skipping secondaryRatUsageReport in query parameter serialization

            // Skipping secondaryRatUsageInfo in query parameter serialization
            self.an_type_can_be_changed
                .as_ref()
                .map(|an_type_can_be_changed| {
                    vec![
                        "anTypeCanBeChanged".to_string(),
                        an_type_can_be_changed.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping maReleaseInd in query parameter serialization
            self.ma_nw_upgrade_ind.as_ref().map(|ma_nw_upgrade_ind| {
                vec!["maNwUpgradeInd".to_string(), ma_nw_upgrade_ind.to_string()].join(",")
            }),
            self.ma_request_ind.as_ref().map(|ma_request_ind| {
                vec!["maRequestInd".to_string(), ma_request_ind.to_string()].join(",")
            }),
            // Skipping unavailableAccessInd in query parameter serialization

            // Skipping psaInfo in query parameter serialization

            // Skipping ulclBpInfo in query parameter serialization

            // Skipping n4Info in query parameter serialization

            // Skipping n4InfoExt1 in query parameter serialization

            // Skipping n4InfoExt2 in query parameter serialization

            // Skipping presenceInLadn in query parameter serialization
            self.vsmf_pdu_session_uri
                .as_ref()
                .map(|vsmf_pdu_session_uri| {
                    vec![
                        "vsmfPduSessionUri".to_string(),
                        vsmf_pdu_session_uri.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping vsmfId in query parameter serialization
            self.v_smf_service_instance_id
                .as_ref()
                .map(|v_smf_service_instance_id| {
                    vec![
                        "vSmfServiceInstanceId".to_string(),
                        v_smf_service_instance_id.to_string(),
                    ]
                    .join(",")
                }),
            self.ismf_pdu_session_uri
                .as_ref()
                .map(|ismf_pdu_session_uri| {
                    vec![
                        "ismfPduSessionUri".to_string(),
                        ismf_pdu_session_uri.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping ismfId in query parameter serialization
            self.i_smf_service_instance_id
                .as_ref()
                .map(|i_smf_service_instance_id| {
                    vec![
                        "iSmfServiceInstanceId".to_string(),
                        i_smf_service_instance_id.to_string(),
                    ]
                    .join(",")
                }),
            self.dl_serving_plmn_rate_ctl
                .as_ref()
                .map(|dl_serving_plmn_rate_ctl| {
                    vec![
                        "dlServingPlmnRateCtl".to_string(),
                        dl_serving_plmn_rate_ctl
                            .as_ref()
                            .map_or("null".to_string(), |x| x.to_string()),
                    ]
                    .join(",")
                }),
            self.dnai_list.as_ref().map(|dnai_list| {
                vec![
                    "dnaiList".to_string(),
                    dnai_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.supported_features.as_ref().map(|supported_features| {
                vec![
                    "supportedFeatures".to_string(),
                    supported_features.to_string(),
                ]
                .join(",")
            }),
            // Skipping roamingChargingProfile in query parameter serialization

            // Skipping moExpDataCounter in query parameter serialization

            // Skipping vplmnQos in query parameter serialization

            // Skipping securityResult in query parameter serialization

            // Skipping upSecurityInfo in query parameter serialization

            // Skipping amfNfId in query parameter serialization

            // Skipping guami in query parameter serialization

            // Skipping secondaryRatUsageDataReportContainer in query parameter serialization
            self.sm_policy_notify_ind
                .as_ref()
                .map(|sm_policy_notify_ind| {
                    vec![
                        "smPolicyNotifyInd".to_string(),
                        sm_policy_notify_ind.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping pcfUeCallbackInfo in query parameter serialization

            // Skipping satelliteBackhaulCat in query parameter serialization

            // Skipping maxIntegrityProtectedDataRateUl in query parameter serialization

            // Skipping maxIntegrityProtectedDataRateDl in query parameter serialization

            // Skipping upCnxState in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a HsmfUpdateData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for HsmfUpdateData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub request_indication: Vec<models::RequestIndication>,
            pub pei: Vec<String>,
            pub vcn_tunnel_info: Vec<models::TunnelInfo>,
            pub icn_tunnel_info: Vec<models::TunnelInfo>,
            pub additional_cn_tunnel_info: Vec<models::TunnelInfo>,
            pub serving_network: Vec<models::PlmnIdNid>,
            pub an_type: Vec<models::AccessType>,
            pub additional_an_type: Vec<models::AccessType>,
            pub rat_type: Vec<models::RatType>,
            pub ue_location: Vec<models::UserLocation>,
            pub ue_time_zone: Vec<String>,
            pub add_ue_location: Vec<models::UserLocation>,
            pub pause_charging: Vec<bool>,
            pub pti: Vec<u8>,
            pub n1_sm_info_from_ue: Vec<models::RefToBinaryData>,
            pub unknown_n1_sm_info: Vec<models::RefToBinaryData>,
            pub qos_flows_rel_notify_list: Vec<Vec<models::QosFlowItem>>,
            pub qos_flows_notify_list: Vec<Vec<models::QosFlowNotifyItem>>,
            pub notify_list: Vec<Vec<models::PduSessionNotifyItem>>,
            pub eps_bearer_id: Vec<Vec<models::EpsBearerId>>,
            pub ho_preparation_indication: Vec<bool>,
            pub revoke_ebi_list: Vec<Vec<models::EpsBearerId>>,
            pub cause: Vec<models::Cause>,
            pub ng_ap_cause: Vec<models::NgApCause>,
            pub param_5g_mm_cause_value: Vec<u32>,
            pub always_on_requested: Vec<bool>,
            pub eps_interworking_ind: Vec<models::EpsInterworkingIndication>,
            pub secondary_rat_usage_report: Vec<Vec<models::SecondaryRatUsageReport>>,
            pub secondary_rat_usage_info: Vec<Vec<models::SecondaryRatUsageInfo>>,
            pub an_type_can_be_changed: Vec<bool>,
            pub ma_release_ind: Vec<models::MaReleaseIndication>,
            pub ma_nw_upgrade_ind: Vec<bool>,
            pub ma_request_ind: Vec<bool>,
            pub unavailable_access_ind: Vec<models::UnavailableAccessIndication>,
            pub psa_info: Vec<Vec<models::PsaInformation>>,
            pub ulcl_bp_info: Vec<models::UlclBpInformation>,
            pub n4_info: Vec<models::N4Information>,
            pub n4_info_ext1: Vec<models::N4Information>,
            pub n4_info_ext2: Vec<models::N4Information>,
            pub presence_in_ladn: Vec<models::PresenceState>,
            pub vsmf_pdu_session_uri: Vec<String>,
            pub vsmf_id: Vec<uuid::Uuid>,
            pub v_smf_service_instance_id: Vec<String>,
            pub ismf_pdu_session_uri: Vec<String>,
            pub ismf_id: Vec<uuid::Uuid>,
            pub i_smf_service_instance_id: Vec<String>,
            pub dl_serving_plmn_rate_ctl: Vec<u32>,
            pub dnai_list: Vec<Vec<models::Dnai>>,
            pub supported_features: Vec<String>,
            pub roaming_charging_profile: Vec<models::RoamingChargingProfile>,
            pub mo_exp_data_counter: Vec<models::MoExpDataCounter>,
            pub vplmn_qos: Vec<models::VplmnQos>,
            pub security_result: Vec<models::SecurityResult>,
            pub up_security_info: Vec<models::UpSecurityInfo>,
            pub amf_nf_id: Vec<uuid::Uuid>,
            pub guami: Vec<models::Guami>,
            pub secondary_rat_usage_data_report_container:
                Vec<Vec<models::SecondaryRatUsageDataReportContainer>>,
            pub sm_policy_notify_ind: Vec<bool>,
            pub pcf_ue_callback_info: Vec<models::PcfUeCallbackInfo>,
            pub satellite_backhaul_cat: Vec<models::SatelliteBackhaulCategory>,
            pub max_integrity_protected_data_rate_ul: Vec<models::MaxIntegrityProtectedDataRate>,
            pub max_integrity_protected_data_rate_dl: Vec<models::MaxIntegrityProtectedDataRate>,
            pub up_cnx_state: Vec<models::UpCnxState>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing HsmfUpdateData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "requestIndication" => intermediate_rep.request_indication.push(
                        <models::RequestIndication as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "pei" => intermediate_rep.pei.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "vcnTunnelInfo" => intermediate_rep.vcn_tunnel_info.push(
                        <models::TunnelInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "icnTunnelInfo" => intermediate_rep.icn_tunnel_info.push(
                        <models::TunnelInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "additionalCnTunnelInfo" => intermediate_rep.additional_cn_tunnel_info.push(
                        <models::TunnelInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "servingNetwork" => intermediate_rep.serving_network.push(
                        <models::PlmnIdNid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "anType" => intermediate_rep.an_type.push(
                        <models::AccessType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "additionalAnType" => intermediate_rep.additional_an_type.push(
                        <models::AccessType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ratType" => intermediate_rep.rat_type.push(
                        <models::RatType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ueLocation" => intermediate_rep.ue_location.push(
                        <models::UserLocation as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ueTimeZone" => intermediate_rep.ue_time_zone.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "addUeLocation" => intermediate_rep.add_ue_location.push(
                        <models::UserLocation as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "pauseCharging" => intermediate_rep.pause_charging.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "pti" => intermediate_rep
                        .pti
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "n1SmInfoFromUe" => intermediate_rep.n1_sm_info_from_ue.push(
                        <models::RefToBinaryData as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "unknownN1SmInfo" => intermediate_rep.unknown_n1_sm_info.push(
                        <models::RefToBinaryData as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "qosFlowsRelNotifyList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in HsmfUpdateData"
                                .to_string(),
                        )
                    }
                    "qosFlowsNotifyList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in HsmfUpdateData"
                                .to_string(),
                        )
                    }
                    "NotifyList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in HsmfUpdateData"
                                .to_string(),
                        )
                    }
                    "epsBearerId" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in HsmfUpdateData"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "hoPreparationIndication" => intermediate_rep.ho_preparation_indication.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "revokeEbiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in HsmfUpdateData"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "cause" => intermediate_rep.cause.push(
                        <models::Cause as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ngApCause" => intermediate_rep.ng_ap_cause.push(
                        <models::NgApCause as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "5gMmCauseValue" => intermediate_rep.param_5g_mm_cause_value.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "alwaysOnRequested" => intermediate_rep.always_on_requested.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "epsInterworkingInd" => intermediate_rep.eps_interworking_ind.push(
                        <models::EpsInterworkingIndication as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "secondaryRatUsageReport" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in HsmfUpdateData"
                                .to_string(),
                        )
                    }
                    "secondaryRatUsageInfo" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in HsmfUpdateData"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "anTypeCanBeChanged" => intermediate_rep.an_type_can_be_changed.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "maReleaseInd" => intermediate_rep.ma_release_ind.push(
                        <models::MaReleaseIndication as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "maNwUpgradeInd" => intermediate_rep.ma_nw_upgrade_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "maRequestInd" => intermediate_rep.ma_request_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "unavailableAccessInd" => intermediate_rep.unavailable_access_ind.push(
                        <models::UnavailableAccessIndication as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "psaInfo" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in HsmfUpdateData"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "ulclBpInfo" => intermediate_rep.ulcl_bp_info.push(
                        <models::UlclBpInformation as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n4Info" => intermediate_rep.n4_info.push(
                        <models::N4Information as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n4InfoExt1" => intermediate_rep.n4_info_ext1.push(
                        <models::N4Information as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n4InfoExt2" => intermediate_rep.n4_info_ext2.push(
                        <models::N4Information as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "presenceInLadn" => intermediate_rep.presence_in_ladn.push(
                        <models::PresenceState as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "vsmfPduSessionUri" => intermediate_rep.vsmf_pdu_session_uri.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "vsmfId" => intermediate_rep.vsmf_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "vSmfServiceInstanceId" => intermediate_rep.v_smf_service_instance_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ismfPduSessionUri" => intermediate_rep.ismf_pdu_session_uri.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ismfId" => intermediate_rep.ismf_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "iSmfServiceInstanceId" => intermediate_rep.i_smf_service_instance_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "dlServingPlmnRateCtl" => return std::result::Result::Err(
                        "Parsing a nullable type in this style is not supported in HsmfUpdateData"
                            .to_string(),
                    ),
                    "dnaiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in HsmfUpdateData"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "supportedFeatures" => intermediate_rep.supported_features.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "roamingChargingProfile" => intermediate_rep.roaming_charging_profile.push(
                        <models::RoamingChargingProfile as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "moExpDataCounter" => intermediate_rep.mo_exp_data_counter.push(
                        <models::MoExpDataCounter as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "vplmnQos" => intermediate_rep.vplmn_qos.push(
                        <models::VplmnQos as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "securityResult" => intermediate_rep.security_result.push(
                        <models::SecurityResult as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "upSecurityInfo" => intermediate_rep.up_security_info.push(
                        <models::UpSecurityInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "amfNfId" => intermediate_rep.amf_nf_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "guami" => intermediate_rep.guami.push(
                        <models::Guami as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "secondaryRatUsageDataReportContainer" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in HsmfUpdateData"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "smPolicyNotifyInd" => intermediate_rep.sm_policy_notify_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "pcfUeCallbackInfo" => return std::result::Result::Err(
                        "Parsing a nullable type in this style is not supported in HsmfUpdateData"
                            .to_string(),
                    ),
                    #[allow(clippy::redundant_clone)]
                    "satelliteBackhaulCat" => intermediate_rep.satellite_backhaul_cat.push(
                        <models::SatelliteBackhaulCategory as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "maxIntegrityProtectedDataRateUl" => {
                        intermediate_rep.max_integrity_protected_data_rate_ul.push(
                            <models::MaxIntegrityProtectedDataRate as std::str::FromStr>::from_str(
                                val,
                            )
                            .map_err(|x| x.to_string())?,
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "maxIntegrityProtectedDataRateDl" => {
                        intermediate_rep.max_integrity_protected_data_rate_dl.push(
                            <models::MaxIntegrityProtectedDataRate as std::str::FromStr>::from_str(
                                val,
                            )
                            .map_err(|x| x.to_string())?,
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "upCnxState" => intermediate_rep.up_cnx_state.push(
                        <models::UpCnxState as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing HsmfUpdateData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(HsmfUpdateData {
            request_indication: intermediate_rep
                .request_indication
                .into_iter()
                .next()
                .ok_or_else(|| "requestIndication missing in HsmfUpdateData".to_string())?,
            pei: intermediate_rep.pei.into_iter().next(),
            vcn_tunnel_info: intermediate_rep.vcn_tunnel_info.into_iter().next(),
            icn_tunnel_info: intermediate_rep.icn_tunnel_info.into_iter().next(),
            additional_cn_tunnel_info: intermediate_rep
                .additional_cn_tunnel_info
                .into_iter()
                .next(),
            serving_network: intermediate_rep.serving_network.into_iter().next(),
            an_type: intermediate_rep.an_type.into_iter().next(),
            additional_an_type: intermediate_rep.additional_an_type.into_iter().next(),
            rat_type: intermediate_rep.rat_type.into_iter().next(),
            ue_location: intermediate_rep.ue_location.into_iter().next(),
            ue_time_zone: intermediate_rep.ue_time_zone.into_iter().next(),
            add_ue_location: intermediate_rep.add_ue_location.into_iter().next(),
            pause_charging: intermediate_rep.pause_charging.into_iter().next(),
            pti: intermediate_rep.pti.into_iter().next(),
            n1_sm_info_from_ue: intermediate_rep.n1_sm_info_from_ue.into_iter().next(),
            unknown_n1_sm_info: intermediate_rep.unknown_n1_sm_info.into_iter().next(),
            qos_flows_rel_notify_list: intermediate_rep
                .qos_flows_rel_notify_list
                .into_iter()
                .next(),
            qos_flows_notify_list: intermediate_rep.qos_flows_notify_list.into_iter().next(),
            notify_list: intermediate_rep.notify_list.into_iter().next(),
            eps_bearer_id: intermediate_rep.eps_bearer_id.into_iter().next(),
            ho_preparation_indication: intermediate_rep
                .ho_preparation_indication
                .into_iter()
                .next(),
            revoke_ebi_list: intermediate_rep.revoke_ebi_list.into_iter().next(),
            cause: intermediate_rep.cause.into_iter().next(),
            ng_ap_cause: intermediate_rep.ng_ap_cause.into_iter().next(),
            param_5g_mm_cause_value: intermediate_rep.param_5g_mm_cause_value.into_iter().next(),
            always_on_requested: intermediate_rep.always_on_requested.into_iter().next(),
            eps_interworking_ind: intermediate_rep.eps_interworking_ind.into_iter().next(),
            secondary_rat_usage_report: intermediate_rep
                .secondary_rat_usage_report
                .into_iter()
                .next(),
            secondary_rat_usage_info: intermediate_rep.secondary_rat_usage_info.into_iter().next(),
            an_type_can_be_changed: intermediate_rep.an_type_can_be_changed.into_iter().next(),
            ma_release_ind: intermediate_rep.ma_release_ind.into_iter().next(),
            ma_nw_upgrade_ind: intermediate_rep.ma_nw_upgrade_ind.into_iter().next(),
            ma_request_ind: intermediate_rep.ma_request_ind.into_iter().next(),
            unavailable_access_ind: intermediate_rep.unavailable_access_ind.into_iter().next(),
            psa_info: intermediate_rep.psa_info.into_iter().next(),
            ulcl_bp_info: intermediate_rep.ulcl_bp_info.into_iter().next(),
            n4_info: intermediate_rep.n4_info.into_iter().next(),
            n4_info_ext1: intermediate_rep.n4_info_ext1.into_iter().next(),
            n4_info_ext2: intermediate_rep.n4_info_ext2.into_iter().next(),
            presence_in_ladn: intermediate_rep.presence_in_ladn.into_iter().next(),
            vsmf_pdu_session_uri: intermediate_rep.vsmf_pdu_session_uri.into_iter().next(),
            vsmf_id: intermediate_rep.vsmf_id.into_iter().next(),
            v_smf_service_instance_id: intermediate_rep
                .v_smf_service_instance_id
                .into_iter()
                .next(),
            ismf_pdu_session_uri: intermediate_rep.ismf_pdu_session_uri.into_iter().next(),
            ismf_id: intermediate_rep.ismf_id.into_iter().next(),
            i_smf_service_instance_id: intermediate_rep
                .i_smf_service_instance_id
                .into_iter()
                .next(),
            dl_serving_plmn_rate_ctl: std::result::Result::Err(
                "Nullable types not supported in HsmfUpdateData".to_string(),
            )?,
            dnai_list: intermediate_rep.dnai_list.into_iter().next(),
            supported_features: intermediate_rep.supported_features.into_iter().next(),
            roaming_charging_profile: intermediate_rep.roaming_charging_profile.into_iter().next(),
            mo_exp_data_counter: intermediate_rep.mo_exp_data_counter.into_iter().next(),
            vplmn_qos: intermediate_rep.vplmn_qos.into_iter().next(),
            security_result: intermediate_rep.security_result.into_iter().next(),
            up_security_info: intermediate_rep.up_security_info.into_iter().next(),
            amf_nf_id: intermediate_rep.amf_nf_id.into_iter().next(),
            guami: intermediate_rep.guami.into_iter().next(),
            secondary_rat_usage_data_report_container: intermediate_rep
                .secondary_rat_usage_data_report_container
                .into_iter()
                .next(),
            sm_policy_notify_ind: intermediate_rep.sm_policy_notify_ind.into_iter().next(),
            pcf_ue_callback_info: std::result::Result::Err(
                "Nullable types not supported in HsmfUpdateData".to_string(),
            )?,
            satellite_backhaul_cat: intermediate_rep.satellite_backhaul_cat.into_iter().next(),
            max_integrity_protected_data_rate_ul: intermediate_rep
                .max_integrity_protected_data_rate_ul
                .into_iter()
                .next(),
            max_integrity_protected_data_rate_dl: intermediate_rep
                .max_integrity_protected_data_rate_dl
                .into_iter()
                .next(),
            up_cnx_state: intermediate_rep.up_cnx_state.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<HsmfUpdateData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<HsmfUpdateData>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<HsmfUpdateData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for HsmfUpdateData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<HsmfUpdateData> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <HsmfUpdateData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into HsmfUpdateData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Error within Update Response from H-SMF, or from SMF to I-SMF
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct HsmfUpdateError {
    #[serde(rename = "error")]
    pub error: models::ProblemDetails,

    /// Procedure Transaction Identifier
    #[serde(rename = "pti")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pti: Option<u8>,

    #[serde(rename = "n1smCause")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n1sm_cause: Option<String>,

    #[serde(rename = "n1SmInfoToUe")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n1_sm_info_to_ue: Option<models::RefToBinaryData>,

    /// indicating a time in seconds.
    #[serde(rename = "backOffTimer")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub back_off_timer: Option<i32>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "recoveryTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recovery_time: Option<chrono::DateTime<chrono::Utc>>,
}

impl HsmfUpdateError {
    #[allow(clippy::new_without_default)]
    pub fn new(error: models::ProblemDetails) -> HsmfUpdateError {
        HsmfUpdateError {
            error,
            pti: None,
            n1sm_cause: None,
            n1_sm_info_to_ue: None,
            back_off_timer: None,
            recovery_time: None,
        }
    }
}

/// Converts the HsmfUpdateError value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for HsmfUpdateError {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping error in query parameter serialization
            self.pti
                .as_ref()
                .map(|pti| vec!["pti".to_string(), pti.to_string()].join(",")),
            self.n1sm_cause
                .as_ref()
                .map(|n1sm_cause| vec!["n1smCause".to_string(), n1sm_cause.to_string()].join(",")),
            // Skipping n1SmInfoToUe in query parameter serialization
            self.back_off_timer.as_ref().map(|back_off_timer| {
                vec!["backOffTimer".to_string(), back_off_timer.to_string()].join(",")
            }),
            // Skipping recoveryTime in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a HsmfUpdateError value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for HsmfUpdateError {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub error: Vec<models::ProblemDetails>,
            pub pti: Vec<u8>,
            pub n1sm_cause: Vec<String>,
            pub n1_sm_info_to_ue: Vec<models::RefToBinaryData>,
            pub back_off_timer: Vec<i32>,
            pub recovery_time: Vec<chrono::DateTime<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing HsmfUpdateError".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "error" => intermediate_rep.error.push(
                        <models::ProblemDetails as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "pti" => intermediate_rep
                        .pti
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "n1smCause" => intermediate_rep.n1sm_cause.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n1SmInfoToUe" => intermediate_rep.n1_sm_info_to_ue.push(
                        <models::RefToBinaryData as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "backOffTimer" => intermediate_rep.back_off_timer.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "recoveryTime" => intermediate_rep.recovery_time.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing HsmfUpdateError".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(HsmfUpdateError {
            error: intermediate_rep
                .error
                .into_iter()
                .next()
                .ok_or_else(|| "error missing in HsmfUpdateError".to_string())?,
            pti: intermediate_rep.pti.into_iter().next(),
            n1sm_cause: intermediate_rep.n1sm_cause.into_iter().next(),
            n1_sm_info_to_ue: intermediate_rep.n1_sm_info_to_ue.into_iter().next(),
            back_off_timer: intermediate_rep.back_off_timer.into_iter().next(),
            recovery_time: intermediate_rep.recovery_time.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<HsmfUpdateError> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<HsmfUpdateError>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<HsmfUpdateError>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for HsmfUpdateError - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<HsmfUpdateError>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <HsmfUpdateError as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into HsmfUpdateError - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Data within Update Response from H-SMF, or from SMF to I-SMF
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct HsmfUpdatedData {
    #[serde(rename = "n1SmInfoToUe")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n1_sm_info_to_ue: Option<models::RefToBinaryData>,

    #[serde(rename = "n4Info")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n4_info: Option<models::N4Information>,

    #[serde(rename = "n4InfoExt1")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n4_info_ext1: Option<models::N4Information>,

    #[serde(rename = "n4InfoExt2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n4_info_ext2: Option<models::N4Information>,

    #[serde(rename = "dnaiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dnai_list: Option<Vec<models::Dnai>>,

    /// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  table 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.
    #[serde(rename = "supportedFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_features: Option<String>,

    #[serde(rename = "roamingChargingProfile")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub roaming_charging_profile: Option<models::RoamingChargingProfile>,

    #[serde(rename = "homeProvidedChargingId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub home_provided_charging_id: Option<String>,

    #[serde(rename = "upSecurity")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub up_security: Option<models::UpSecurity>,

    #[serde(rename = "maxIntegrityProtectedDataRateUl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_integrity_protected_data_rate_ul: Option<models::MaxIntegrityProtectedDataRate>,

    #[serde(rename = "maxIntegrityProtectedDataRateDl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_integrity_protected_data_rate_dl: Option<models::MaxIntegrityProtectedDataRate>,

    #[serde(rename = "ipv6MultiHomingInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_multi_homing_ind: Option<bool>,

    #[serde(rename = "qosFlowsSetupList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub qos_flows_setup_list: Option<Vec<models::QosFlowSetupItem>>,

    #[serde(rename = "sessionAmbr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub session_ambr: Option<models::Ambr>,

    #[serde(rename = "epsPdnCnxInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub eps_pdn_cnx_info: Option<models::EpsPdnCnxInfo>,

    #[serde(rename = "epsBearerInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub eps_bearer_info: Option<Vec<models::EpsBearerInfo>>,

    /// Procedure Transaction Identifier
    #[serde(rename = "pti")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pti: Option<u8>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "interPlmnApiRoot")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub inter_plmn_api_root: Option<String>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "intraPlmnApiRoot")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub intra_plmn_api_root: Option<String>,
}

impl HsmfUpdatedData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> HsmfUpdatedData {
        HsmfUpdatedData {
            n1_sm_info_to_ue: None,
            n4_info: None,
            n4_info_ext1: None,
            n4_info_ext2: None,
            dnai_list: None,
            supported_features: None,
            roaming_charging_profile: None,
            home_provided_charging_id: None,
            up_security: None,
            max_integrity_protected_data_rate_ul: None,
            max_integrity_protected_data_rate_dl: None,
            ipv6_multi_homing_ind: Some(false),
            qos_flows_setup_list: None,
            session_ambr: None,
            eps_pdn_cnx_info: None,
            eps_bearer_info: None,
            pti: None,
            inter_plmn_api_root: None,
            intra_plmn_api_root: None,
        }
    }
}

/// Converts the HsmfUpdatedData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for HsmfUpdatedData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping n1SmInfoToUe in query parameter serialization

            // Skipping n4Info in query parameter serialization

            // Skipping n4InfoExt1 in query parameter serialization

            // Skipping n4InfoExt2 in query parameter serialization
            self.dnai_list.as_ref().map(|dnai_list| {
                vec![
                    "dnaiList".to_string(),
                    dnai_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.supported_features.as_ref().map(|supported_features| {
                vec![
                    "supportedFeatures".to_string(),
                    supported_features.to_string(),
                ]
                .join(",")
            }),
            // Skipping roamingChargingProfile in query parameter serialization
            self.home_provided_charging_id
                .as_ref()
                .map(|home_provided_charging_id| {
                    vec![
                        "homeProvidedChargingId".to_string(),
                        home_provided_charging_id.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping upSecurity in query parameter serialization

            // Skipping maxIntegrityProtectedDataRateUl in query parameter serialization

            // Skipping maxIntegrityProtectedDataRateDl in query parameter serialization
            self.ipv6_multi_homing_ind
                .as_ref()
                .map(|ipv6_multi_homing_ind| {
                    vec![
                        "ipv6MultiHomingInd".to_string(),
                        ipv6_multi_homing_ind.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping qosFlowsSetupList in query parameter serialization

            // Skipping sessionAmbr in query parameter serialization

            // Skipping epsPdnCnxInfo in query parameter serialization

            // Skipping epsBearerInfo in query parameter serialization
            self.pti
                .as_ref()
                .map(|pti| vec!["pti".to_string(), pti.to_string()].join(",")),
            self.inter_plmn_api_root
                .as_ref()
                .map(|inter_plmn_api_root| {
                    vec![
                        "interPlmnApiRoot".to_string(),
                        inter_plmn_api_root.to_string(),
                    ]
                    .join(",")
                }),
            self.intra_plmn_api_root
                .as_ref()
                .map(|intra_plmn_api_root| {
                    vec![
                        "intraPlmnApiRoot".to_string(),
                        intra_plmn_api_root.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a HsmfUpdatedData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for HsmfUpdatedData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub n1_sm_info_to_ue: Vec<models::RefToBinaryData>,
            pub n4_info: Vec<models::N4Information>,
            pub n4_info_ext1: Vec<models::N4Information>,
            pub n4_info_ext2: Vec<models::N4Information>,
            pub dnai_list: Vec<Vec<models::Dnai>>,
            pub supported_features: Vec<String>,
            pub roaming_charging_profile: Vec<models::RoamingChargingProfile>,
            pub home_provided_charging_id: Vec<String>,
            pub up_security: Vec<models::UpSecurity>,
            pub max_integrity_protected_data_rate_ul: Vec<models::MaxIntegrityProtectedDataRate>,
            pub max_integrity_protected_data_rate_dl: Vec<models::MaxIntegrityProtectedDataRate>,
            pub ipv6_multi_homing_ind: Vec<bool>,
            pub qos_flows_setup_list: Vec<Vec<models::QosFlowSetupItem>>,
            pub session_ambr: Vec<models::Ambr>,
            pub eps_pdn_cnx_info: Vec<models::EpsPdnCnxInfo>,
            pub eps_bearer_info: Vec<Vec<models::EpsBearerInfo>>,
            pub pti: Vec<u8>,
            pub inter_plmn_api_root: Vec<String>,
            pub intra_plmn_api_root: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing HsmfUpdatedData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "n1SmInfoToUe" => intermediate_rep.n1_sm_info_to_ue.push(
                        <models::RefToBinaryData as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n4Info" => intermediate_rep.n4_info.push(
                        <models::N4Information as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n4InfoExt1" => intermediate_rep.n4_info_ext1.push(
                        <models::N4Information as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n4InfoExt2" => intermediate_rep.n4_info_ext2.push(
                        <models::N4Information as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "dnaiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in HsmfUpdatedData"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "supportedFeatures" => intermediate_rep.supported_features.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "roamingChargingProfile" => intermediate_rep.roaming_charging_profile.push(
                        <models::RoamingChargingProfile as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "homeProvidedChargingId" => intermediate_rep.home_provided_charging_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "upSecurity" => intermediate_rep.up_security.push(
                        <models::UpSecurity as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "maxIntegrityProtectedDataRateUl" => {
                        intermediate_rep.max_integrity_protected_data_rate_ul.push(
                            <models::MaxIntegrityProtectedDataRate as std::str::FromStr>::from_str(
                                val,
                            )
                            .map_err(|x| x.to_string())?,
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "maxIntegrityProtectedDataRateDl" => {
                        intermediate_rep.max_integrity_protected_data_rate_dl.push(
                            <models::MaxIntegrityProtectedDataRate as std::str::FromStr>::from_str(
                                val,
                            )
                            .map_err(|x| x.to_string())?,
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "ipv6MultiHomingInd" => intermediate_rep.ipv6_multi_homing_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "qosFlowsSetupList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in HsmfUpdatedData"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "sessionAmbr" => intermediate_rep.session_ambr.push(
                        <models::Ambr as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "epsPdnCnxInfo" => intermediate_rep.eps_pdn_cnx_info.push(
                        <models::EpsPdnCnxInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "epsBearerInfo" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in HsmfUpdatedData"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "pti" => intermediate_rep
                        .pti
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "interPlmnApiRoot" => intermediate_rep.inter_plmn_api_root.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "intraPlmnApiRoot" => intermediate_rep.intra_plmn_api_root.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing HsmfUpdatedData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(HsmfUpdatedData {
            n1_sm_info_to_ue: intermediate_rep.n1_sm_info_to_ue.into_iter().next(),
            n4_info: intermediate_rep.n4_info.into_iter().next(),
            n4_info_ext1: intermediate_rep.n4_info_ext1.into_iter().next(),
            n4_info_ext2: intermediate_rep.n4_info_ext2.into_iter().next(),
            dnai_list: intermediate_rep.dnai_list.into_iter().next(),
            supported_features: intermediate_rep.supported_features.into_iter().next(),
            roaming_charging_profile: intermediate_rep.roaming_charging_profile.into_iter().next(),
            home_provided_charging_id: intermediate_rep
                .home_provided_charging_id
                .into_iter()
                .next(),
            up_security: intermediate_rep.up_security.into_iter().next(),
            max_integrity_protected_data_rate_ul: intermediate_rep
                .max_integrity_protected_data_rate_ul
                .into_iter()
                .next(),
            max_integrity_protected_data_rate_dl: intermediate_rep
                .max_integrity_protected_data_rate_dl
                .into_iter()
                .next(),
            ipv6_multi_homing_ind: intermediate_rep.ipv6_multi_homing_ind.into_iter().next(),
            qos_flows_setup_list: intermediate_rep.qos_flows_setup_list.into_iter().next(),
            session_ambr: intermediate_rep.session_ambr.into_iter().next(),
            eps_pdn_cnx_info: intermediate_rep.eps_pdn_cnx_info.into_iter().next(),
            eps_bearer_info: intermediate_rep.eps_bearer_info.into_iter().next(),
            pti: intermediate_rep.pti.into_iter().next(),
            inter_plmn_api_root: intermediate_rep.inter_plmn_api_root.into_iter().next(),
            intra_plmn_api_root: intermediate_rep.intra_plmn_api_root.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<HsmfUpdatedData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<HsmfUpdatedData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<HsmfUpdatedData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for HsmfUpdatedData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<HsmfUpdatedData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <HsmfUpdatedData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into HsmfUpdatedData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Indirect Data Forwarding Tunnel Information
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IndirectDataForwardingTunnelInfo {
    /// String identifying a IPv4 address formatted in the 'dotted decimal' notation as defined in RFC 1166.
    #[serde(rename = "ipv4Addr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv4_addr: Option<String>,

    #[serde(rename = "ipv6Addr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_addr: Option<models::Ipv6Addr>,

    /// GTP Tunnel Endpoint Identifier
    #[serde(rename = "gtpTeid")]
    pub gtp_teid: String,

    /// Data Radio Bearer Identity
    #[serde(rename = "drbId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub drb_id: Option<u8>,

    /// indicates first, second or third additional indirect data forwarding tunnel
    #[serde(rename = "additionalTnlNb")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_tnl_nb: Option<u8>,
}

impl IndirectDataForwardingTunnelInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(gtp_teid: String) -> IndirectDataForwardingTunnelInfo {
        IndirectDataForwardingTunnelInfo {
            ipv4_addr: None,
            ipv6_addr: None,
            gtp_teid,
            drb_id: None,
            additional_tnl_nb: None,
        }
    }
}

/// Converts the IndirectDataForwardingTunnelInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for IndirectDataForwardingTunnelInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.ipv4_addr
                .as_ref()
                .map(|ipv4_addr| vec!["ipv4Addr".to_string(), ipv4_addr.to_string()].join(",")),
            // Skipping ipv6Addr in query parameter serialization
            Some("gtpTeid".to_string()),
            Some(self.gtp_teid.to_string()),
            self.drb_id
                .as_ref()
                .map(|drb_id| vec!["drbId".to_string(), drb_id.to_string()].join(",")),
            self.additional_tnl_nb.as_ref().map(|additional_tnl_nb| {
                vec!["additionalTnlNb".to_string(), additional_tnl_nb.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IndirectDataForwardingTunnelInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IndirectDataForwardingTunnelInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ipv4_addr: Vec<String>,
            pub ipv6_addr: Vec<models::Ipv6Addr>,
            pub gtp_teid: Vec<String>,
            pub drb_id: Vec<u8>,
            pub additional_tnl_nb: Vec<u8>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing IndirectDataForwardingTunnelInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ipv4Addr" => intermediate_rep.ipv4_addr.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ipv6Addr" => intermediate_rep.ipv6_addr.push(
                        <models::Ipv6Addr as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "gtpTeid" => intermediate_rep.gtp_teid.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "drbId" => intermediate_rep
                        .drb_id
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "additionalTnlNb" => intermediate_rep
                        .additional_tnl_nb
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing IndirectDataForwardingTunnelInfo"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IndirectDataForwardingTunnelInfo {
            ipv4_addr: intermediate_rep.ipv4_addr.into_iter().next(),
            ipv6_addr: intermediate_rep.ipv6_addr.into_iter().next(),
            gtp_teid: intermediate_rep
                .gtp_teid
                .into_iter()
                .next()
                .ok_or_else(|| "gtpTeid missing in IndirectDataForwardingTunnelInfo".to_string())?,
            drb_id: intermediate_rep.drb_id.into_iter().next(),
            additional_tnl_nb: intermediate_rep.additional_tnl_nb.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IndirectDataForwardingTunnelInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<IndirectDataForwardingTunnelInfo>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<IndirectDataForwardingTunnelInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for IndirectDataForwardingTunnelInfo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<IndirectDataForwardingTunnelInfo>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <IndirectDataForwardingTunnelInfo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into IndirectDataForwardingTunnelInfo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

/// string with format 'int64' as defined in OpenAPI.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Int64(i64);

impl std::convert::From<i64> for Int64 {
    fn from(x: i64) -> Self {
        Int64(x)
    }
}

impl std::convert::From<Int64> for i64 {
    fn from(x: Int64) -> Self {
        x.0
    }
}

impl std::ops::Deref for Int64 {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}

impl std::ops::DerefMut for Int64 {
    fn deref_mut(&mut self) -> &mut i64 {
        &mut self.0
    }
}

/// It contains an invalid parameter and a related description.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InvalidParam {
    /// If the invalid parameter is an attribute in a JSON body, this IE shall contain the  attribute's name and shall be encoded as a JSON Pointer. If the invalid parameter is  an HTTP header, this IE shall be formatted as the concatenation of the string \"header \"  plus the name of such header. If the invalid parameter is a query parameter, this IE  shall be formatted as the concatenation of the string \"query \" plus the name of such  query parameter. If the invalid parameter is a variable part in the path of a resource  URI, this IE shall contain the name of the variable, including the symbols \"{\" and \"}\"  used in OpenAPI specification as the notation to represent variable path segments.
    #[serde(rename = "param")]
    pub param: String,

    /// A human-readable reason, e.g. \"must be a positive integer\". In cases involving failed  operations in a PATCH request, the reason string should identify the operation that  failed using the operation's array index to assist in correlation of the invalid  parameter with the failed operation, e.g.\" Replacement value invalid for attribute  (failed operation index= 4)\"
    #[serde(rename = "reason")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
}

impl InvalidParam {
    #[allow(clippy::new_without_default)]
    pub fn new(param: String) -> InvalidParam {
        InvalidParam {
            param,
            reason: None,
        }
    }
}

/// Converts the InvalidParam value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for InvalidParam {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("param".to_string()),
            Some(self.param.to_string()),
            self.reason
                .as_ref()
                .map(|reason| vec!["reason".to_string(), reason.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InvalidParam value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InvalidParam {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub param: Vec<String>,
            pub reason: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing InvalidParam".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "param" => intermediate_rep.param.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "reason" => intermediate_rep.reason.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing InvalidParam".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InvalidParam {
            param: intermediate_rep
                .param
                .into_iter()
                .next()
                .ok_or_else(|| "param missing in InvalidParam".to_string())?,
            reason: intermediate_rep.reason.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InvalidParam> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<InvalidParam>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<InvalidParam>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for InvalidParam - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<InvalidParam> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <InvalidParam as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into InvalidParam - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// IP Address
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IpAddress {
    /// String identifying a IPv4 address formatted in the 'dotted decimal' notation as defined in RFC 1166.
    #[serde(rename = "ipv4Addr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv4_addr: Option<String>,

    #[serde(rename = "ipv6Addr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_addr: Option<models::Ipv6Addr>,

    #[serde(rename = "ipv6Prefix")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_prefix: Option<models::Ipv6Prefix>,
}

impl IpAddress {
    #[allow(clippy::new_without_default)]
    pub fn new() -> IpAddress {
        IpAddress {
            ipv4_addr: None,
            ipv6_addr: None,
            ipv6_prefix: None,
        }
    }
}

/// Converts the IpAddress value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for IpAddress {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.ipv4_addr
                .as_ref()
                .map(|ipv4_addr| vec!["ipv4Addr".to_string(), ipv4_addr.to_string()].join(",")),
            // Skipping ipv6Addr in query parameter serialization

            // Skipping ipv6Prefix in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IpAddress value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IpAddress {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ipv4_addr: Vec<String>,
            pub ipv6_addr: Vec<models::Ipv6Addr>,
            pub ipv6_prefix: Vec<models::Ipv6Prefix>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing IpAddress".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ipv4Addr" => intermediate_rep.ipv4_addr.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ipv6Addr" => intermediate_rep.ipv6_addr.push(
                        <models::Ipv6Addr as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ipv6Prefix" => intermediate_rep.ipv6_prefix.push(
                        <models::Ipv6Prefix as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing IpAddress".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IpAddress {
            ipv4_addr: intermediate_rep.ipv4_addr.into_iter().next(),
            ipv6_addr: intermediate_rep.ipv6_addr.into_iter().next(),
            ipv6_prefix: intermediate_rep.ipv6_prefix.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IpAddress> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<IpAddress>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<IpAddress>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for IpAddress - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<IpAddress> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <IpAddress as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into IpAddress - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Represents information that identifies which IP pool or external server is used to allocate the IP address.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IpIndex(i32);

impl std::convert::From<i32> for IpIndex {
    fn from(x: i32) -> Self {
        IpIndex(x)
    }
}

impl std::convert::From<IpIndex> for i32 {
    fn from(x: IpIndex) -> Self {
        x.0
    }
}

impl std::ops::Deref for IpIndex {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for IpIndex {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// String identifying a IPv4 address formatted in the 'dotted decimal' notation as defined in RFC 1166.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Ipv4Addr(String);

impl std::convert::From<String> for Ipv4Addr {
    fn from(x: String) -> Self {
        Ipv4Addr(x)
    }
}

impl std::string::ToString for Ipv4Addr {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Ipv4Addr {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Ipv4Addr(x.to_string()))
    }
}

impl std::convert::From<Ipv4Addr> for String {
    fn from(x: Ipv4Addr) -> Self {
        x.0
    }
}

impl std::ops::Deref for Ipv4Addr {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Ipv4Addr {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// String identifying an IPv6 address formatted according to clause 4 of RFC5952. The mixed IPv4 IPv6 notation according to clause 5 of RFC5952 shall not be used.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Ipv6Addr(serde_json::Value);

impl std::convert::From<serde_json::Value> for Ipv6Addr {
    fn from(x: serde_json::Value) -> Self {
        Ipv6Addr(x)
    }
}

impl std::convert::From<Ipv6Addr> for serde_json::Value {
    fn from(x: Ipv6Addr) -> Self {
        x.0
    }
}

impl std::ops::Deref for Ipv6Addr {
    type Target = serde_json::Value;
    fn deref(&self) -> &serde_json::Value {
        &self.0
    }
}

impl std::ops::DerefMut for Ipv6Addr {
    fn deref_mut(&mut self) -> &mut serde_json::Value {
        &mut self.0
    }
}

impl FromStr for Ipv6Addr {
    type Err = serde_json::Error;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(Self(serde_json::from_str(s)?))
    }
}

/// String identifying an IPv6 address prefix formatted according to clause 4 of RFC 5952. IPv6Prefix data type may contain an individual /128 IPv6 address.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Ipv6Prefix(serde_json::Value);

impl std::convert::From<serde_json::Value> for Ipv6Prefix {
    fn from(x: serde_json::Value) -> Self {
        Ipv6Prefix(x)
    }
}

impl std::convert::From<Ipv6Prefix> for serde_json::Value {
    fn from(x: Ipv6Prefix) -> Self {
        x.0
    }
}

impl std::ops::Deref for Ipv6Prefix {
    type Target = serde_json::Value;
    fn deref(&self) -> &serde_json::Value {
        &self.0
    }
}

impl std::ops::DerefMut for Ipv6Prefix {
    fn deref_mut(&mut self) -> &mut serde_json::Value {
        &mut self.0
    }
}

impl FromStr for Ipv6Prefix {
    type Err = serde_json::Error;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(Self(serde_json::from_str(s)?))
    }
}

/// Possible values are: - DSL: Identifies a DSL line - PON: Identifies a PON line
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LineType {}

impl LineType {
    #[allow(clippy::new_without_default)]
    pub fn new() -> LineType {
        LineType {}
    }
}

/// Converts the LineType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for LineType {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LineType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LineType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing LineType".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing LineType".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LineType {})
    }
}

// Methods for converting between header::IntoHeaderValue<LineType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<LineType>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<LineType>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for LineType - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<LineType> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <LineType as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into LineType - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum LineTypeAnyOf {
    #[serde(rename = "DSL")]
    Dsl,
    #[serde(rename = "PON")]
    Pon,
}

impl std::fmt::Display for LineTypeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            LineTypeAnyOf::Dsl => write!(f, "DSL"),
            LineTypeAnyOf::Pon => write!(f, "PON"),
        }
    }
}

impl std::str::FromStr for LineTypeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "DSL" => std::result::Result::Ok(LineTypeAnyOf::Dsl),
            "PON" => std::result::Result::Ok(LineTypeAnyOf::Pon),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Contains a Location area identification as defined in 3GPP TS 23.003, clause 4.1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LocationAreaId {
    #[serde(rename = "plmnId")]
    pub plmn_id: models::PlmnId,

    /// Location Area Code.
    #[serde(rename = "lac")]
    pub lac: String,
}

impl LocationAreaId {
    #[allow(clippy::new_without_default)]
    pub fn new(plmn_id: models::PlmnId, lac: String) -> LocationAreaId {
        LocationAreaId { plmn_id, lac }
    }
}

/// Converts the LocationAreaId value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for LocationAreaId {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping plmnId in query parameter serialization
            Some("lac".to_string()),
            Some(self.lac.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LocationAreaId value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LocationAreaId {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub plmn_id: Vec<models::PlmnId>,
            pub lac: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing LocationAreaId".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "plmnId" => intermediate_rep.plmn_id.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "lac" => intermediate_rep.lac.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing LocationAreaId".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LocationAreaId {
            plmn_id: intermediate_rep
                .plmn_id
                .into_iter()
                .next()
                .ok_or_else(|| "plmnId missing in LocationAreaId".to_string())?,
            lac: intermediate_rep
                .lac
                .into_iter()
                .next()
                .ok_or_else(|| "lac missing in LocationAreaId".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LocationAreaId> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<LocationAreaId>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<LocationAreaId>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for LocationAreaId - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<LocationAreaId> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <LocationAreaId as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into LocationAreaId - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Multi-Access PDU session release Indication. Possible values are   - REL_MAPDU_OVER_3GPP   - REL_MAPDU_OVER_N3GPP
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MaReleaseIndication {}

impl MaReleaseIndication {
    #[allow(clippy::new_without_default)]
    pub fn new() -> MaReleaseIndication {
        MaReleaseIndication {}
    }
}

/// Converts the MaReleaseIndication value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MaReleaseIndication {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MaReleaseIndication value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MaReleaseIndication {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing MaReleaseIndication".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing MaReleaseIndication".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MaReleaseIndication {})
    }
}

// Methods for converting between header::IntoHeaderValue<MaReleaseIndication> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MaReleaseIndication>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<MaReleaseIndication>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for MaReleaseIndication - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<MaReleaseIndication>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <MaReleaseIndication as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into MaReleaseIndication - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum MaReleaseIndicationAnyOf {
    #[serde(rename = "REL_MAPDU_OVER_3GPP")]
    Variant3Gpp,
    #[serde(rename = "REL_MAPDU_OVER_N3GPP")]
    N3Gpp,
}

impl std::fmt::Display for MaReleaseIndicationAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            MaReleaseIndicationAnyOf::Variant3Gpp => write!(f, "REL_MAPDU_OVER_3GPP"),
            MaReleaseIndicationAnyOf::N3Gpp => write!(f, "REL_MAPDU_OVER_N3GPP"),
        }
    }
}

impl std::str::FromStr for MaReleaseIndicationAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "REL_MAPDU_OVER_3GPP" => std::result::Result::Ok(MaReleaseIndicationAnyOf::Variant3Gpp),
            "REL_MAPDU_OVER_N3GPP" => std::result::Result::Ok(MaReleaseIndicationAnyOf::N3Gpp),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// String identifying a MAC address formatted in the hexadecimal notation according to clause 1.1 and clause 2.1 of RFC 7042.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MacAddr48(String);

impl std::convert::From<String> for MacAddr48 {
    fn from(x: String) -> Self {
        MacAddr48(x)
    }
}

impl std::string::ToString for MacAddr48 {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for MacAddr48 {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(MacAddr48(x.to_string()))
    }
}

impl std::convert::From<MacAddr48> for String {
    fn from(x: MacAddr48) -> Self {
        x.0
    }
}

impl std::ops::Deref for MacAddr48 {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for MacAddr48 {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Unsigned integer indicating Maximum Data Burst Volume (see clauses 5.7.3.7 and 5.7.4 of 3GPP TS 23.501), expressed in Bytes.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MaxDataBurstVol(i32);

impl std::convert::From<i32> for MaxDataBurstVol {
    fn from(x: i32) -> Self {
        MaxDataBurstVol(x)
    }
}

impl std::convert::From<MaxDataBurstVol> for i32 {
    fn from(x: MaxDataBurstVol) -> Self {
        x.0
    }
}

impl std::ops::Deref for MaxDataBurstVol {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for MaxDataBurstVol {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// Maximum Integrity Protected Data Rate. Possible values are   - 64_KBPS   - MAX_UE_RATE
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MaxIntegrityProtectedDataRate {}

impl MaxIntegrityProtectedDataRate {
    #[allow(clippy::new_without_default)]
    pub fn new() -> MaxIntegrityProtectedDataRate {
        MaxIntegrityProtectedDataRate {}
    }
}

/// Converts the MaxIntegrityProtectedDataRate value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MaxIntegrityProtectedDataRate {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MaxIntegrityProtectedDataRate value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MaxIntegrityProtectedDataRate {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing MaxIntegrityProtectedDataRate".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing MaxIntegrityProtectedDataRate"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MaxIntegrityProtectedDataRate {})
    }
}

// Methods for converting between header::IntoHeaderValue<MaxIntegrityProtectedDataRate> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MaxIntegrityProtectedDataRate>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<MaxIntegrityProtectedDataRate>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for MaxIntegrityProtectedDataRate - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<MaxIntegrityProtectedDataRate>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MaxIntegrityProtectedDataRate as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MaxIntegrityProtectedDataRate - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum MaxIntegrityProtectedDataRateAnyOf {
    #[serde(rename = "64_KBPS")]
    Variant64Kbps,
    #[serde(rename = "MAX_UE_RATE")]
    MaxUeRate,
}

impl std::fmt::Display for MaxIntegrityProtectedDataRateAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            MaxIntegrityProtectedDataRateAnyOf::Variant64Kbps => write!(f, "64_KBPS"),
            MaxIntegrityProtectedDataRateAnyOf::MaxUeRate => write!(f, "MAX_UE_RATE"),
        }
    }
}

impl std::str::FromStr for MaxIntegrityProtectedDataRateAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "64_KBPS" => std::result::Result::Ok(MaxIntegrityProtectedDataRateAnyOf::Variant64Kbps),
            "MAX_UE_RATE" => std::result::Result::Ok(MaxIntegrityProtectedDataRateAnyOf::MaxUeRate),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Mobile Country Code part of the PLMN, comprising 3 digits, as defined in clause 9.3.3.5 of 3GPP TS 38.413.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Mcc(String);

impl std::convert::From<String> for Mcc {
    fn from(x: String) -> Self {
        Mcc(x)
    }
}

impl std::string::ToString for Mcc {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Mcc {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Mcc(x.to_string()))
    }
}

impl std::convert::From<Mcc> for String {
    fn from(x: Mcc) -> Self {
        x.0
    }
}

impl std::ops::Deref for Mcc {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Mcc {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// MME capabilities
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MmeCapabilities {
    #[serde(rename = "nonIpSupported")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub non_ip_supported: Option<bool>,

    #[serde(rename = "ethernetSupported")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ethernet_supported: Option<bool>,

    #[serde(rename = "upipSupported")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub upip_supported: Option<bool>,
}

impl MmeCapabilities {
    #[allow(clippy::new_without_default)]
    pub fn new() -> MmeCapabilities {
        MmeCapabilities {
            non_ip_supported: Some(false),
            ethernet_supported: Some(false),
            upip_supported: Some(false),
        }
    }
}

/// Converts the MmeCapabilities value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MmeCapabilities {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.non_ip_supported.as_ref().map(|non_ip_supported| {
                vec!["nonIpSupported".to_string(), non_ip_supported.to_string()].join(",")
            }),
            self.ethernet_supported.as_ref().map(|ethernet_supported| {
                vec![
                    "ethernetSupported".to_string(),
                    ethernet_supported.to_string(),
                ]
                .join(",")
            }),
            self.upip_supported.as_ref().map(|upip_supported| {
                vec!["upipSupported".to_string(), upip_supported.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MmeCapabilities value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MmeCapabilities {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub non_ip_supported: Vec<bool>,
            pub ethernet_supported: Vec<bool>,
            pub upip_supported: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing MmeCapabilities".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "nonIpSupported" => intermediate_rep.non_ip_supported.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ethernetSupported" => intermediate_rep.ethernet_supported.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "upipSupported" => intermediate_rep.upip_supported.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing MmeCapabilities".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MmeCapabilities {
            non_ip_supported: intermediate_rep.non_ip_supported.into_iter().next(),
            ethernet_supported: intermediate_rep.ethernet_supported.into_iter().next(),
            upip_supported: intermediate_rep.upip_supported.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MmeCapabilities> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MmeCapabilities>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<MmeCapabilities>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for MmeCapabilities - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<MmeCapabilities>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <MmeCapabilities as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into MmeCapabilities - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Mobile Network Code part of the PLMN, comprising 2 or 3 digits, as defined in clause 9.3.3.5 of 3GPP TS 38.413.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Mnc(String);

impl std::convert::From<String> for Mnc {
    fn from(x: String) -> Self {
        Mnc(x)
    }
}

impl std::string::ToString for Mnc {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Mnc {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Mnc(x.to_string()))
    }
}

impl std::convert::From<Mnc> for String {
    fn from(x: Mnc) -> Self {
        x.0
    }
}

impl std::ops::Deref for Mnc {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Mnc {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Contain the MO Exception Data Counter.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoExpDataCounter {
    /// Unsigned integer identifying the MO Exception Data Counter, as specified in clause 5.31.14.3 of 3GPP TS 23.501.
    #[serde(rename = "counter")]
    pub counter: i32,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "timeStamp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub time_stamp: Option<chrono::DateTime<chrono::Utc>>,
}

impl MoExpDataCounter {
    #[allow(clippy::new_without_default)]
    pub fn new(counter: i32) -> MoExpDataCounter {
        MoExpDataCounter {
            counter,
            time_stamp: None,
        }
    }
}

/// Converts the MoExpDataCounter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MoExpDataCounter {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("counter".to_string()),
            Some(self.counter.to_string()),
            // Skipping timeStamp in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoExpDataCounter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoExpDataCounter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub counter: Vec<i32>,
            pub time_stamp: Vec<chrono::DateTime<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing MoExpDataCounter".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "counter" => intermediate_rep.counter.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "timeStamp" => intermediate_rep.time_stamp.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing MoExpDataCounter".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoExpDataCounter {
            counter: intermediate_rep
                .counter
                .into_iter()
                .next()
                .ok_or_else(|| "counter missing in MoExpDataCounter".to_string())?,
            time_stamp: intermediate_rep.time_stamp.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoExpDataCounter> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MoExpDataCounter>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<MoExpDataCounter>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for MoExpDataCounter - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<MoExpDataCounter>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <MoExpDataCounter as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into MoExpDataCounter - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Unsigned Integer, i.e. only value 0 and integers above 0 are permissible.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Model5GmmCause {}

impl Model5GmmCause {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Model5GmmCause {
        Model5GmmCause {}
    }
}

/// Converts the Model5GmmCause value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Model5GmmCause {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Model5GmmCause value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Model5GmmCause {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Model5GmmCause".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Model5GmmCause".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Model5GmmCause {})
    }
}

// Methods for converting between header::IntoHeaderValue<Model5GmmCause> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Model5GmmCause>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Model5GmmCause>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Model5GmmCause - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Model5GmmCause> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <Model5GmmCause as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into Model5GmmCause - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Unsigned integer representing a 5G QoS Identifier (see clause 5.7.2.1 of 3GPP TS 23.501, within the range 0 to 255.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Model5Qi(i32);

impl std::convert::From<i32> for Model5Qi {
    fn from(x: i32) -> Self {
        Model5Qi(x)
    }
}

impl std::convert::From<Model5Qi> for i32 {
    fn from(x: Model5Qi) -> Self {
        x.0
    }
}

impl std::ops::Deref for Model5Qi {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for Model5Qi {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// Unsigned integer indicating the 5QI Priority Level (see clauses 5.7.3.3 and 5.7.4 of 3GPP TS 23.501, within the range 1 to 127.Values are ordered in decreasing order of priority,  i.e. with 1 as the highest priority and 127 as the lowest priority.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Model5QiPriorityLevel(i32);

impl std::convert::From<i32> for Model5QiPriorityLevel {
    fn from(x: i32) -> Self {
        Model5QiPriorityLevel(x)
    }
}

impl std::convert::From<Model5QiPriorityLevel> for i32 {
    fn from(x: Model5QiPriorityLevel) -> Self {
        x.0
    }
}

impl std::ops::Deref for Model5QiPriorityLevel {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for Model5QiPriorityLevel {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// N2 SM Information Type. Possible values are - PDU_RES_SETUP_REQ - PDU_RES_SETUP_RSP - PDU_RES_SETUP_FAIL - PDU_RES_REL_CMD - PDU_RES_REL_RSP - PDU_RES_MOD_REQ - PDU_RES_MOD_RSP - PDU_RES_MOD_FAIL - PDU_RES_NTY - PDU_RES_NTY_REL - PDU_RES_MOD_IND - PDU_RES_MOD_CFM - PATH_SWITCH_REQ - PATH_SWITCH_SETUP_FAIL - PATH_SWITCH_REQ_ACK - PATH_SWITCH_REQ_FAIL - HANDOVER_REQUIRED - HANDOVER_CMD - HANDOVER_PREP_FAIL - HANDOVER_REQ_ACK - HANDOVER_RES_ALLOC_FAIL - SECONDARY_RAT_USAGE - PDU_RES_MOD_IND_FAIL - UE_CONTEXT_RESUME_REQ - UE_CONTEXT_RESUME_RSP - UE_CONTEXT_SUSPEND_REQ
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct N2SmInfoType {}

impl N2SmInfoType {
    #[allow(clippy::new_without_default)]
    pub fn new() -> N2SmInfoType {
        N2SmInfoType {}
    }
}

/// Converts the N2SmInfoType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for N2SmInfoType {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a N2SmInfoType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for N2SmInfoType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing N2SmInfoType".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing N2SmInfoType".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(N2SmInfoType {})
    }
}

// Methods for converting between header::IntoHeaderValue<N2SmInfoType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<N2SmInfoType>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<N2SmInfoType>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for N2SmInfoType - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<N2SmInfoType> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <N2SmInfoType as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into N2SmInfoType - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum N2SmInfoTypeAnyOf {
    #[serde(rename = "PDU_RES_SETUP_REQ")]
    PduResSetupReq,
    #[serde(rename = "PDU_RES_SETUP_RSP")]
    PduResSetupRsp,
    #[serde(rename = "PDU_RES_SETUP_FAIL")]
    PduResSetupFail,
    #[serde(rename = "PDU_RES_REL_CMD")]
    PduResRelCmd,
    #[serde(rename = "PDU_RES_REL_RSP")]
    PduResRelRsp,
    #[serde(rename = "PDU_RES_MOD_REQ")]
    PduResModReq,
    #[serde(rename = "PDU_RES_MOD_RSP")]
    PduResModRsp,
    #[serde(rename = "PDU_RES_MOD_FAIL")]
    PduResModFail,
    #[serde(rename = "PDU_RES_NTY")]
    PduResNty,
    #[serde(rename = "PDU_RES_NTY_REL")]
    PduResNtyRel,
    #[serde(rename = "PDU_RES_MOD_IND")]
    PduResModInd,
    #[serde(rename = "PDU_RES_MOD_CFM")]
    PduResModCfm,
    #[serde(rename = "PATH_SWITCH_REQ")]
    PathSwitchReq,
    #[serde(rename = "PATH_SWITCH_SETUP_FAIL")]
    PathSwitchSetupFail,
    #[serde(rename = "PATH_SWITCH_REQ_ACK")]
    PathSwitchReqAck,
    #[serde(rename = "PATH_SWITCH_REQ_FAIL")]
    PathSwitchReqFail,
    #[serde(rename = "HANDOVER_REQUIRED")]
    HandoverRequired,
    #[serde(rename = "HANDOVER_CMD")]
    HandoverCmd,
    #[serde(rename = "HANDOVER_PREP_FAIL")]
    HandoverPrepFail,
    #[serde(rename = "HANDOVER_REQ_ACK")]
    HandoverReqAck,
    #[serde(rename = "HANDOVER_RES_ALLOC_FAIL")]
    HandoverResAllocFail,
    #[serde(rename = "SECONDARY_RAT_USAGE")]
    SecondaryRatUsage,
    #[serde(rename = "PDU_RES_MOD_IND_FAIL")]
    PduResModIndFail,
    #[serde(rename = "UE_CONTEXT_RESUME_REQ")]
    UeContextResumeReq,
    #[serde(rename = "UE_CONTEXT_RESUME_RSP")]
    UeContextResumeRsp,
    #[serde(rename = "UE_CONTEXT_SUSPEND_REQ")]
    UeContextSuspendReq,
}

impl std::fmt::Display for N2SmInfoTypeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            N2SmInfoTypeAnyOf::PduResSetupReq => write!(f, "PDU_RES_SETUP_REQ"),
            N2SmInfoTypeAnyOf::PduResSetupRsp => write!(f, "PDU_RES_SETUP_RSP"),
            N2SmInfoTypeAnyOf::PduResSetupFail => write!(f, "PDU_RES_SETUP_FAIL"),
            N2SmInfoTypeAnyOf::PduResRelCmd => write!(f, "PDU_RES_REL_CMD"),
            N2SmInfoTypeAnyOf::PduResRelRsp => write!(f, "PDU_RES_REL_RSP"),
            N2SmInfoTypeAnyOf::PduResModReq => write!(f, "PDU_RES_MOD_REQ"),
            N2SmInfoTypeAnyOf::PduResModRsp => write!(f, "PDU_RES_MOD_RSP"),
            N2SmInfoTypeAnyOf::PduResModFail => write!(f, "PDU_RES_MOD_FAIL"),
            N2SmInfoTypeAnyOf::PduResNty => write!(f, "PDU_RES_NTY"),
            N2SmInfoTypeAnyOf::PduResNtyRel => write!(f, "PDU_RES_NTY_REL"),
            N2SmInfoTypeAnyOf::PduResModInd => write!(f, "PDU_RES_MOD_IND"),
            N2SmInfoTypeAnyOf::PduResModCfm => write!(f, "PDU_RES_MOD_CFM"),
            N2SmInfoTypeAnyOf::PathSwitchReq => write!(f, "PATH_SWITCH_REQ"),
            N2SmInfoTypeAnyOf::PathSwitchSetupFail => write!(f, "PATH_SWITCH_SETUP_FAIL"),
            N2SmInfoTypeAnyOf::PathSwitchReqAck => write!(f, "PATH_SWITCH_REQ_ACK"),
            N2SmInfoTypeAnyOf::PathSwitchReqFail => write!(f, "PATH_SWITCH_REQ_FAIL"),
            N2SmInfoTypeAnyOf::HandoverRequired => write!(f, "HANDOVER_REQUIRED"),
            N2SmInfoTypeAnyOf::HandoverCmd => write!(f, "HANDOVER_CMD"),
            N2SmInfoTypeAnyOf::HandoverPrepFail => write!(f, "HANDOVER_PREP_FAIL"),
            N2SmInfoTypeAnyOf::HandoverReqAck => write!(f, "HANDOVER_REQ_ACK"),
            N2SmInfoTypeAnyOf::HandoverResAllocFail => write!(f, "HANDOVER_RES_ALLOC_FAIL"),
            N2SmInfoTypeAnyOf::SecondaryRatUsage => write!(f, "SECONDARY_RAT_USAGE"),
            N2SmInfoTypeAnyOf::PduResModIndFail => write!(f, "PDU_RES_MOD_IND_FAIL"),
            N2SmInfoTypeAnyOf::UeContextResumeReq => write!(f, "UE_CONTEXT_RESUME_REQ"),
            N2SmInfoTypeAnyOf::UeContextResumeRsp => write!(f, "UE_CONTEXT_RESUME_RSP"),
            N2SmInfoTypeAnyOf::UeContextSuspendReq => write!(f, "UE_CONTEXT_SUSPEND_REQ"),
        }
    }
}

impl std::str::FromStr for N2SmInfoTypeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "PDU_RES_SETUP_REQ" => std::result::Result::Ok(N2SmInfoTypeAnyOf::PduResSetupReq),
            "PDU_RES_SETUP_RSP" => std::result::Result::Ok(N2SmInfoTypeAnyOf::PduResSetupRsp),
            "PDU_RES_SETUP_FAIL" => std::result::Result::Ok(N2SmInfoTypeAnyOf::PduResSetupFail),
            "PDU_RES_REL_CMD" => std::result::Result::Ok(N2SmInfoTypeAnyOf::PduResRelCmd),
            "PDU_RES_REL_RSP" => std::result::Result::Ok(N2SmInfoTypeAnyOf::PduResRelRsp),
            "PDU_RES_MOD_REQ" => std::result::Result::Ok(N2SmInfoTypeAnyOf::PduResModReq),
            "PDU_RES_MOD_RSP" => std::result::Result::Ok(N2SmInfoTypeAnyOf::PduResModRsp),
            "PDU_RES_MOD_FAIL" => std::result::Result::Ok(N2SmInfoTypeAnyOf::PduResModFail),
            "PDU_RES_NTY" => std::result::Result::Ok(N2SmInfoTypeAnyOf::PduResNty),
            "PDU_RES_NTY_REL" => std::result::Result::Ok(N2SmInfoTypeAnyOf::PduResNtyRel),
            "PDU_RES_MOD_IND" => std::result::Result::Ok(N2SmInfoTypeAnyOf::PduResModInd),
            "PDU_RES_MOD_CFM" => std::result::Result::Ok(N2SmInfoTypeAnyOf::PduResModCfm),
            "PATH_SWITCH_REQ" => std::result::Result::Ok(N2SmInfoTypeAnyOf::PathSwitchReq),
            "PATH_SWITCH_SETUP_FAIL" => {
                std::result::Result::Ok(N2SmInfoTypeAnyOf::PathSwitchSetupFail)
            }
            "PATH_SWITCH_REQ_ACK" => std::result::Result::Ok(N2SmInfoTypeAnyOf::PathSwitchReqAck),
            "PATH_SWITCH_REQ_FAIL" => std::result::Result::Ok(N2SmInfoTypeAnyOf::PathSwitchReqFail),
            "HANDOVER_REQUIRED" => std::result::Result::Ok(N2SmInfoTypeAnyOf::HandoverRequired),
            "HANDOVER_CMD" => std::result::Result::Ok(N2SmInfoTypeAnyOf::HandoverCmd),
            "HANDOVER_PREP_FAIL" => std::result::Result::Ok(N2SmInfoTypeAnyOf::HandoverPrepFail),
            "HANDOVER_REQ_ACK" => std::result::Result::Ok(N2SmInfoTypeAnyOf::HandoverReqAck),
            "HANDOVER_RES_ALLOC_FAIL" => {
                std::result::Result::Ok(N2SmInfoTypeAnyOf::HandoverResAllocFail)
            }
            "SECONDARY_RAT_USAGE" => std::result::Result::Ok(N2SmInfoTypeAnyOf::SecondaryRatUsage),
            "PDU_RES_MOD_IND_FAIL" => std::result::Result::Ok(N2SmInfoTypeAnyOf::PduResModIndFail),
            "UE_CONTEXT_RESUME_REQ" => {
                std::result::Result::Ok(N2SmInfoTypeAnyOf::UeContextResumeReq)
            }
            "UE_CONTEXT_RESUME_RSP" => {
                std::result::Result::Ok(N2SmInfoTypeAnyOf::UeContextResumeRsp)
            }
            "UE_CONTEXT_SUSPEND_REQ" => {
                std::result::Result::Ok(N2SmInfoTypeAnyOf::UeContextSuspendReq)
            }
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// This represents the identifier of the N3IWF ID as specified in clause 9.3.1.57 of  3GPP TS 38.413 in hexadecimal representation. Each character in the string shall take a value  of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant  character representing the 4 most significant bits of the N3IWF ID shall appear first in the  string, and the character representing the 4 least significant bit of the N3IWF ID shall  appear last in the string.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct N3IwfId(String);

impl std::convert::From<String> for N3IwfId {
    fn from(x: String) -> Self {
        N3IwfId(x)
    }
}

impl std::string::ToString for N3IwfId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for N3IwfId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(N3IwfId(x.to_string()))
    }
}

impl std::convert::From<N3IwfId> for String {
    fn from(x: N3IwfId) -> Self {
        x.0
    }
}

impl std::ops::Deref for N3IwfId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for N3IwfId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Contains the Non-3GPP access user location.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct N3gaLocation {
    #[serde(rename = "n3gppTai")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n3gpp_tai: Option<models::Tai>,

    /// This IE shall contain the N3IWF identifier received over NGAP and shall be encoded as a  string of hexadecimal characters. Each character in the string shall take a value of \"0\"  to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant  character representing the 4 most significant bits of the N3IWF ID shall appear first in  the string, and the character representing the 4 least significant bit of the N3IWF ID  shall appear last in the string.
    #[serde(rename = "n3IwfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n3_iwf_id: Option<String>,

    /// String identifying a IPv4 address formatted in the 'dotted decimal' notation as defined in RFC 1166.
    #[serde(rename = "ueIpv4Addr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_ipv4_addr: Option<String>,

    #[serde(rename = "ueIpv6Addr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_ipv6_addr: Option<models::Ipv6Addr>,

    /// Unsigned Integer, i.e. only value 0 and integers above 0 are permissible.
    #[serde(rename = "portNumber")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub port_number: Option<u32>,

    #[serde(rename = "protocol")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub protocol: Option<models::TransportProtocol>,

    #[serde(rename = "tnapId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tnap_id: Option<models::TnapId>,

    #[serde(rename = "twapId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub twap_id: Option<models::TwapId>,

    #[serde(rename = "hfcNodeId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hfc_node_id: Option<models::HfcNodeId>,

    /// string with format 'bytes' as defined in OpenAPI
    #[serde(rename = "gli")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gli: Option<swagger::ByteArray>,

    #[serde(rename = "w5gbanLineType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub w5gban_line_type: Option<models::LineType>,

    /// Global Cable Identifier uniquely identifying the connection between the 5G-CRG or FN-CRG to the 5GS. See clause 28.15.4 of 3GPP TS 23.003. This shall be encoded as a string per clause 28.15.4 of 3GPP TS 23.003, and compliant with the syntax specified  in clause 2.2  of IETF RFC 7542 for the username part of a NAI. The GCI value is specified in CableLabs WR-TR-5WWC-ARCH.
    #[serde(rename = "gci")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gci: Option<String>,
}

impl N3gaLocation {
    #[allow(clippy::new_without_default)]
    pub fn new() -> N3gaLocation {
        N3gaLocation {
            n3gpp_tai: None,
            n3_iwf_id: None,
            ue_ipv4_addr: None,
            ue_ipv6_addr: None,
            port_number: None,
            protocol: None,
            tnap_id: None,
            twap_id: None,
            hfc_node_id: None,
            gli: None,
            w5gban_line_type: None,
            gci: None,
        }
    }
}

/// Converts the N3gaLocation value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for N3gaLocation {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping n3gppTai in query parameter serialization
            self.n3_iwf_id
                .as_ref()
                .map(|n3_iwf_id| vec!["n3IwfId".to_string(), n3_iwf_id.to_string()].join(",")),
            self.ue_ipv4_addr.as_ref().map(|ue_ipv4_addr| {
                vec!["ueIpv4Addr".to_string(), ue_ipv4_addr.to_string()].join(",")
            }),
            // Skipping ueIpv6Addr in query parameter serialization
            self.port_number.as_ref().map(|port_number| {
                vec!["portNumber".to_string(), port_number.to_string()].join(",")
            }),
            // Skipping protocol in query parameter serialization

            // Skipping tnapId in query parameter serialization

            // Skipping twapId in query parameter serialization

            // Skipping hfcNodeId in query parameter serialization

            // Skipping gli in query parameter serialization
            // Skipping gli in query parameter serialization

            // Skipping w5gbanLineType in query parameter serialization
            self.gci
                .as_ref()
                .map(|gci| vec!["gci".to_string(), gci.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a N3gaLocation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for N3gaLocation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub n3gpp_tai: Vec<models::Tai>,
            pub n3_iwf_id: Vec<String>,
            pub ue_ipv4_addr: Vec<String>,
            pub ue_ipv6_addr: Vec<models::Ipv6Addr>,
            pub port_number: Vec<u32>,
            pub protocol: Vec<models::TransportProtocol>,
            pub tnap_id: Vec<models::TnapId>,
            pub twap_id: Vec<models::TwapId>,
            pub hfc_node_id: Vec<models::HfcNodeId>,
            pub gli: Vec<swagger::ByteArray>,
            pub w5gban_line_type: Vec<models::LineType>,
            pub gci: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing N3gaLocation".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "n3gppTai" => intermediate_rep.n3gpp_tai.push(
                        <models::Tai as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n3IwfId" => intermediate_rep.n3_iwf_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ueIpv4Addr" => intermediate_rep.ue_ipv4_addr.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ueIpv6Addr" => intermediate_rep.ue_ipv6_addr.push(
                        <models::Ipv6Addr as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "portNumber" => intermediate_rep.port_number.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "protocol" => intermediate_rep.protocol.push(
                        <models::TransportProtocol as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "tnapId" => intermediate_rep.tnap_id.push(
                        <models::TnapId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "twapId" => intermediate_rep.twap_id.push(
                        <models::TwapId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "hfcNodeId" => intermediate_rep.hfc_node_id.push(
                        <models::HfcNodeId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "gli" => {
                        return std::result::Result::Err(
                            "Parsing binary data in this style is not supported in N3gaLocation"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "w5gbanLineType" => intermediate_rep.w5gban_line_type.push(
                        <models::LineType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "gci" => intermediate_rep.gci.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing N3gaLocation".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(N3gaLocation {
            n3gpp_tai: intermediate_rep.n3gpp_tai.into_iter().next(),
            n3_iwf_id: intermediate_rep.n3_iwf_id.into_iter().next(),
            ue_ipv4_addr: intermediate_rep.ue_ipv4_addr.into_iter().next(),
            ue_ipv6_addr: intermediate_rep.ue_ipv6_addr.into_iter().next(),
            port_number: intermediate_rep.port_number.into_iter().next(),
            protocol: intermediate_rep.protocol.into_iter().next(),
            tnap_id: intermediate_rep.tnap_id.into_iter().next(),
            twap_id: intermediate_rep.twap_id.into_iter().next(),
            hfc_node_id: intermediate_rep.hfc_node_id.into_iter().next(),
            gli: intermediate_rep.gli.into_iter().next(),
            w5gban_line_type: intermediate_rep.w5gban_line_type.into_iter().next(),
            gci: intermediate_rep.gci.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<N3gaLocation> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<N3gaLocation>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<N3gaLocation>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for N3gaLocation - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<N3gaLocation> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <N3gaLocation as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into N3gaLocation - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// N4 Information
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct N4Information {
    #[serde(rename = "n4MessageType")]
    pub n4_message_type: models::N4MessageType,

    #[serde(rename = "n4MessagePayload")]
    pub n4_message_payload: models::RefToBinaryData,

    #[serde(rename = "n4DnaiInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n4_dnai_info: Option<models::DnaiInformation>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "psaUpfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub psa_upf_id: Option<uuid::Uuid>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "ulClBpId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ul_cl_bp_id: Option<uuid::Uuid>,

    #[serde(rename = "n9UlPdrIdList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n9_ul_pdr_id_list: Option<Vec<models::Uint16>>,
}

impl N4Information {
    #[allow(clippy::new_without_default)]
    pub fn new(
        n4_message_type: models::N4MessageType,
        n4_message_payload: models::RefToBinaryData,
    ) -> N4Information {
        N4Information {
            n4_message_type,
            n4_message_payload,
            n4_dnai_info: None,
            psa_upf_id: None,
            ul_cl_bp_id: None,
            n9_ul_pdr_id_list: None,
        }
    }
}

/// Converts the N4Information value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for N4Information {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping n4MessageType in query parameter serialization

            // Skipping n4MessagePayload in query parameter serialization

            // Skipping n4DnaiInfo in query parameter serialization

            // Skipping psaUpfId in query parameter serialization

            // Skipping ulClBpId in query parameter serialization
            self.n9_ul_pdr_id_list.as_ref().map(|n9_ul_pdr_id_list| {
                vec![
                    "n9UlPdrIdList".to_string(),
                    n9_ul_pdr_id_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a N4Information value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for N4Information {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub n4_message_type: Vec<models::N4MessageType>,
            pub n4_message_payload: Vec<models::RefToBinaryData>,
            pub n4_dnai_info: Vec<models::DnaiInformation>,
            pub psa_upf_id: Vec<uuid::Uuid>,
            pub ul_cl_bp_id: Vec<uuid::Uuid>,
            pub n9_ul_pdr_id_list: Vec<Vec<models::Uint16>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing N4Information".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "n4MessageType" => intermediate_rep.n4_message_type.push(
                        <models::N4MessageType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n4MessagePayload" => intermediate_rep.n4_message_payload.push(
                        <models::RefToBinaryData as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n4DnaiInfo" => intermediate_rep.n4_dnai_info.push(
                        <models::DnaiInformation as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "psaUpfId" => intermediate_rep.psa_upf_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ulClBpId" => intermediate_rep.ul_cl_bp_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "n9UlPdrIdList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in N4Information"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing N4Information".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(N4Information {
            n4_message_type: intermediate_rep
                .n4_message_type
                .into_iter()
                .next()
                .ok_or_else(|| "n4MessageType missing in N4Information".to_string())?,
            n4_message_payload: intermediate_rep
                .n4_message_payload
                .into_iter()
                .next()
                .ok_or_else(|| "n4MessagePayload missing in N4Information".to_string())?,
            n4_dnai_info: intermediate_rep.n4_dnai_info.into_iter().next(),
            psa_upf_id: intermediate_rep.psa_upf_id.into_iter().next(),
            ul_cl_bp_id: intermediate_rep.ul_cl_bp_id.into_iter().next(),
            n9_ul_pdr_id_list: intermediate_rep.n9_ul_pdr_id_list.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<N4Information> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<N4Information>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<N4Information>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for N4Information - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<N4Information> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <N4Information as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into N4Information - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// N4 Message Type. Possible values are   - PFCP_SES_EST_REQ   - PFCP_SES_EST_RSP   - PFCP_SES_MOD_REQ   - PFCP_SES_MOD_RSP   - PFCP_SES_DEL_REQ   - PFCP_SES_DEL_RSP   - PFCP_SES_REP_REQ   - PFCP_SES_REP_RSP
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct N4MessageType {}

impl N4MessageType {
    #[allow(clippy::new_without_default)]
    pub fn new() -> N4MessageType {
        N4MessageType {}
    }
}

/// Converts the N4MessageType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for N4MessageType {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a N4MessageType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for N4MessageType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing N4MessageType".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing N4MessageType".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(N4MessageType {})
    }
}

// Methods for converting between header::IntoHeaderValue<N4MessageType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<N4MessageType>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<N4MessageType>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for N4MessageType - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<N4MessageType> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <N4MessageType as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into N4MessageType - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum N4MessageTypeAnyOf {
    #[serde(rename = "PFCP_SES_EST_REQ")]
    EstReq,
    #[serde(rename = "PFCP_SES_EST_RSP")]
    EstRsp,
    #[serde(rename = "PFCP_SES_MOD_REQ")]
    ModReq,
    #[serde(rename = "PFCP_SES_MOD_RSP")]
    ModRsp,
    #[serde(rename = "PFCP_SES_DEL_REQ")]
    DelReq,
    #[serde(rename = "PFCP_SES_DEL_RSP")]
    DelRsp,
    #[serde(rename = "PFCP_SES_REP_REQ")]
    RepReq,
    #[serde(rename = "PFCP_SES_REP_RSP")]
    RepRsp,
}

impl std::fmt::Display for N4MessageTypeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            N4MessageTypeAnyOf::EstReq => write!(f, "PFCP_SES_EST_REQ"),
            N4MessageTypeAnyOf::EstRsp => write!(f, "PFCP_SES_EST_RSP"),
            N4MessageTypeAnyOf::ModReq => write!(f, "PFCP_SES_MOD_REQ"),
            N4MessageTypeAnyOf::ModRsp => write!(f, "PFCP_SES_MOD_RSP"),
            N4MessageTypeAnyOf::DelReq => write!(f, "PFCP_SES_DEL_REQ"),
            N4MessageTypeAnyOf::DelRsp => write!(f, "PFCP_SES_DEL_RSP"),
            N4MessageTypeAnyOf::RepReq => write!(f, "PFCP_SES_REP_REQ"),
            N4MessageTypeAnyOf::RepRsp => write!(f, "PFCP_SES_REP_RSP"),
        }
    }
}

impl std::str::FromStr for N4MessageTypeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "PFCP_SES_EST_REQ" => std::result::Result::Ok(N4MessageTypeAnyOf::EstReq),
            "PFCP_SES_EST_RSP" => std::result::Result::Ok(N4MessageTypeAnyOf::EstRsp),
            "PFCP_SES_MOD_REQ" => std::result::Result::Ok(N4MessageTypeAnyOf::ModReq),
            "PFCP_SES_MOD_RSP" => std::result::Result::Ok(N4MessageTypeAnyOf::ModRsp),
            "PFCP_SES_DEL_REQ" => std::result::Result::Ok(N4MessageTypeAnyOf::DelReq),
            "PFCP_SES_DEL_RSP" => std::result::Result::Ok(N4MessageTypeAnyOf::DelRsp),
            "PFCP_SES_REP_REQ" => std::result::Result::Ok(N4MessageTypeAnyOf::RepReq),
            "PFCP_SES_REP_RSP" => std::result::Result::Ok(N4MessageTypeAnyOf::RepRsp),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Contains the NCGI (NR Cell Global Identity), as described in 3GPP 23.003
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Ncgi {
    #[serde(rename = "plmnId")]
    pub plmn_id: models::PlmnId,

    /// 36-bit string identifying an NR Cell Id as specified in clause 9.3.1.7 of 3GPP TS 38.413,  in hexadecimal representation. Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character  representing the 4 most significant bits of the Cell Id shall appear first in the string, and  the character representing the 4 least significant bit of the Cell Id shall appear last in the  string.
    #[serde(rename = "nrCellId")]
    pub nr_cell_id: String,

    /// This represents the Network Identifier, which together with a PLMN ID is used to identify an SNPN (see 3GPP TS 23.003 and 3GPP TS 23.501 clause 5.30.2.1).
    #[serde(rename = "nid")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nid: Option<String>,
}

impl Ncgi {
    #[allow(clippy::new_without_default)]
    pub fn new(plmn_id: models::PlmnId, nr_cell_id: String) -> Ncgi {
        Ncgi {
            plmn_id,
            nr_cell_id,
            nid: None,
        }
    }
}

/// Converts the Ncgi value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Ncgi {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping plmnId in query parameter serialization
            Some("nrCellId".to_string()),
            Some(self.nr_cell_id.to_string()),
            self.nid
                .as_ref()
                .map(|nid| vec!["nid".to_string(), nid.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Ncgi value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Ncgi {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub plmn_id: Vec<models::PlmnId>,
            pub nr_cell_id: Vec<String>,
            pub nid: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err("Missing value while parsing Ncgi".to_string())
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "plmnId" => intermediate_rep.plmn_id.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nrCellId" => intermediate_rep.nr_cell_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nid" => intermediate_rep.nid.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Ncgi".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Ncgi {
            plmn_id: intermediate_rep
                .plmn_id
                .into_iter()
                .next()
                .ok_or_else(|| "plmnId missing in Ncgi".to_string())?,
            nr_cell_id: intermediate_rep
                .nr_cell_id
                .into_iter()
                .next()
                .ok_or_else(|| "nrCellId missing in Ncgi".to_string())?,
            nid: intermediate_rep.nid.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Ncgi> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Ncgi>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Ncgi>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Ncgi - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Ncgi> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Ncgi as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Ncgi - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Identifier of a group of NFs.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NfGroupId(String);

impl std::convert::From<String> for NfGroupId {
    fn from(x: String) -> Self {
        NfGroupId(x)
    }
}

impl std::string::ToString for NfGroupId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for NfGroupId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(NfGroupId(x.to_string()))
    }
}

impl std::convert::From<NfGroupId> for String {
    fn from(x: NfGroupId) -> Self {
        x.0
    }
}

impl std::ops::Deref for NfGroupId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for NfGroupId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NfInstanceId(uuid::Uuid);

impl std::convert::From<uuid::Uuid> for NfInstanceId {
    fn from(x: uuid::Uuid) -> Self {
        NfInstanceId(x)
    }
}

impl std::convert::From<NfInstanceId> for uuid::Uuid {
    fn from(x: NfInstanceId) -> Self {
        x.0
    }
}

impl std::ops::Deref for NfInstanceId {
    type Target = uuid::Uuid;
    fn deref(&self) -> &uuid::Uuid {
        &self.0
    }
}

impl std::ops::DerefMut for NfInstanceId {
    fn deref_mut(&mut self) -> &mut uuid::Uuid {
        &mut self.0
    }
}

/// NF Service Set Identifier (see clause 28.12 of 3GPP TS 23.003) formatted as the following  string \"set<Set ID>.sn<Service Name>.nfi<NF Instance ID>.5gc.mnc<MNC>.mcc<MCC>\", or  \"set<SetID>.sn<ServiceName>.nfi<NFInstanceID>.5gc.nid<NID>.mnc<MNC>.mcc<MCC>\" with  <MCC> encoded as defined in clause 5.4.2 (\"Mcc\" data type definition)   <MNC> encoding the Mobile Network Code part of the PLMN, comprising 3 digits.    If there are only 2 significant digits in the MNC, one \"0\" digit shall be inserted    at the left side to fill the 3 digits coding of MNC.  Pattern: '^[0-9]{3}$' <NID> encoded as defined in clause 5.4.2 (\"Nid\" data type definition)  <NFInstanceId> encoded as defined in clause 5.3.2  <ServiceName> encoded as defined in 3GPP TS 29.510  <Set ID> encoded as a string of characters consisting of alphabetic    characters (A-Z and a-z), digits (0-9) and/or the hyphen (-) and that shall end    with either an alphabetic character or a digit.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NfServiceSetId(String);

impl std::convert::From<String> for NfServiceSetId {
    fn from(x: String) -> Self {
        NfServiceSetId(x)
    }
}

impl std::string::ToString for NfServiceSetId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for NfServiceSetId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(NfServiceSetId(x.to_string()))
    }
}

impl std::convert::From<NfServiceSetId> for String {
    fn from(x: NfServiceSetId) -> Self {
        x.0
    }
}

impl std::ops::Deref for NfServiceSetId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for NfServiceSetId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// NF Set Identifier (see clause 28.12 of 3GPP TS 23.003), formatted as the following string \"set<Set ID>.<nftype>set.5gc.mnc<MNC>.mcc<MCC>\", or  \"set<SetID>.<NFType>set.5gc.nid<NID>.mnc<MNC>.mcc<MCC>\" with  <MCC> encoded as defined in clause 5.4.2 (\"Mcc\" data type definition)  <MNC> encoding the Mobile Network Code part of the PLMN, comprising 3 digits.    If there are only 2 significant digits in the MNC, one \"0\" digit shall be inserted    at the left side to fill the 3 digits coding of MNC.  Pattern: '^[0-9]{3}$' <NFType> encoded as a value defined in Table 6.1.6.3.3-1 of 3GPP TS 29.510 but    with lower case characters <Set ID> encoded as a string of characters consisting of    alphabetic characters (A-Z and a-z), digits (0-9) and/or the hyphen (-) and that    shall end with either an alphabetic character or a digit.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NfSetId(String);

impl std::convert::From<String> for NfSetId {
    fn from(x: String) -> Self {
        NfSetId(x)
    }
}

impl std::string::ToString for NfSetId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for NfSetId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(NfSetId(x.to_string()))
    }
}

impl std::convert::From<NfSetId> for String {
    fn from(x: NfSetId) -> Self {
        x.0
    }
}

impl std::ops::Deref for NfSetId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for NfSetId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// NF types known to NRF
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NfType {}

impl NfType {
    #[allow(clippy::new_without_default)]
    pub fn new() -> NfType {
        NfType {}
    }
}

/// Converts the NfType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NfType {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NfType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NfType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NfType".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NfType".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NfType {})
    }
}

// Methods for converting between header::IntoHeaderValue<NfType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NfType>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NfType>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NfType - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<NfType> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NfType as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NfType - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum NfTypeAnyOf {
    #[serde(rename = "NRF")]
    Nrf,
    #[serde(rename = "UDM")]
    Udm,
    #[serde(rename = "AMF")]
    Amf,
    #[serde(rename = "SMF")]
    Smf,
    #[serde(rename = "AUSF")]
    Ausf,
    #[serde(rename = "NEF")]
    Nef,
    #[serde(rename = "PCF")]
    Pcf,
    #[serde(rename = "SMSF")]
    Smsf,
    #[serde(rename = "NSSF")]
    Nssf,
    #[serde(rename = "UDR")]
    Udr,
    #[serde(rename = "LMF")]
    Lmf,
    #[serde(rename = "GMLC")]
    Gmlc,
    #[serde(rename = "5G_EIR")]
    Variant5GEir,
    #[serde(rename = "SEPP")]
    Sepp,
    #[serde(rename = "UPF")]
    Upf,
    #[serde(rename = "N3IWF")]
    N3Iwf,
    #[serde(rename = "AF")]
    Af,
    #[serde(rename = "UDSF")]
    Udsf,
    #[serde(rename = "BSF")]
    Bsf,
    #[serde(rename = "CHF")]
    Chf,
    #[serde(rename = "NWDAF")]
    Nwdaf,
    #[serde(rename = "PCSCF")]
    Pcscf,
    #[serde(rename = "CBCF")]
    Cbcf,
    #[serde(rename = "HSS")]
    Hss,
    #[serde(rename = "UCMF")]
    Ucmf,
    #[serde(rename = "SOR_AF")]
    SorAf,
    #[serde(rename = "SPAF")]
    Spaf,
    #[serde(rename = "MME")]
    Mme,
    #[serde(rename = "SCSAS")]
    Scsas,
    #[serde(rename = "SCEF")]
    Scef,
    #[serde(rename = "SCP")]
    Scp,
    #[serde(rename = "NSSAAF")]
    Nssaaf,
    #[serde(rename = "ICSCF")]
    Icscf,
    #[serde(rename = "SCSCF")]
    Scscf,
    #[serde(rename = "DRA")]
    Dra,
    #[serde(rename = "IMS_AS")]
    ImsAs,
    #[serde(rename = "AANF")]
    Aanf,
    #[serde(rename = "5G_DDNMF")]
    Variant5GDdnmf,
    #[serde(rename = "NSACF")]
    Nsacf,
    #[serde(rename = "MFAF")]
    Mfaf,
    #[serde(rename = "EASDF")]
    Easdf,
    #[serde(rename = "DCCF")]
    Dccf,
    #[serde(rename = "MB_SMF")]
    MbSmf,
    #[serde(rename = "TSCTSF")]
    Tsctsf,
    #[serde(rename = "ADRF")]
    Adrf,
    #[serde(rename = "GBA_BSF")]
    GbaBsf,
    #[serde(rename = "CEF")]
    Cef,
    #[serde(rename = "MB_UPF")]
    MbUpf,
    #[serde(rename = "NSWOF")]
    Nswof,
    #[serde(rename = "PKMF")]
    Pkmf,
    #[serde(rename = "MNPF")]
    Mnpf,
    #[serde(rename = "SMS_GMSC")]
    SmsGmsc,
    #[serde(rename = "SMS_IWMSC")]
    SmsIwmsc,
    #[serde(rename = "MBSF")]
    Mbsf,
    #[serde(rename = "MBSTF")]
    Mbstf,
    #[serde(rename = "PANF")]
    Panf,
}

impl std::fmt::Display for NfTypeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            NfTypeAnyOf::Nrf => write!(f, "NRF"),
            NfTypeAnyOf::Udm => write!(f, "UDM"),
            NfTypeAnyOf::Amf => write!(f, "AMF"),
            NfTypeAnyOf::Smf => write!(f, "SMF"),
            NfTypeAnyOf::Ausf => write!(f, "AUSF"),
            NfTypeAnyOf::Nef => write!(f, "NEF"),
            NfTypeAnyOf::Pcf => write!(f, "PCF"),
            NfTypeAnyOf::Smsf => write!(f, "SMSF"),
            NfTypeAnyOf::Nssf => write!(f, "NSSF"),
            NfTypeAnyOf::Udr => write!(f, "UDR"),
            NfTypeAnyOf::Lmf => write!(f, "LMF"),
            NfTypeAnyOf::Gmlc => write!(f, "GMLC"),
            NfTypeAnyOf::Variant5GEir => write!(f, "5G_EIR"),
            NfTypeAnyOf::Sepp => write!(f, "SEPP"),
            NfTypeAnyOf::Upf => write!(f, "UPF"),
            NfTypeAnyOf::N3Iwf => write!(f, "N3IWF"),
            NfTypeAnyOf::Af => write!(f, "AF"),
            NfTypeAnyOf::Udsf => write!(f, "UDSF"),
            NfTypeAnyOf::Bsf => write!(f, "BSF"),
            NfTypeAnyOf::Chf => write!(f, "CHF"),
            NfTypeAnyOf::Nwdaf => write!(f, "NWDAF"),
            NfTypeAnyOf::Pcscf => write!(f, "PCSCF"),
            NfTypeAnyOf::Cbcf => write!(f, "CBCF"),
            NfTypeAnyOf::Hss => write!(f, "HSS"),
            NfTypeAnyOf::Ucmf => write!(f, "UCMF"),
            NfTypeAnyOf::SorAf => write!(f, "SOR_AF"),
            NfTypeAnyOf::Spaf => write!(f, "SPAF"),
            NfTypeAnyOf::Mme => write!(f, "MME"),
            NfTypeAnyOf::Scsas => write!(f, "SCSAS"),
            NfTypeAnyOf::Scef => write!(f, "SCEF"),
            NfTypeAnyOf::Scp => write!(f, "SCP"),
            NfTypeAnyOf::Nssaaf => write!(f, "NSSAAF"),
            NfTypeAnyOf::Icscf => write!(f, "ICSCF"),
            NfTypeAnyOf::Scscf => write!(f, "SCSCF"),
            NfTypeAnyOf::Dra => write!(f, "DRA"),
            NfTypeAnyOf::ImsAs => write!(f, "IMS_AS"),
            NfTypeAnyOf::Aanf => write!(f, "AANF"),
            NfTypeAnyOf::Variant5GDdnmf => write!(f, "5G_DDNMF"),
            NfTypeAnyOf::Nsacf => write!(f, "NSACF"),
            NfTypeAnyOf::Mfaf => write!(f, "MFAF"),
            NfTypeAnyOf::Easdf => write!(f, "EASDF"),
            NfTypeAnyOf::Dccf => write!(f, "DCCF"),
            NfTypeAnyOf::MbSmf => write!(f, "MB_SMF"),
            NfTypeAnyOf::Tsctsf => write!(f, "TSCTSF"),
            NfTypeAnyOf::Adrf => write!(f, "ADRF"),
            NfTypeAnyOf::GbaBsf => write!(f, "GBA_BSF"),
            NfTypeAnyOf::Cef => write!(f, "CEF"),
            NfTypeAnyOf::MbUpf => write!(f, "MB_UPF"),
            NfTypeAnyOf::Nswof => write!(f, "NSWOF"),
            NfTypeAnyOf::Pkmf => write!(f, "PKMF"),
            NfTypeAnyOf::Mnpf => write!(f, "MNPF"),
            NfTypeAnyOf::SmsGmsc => write!(f, "SMS_GMSC"),
            NfTypeAnyOf::SmsIwmsc => write!(f, "SMS_IWMSC"),
            NfTypeAnyOf::Mbsf => write!(f, "MBSF"),
            NfTypeAnyOf::Mbstf => write!(f, "MBSTF"),
            NfTypeAnyOf::Panf => write!(f, "PANF"),
        }
    }
}

impl std::str::FromStr for NfTypeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "NRF" => std::result::Result::Ok(NfTypeAnyOf::Nrf),
            "UDM" => std::result::Result::Ok(NfTypeAnyOf::Udm),
            "AMF" => std::result::Result::Ok(NfTypeAnyOf::Amf),
            "SMF" => std::result::Result::Ok(NfTypeAnyOf::Smf),
            "AUSF" => std::result::Result::Ok(NfTypeAnyOf::Ausf),
            "NEF" => std::result::Result::Ok(NfTypeAnyOf::Nef),
            "PCF" => std::result::Result::Ok(NfTypeAnyOf::Pcf),
            "SMSF" => std::result::Result::Ok(NfTypeAnyOf::Smsf),
            "NSSF" => std::result::Result::Ok(NfTypeAnyOf::Nssf),
            "UDR" => std::result::Result::Ok(NfTypeAnyOf::Udr),
            "LMF" => std::result::Result::Ok(NfTypeAnyOf::Lmf),
            "GMLC" => std::result::Result::Ok(NfTypeAnyOf::Gmlc),
            "5G_EIR" => std::result::Result::Ok(NfTypeAnyOf::Variant5GEir),
            "SEPP" => std::result::Result::Ok(NfTypeAnyOf::Sepp),
            "UPF" => std::result::Result::Ok(NfTypeAnyOf::Upf),
            "N3IWF" => std::result::Result::Ok(NfTypeAnyOf::N3Iwf),
            "AF" => std::result::Result::Ok(NfTypeAnyOf::Af),
            "UDSF" => std::result::Result::Ok(NfTypeAnyOf::Udsf),
            "BSF" => std::result::Result::Ok(NfTypeAnyOf::Bsf),
            "CHF" => std::result::Result::Ok(NfTypeAnyOf::Chf),
            "NWDAF" => std::result::Result::Ok(NfTypeAnyOf::Nwdaf),
            "PCSCF" => std::result::Result::Ok(NfTypeAnyOf::Pcscf),
            "CBCF" => std::result::Result::Ok(NfTypeAnyOf::Cbcf),
            "HSS" => std::result::Result::Ok(NfTypeAnyOf::Hss),
            "UCMF" => std::result::Result::Ok(NfTypeAnyOf::Ucmf),
            "SOR_AF" => std::result::Result::Ok(NfTypeAnyOf::SorAf),
            "SPAF" => std::result::Result::Ok(NfTypeAnyOf::Spaf),
            "MME" => std::result::Result::Ok(NfTypeAnyOf::Mme),
            "SCSAS" => std::result::Result::Ok(NfTypeAnyOf::Scsas),
            "SCEF" => std::result::Result::Ok(NfTypeAnyOf::Scef),
            "SCP" => std::result::Result::Ok(NfTypeAnyOf::Scp),
            "NSSAAF" => std::result::Result::Ok(NfTypeAnyOf::Nssaaf),
            "ICSCF" => std::result::Result::Ok(NfTypeAnyOf::Icscf),
            "SCSCF" => std::result::Result::Ok(NfTypeAnyOf::Scscf),
            "DRA" => std::result::Result::Ok(NfTypeAnyOf::Dra),
            "IMS_AS" => std::result::Result::Ok(NfTypeAnyOf::ImsAs),
            "AANF" => std::result::Result::Ok(NfTypeAnyOf::Aanf),
            "5G_DDNMF" => std::result::Result::Ok(NfTypeAnyOf::Variant5GDdnmf),
            "NSACF" => std::result::Result::Ok(NfTypeAnyOf::Nsacf),
            "MFAF" => std::result::Result::Ok(NfTypeAnyOf::Mfaf),
            "EASDF" => std::result::Result::Ok(NfTypeAnyOf::Easdf),
            "DCCF" => std::result::Result::Ok(NfTypeAnyOf::Dccf),
            "MB_SMF" => std::result::Result::Ok(NfTypeAnyOf::MbSmf),
            "TSCTSF" => std::result::Result::Ok(NfTypeAnyOf::Tsctsf),
            "ADRF" => std::result::Result::Ok(NfTypeAnyOf::Adrf),
            "GBA_BSF" => std::result::Result::Ok(NfTypeAnyOf::GbaBsf),
            "CEF" => std::result::Result::Ok(NfTypeAnyOf::Cef),
            "MB_UPF" => std::result::Result::Ok(NfTypeAnyOf::MbUpf),
            "NSWOF" => std::result::Result::Ok(NfTypeAnyOf::Nswof),
            "PKMF" => std::result::Result::Ok(NfTypeAnyOf::Pkmf),
            "MNPF" => std::result::Result::Ok(NfTypeAnyOf::Mnpf),
            "SMS_GMSC" => std::result::Result::Ok(NfTypeAnyOf::SmsGmsc),
            "SMS_IWMSC" => std::result::Result::Ok(NfTypeAnyOf::SmsIwmsc),
            "MBSF" => std::result::Result::Ok(NfTypeAnyOf::Mbsf),
            "MBSTF" => std::result::Result::Ok(NfTypeAnyOf::Mbstf),
            "PANF" => std::result::Result::Ok(NfTypeAnyOf::Panf),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Represents the NGAP cause.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NgApCause {
    /// Unsigned Integer, i.e. only value 0 and integers above 0 are permissible.
    #[serde(rename = "group")]
    pub group: u32,

    /// Unsigned Integer, i.e. only value 0 and integers above 0 are permissible.
    #[serde(rename = "value")]
    pub value: u32,
}

impl NgApCause {
    #[allow(clippy::new_without_default)]
    pub fn new(group: u32, value: u32) -> NgApCause {
        NgApCause { group, value }
    }
}

/// Converts the NgApCause value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NgApCause {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("group".to_string()),
            Some(self.group.to_string()),
            Some("value".to_string()),
            Some(self.value.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NgApCause value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NgApCause {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub group: Vec<u32>,
            pub value: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NgApCause".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "group" => intermediate_rep.group.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NgApCause".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NgApCause {
            group: intermediate_rep
                .group
                .into_iter()
                .next()
                .ok_or_else(|| "group missing in NgApCause".to_string())?,
            value: intermediate_rep
                .value
                .into_iter()
                .next()
                .ok_or_else(|| "value missing in NgApCause".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NgApCause> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NgApCause>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NgApCause>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NgApCause - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<NgApCause> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NgApCause as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NgApCause - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Indicates a NG RAN as target of the handover
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NgRanTargetId {
    #[serde(rename = "ranNodeId")]
    pub ran_node_id: models::GlobalRanNodeId,

    #[serde(rename = "tai")]
    pub tai: models::Tai,
}

impl NgRanTargetId {
    #[allow(clippy::new_without_default)]
    pub fn new(ran_node_id: models::GlobalRanNodeId, tai: models::Tai) -> NgRanTargetId {
        NgRanTargetId { ran_node_id, tai }
    }
}

/// Converts the NgRanTargetId value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NgRanTargetId {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping ranNodeId in query parameter serialization

            // Skipping tai in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NgRanTargetId value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NgRanTargetId {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ran_node_id: Vec<models::GlobalRanNodeId>,
            pub tai: Vec<models::Tai>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NgRanTargetId".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ranNodeId" => intermediate_rep.ran_node_id.push(
                        <models::GlobalRanNodeId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "tai" => intermediate_rep.tai.push(
                        <models::Tai as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NgRanTargetId".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NgRanTargetId {
            ran_node_id: intermediate_rep
                .ran_node_id
                .into_iter()
                .next()
                .ok_or_else(|| "ranNodeId missing in NgRanTargetId".to_string())?,
            tai: intermediate_rep
                .tai
                .into_iter()
                .next()
                .ok_or_else(|| "tai missing in NgRanTargetId".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NgRanTargetId> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NgRanTargetId>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NgRanTargetId>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NgRanTargetId - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<NgRanTargetId> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NgRanTargetId as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NgRanTargetId - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// This represents the identifier of the ng-eNB ID as specified in clause 9.3.1.8 of  3GPP TS 38.413. The value of the ng-eNB ID shall be encoded in hexadecimal representation.  Each character in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and  shall represent 4 bits. The padding 0 shall be added to make multiple nibbles, so the most  significant character representing the padding 0 if required together with the 4 most  significant bits of the ng-eNB ID shall appear first in the string, and the character  representing the 4 least significant bit of the ng-eNB ID (to form a nibble) shall appear last  in the string.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NgeNbId(String);

impl std::convert::From<String> for NgeNbId {
    fn from(x: String) -> Self {
        NgeNbId(x)
    }
}

impl std::string::ToString for NgeNbId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for NgeNbId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(NgeNbId(x.to_string()))
    }
}

impl std::convert::From<NgeNbId> for String {
    fn from(x: NgeNbId) -> Self {
        x.0
    }
}

impl std::ops::Deref for NgeNbId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for NgeNbId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// This represents the Network Identifier, which together with a PLMN ID is used to identify an SNPN (see 3GPP TS 23.003 and 3GPP TS 23.501 clause 5.30.2.1).
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Nid(String);

impl std::convert::From<String> for Nid {
    fn from(x: String) -> Self {
        Nid(x)
    }
}

impl std::string::ToString for Nid {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Nid {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Nid(x.to_string()))
    }
}

impl std::convert::From<Nid> for String {
    fn from(x: Nid) -> Self {
        x.0
    }
}

impl std::ops::Deref for Nid {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Nid {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// It indicates the QoS Characteristics for a standardized or pre-configured 5QI for downlink and uplink.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NonDynamic5Qi {
    /// Unsigned integer indicating the 5QI Priority Level (see clauses 5.7.3.3 and 5.7.4 of 3GPP TS 23.501, within the range 1 to 127.Values are ordered in decreasing order of priority,  i.e. with 1 as the highest priority and 127 as the lowest priority.
    #[serde(rename = "priorityLevel")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority_level: Option<u8>,

    /// Unsigned integer indicating Averaging Window (see clause 5.7.3.6 and 5.7.4 of 3GPP TS 23.501), expressed in milliseconds.
    #[serde(rename = "averWindow")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aver_window: Option<u16>,

    /// Unsigned integer indicating Maximum Data Burst Volume (see clauses 5.7.3.7 and 5.7.4 of 3GPP TS 23.501), expressed in Bytes.
    #[serde(rename = "maxDataBurstVol")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_data_burst_vol: Option<u16>,

    /// Unsigned integer indicating Maximum Data Burst Volume (see clauses 5.7.3.7 and 5.7.4 of 3GPP TS 23.501), expressed in Bytes.
    #[serde(rename = "extMaxDataBurstVol")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ext_max_data_burst_vol: Option<u32>,

    /// Unsigned integer indicating Packet Delay Budget (see clauses 5.7.3.4 and 5.7.4 of 3GPP TS 23.501 [8])), expressed in 0.01 milliseconds.
    #[serde(rename = "cnPacketDelayBudgetDl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cn_packet_delay_budget_dl: Option<u32>,

    /// Unsigned integer indicating Packet Delay Budget (see clauses 5.7.3.4 and 5.7.4 of 3GPP TS 23.501 [8])), expressed in 0.01 milliseconds.
    #[serde(rename = "cnPacketDelayBudgetUl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cn_packet_delay_budget_ul: Option<u32>,
}

impl NonDynamic5Qi {
    #[allow(clippy::new_without_default)]
    pub fn new() -> NonDynamic5Qi {
        NonDynamic5Qi {
            priority_level: None,
            aver_window: Some(2000),
            max_data_burst_vol: None,
            ext_max_data_burst_vol: None,
            cn_packet_delay_budget_dl: None,
            cn_packet_delay_budget_ul: None,
        }
    }
}

/// Converts the NonDynamic5Qi value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NonDynamic5Qi {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.priority_level.as_ref().map(|priority_level| {
                vec!["priorityLevel".to_string(), priority_level.to_string()].join(",")
            }),
            self.aver_window.as_ref().map(|aver_window| {
                vec!["averWindow".to_string(), aver_window.to_string()].join(",")
            }),
            self.max_data_burst_vol.as_ref().map(|max_data_burst_vol| {
                vec![
                    "maxDataBurstVol".to_string(),
                    max_data_burst_vol.to_string(),
                ]
                .join(",")
            }),
            self.ext_max_data_burst_vol
                .as_ref()
                .map(|ext_max_data_burst_vol| {
                    vec![
                        "extMaxDataBurstVol".to_string(),
                        ext_max_data_burst_vol.to_string(),
                    ]
                    .join(",")
                }),
            self.cn_packet_delay_budget_dl
                .as_ref()
                .map(|cn_packet_delay_budget_dl| {
                    vec![
                        "cnPacketDelayBudgetDl".to_string(),
                        cn_packet_delay_budget_dl.to_string(),
                    ]
                    .join(",")
                }),
            self.cn_packet_delay_budget_ul
                .as_ref()
                .map(|cn_packet_delay_budget_ul| {
                    vec![
                        "cnPacketDelayBudgetUl".to_string(),
                        cn_packet_delay_budget_ul.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NonDynamic5Qi value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NonDynamic5Qi {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub priority_level: Vec<u8>,
            pub aver_window: Vec<u16>,
            pub max_data_burst_vol: Vec<u16>,
            pub ext_max_data_burst_vol: Vec<u32>,
            pub cn_packet_delay_budget_dl: Vec<u32>,
            pub cn_packet_delay_budget_ul: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NonDynamic5Qi".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "priorityLevel" => intermediate_rep
                        .priority_level
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "averWindow" => intermediate_rep.aver_window.push(
                        <u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "maxDataBurstVol" => intermediate_rep.max_data_burst_vol.push(
                        <u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "extMaxDataBurstVol" => intermediate_rep.ext_max_data_burst_vol.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "cnPacketDelayBudgetDl" => intermediate_rep.cn_packet_delay_budget_dl.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "cnPacketDelayBudgetUl" => intermediate_rep.cn_packet_delay_budget_ul.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NonDynamic5Qi".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NonDynamic5Qi {
            priority_level: intermediate_rep.priority_level.into_iter().next(),
            aver_window: intermediate_rep.aver_window.into_iter().next(),
            max_data_burst_vol: intermediate_rep.max_data_burst_vol.into_iter().next(),
            ext_max_data_burst_vol: intermediate_rep.ext_max_data_burst_vol.into_iter().next(),
            cn_packet_delay_budget_dl: intermediate_rep
                .cn_packet_delay_budget_dl
                .into_iter()
                .next(),
            cn_packet_delay_budget_ul: intermediate_rep
                .cn_packet_delay_budget_ul
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NonDynamic5Qi> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NonDynamic5Qi>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NonDynamic5Qi>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NonDynamic5Qi - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<NonDynamic5Qi> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NonDynamic5Qi as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NonDynamic5Qi - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Cause for generating a notification. Possible values are - QOS_FULFILLED - QOS_NOT_FULFILLED - UP_SEC_FULFILLED - UP_SEC_NOT_FULFILLED
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NotificationCause {}

impl NotificationCause {
    #[allow(clippy::new_without_default)]
    pub fn new() -> NotificationCause {
        NotificationCause {}
    }
}

/// Converts the NotificationCause value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NotificationCause {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NotificationCause value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NotificationCause {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NotificationCause".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NotificationCause".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NotificationCause {})
    }
}

// Methods for converting between header::IntoHeaderValue<NotificationCause> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NotificationCause>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NotificationCause>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NotificationCause - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<NotificationCause>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NotificationCause as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NotificationCause - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum NotificationCauseAnyOf {
    #[serde(rename = "QOS_FULFILLED")]
    QosFulfilled,
    #[serde(rename = "QOS_NOT_FULFILLED")]
    QosNotFulfilled,
    #[serde(rename = "UP_SEC_FULFILLED")]
    UpSecFulfilled,
    #[serde(rename = "UP_SEC_NOT_FULFILLED")]
    UpSecNotFulfilled,
}

impl std::fmt::Display for NotificationCauseAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            NotificationCauseAnyOf::QosFulfilled => write!(f, "QOS_FULFILLED"),
            NotificationCauseAnyOf::QosNotFulfilled => write!(f, "QOS_NOT_FULFILLED"),
            NotificationCauseAnyOf::UpSecFulfilled => write!(f, "UP_SEC_FULFILLED"),
            NotificationCauseAnyOf::UpSecNotFulfilled => write!(f, "UP_SEC_NOT_FULFILLED"),
        }
    }
}

impl std::str::FromStr for NotificationCauseAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "QOS_FULFILLED" => std::result::Result::Ok(NotificationCauseAnyOf::QosFulfilled),
            "QOS_NOT_FULFILLED" => std::result::Result::Ok(NotificationCauseAnyOf::QosNotFulfilled),
            "UP_SEC_FULFILLED" => std::result::Result::Ok(NotificationCauseAnyOf::UpSecFulfilled),
            "UP_SEC_NOT_FULFILLED" => {
                std::result::Result::Ok(NotificationCauseAnyOf::UpSecNotFulfilled)
            }
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// The enumeration NotificationControl indicates whether notifications are requested from the RAN when the GFBR can no longer  (or again) be fulfilled for a QoS Flow during the lifetime of the QoS Flow (see clause 5.7.2.4 of 3GPP TS 23.501). It shall comply with the provisions defined in table 5.5.3.5-1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NotificationControl {}

impl NotificationControl {
    #[allow(clippy::new_without_default)]
    pub fn new() -> NotificationControl {
        NotificationControl {}
    }
}

/// Converts the NotificationControl value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NotificationControl {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NotificationControl value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NotificationControl {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NotificationControl".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NotificationControl".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NotificationControl {})
    }
}

// Methods for converting between header::IntoHeaderValue<NotificationControl> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NotificationControl>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NotificationControl>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NotificationControl - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<NotificationControl>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NotificationControl as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NotificationControl - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum NotificationControlAnyOf {
    #[serde(rename = "REQUESTED")]
    Requested,
    #[serde(rename = "NOT_REQUESTED")]
    NotRequested,
}

impl std::fmt::Display for NotificationControlAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            NotificationControlAnyOf::Requested => write!(f, "REQUESTED"),
            NotificationControlAnyOf::NotRequested => write!(f, "NOT_REQUESTED"),
        }
    }
}

impl std::str::FromStr for NotificationControlAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "REQUESTED" => std::result::Result::Ok(NotificationControlAnyOf::Requested),
            "NOT_REQUESTED" => std::result::Result::Ok(NotificationControlAnyOf::NotRequested),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Notification Correlation ID and Notification URI provided by the NF service consumer
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NotificationInfo {
    #[serde(rename = "notifId")]
    pub notif_id: String,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "notifUri")]
    pub notif_uri: String,

    #[serde(rename = "upBufferInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub up_buffer_ind: Option<bool>,
}

impl NotificationInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(notif_id: String, notif_uri: String) -> NotificationInfo {
        NotificationInfo {
            notif_id,
            notif_uri,
            up_buffer_ind: Some(false),
        }
    }
}

/// Converts the NotificationInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NotificationInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("notifId".to_string()),
            Some(self.notif_id.to_string()),
            Some("notifUri".to_string()),
            Some(self.notif_uri.to_string()),
            self.up_buffer_ind.as_ref().map(|up_buffer_ind| {
                vec!["upBufferInd".to_string(), up_buffer_ind.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NotificationInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NotificationInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub notif_id: Vec<String>,
            pub notif_uri: Vec<String>,
            pub up_buffer_ind: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NotificationInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "notifId" => intermediate_rep.notif_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "notifUri" => intermediate_rep.notif_uri.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "upBufferInd" => intermediate_rep.up_buffer_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NotificationInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NotificationInfo {
            notif_id: intermediate_rep
                .notif_id
                .into_iter()
                .next()
                .ok_or_else(|| "notifId missing in NotificationInfo".to_string())?,
            notif_uri: intermediate_rep
                .notif_uri
                .into_iter()
                .next()
                .ok_or_else(|| "notifUri missing in NotificationInfo".to_string())?,
            up_buffer_ind: intermediate_rep.up_buffer_ind.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NotificationInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NotificationInfo>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NotificationInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NotificationInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<NotificationInfo>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NotificationInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NotificationInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// 36-bit string identifying an NR Cell Id as specified in clause 9.3.1.7 of 3GPP TS 38.413,  in hexadecimal representation. Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character  representing the 4 most significant bits of the Cell Id shall appear first in the string, and  the character representing the 4 least significant bit of the Cell Id shall appear last in the  string.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NrCellId(String);

impl std::convert::From<String> for NrCellId {
    fn from(x: String) -> Self {
        NrCellId(x)
    }
}

impl std::string::ToString for NrCellId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for NrCellId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(NrCellId(x.to_string()))
    }
}

impl std::convert::From<NrCellId> for String {
    fn from(x: NrCellId) -> Self {
        x.0
    }
}

impl std::ops::Deref for NrCellId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for NrCellId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Contains the NR user location.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NrLocation {
    #[serde(rename = "tai")]
    pub tai: models::Tai,

    #[serde(rename = "ncgi")]
    pub ncgi: models::Ncgi,

    #[serde(rename = "ignoreNcgi")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ignore_ncgi: Option<bool>,

    /// The value represents the elapsed time in minutes since the last network contact of the mobile station. Value \"0\" indicates that the location information was obtained after a successful paging procedure for Active Location Retrieval when the UE is in idle mode or after a successful  NG-RAN location reporting procedure with the eNB when the UE is in connected mode. Any other value than \"0\" indicates that the location information is the last known one. See 3GPP TS 29.002 clause 17.7.8.
    #[serde(rename = "ageOfLocationInformation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub age_of_location_information: Option<u16>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "ueLocationTimestamp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_location_timestamp: Option<chrono::DateTime<chrono::Utc>>,

    /// Refer to geographical Information. See 3GPP TS 23.032 clause 7.3.2. Only the description of an ellipsoid point with uncertainty circle is allowed to be used.
    #[serde(rename = "geographicalInformation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub geographical_information: Option<String>,

    /// Refers to Calling Geodetic Location. See ITU-T Recommendation Q.763 (1999) [24] clause 3.88.2. Only the description of an ellipsoid point with uncertainty circle is allowed to be used.
    #[serde(rename = "geodeticInformation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub geodetic_information: Option<String>,

    #[serde(rename = "globalGnbId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub global_gnb_id: Option<models::GlobalRanNodeId>,
}

impl NrLocation {
    #[allow(clippy::new_without_default)]
    pub fn new(tai: models::Tai, ncgi: models::Ncgi) -> NrLocation {
        NrLocation {
            tai,
            ncgi,
            ignore_ncgi: Some(false),
            age_of_location_information: None,
            ue_location_timestamp: None,
            geographical_information: None,
            geodetic_information: None,
            global_gnb_id: None,
        }
    }
}

/// Converts the NrLocation value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NrLocation {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping tai in query parameter serialization

            // Skipping ncgi in query parameter serialization
            self.ignore_ncgi.as_ref().map(|ignore_ncgi| {
                vec!["ignoreNcgi".to_string(), ignore_ncgi.to_string()].join(",")
            }),
            self.age_of_location_information
                .as_ref()
                .map(|age_of_location_information| {
                    vec![
                        "ageOfLocationInformation".to_string(),
                        age_of_location_information.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping ueLocationTimestamp in query parameter serialization
            self.geographical_information
                .as_ref()
                .map(|geographical_information| {
                    vec![
                        "geographicalInformation".to_string(),
                        geographical_information.to_string(),
                    ]
                    .join(",")
                }),
            self.geodetic_information
                .as_ref()
                .map(|geodetic_information| {
                    vec![
                        "geodeticInformation".to_string(),
                        geodetic_information.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping globalGnbId in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NrLocation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NrLocation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub tai: Vec<models::Tai>,
            pub ncgi: Vec<models::Ncgi>,
            pub ignore_ncgi: Vec<bool>,
            pub age_of_location_information: Vec<u16>,
            pub ue_location_timestamp: Vec<chrono::DateTime<chrono::Utc>>,
            pub geographical_information: Vec<String>,
            pub geodetic_information: Vec<String>,
            pub global_gnb_id: Vec<models::GlobalRanNodeId>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NrLocation".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "tai" => intermediate_rep.tai.push(
                        <models::Tai as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ncgi" => intermediate_rep.ncgi.push(
                        <models::Ncgi as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ignoreNcgi" => intermediate_rep.ignore_ncgi.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ageOfLocationInformation" => {
                        intermediate_rep.age_of_location_information.push(
                            <u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "ueLocationTimestamp" => intermediate_rep.ue_location_timestamp.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "geographicalInformation" => intermediate_rep.geographical_information.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "geodeticInformation" => intermediate_rep.geodetic_information.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "globalGnbId" => intermediate_rep.global_gnb_id.push(
                        <models::GlobalRanNodeId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NrLocation".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NrLocation {
            tai: intermediate_rep
                .tai
                .into_iter()
                .next()
                .ok_or_else(|| "tai missing in NrLocation".to_string())?,
            ncgi: intermediate_rep
                .ncgi
                .into_iter()
                .next()
                .ok_or_else(|| "ncgi missing in NrLocation".to_string())?,
            ignore_ncgi: intermediate_rep.ignore_ncgi.into_iter().next(),
            age_of_location_information: intermediate_rep
                .age_of_location_information
                .into_iter()
                .next(),
            ue_location_timestamp: intermediate_rep.ue_location_timestamp.into_iter().next(),
            geographical_information: intermediate_rep.geographical_information.into_iter().next(),
            geodetic_information: intermediate_rep.geodetic_information.into_iter().next(),
            global_gnb_id: intermediate_rep.global_gnb_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NrLocation> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NrLocation>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NrLocation>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NrLocation - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<NrLocation> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NrLocation as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NrLocation - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// JSON's null value.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum NullValue {
    #[serde(rename = "null")]
    Null,
}

impl std::fmt::Display for NullValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            NullValue::Null => write!(f, "null"),
        }
    }
}

impl std::str::FromStr for NullValue {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "null" => std::result::Result::Ok(NullValue::Null),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Unsigned integer indicating Packet Delay Budget (see clauses 5.7.3.4 and 5.7.4 of 3GPP TS 23.501), expressed in milliseconds.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PacketDelBudget(i32);

impl std::convert::From<i32> for PacketDelBudget {
    fn from(x: i32) -> Self {
        PacketDelBudget(x)
    }
}

impl std::convert::From<PacketDelBudget> for i32 {
    fn from(x: PacketDelBudget) -> Self {
        x.0
    }
}

impl std::ops::Deref for PacketDelBudget {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for PacketDelBudget {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// String representing Packet Error Rate (see clause 5.7.3.5 and 5.7.4 of 3GPP TS 23.501, expressed as a \"scalar x 10-k\" where the scalar and the exponent k are each encoded as one decimal digit.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PacketErrRate(String);

impl std::convert::From<String> for PacketErrRate {
    fn from(x: String) -> Self {
        PacketErrRate(x)
    }
}

impl std::string::ToString for PacketErrRate {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for PacketErrRate {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(PacketErrRate(x.to_string()))
    }
}

impl std::convert::From<PacketErrRate> for String {
    fn from(x: PacketErrRate) -> Self {
        x.0
    }
}

impl std::ops::Deref for PacketErrRate {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for PacketErrRate {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Unsigned integer indicating Packet Loss Rate (see clauses 5.7.2.8 and 5.7.4 of 3GPP TS 23.501), expressed in tenth of percent.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PacketLossRate(i32);

impl std::convert::From<i32> for PacketLossRate {
    fn from(x: i32) -> Self {
        PacketLossRate(x)
    }
}

impl std::convert::From<PacketLossRate> for i32 {
    fn from(x: PacketLossRate) -> Self {
        x.0
    }
}

impl std::ops::Deref for PacketLossRate {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for PacketLossRate {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PartialRecordMethod {}

impl PartialRecordMethod {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PartialRecordMethod {
        PartialRecordMethod {}
    }
}

/// Converts the PartialRecordMethod value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PartialRecordMethod {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PartialRecordMethod value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PartialRecordMethod {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PartialRecordMethod".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PartialRecordMethod".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PartialRecordMethod {})
    }
}

// Methods for converting between header::IntoHeaderValue<PartialRecordMethod> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PartialRecordMethod>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PartialRecordMethod>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PartialRecordMethod - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<PartialRecordMethod>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PartialRecordMethod as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PartialRecordMethod - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PartialRecordMethodAnyOf {
    #[serde(rename = "DEFAULT")]
    Default,
    #[serde(rename = "INDIVIDUAL")]
    Individual,
}

impl std::fmt::Display for PartialRecordMethodAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PartialRecordMethodAnyOf::Default => write!(f, "DEFAULT"),
            PartialRecordMethodAnyOf::Individual => write!(f, "INDIVIDUAL"),
        }
    }
}

impl std::str::FromStr for PartialRecordMethodAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "DEFAULT" => std::result::Result::Ok(PartialRecordMethodAnyOf::Default),
            "INDIVIDUAL" => std::result::Result::Ok(PartialRecordMethodAnyOf::Individual),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Contains the PCF for the UE information necessary for the PCF for the PDU session to send  SM Policy Association Establishment and Termination events.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PcfUeCallbackInfo {
    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "callbackUri")]
    pub callback_uri: String,

    #[serde(rename = "bindingInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub binding_info: Option<String>,
}

impl PcfUeCallbackInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(callback_uri: String) -> PcfUeCallbackInfo {
        PcfUeCallbackInfo {
            callback_uri,
            binding_info: None,
        }
    }
}

/// Converts the PcfUeCallbackInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PcfUeCallbackInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("callbackUri".to_string()),
            Some(self.callback_uri.to_string()),
            self.binding_info.as_ref().map(|binding_info| {
                vec!["bindingInfo".to_string(), binding_info.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PcfUeCallbackInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PcfUeCallbackInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub callback_uri: Vec<String>,
            pub binding_info: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PcfUeCallbackInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "callbackUri" => intermediate_rep.callback_uri.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "bindingInfo" => intermediate_rep.binding_info.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PcfUeCallbackInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PcfUeCallbackInfo {
            callback_uri: intermediate_rep
                .callback_uri
                .into_iter()
                .next()
                .ok_or_else(|| "callbackUri missing in PcfUeCallbackInfo".to_string())?,
            binding_info: intermediate_rep.binding_info.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PcfUeCallbackInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PcfUeCallbackInfo>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PcfUeCallbackInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PcfUeCallbackInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<PcfUeCallbackInfo>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PcfUeCallbackInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PcfUeCallbackInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Type of PDU Session information. Possible values are   - AF_COORDINATION_INFO
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PduSessionContextType {}

impl PduSessionContextType {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PduSessionContextType {
        PduSessionContextType {}
    }
}

/// Converts the PduSessionContextType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PduSessionContextType {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PduSessionContextType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PduSessionContextType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PduSessionContextType".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PduSessionContextType".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PduSessionContextType {})
    }
}

// Methods for converting between header::IntoHeaderValue<PduSessionContextType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PduSessionContextType>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PduSessionContextType>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PduSessionContextType - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<PduSessionContextType>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PduSessionContextType as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PduSessionContextType - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PduSessionContextTypeAnyOf {
    #[serde(rename = "AF_COORDINATION_INFO")]
    AfCoordinationInfo,
}

impl std::fmt::Display for PduSessionContextTypeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PduSessionContextTypeAnyOf::AfCoordinationInfo => write!(f, "AF_COORDINATION_INFO"),
        }
    }
}

impl std::str::FromStr for PduSessionContextTypeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "AF_COORDINATION_INFO" => {
                std::result::Result::Ok(PduSessionContextTypeAnyOf::AfCoordinationInfo)
            }
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Data within Create Request
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PduSessionCreateData {
    /// String identifying a Supi that shall contain either an IMSI, a network specific identifier, a Global Cable Identifier (GCI) or a Global Line Identifier (GLI) as specified in clause  2.2A of 3GPP TS 23.003. It shall be formatted as follows  - for an IMSI \"imsi-<imsi>\", where <imsi> shall be formatted according to clause 2.2    of 3GPP TS 23.003 that describes an IMSI.  - for a network specific identifier \"nai-<nai>, where <nai> shall be formatted    according to clause 28.7.2 of 3GPP TS 23.003 that describes an NAI.  - for a GCI \"gci-<gci>\", where <gci> shall be formatted according to clause 28.15.2    of 3GPP TS 23.003.  - for a GLI \"gli-<gli>\", where <gli> shall be formatted according to clause 28.16.2 of    3GPP TS 23.003.To enable that the value is used as part of an URI, the string shall    only contain characters allowed according to the \"lower-with-hyphen\" naming convention    defined in 3GPP TS 29.501.
    #[serde(rename = "supi")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supi: Option<String>,

    #[serde(rename = "unauthenticatedSupi")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unauthenticated_supi: Option<bool>,

    /// String representing a Permanent Equipment Identifier that may contain - an IMEI or IMEISV, as  specified in clause 6.2 of 3GPP TS 23.003; a MAC address for a 5G-RG or FN-RG via  wireline  access, with an indication that this address cannot be trusted for regulatory purpose if this  address cannot be used as an Equipment Identifier of the FN-RG, as specified in clause 4.7.7  of 3GPP TS23.316. Examples are imei-012345678901234 or imeisv-0123456789012345.
    #[serde(rename = "pei")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pei: Option<String>,

    /// Unsigned integer identifying a PDU session, within the range 0 to 255, as specified in  clause 11.2.3.1b, bits 1 to 8, of 3GPP TS 24.007. If the PDU Session ID is allocated by the  Core Network for UEs not supporting N1 mode, reserved range 64 to 95 is used. PDU Session ID  within the reserved range is only visible in the Core Network.
    #[serde(rename = "pduSessionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pdu_session_id: Option<u8>,

    /// String representing a Data Network as defined in clause 9A of 3GPP TS 23.003;  it shall contain either a DNN Network Identifier, or a full DNN with both the Network  Identifier and Operator Identifier, as specified in 3GPP TS 23.003 clause 9.1.1 and 9.1.2. It shall be coded as string in which the labels are separated by dots  (e.g. \"Label1.Label2.Label3\").
    #[serde(rename = "dnn")]
    pub dnn: String,

    /// String representing a Data Network as defined in clause 9A of 3GPP TS 23.003;  it shall contain either a DNN Network Identifier, or a full DNN with both the Network  Identifier and Operator Identifier, as specified in 3GPP TS 23.003 clause 9.1.1 and 9.1.2. It shall be coded as string in which the labels are separated by dots  (e.g. \"Label1.Label2.Label3\").
    #[serde(rename = "selectedDnn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub selected_dnn: Option<String>,

    #[serde(rename = "sNssai")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub s_nssai: Option<models::Snssai>,

    #[serde(rename = "hplmnSnssai")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hplmn_snssai: Option<models::Snssai>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "vsmfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub vsmf_id: Option<uuid::Uuid>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "ismfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ismf_id: Option<uuid::Uuid>,

    #[serde(rename = "servingNetwork")]
    pub serving_network: models::PlmnIdNid,

    #[serde(rename = "requestType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub request_type: Option<models::RequestType>,

    #[serde(rename = "epsBearerId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub eps_bearer_id: Option<Vec<models::EpsBearerId>>,

    /// string with format 'bytes' as defined in OpenAPI
    #[serde(rename = "pgwS8cFteid")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pgw_s8c_fteid: Option<swagger::ByteArray>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "vsmfPduSessionUri")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub vsmf_pdu_session_uri: Option<String>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "ismfPduSessionUri")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ismf_pdu_session_uri: Option<String>,

    #[serde(rename = "vcnTunnelInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub vcn_tunnel_info: Option<models::TunnelInfo>,

    #[serde(rename = "icnTunnelInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icn_tunnel_info: Option<models::TunnelInfo>,

    #[serde(rename = "n9ForwardingTunnelInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n9_forwarding_tunnel_info: Option<models::TunnelInfo>,

    #[serde(rename = "additionalCnTunnelInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_cn_tunnel_info: Option<models::TunnelInfo>,

    #[serde(rename = "anType")]
    pub an_type: models::AccessType,

    #[serde(rename = "additionalAnType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_an_type: Option<models::AccessType>,

    #[serde(rename = "ratType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rat_type: Option<models::RatType>,

    #[serde(rename = "ueLocation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_location: Option<models::UserLocation>,

    /// String with format \"time-numoffset\" optionally appended by \"daylightSavingTime\", where  - \"time-numoffset\" shall represent the time zone adjusted for daylight saving time and be    encoded as time-numoffset as defined in clause 5.6 of IETF RFC 3339;  - \"daylightSavingTime\" shall represent the adjustment that has been made and shall be    encoded as \"+1\" or \"+2\" for a +1 or +2 hours adjustment.   The example is for 8 hours behind UTC, +1 hour adjustment for Daylight Saving Time.
    #[serde(rename = "ueTimeZone")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_time_zone: Option<String>,

    #[serde(rename = "addUeLocation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub add_ue_location: Option<models::UserLocation>,

    /// String identifying a Gpsi shall contain either an External Id or an MSISDN.  It shall be formatted as follows -External Identifier= \"extid-'extid', where 'extid'  shall be formatted according to clause 19.7.2 of 3GPP TS 23.003 that describes an  External Identifier.
    #[serde(rename = "gpsi")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gpsi: Option<String>,

    #[serde(rename = "n1SmInfoFromUe")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n1_sm_info_from_ue: Option<models::RefToBinaryData>,

    #[serde(rename = "unknownN1SmInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unknown_n1_sm_info: Option<models::RefToBinaryData>,

    /// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  table 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.
    #[serde(rename = "supportedFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_features: Option<String>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "hPcfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub h_pcf_id: Option<uuid::Uuid>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "pcfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pcf_id: Option<uuid::Uuid>,

    /// Identifier of a group of NFs.
    #[serde(rename = "pcfGroupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pcf_group_id: Option<String>,

    /// NF Set Identifier (see clause 28.12 of 3GPP TS 23.003), formatted as the following string \"set<Set ID>.<nftype>set.5gc.mnc<MNC>.mcc<MCC>\", or  \"set<SetID>.<NFType>set.5gc.nid<NID>.mnc<MNC>.mcc<MCC>\" with  <MCC> encoded as defined in clause 5.4.2 (\"Mcc\" data type definition)  <MNC> encoding the Mobile Network Code part of the PLMN, comprising 3 digits.    If there are only 2 significant digits in the MNC, one \"0\" digit shall be inserted    at the left side to fill the 3 digits coding of MNC.  Pattern: '^[0-9]{3}$' <NFType> encoded as a value defined in Table 6.1.6.3.3-1 of 3GPP TS 29.510 but    with lower case characters <Set ID> encoded as a string of characters consisting of    alphabetic characters (A-Z and a-z), digits (0-9) and/or the hyphen (-) and that    shall end with either an alphabetic character or a digit.
    #[serde(rename = "pcfSetId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pcf_set_id: Option<String>,

    #[serde(rename = "hoPreparationIndication")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ho_preparation_indication: Option<bool>,

    #[serde(rename = "selMode")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sel_mode: Option<models::DnnSelectionMode>,

    #[serde(rename = "alwaysOnRequested")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub always_on_requested: Option<bool>,

    /// Identifier of a group of NFs.
    #[serde(rename = "udmGroupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub udm_group_id: Option<String>,

    #[serde(rename = "routingIndicator")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub routing_indicator: Option<String>,

    #[serde(rename = "hNwPubKeyId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub h_nw_pub_key_id: Option<i32>,

    #[serde(rename = "epsInterworkingInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub eps_interworking_ind: Option<models::EpsInterworkingIndication>,

    #[serde(rename = "vSmfServiceInstanceId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub v_smf_service_instance_id: Option<String>,

    #[serde(rename = "iSmfServiceInstanceId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub i_smf_service_instance_id: Option<String>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "recoveryTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recovery_time: Option<chrono::DateTime<chrono::Utc>>,

    #[serde(rename = "roamingChargingProfile")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub roaming_charging_profile: Option<models::RoamingChargingProfile>,

    #[serde(rename = "chargingId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub charging_id: Option<String>,

    /// Unsigned integer identifying a PDU session, within the range 0 to 255, as specified in  clause 11.2.3.1b, bits 1 to 8, of 3GPP TS 24.007. If the PDU Session ID is allocated by the  Core Network for UEs not supporting N1 mode, reserved range 64 to 95 is used. PDU Session ID  within the reserved range is only visible in the Core Network.
    #[serde(rename = "oldPduSessionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub old_pdu_session_id: Option<u8>,

    /// EPS bearer context status
    #[serde(rename = "epsBearerCtxStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub eps_bearer_ctx_status: Option<String>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "amfNfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub amf_nf_id: Option<uuid::Uuid>,

    #[serde(rename = "guami")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub guami: Option<models::Guami>,

    #[serde(rename = "maxIntegrityProtectedDataRateUl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_integrity_protected_data_rate_ul: Option<models::MaxIntegrityProtectedDataRate>,

    #[serde(rename = "maxIntegrityProtectedDataRateDl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_integrity_protected_data_rate_dl: Option<models::MaxIntegrityProtectedDataRate>,

    #[serde(rename = "cpCiotEnabled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cp_ciot_enabled: Option<bool>,

    #[serde(rename = "cpOnlyInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cp_only_ind: Option<bool>,

    #[serde(rename = "invokeNef")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub invoke_nef: Option<bool>,

    #[serde(rename = "maRequestInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ma_request_ind: Option<bool>,

    #[serde(rename = "maNwUpgradeInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ma_nw_upgrade_ind: Option<bool>,

    #[serde(rename = "dnaiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dnai_list: Option<Vec<models::Dnai>>,

    #[serde(rename = "presenceInLadn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub presence_in_ladn: Option<models::PresenceState>,

    #[serde(rename = "secondaryRatUsageInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub secondary_rat_usage_info: Option<Vec<models::SecondaryRatUsageInfo>>,

    #[serde(rename = "smallDataRateStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub small_data_rate_status: Option<models::SmallDataRateStatus>,

    #[serde(rename = "apnRateStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub apn_rate_status: Option<models::ApnRateStatus>,

    #[serde(rename = "dlServingPlmnRateCtl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dl_serving_plmn_rate_ctl: Option<u32>,

    #[serde(rename = "upSecurityInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub up_security_info: Option<models::UpSecurityInfo>,

    #[serde(rename = "vplmnQos")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub vplmn_qos: Option<models::VplmnQos>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "oldSmContextRef")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub old_sm_context_ref: Option<String>,

    #[serde(rename = "redundantPduSessionInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub redundant_pdu_session_info: Option<models::RedundantPduSessionInformation>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "oldPduSessionRef")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub old_pdu_session_ref: Option<String>,

    #[serde(rename = "smPolicyNotifyInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sm_policy_notify_ind: Option<bool>,

    #[serde(rename = "pcfUeCallbackInfo")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pcf_ue_callback_info: Option<swagger::Nullable<models::PcfUeCallbackInfo>>,

    #[serde(rename = "satelliteBackhaulCat")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub satellite_backhaul_cat: Option<models::SatelliteBackhaulCategory>,

    #[serde(rename = "upipSupported")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub upip_supported: Option<bool>,

    #[serde(rename = "upCnxState")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub up_cnx_state: Option<models::UpCnxState>,

    #[serde(rename = "disasterRoamingInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub disaster_roaming_ind: Option<bool>,
}

impl PduSessionCreateData {
    #[allow(clippy::new_without_default)]
    pub fn new(
        dnn: String,
        serving_network: models::PlmnIdNid,
        an_type: models::AccessType,
    ) -> PduSessionCreateData {
        PduSessionCreateData {
            supi: None,
            unauthenticated_supi: Some(false),
            pei: None,
            pdu_session_id: None,
            dnn,
            selected_dnn: None,
            s_nssai: None,
            hplmn_snssai: None,
            vsmf_id: None,
            ismf_id: None,
            serving_network,
            request_type: None,
            eps_bearer_id: None,
            pgw_s8c_fteid: None,
            vsmf_pdu_session_uri: None,
            ismf_pdu_session_uri: None,
            vcn_tunnel_info: None,
            icn_tunnel_info: None,
            n9_forwarding_tunnel_info: None,
            additional_cn_tunnel_info: None,
            an_type,
            additional_an_type: None,
            rat_type: None,
            ue_location: None,
            ue_time_zone: None,
            add_ue_location: None,
            gpsi: None,
            n1_sm_info_from_ue: None,
            unknown_n1_sm_info: None,
            supported_features: None,
            h_pcf_id: None,
            pcf_id: None,
            pcf_group_id: None,
            pcf_set_id: None,
            ho_preparation_indication: None,
            sel_mode: None,
            always_on_requested: Some(false),
            udm_group_id: None,
            routing_indicator: None,
            h_nw_pub_key_id: None,
            eps_interworking_ind: None,
            v_smf_service_instance_id: None,
            i_smf_service_instance_id: None,
            recovery_time: None,
            roaming_charging_profile: None,
            charging_id: None,
            old_pdu_session_id: None,
            eps_bearer_ctx_status: None,
            amf_nf_id: None,
            guami: None,
            max_integrity_protected_data_rate_ul: None,
            max_integrity_protected_data_rate_dl: None,
            cp_ciot_enabled: Some(false),
            cp_only_ind: Some(false),
            invoke_nef: Some(false),
            ma_request_ind: Some(false),
            ma_nw_upgrade_ind: Some(false),
            dnai_list: None,
            presence_in_ladn: None,
            secondary_rat_usage_info: None,
            small_data_rate_status: None,
            apn_rate_status: None,
            dl_serving_plmn_rate_ctl: None,
            up_security_info: None,
            vplmn_qos: None,
            old_sm_context_ref: None,
            redundant_pdu_session_info: None,
            old_pdu_session_ref: None,
            sm_policy_notify_ind: Some(false),
            pcf_ue_callback_info: None,
            satellite_backhaul_cat: None,
            upip_supported: Some(false),
            up_cnx_state: None,
            disaster_roaming_ind: Some(false),
        }
    }
}

/// Converts the PduSessionCreateData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PduSessionCreateData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.supi
                .as_ref()
                .map(|supi| vec!["supi".to_string(), supi.to_string()].join(",")),
            self.unauthenticated_supi
                .as_ref()
                .map(|unauthenticated_supi| {
                    vec![
                        "unauthenticatedSupi".to_string(),
                        unauthenticated_supi.to_string(),
                    ]
                    .join(",")
                }),
            self.pei
                .as_ref()
                .map(|pei| vec!["pei".to_string(), pei.to_string()].join(",")),
            self.pdu_session_id.as_ref().map(|pdu_session_id| {
                vec!["pduSessionId".to_string(), pdu_session_id.to_string()].join(",")
            }),
            Some("dnn".to_string()),
            Some(self.dnn.to_string()),
            self.selected_dnn.as_ref().map(|selected_dnn| {
                vec!["selectedDnn".to_string(), selected_dnn.to_string()].join(",")
            }),
            // Skipping sNssai in query parameter serialization

            // Skipping hplmnSnssai in query parameter serialization

            // Skipping vsmfId in query parameter serialization

            // Skipping ismfId in query parameter serialization

            // Skipping servingNetwork in query parameter serialization

            // Skipping requestType in query parameter serialization
            self.eps_bearer_id.as_ref().map(|eps_bearer_id| {
                vec![
                    "epsBearerId".to_string(),
                    eps_bearer_id
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping pgwS8cFteid in query parameter serialization
            // Skipping pgwS8cFteid in query parameter serialization
            self.vsmf_pdu_session_uri
                .as_ref()
                .map(|vsmf_pdu_session_uri| {
                    vec![
                        "vsmfPduSessionUri".to_string(),
                        vsmf_pdu_session_uri.to_string(),
                    ]
                    .join(",")
                }),
            self.ismf_pdu_session_uri
                .as_ref()
                .map(|ismf_pdu_session_uri| {
                    vec![
                        "ismfPduSessionUri".to_string(),
                        ismf_pdu_session_uri.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping vcnTunnelInfo in query parameter serialization

            // Skipping icnTunnelInfo in query parameter serialization

            // Skipping n9ForwardingTunnelInfo in query parameter serialization

            // Skipping additionalCnTunnelInfo in query parameter serialization

            // Skipping anType in query parameter serialization

            // Skipping additionalAnType in query parameter serialization

            // Skipping ratType in query parameter serialization

            // Skipping ueLocation in query parameter serialization
            self.ue_time_zone.as_ref().map(|ue_time_zone| {
                vec!["ueTimeZone".to_string(), ue_time_zone.to_string()].join(",")
            }),
            // Skipping addUeLocation in query parameter serialization
            self.gpsi
                .as_ref()
                .map(|gpsi| vec!["gpsi".to_string(), gpsi.to_string()].join(",")),
            // Skipping n1SmInfoFromUe in query parameter serialization

            // Skipping unknownN1SmInfo in query parameter serialization
            self.supported_features.as_ref().map(|supported_features| {
                vec![
                    "supportedFeatures".to_string(),
                    supported_features.to_string(),
                ]
                .join(",")
            }),
            // Skipping hPcfId in query parameter serialization

            // Skipping pcfId in query parameter serialization
            self.pcf_group_id.as_ref().map(|pcf_group_id| {
                vec!["pcfGroupId".to_string(), pcf_group_id.to_string()].join(",")
            }),
            self.pcf_set_id
                .as_ref()
                .map(|pcf_set_id| vec!["pcfSetId".to_string(), pcf_set_id.to_string()].join(",")),
            self.ho_preparation_indication
                .as_ref()
                .map(|ho_preparation_indication| {
                    vec![
                        "hoPreparationIndication".to_string(),
                        ho_preparation_indication.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping selMode in query parameter serialization
            self.always_on_requested
                .as_ref()
                .map(|always_on_requested| {
                    vec![
                        "alwaysOnRequested".to_string(),
                        always_on_requested.to_string(),
                    ]
                    .join(",")
                }),
            self.udm_group_id.as_ref().map(|udm_group_id| {
                vec!["udmGroupId".to_string(), udm_group_id.to_string()].join(",")
            }),
            self.routing_indicator.as_ref().map(|routing_indicator| {
                vec![
                    "routingIndicator".to_string(),
                    routing_indicator.to_string(),
                ]
                .join(",")
            }),
            self.h_nw_pub_key_id.as_ref().map(|h_nw_pub_key_id| {
                vec!["hNwPubKeyId".to_string(), h_nw_pub_key_id.to_string()].join(",")
            }),
            // Skipping epsInterworkingInd in query parameter serialization
            self.v_smf_service_instance_id
                .as_ref()
                .map(|v_smf_service_instance_id| {
                    vec![
                        "vSmfServiceInstanceId".to_string(),
                        v_smf_service_instance_id.to_string(),
                    ]
                    .join(",")
                }),
            self.i_smf_service_instance_id
                .as_ref()
                .map(|i_smf_service_instance_id| {
                    vec![
                        "iSmfServiceInstanceId".to_string(),
                        i_smf_service_instance_id.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping recoveryTime in query parameter serialization

            // Skipping roamingChargingProfile in query parameter serialization
            self.charging_id.as_ref().map(|charging_id| {
                vec!["chargingId".to_string(), charging_id.to_string()].join(",")
            }),
            self.old_pdu_session_id.as_ref().map(|old_pdu_session_id| {
                vec![
                    "oldPduSessionId".to_string(),
                    old_pdu_session_id.to_string(),
                ]
                .join(",")
            }),
            self.eps_bearer_ctx_status
                .as_ref()
                .map(|eps_bearer_ctx_status| {
                    vec![
                        "epsBearerCtxStatus".to_string(),
                        eps_bearer_ctx_status.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping amfNfId in query parameter serialization

            // Skipping guami in query parameter serialization

            // Skipping maxIntegrityProtectedDataRateUl in query parameter serialization

            // Skipping maxIntegrityProtectedDataRateDl in query parameter serialization
            self.cp_ciot_enabled.as_ref().map(|cp_ciot_enabled| {
                vec!["cpCiotEnabled".to_string(), cp_ciot_enabled.to_string()].join(",")
            }),
            self.cp_only_ind.as_ref().map(|cp_only_ind| {
                vec!["cpOnlyInd".to_string(), cp_only_ind.to_string()].join(",")
            }),
            self.invoke_nef
                .as_ref()
                .map(|invoke_nef| vec!["invokeNef".to_string(), invoke_nef.to_string()].join(",")),
            self.ma_request_ind.as_ref().map(|ma_request_ind| {
                vec!["maRequestInd".to_string(), ma_request_ind.to_string()].join(",")
            }),
            self.ma_nw_upgrade_ind.as_ref().map(|ma_nw_upgrade_ind| {
                vec!["maNwUpgradeInd".to_string(), ma_nw_upgrade_ind.to_string()].join(",")
            }),
            self.dnai_list.as_ref().map(|dnai_list| {
                vec![
                    "dnaiList".to_string(),
                    dnai_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping presenceInLadn in query parameter serialization

            // Skipping secondaryRatUsageInfo in query parameter serialization

            // Skipping smallDataRateStatus in query parameter serialization

            // Skipping apnRateStatus in query parameter serialization
            self.dl_serving_plmn_rate_ctl
                .as_ref()
                .map(|dl_serving_plmn_rate_ctl| {
                    vec![
                        "dlServingPlmnRateCtl".to_string(),
                        dl_serving_plmn_rate_ctl.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping upSecurityInfo in query parameter serialization

            // Skipping vplmnQos in query parameter serialization
            self.old_sm_context_ref.as_ref().map(|old_sm_context_ref| {
                vec![
                    "oldSmContextRef".to_string(),
                    old_sm_context_ref.to_string(),
                ]
                .join(",")
            }),
            // Skipping redundantPduSessionInfo in query parameter serialization
            self.old_pdu_session_ref
                .as_ref()
                .map(|old_pdu_session_ref| {
                    vec![
                        "oldPduSessionRef".to_string(),
                        old_pdu_session_ref.to_string(),
                    ]
                    .join(",")
                }),
            self.sm_policy_notify_ind
                .as_ref()
                .map(|sm_policy_notify_ind| {
                    vec![
                        "smPolicyNotifyInd".to_string(),
                        sm_policy_notify_ind.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping pcfUeCallbackInfo in query parameter serialization

            // Skipping satelliteBackhaulCat in query parameter serialization
            self.upip_supported.as_ref().map(|upip_supported| {
                vec!["upipSupported".to_string(), upip_supported.to_string()].join(",")
            }),
            // Skipping upCnxState in query parameter serialization
            self.disaster_roaming_ind
                .as_ref()
                .map(|disaster_roaming_ind| {
                    vec![
                        "disasterRoamingInd".to_string(),
                        disaster_roaming_ind.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PduSessionCreateData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PduSessionCreateData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub supi: Vec<String>,
            pub unauthenticated_supi: Vec<bool>,
            pub pei: Vec<String>,
            pub pdu_session_id: Vec<u8>,
            pub dnn: Vec<String>,
            pub selected_dnn: Vec<String>,
            pub s_nssai: Vec<models::Snssai>,
            pub hplmn_snssai: Vec<models::Snssai>,
            pub vsmf_id: Vec<uuid::Uuid>,
            pub ismf_id: Vec<uuid::Uuid>,
            pub serving_network: Vec<models::PlmnIdNid>,
            pub request_type: Vec<models::RequestType>,
            pub eps_bearer_id: Vec<Vec<models::EpsBearerId>>,
            pub pgw_s8c_fteid: Vec<swagger::ByteArray>,
            pub vsmf_pdu_session_uri: Vec<String>,
            pub ismf_pdu_session_uri: Vec<String>,
            pub vcn_tunnel_info: Vec<models::TunnelInfo>,
            pub icn_tunnel_info: Vec<models::TunnelInfo>,
            pub n9_forwarding_tunnel_info: Vec<models::TunnelInfo>,
            pub additional_cn_tunnel_info: Vec<models::TunnelInfo>,
            pub an_type: Vec<models::AccessType>,
            pub additional_an_type: Vec<models::AccessType>,
            pub rat_type: Vec<models::RatType>,
            pub ue_location: Vec<models::UserLocation>,
            pub ue_time_zone: Vec<String>,
            pub add_ue_location: Vec<models::UserLocation>,
            pub gpsi: Vec<String>,
            pub n1_sm_info_from_ue: Vec<models::RefToBinaryData>,
            pub unknown_n1_sm_info: Vec<models::RefToBinaryData>,
            pub supported_features: Vec<String>,
            pub h_pcf_id: Vec<uuid::Uuid>,
            pub pcf_id: Vec<uuid::Uuid>,
            pub pcf_group_id: Vec<String>,
            pub pcf_set_id: Vec<String>,
            pub ho_preparation_indication: Vec<bool>,
            pub sel_mode: Vec<models::DnnSelectionMode>,
            pub always_on_requested: Vec<bool>,
            pub udm_group_id: Vec<String>,
            pub routing_indicator: Vec<String>,
            pub h_nw_pub_key_id: Vec<i32>,
            pub eps_interworking_ind: Vec<models::EpsInterworkingIndication>,
            pub v_smf_service_instance_id: Vec<String>,
            pub i_smf_service_instance_id: Vec<String>,
            pub recovery_time: Vec<chrono::DateTime<chrono::Utc>>,
            pub roaming_charging_profile: Vec<models::RoamingChargingProfile>,
            pub charging_id: Vec<String>,
            pub old_pdu_session_id: Vec<u8>,
            pub eps_bearer_ctx_status: Vec<String>,
            pub amf_nf_id: Vec<uuid::Uuid>,
            pub guami: Vec<models::Guami>,
            pub max_integrity_protected_data_rate_ul: Vec<models::MaxIntegrityProtectedDataRate>,
            pub max_integrity_protected_data_rate_dl: Vec<models::MaxIntegrityProtectedDataRate>,
            pub cp_ciot_enabled: Vec<bool>,
            pub cp_only_ind: Vec<bool>,
            pub invoke_nef: Vec<bool>,
            pub ma_request_ind: Vec<bool>,
            pub ma_nw_upgrade_ind: Vec<bool>,
            pub dnai_list: Vec<Vec<models::Dnai>>,
            pub presence_in_ladn: Vec<models::PresenceState>,
            pub secondary_rat_usage_info: Vec<Vec<models::SecondaryRatUsageInfo>>,
            pub small_data_rate_status: Vec<models::SmallDataRateStatus>,
            pub apn_rate_status: Vec<models::ApnRateStatus>,
            pub dl_serving_plmn_rate_ctl: Vec<u32>,
            pub up_security_info: Vec<models::UpSecurityInfo>,
            pub vplmn_qos: Vec<models::VplmnQos>,
            pub old_sm_context_ref: Vec<String>,
            pub redundant_pdu_session_info: Vec<models::RedundantPduSessionInformation>,
            pub old_pdu_session_ref: Vec<String>,
            pub sm_policy_notify_ind: Vec<bool>,
            pub pcf_ue_callback_info: Vec<models::PcfUeCallbackInfo>,
            pub satellite_backhaul_cat: Vec<models::SatelliteBackhaulCategory>,
            pub upip_supported: Vec<bool>,
            pub up_cnx_state: Vec<models::UpCnxState>,
            pub disaster_roaming_ind: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PduSessionCreateData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "supi" => intermediate_rep.supi.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "unauthenticatedSupi" => intermediate_rep.unauthenticated_supi.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pei" => intermediate_rep.pei.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pduSessionId" => intermediate_rep.pdu_session_id.push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dnn" => intermediate_rep.dnn.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "selectedDnn" => intermediate_rep.selected_dnn.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sNssai" => intermediate_rep.s_nssai.push(<models::Snssai as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hplmnSnssai" => intermediate_rep.hplmn_snssai.push(<models::Snssai as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "vsmfId" => intermediate_rep.vsmf_id.push(<uuid::Uuid as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ismfId" => intermediate_rep.ismf_id.push(<uuid::Uuid as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "servingNetwork" => intermediate_rep.serving_network.push(<models::PlmnIdNid as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "requestType" => intermediate_rep.request_type.push(<models::RequestType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "epsBearerId" => return std::result::Result::Err("Parsing a container in this style is not supported in PduSessionCreateData".to_string()),
                    "pgwS8cFteid" => return std::result::Result::Err("Parsing binary data in this style is not supported in PduSessionCreateData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "vsmfPduSessionUri" => intermediate_rep.vsmf_pdu_session_uri.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ismfPduSessionUri" => intermediate_rep.ismf_pdu_session_uri.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "vcnTunnelInfo" => intermediate_rep.vcn_tunnel_info.push(<models::TunnelInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "icnTunnelInfo" => intermediate_rep.icn_tunnel_info.push(<models::TunnelInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "n9ForwardingTunnelInfo" => intermediate_rep.n9_forwarding_tunnel_info.push(<models::TunnelInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "additionalCnTunnelInfo" => intermediate_rep.additional_cn_tunnel_info.push(<models::TunnelInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "anType" => intermediate_rep.an_type.push(<models::AccessType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "additionalAnType" => intermediate_rep.additional_an_type.push(<models::AccessType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ratType" => intermediate_rep.rat_type.push(<models::RatType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ueLocation" => intermediate_rep.ue_location.push(<models::UserLocation as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ueTimeZone" => intermediate_rep.ue_time_zone.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "addUeLocation" => intermediate_rep.add_ue_location.push(<models::UserLocation as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "gpsi" => intermediate_rep.gpsi.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "n1SmInfoFromUe" => intermediate_rep.n1_sm_info_from_ue.push(<models::RefToBinaryData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "unknownN1SmInfo" => intermediate_rep.unknown_n1_sm_info.push(<models::RefToBinaryData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "supportedFeatures" => intermediate_rep.supported_features.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hPcfId" => intermediate_rep.h_pcf_id.push(<uuid::Uuid as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pcfId" => intermediate_rep.pcf_id.push(<uuid::Uuid as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pcfGroupId" => intermediate_rep.pcf_group_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pcfSetId" => intermediate_rep.pcf_set_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hoPreparationIndication" => intermediate_rep.ho_preparation_indication.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "selMode" => intermediate_rep.sel_mode.push(<models::DnnSelectionMode as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "alwaysOnRequested" => intermediate_rep.always_on_requested.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "udmGroupId" => intermediate_rep.udm_group_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "routingIndicator" => intermediate_rep.routing_indicator.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hNwPubKeyId" => intermediate_rep.h_nw_pub_key_id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "epsInterworkingInd" => intermediate_rep.eps_interworking_ind.push(<models::EpsInterworkingIndication as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "vSmfServiceInstanceId" => intermediate_rep.v_smf_service_instance_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "iSmfServiceInstanceId" => intermediate_rep.i_smf_service_instance_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "recoveryTime" => intermediate_rep.recovery_time.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "roamingChargingProfile" => intermediate_rep.roaming_charging_profile.push(<models::RoamingChargingProfile as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "chargingId" => intermediate_rep.charging_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "oldPduSessionId" => intermediate_rep.old_pdu_session_id.push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "epsBearerCtxStatus" => intermediate_rep.eps_bearer_ctx_status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "amfNfId" => intermediate_rep.amf_nf_id.push(<uuid::Uuid as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "guami" => intermediate_rep.guami.push(<models::Guami as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maxIntegrityProtectedDataRateUl" => intermediate_rep.max_integrity_protected_data_rate_ul.push(<models::MaxIntegrityProtectedDataRate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maxIntegrityProtectedDataRateDl" => intermediate_rep.max_integrity_protected_data_rate_dl.push(<models::MaxIntegrityProtectedDataRate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cpCiotEnabled" => intermediate_rep.cp_ciot_enabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cpOnlyInd" => intermediate_rep.cp_only_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "invokeNef" => intermediate_rep.invoke_nef.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maRequestInd" => intermediate_rep.ma_request_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maNwUpgradeInd" => intermediate_rep.ma_nw_upgrade_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "dnaiList" => return std::result::Result::Err("Parsing a container in this style is not supported in PduSessionCreateData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "presenceInLadn" => intermediate_rep.presence_in_ladn.push(<models::PresenceState as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "secondaryRatUsageInfo" => return std::result::Result::Err("Parsing a container in this style is not supported in PduSessionCreateData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "smallDataRateStatus" => intermediate_rep.small_data_rate_status.push(<models::SmallDataRateStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "apnRateStatus" => intermediate_rep.apn_rate_status.push(<models::ApnRateStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dlServingPlmnRateCtl" => intermediate_rep.dl_serving_plmn_rate_ctl.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "upSecurityInfo" => intermediate_rep.up_security_info.push(<models::UpSecurityInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "vplmnQos" => intermediate_rep.vplmn_qos.push(<models::VplmnQos as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "oldSmContextRef" => intermediate_rep.old_sm_context_ref.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "redundantPduSessionInfo" => intermediate_rep.redundant_pdu_session_info.push(<models::RedundantPduSessionInformation as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "oldPduSessionRef" => intermediate_rep.old_pdu_session_ref.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "smPolicyNotifyInd" => intermediate_rep.sm_policy_notify_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "pcfUeCallbackInfo" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PduSessionCreateData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "satelliteBackhaulCat" => intermediate_rep.satellite_backhaul_cat.push(<models::SatelliteBackhaulCategory as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "upipSupported" => intermediate_rep.upip_supported.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "upCnxState" => intermediate_rep.up_cnx_state.push(<models::UpCnxState as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "disasterRoamingInd" => intermediate_rep.disaster_roaming_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PduSessionCreateData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PduSessionCreateData {
            supi: intermediate_rep.supi.into_iter().next(),
            unauthenticated_supi: intermediate_rep.unauthenticated_supi.into_iter().next(),
            pei: intermediate_rep.pei.into_iter().next(),
            pdu_session_id: intermediate_rep.pdu_session_id.into_iter().next(),
            dnn: intermediate_rep
                .dnn
                .into_iter()
                .next()
                .ok_or_else(|| "dnn missing in PduSessionCreateData".to_string())?,
            selected_dnn: intermediate_rep.selected_dnn.into_iter().next(),
            s_nssai: intermediate_rep.s_nssai.into_iter().next(),
            hplmn_snssai: intermediate_rep.hplmn_snssai.into_iter().next(),
            vsmf_id: intermediate_rep.vsmf_id.into_iter().next(),
            ismf_id: intermediate_rep.ismf_id.into_iter().next(),
            serving_network: intermediate_rep
                .serving_network
                .into_iter()
                .next()
                .ok_or_else(|| "servingNetwork missing in PduSessionCreateData".to_string())?,
            request_type: intermediate_rep.request_type.into_iter().next(),
            eps_bearer_id: intermediate_rep.eps_bearer_id.into_iter().next(),
            pgw_s8c_fteid: intermediate_rep.pgw_s8c_fteid.into_iter().next(),
            vsmf_pdu_session_uri: intermediate_rep.vsmf_pdu_session_uri.into_iter().next(),
            ismf_pdu_session_uri: intermediate_rep.ismf_pdu_session_uri.into_iter().next(),
            vcn_tunnel_info: intermediate_rep.vcn_tunnel_info.into_iter().next(),
            icn_tunnel_info: intermediate_rep.icn_tunnel_info.into_iter().next(),
            n9_forwarding_tunnel_info: intermediate_rep
                .n9_forwarding_tunnel_info
                .into_iter()
                .next(),
            additional_cn_tunnel_info: intermediate_rep
                .additional_cn_tunnel_info
                .into_iter()
                .next(),
            an_type: intermediate_rep
                .an_type
                .into_iter()
                .next()
                .ok_or_else(|| "anType missing in PduSessionCreateData".to_string())?,
            additional_an_type: intermediate_rep.additional_an_type.into_iter().next(),
            rat_type: intermediate_rep.rat_type.into_iter().next(),
            ue_location: intermediate_rep.ue_location.into_iter().next(),
            ue_time_zone: intermediate_rep.ue_time_zone.into_iter().next(),
            add_ue_location: intermediate_rep.add_ue_location.into_iter().next(),
            gpsi: intermediate_rep.gpsi.into_iter().next(),
            n1_sm_info_from_ue: intermediate_rep.n1_sm_info_from_ue.into_iter().next(),
            unknown_n1_sm_info: intermediate_rep.unknown_n1_sm_info.into_iter().next(),
            supported_features: intermediate_rep.supported_features.into_iter().next(),
            h_pcf_id: intermediate_rep.h_pcf_id.into_iter().next(),
            pcf_id: intermediate_rep.pcf_id.into_iter().next(),
            pcf_group_id: intermediate_rep.pcf_group_id.into_iter().next(),
            pcf_set_id: intermediate_rep.pcf_set_id.into_iter().next(),
            ho_preparation_indication: intermediate_rep
                .ho_preparation_indication
                .into_iter()
                .next(),
            sel_mode: intermediate_rep.sel_mode.into_iter().next(),
            always_on_requested: intermediate_rep.always_on_requested.into_iter().next(),
            udm_group_id: intermediate_rep.udm_group_id.into_iter().next(),
            routing_indicator: intermediate_rep.routing_indicator.into_iter().next(),
            h_nw_pub_key_id: intermediate_rep.h_nw_pub_key_id.into_iter().next(),
            eps_interworking_ind: intermediate_rep.eps_interworking_ind.into_iter().next(),
            v_smf_service_instance_id: intermediate_rep
                .v_smf_service_instance_id
                .into_iter()
                .next(),
            i_smf_service_instance_id: intermediate_rep
                .i_smf_service_instance_id
                .into_iter()
                .next(),
            recovery_time: intermediate_rep.recovery_time.into_iter().next(),
            roaming_charging_profile: intermediate_rep.roaming_charging_profile.into_iter().next(),
            charging_id: intermediate_rep.charging_id.into_iter().next(),
            old_pdu_session_id: intermediate_rep.old_pdu_session_id.into_iter().next(),
            eps_bearer_ctx_status: intermediate_rep.eps_bearer_ctx_status.into_iter().next(),
            amf_nf_id: intermediate_rep.amf_nf_id.into_iter().next(),
            guami: intermediate_rep.guami.into_iter().next(),
            max_integrity_protected_data_rate_ul: intermediate_rep
                .max_integrity_protected_data_rate_ul
                .into_iter()
                .next(),
            max_integrity_protected_data_rate_dl: intermediate_rep
                .max_integrity_protected_data_rate_dl
                .into_iter()
                .next(),
            cp_ciot_enabled: intermediate_rep.cp_ciot_enabled.into_iter().next(),
            cp_only_ind: intermediate_rep.cp_only_ind.into_iter().next(),
            invoke_nef: intermediate_rep.invoke_nef.into_iter().next(),
            ma_request_ind: intermediate_rep.ma_request_ind.into_iter().next(),
            ma_nw_upgrade_ind: intermediate_rep.ma_nw_upgrade_ind.into_iter().next(),
            dnai_list: intermediate_rep.dnai_list.into_iter().next(),
            presence_in_ladn: intermediate_rep.presence_in_ladn.into_iter().next(),
            secondary_rat_usage_info: intermediate_rep.secondary_rat_usage_info.into_iter().next(),
            small_data_rate_status: intermediate_rep.small_data_rate_status.into_iter().next(),
            apn_rate_status: intermediate_rep.apn_rate_status.into_iter().next(),
            dl_serving_plmn_rate_ctl: intermediate_rep.dl_serving_plmn_rate_ctl.into_iter().next(),
            up_security_info: intermediate_rep.up_security_info.into_iter().next(),
            vplmn_qos: intermediate_rep.vplmn_qos.into_iter().next(),
            old_sm_context_ref: intermediate_rep.old_sm_context_ref.into_iter().next(),
            redundant_pdu_session_info: intermediate_rep
                .redundant_pdu_session_info
                .into_iter()
                .next(),
            old_pdu_session_ref: intermediate_rep.old_pdu_session_ref.into_iter().next(),
            sm_policy_notify_ind: intermediate_rep.sm_policy_notify_ind.into_iter().next(),
            pcf_ue_callback_info: std::result::Result::Err(
                "Nullable types not supported in PduSessionCreateData".to_string(),
            )?,
            satellite_backhaul_cat: intermediate_rep.satellite_backhaul_cat.into_iter().next(),
            upip_supported: intermediate_rep.upip_supported.into_iter().next(),
            up_cnx_state: intermediate_rep.up_cnx_state.into_iter().next(),
            disaster_roaming_ind: intermediate_rep.disaster_roaming_ind.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PduSessionCreateData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PduSessionCreateData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PduSessionCreateData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PduSessionCreateData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<PduSessionCreateData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PduSessionCreateData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PduSessionCreateData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Error within Create Response
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PduSessionCreateError {
    #[serde(rename = "error")]
    pub error: models::ProblemDetails,

    #[serde(rename = "n1smCause")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n1sm_cause: Option<String>,

    #[serde(rename = "n1SmInfoToUe")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n1_sm_info_to_ue: Option<models::RefToBinaryData>,

    /// indicating a time in seconds.
    #[serde(rename = "backOffTimer")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub back_off_timer: Option<i32>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "recoveryTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recovery_time: Option<chrono::DateTime<chrono::Utc>>,
}

impl PduSessionCreateError {
    #[allow(clippy::new_without_default)]
    pub fn new(error: models::ProblemDetails) -> PduSessionCreateError {
        PduSessionCreateError {
            error,
            n1sm_cause: None,
            n1_sm_info_to_ue: None,
            back_off_timer: None,
            recovery_time: None,
        }
    }
}

/// Converts the PduSessionCreateError value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PduSessionCreateError {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping error in query parameter serialization
            self.n1sm_cause
                .as_ref()
                .map(|n1sm_cause| vec!["n1smCause".to_string(), n1sm_cause.to_string()].join(",")),
            // Skipping n1SmInfoToUe in query parameter serialization
            self.back_off_timer.as_ref().map(|back_off_timer| {
                vec!["backOffTimer".to_string(), back_off_timer.to_string()].join(",")
            }),
            // Skipping recoveryTime in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PduSessionCreateError value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PduSessionCreateError {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub error: Vec<models::ProblemDetails>,
            pub n1sm_cause: Vec<String>,
            pub n1_sm_info_to_ue: Vec<models::RefToBinaryData>,
            pub back_off_timer: Vec<i32>,
            pub recovery_time: Vec<chrono::DateTime<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PduSessionCreateError".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "error" => intermediate_rep.error.push(
                        <models::ProblemDetails as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n1smCause" => intermediate_rep.n1sm_cause.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n1SmInfoToUe" => intermediate_rep.n1_sm_info_to_ue.push(
                        <models::RefToBinaryData as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "backOffTimer" => intermediate_rep.back_off_timer.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "recoveryTime" => intermediate_rep.recovery_time.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PduSessionCreateError".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PduSessionCreateError {
            error: intermediate_rep
                .error
                .into_iter()
                .next()
                .ok_or_else(|| "error missing in PduSessionCreateError".to_string())?,
            n1sm_cause: intermediate_rep.n1sm_cause.into_iter().next(),
            n1_sm_info_to_ue: intermediate_rep.n1_sm_info_to_ue.into_iter().next(),
            back_off_timer: intermediate_rep.back_off_timer.into_iter().next(),
            recovery_time: intermediate_rep.recovery_time.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PduSessionCreateError> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PduSessionCreateError>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PduSessionCreateError>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PduSessionCreateError - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<PduSessionCreateError>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PduSessionCreateError as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PduSessionCreateError - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Data within Create Response
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PduSessionCreatedData {
    #[serde(rename = "pduSessionType")]
    pub pdu_session_type: models::PduSessionType,

    #[serde(rename = "sscMode")]
    pub ssc_mode: String,

    #[serde(rename = "hcnTunnelInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hcn_tunnel_info: Option<models::TunnelInfo>,

    #[serde(rename = "cnTunnelInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cn_tunnel_info: Option<models::TunnelInfo>,

    #[serde(rename = "additionalCnTunnelInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_cn_tunnel_info: Option<models::TunnelInfo>,

    #[serde(rename = "sessionAmbr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub session_ambr: Option<models::Ambr>,

    #[serde(rename = "qosFlowsSetupList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub qos_flows_setup_list: Option<Vec<models::QosFlowSetupItem>>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "hSmfInstanceId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub h_smf_instance_id: Option<uuid::Uuid>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "smfInstanceId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub smf_instance_id: Option<uuid::Uuid>,

    /// Unsigned integer identifying a PDU session, within the range 0 to 255, as specified in  clause 11.2.3.1b, bits 1 to 8, of 3GPP TS 24.007. If the PDU Session ID is allocated by the  Core Network for UEs not supporting N1 mode, reserved range 64 to 95 is used. PDU Session ID  within the reserved range is only visible in the Core Network.
    #[serde(rename = "pduSessionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pdu_session_id: Option<u8>,

    #[serde(rename = "sNssai")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub s_nssai: Option<models::Snssai>,

    #[serde(rename = "enablePauseCharging")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enable_pause_charging: Option<bool>,

    /// String identifying a IPv4 address formatted in the 'dotted decimal' notation as defined in RFC 1166.
    #[serde(rename = "ueIpv4Address")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_ipv4_address: Option<String>,

    #[serde(rename = "ueIpv6Prefix")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_ipv6_prefix: Option<models::Ipv6Prefix>,

    #[serde(rename = "n1SmInfoToUe")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n1_sm_info_to_ue: Option<models::RefToBinaryData>,

    #[serde(rename = "epsPdnCnxInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub eps_pdn_cnx_info: Option<models::EpsPdnCnxInfo>,

    #[serde(rename = "epsBearerInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub eps_bearer_info: Option<Vec<models::EpsBearerInfo>>,

    /// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  table 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.
    #[serde(rename = "supportedFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_features: Option<String>,

    #[serde(rename = "maxIntegrityProtectedDataRate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_integrity_protected_data_rate: Option<models::MaxIntegrityProtectedDataRate>,

    #[serde(rename = "maxIntegrityProtectedDataRateDl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_integrity_protected_data_rate_dl: Option<models::MaxIntegrityProtectedDataRate>,

    #[serde(rename = "alwaysOnGranted")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub always_on_granted: Option<bool>,

    /// String identifying a Gpsi shall contain either an External Id or an MSISDN.  It shall be formatted as follows -External Identifier= \"extid-'extid', where 'extid'  shall be formatted according to clause 19.7.2 of 3GPP TS 23.003 that describes an  External Identifier.
    #[serde(rename = "gpsi")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gpsi: Option<String>,

    #[serde(rename = "upSecurity")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub up_security: Option<models::UpSecurity>,

    #[serde(rename = "roamingChargingProfile")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub roaming_charging_profile: Option<models::RoamingChargingProfile>,

    #[serde(rename = "hSmfServiceInstanceId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub h_smf_service_instance_id: Option<String>,

    #[serde(rename = "smfServiceInstanceId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub smf_service_instance_id: Option<String>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "recoveryTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recovery_time: Option<chrono::DateTime<chrono::Utc>>,

    #[serde(rename = "dnaiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dnai_list: Option<Vec<models::Dnai>>,

    #[serde(rename = "ipv6MultiHomingInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_multi_homing_ind: Option<bool>,

    #[serde(rename = "maAcceptedInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ma_accepted_ind: Option<bool>,

    #[serde(rename = "homeProvidedChargingId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub home_provided_charging_id: Option<String>,

    #[serde(rename = "nefExtBufSupportInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nef_ext_buf_support_ind: Option<bool>,

    #[serde(rename = "smallDataRateControlEnabled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub small_data_rate_control_enabled: Option<bool>,

    #[serde(rename = "ueIpv6InterfaceId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_ipv6_interface_id: Option<String>,

    /// Represents information that identifies which IP pool or external server is used to allocate the IP address.
    #[serde(rename = "ipv6Index")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_index: Option<i32>,

    #[serde(rename = "dnAaaAddress")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dn_aaa_address: Option<models::IpAddress>,

    #[serde(rename = "redundantPduSessionInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub redundant_pdu_session_info: Option<models::RedundantPduSessionInformation>,

    #[serde(rename = "nspuSupportInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nspu_support_ind: Option<bool>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "interPlmnApiRoot")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub inter_plmn_api_root: Option<String>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "intraPlmnApiRoot")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub intra_plmn_api_root: Option<String>,
}

impl PduSessionCreatedData {
    #[allow(clippy::new_without_default)]
    pub fn new(
        pdu_session_type: models::PduSessionType,
        ssc_mode: String,
    ) -> PduSessionCreatedData {
        PduSessionCreatedData {
            pdu_session_type,
            ssc_mode,
            hcn_tunnel_info: None,
            cn_tunnel_info: None,
            additional_cn_tunnel_info: None,
            session_ambr: None,
            qos_flows_setup_list: None,
            h_smf_instance_id: None,
            smf_instance_id: None,
            pdu_session_id: None,
            s_nssai: None,
            enable_pause_charging: Some(false),
            ue_ipv4_address: None,
            ue_ipv6_prefix: None,
            n1_sm_info_to_ue: None,
            eps_pdn_cnx_info: None,
            eps_bearer_info: None,
            supported_features: None,
            max_integrity_protected_data_rate: None,
            max_integrity_protected_data_rate_dl: None,
            always_on_granted: Some(false),
            gpsi: None,
            up_security: None,
            roaming_charging_profile: None,
            h_smf_service_instance_id: None,
            smf_service_instance_id: None,
            recovery_time: None,
            dnai_list: None,
            ipv6_multi_homing_ind: Some(false),
            ma_accepted_ind: Some(false),
            home_provided_charging_id: None,
            nef_ext_buf_support_ind: Some(false),
            small_data_rate_control_enabled: Some(false),
            ue_ipv6_interface_id: None,
            ipv6_index: None,
            dn_aaa_address: None,
            redundant_pdu_session_info: None,
            nspu_support_ind: None,
            inter_plmn_api_root: None,
            intra_plmn_api_root: None,
        }
    }
}

/// Converts the PduSessionCreatedData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PduSessionCreatedData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping pduSessionType in query parameter serialization
            Some("sscMode".to_string()),
            Some(self.ssc_mode.to_string()),
            // Skipping hcnTunnelInfo in query parameter serialization

            // Skipping cnTunnelInfo in query parameter serialization

            // Skipping additionalCnTunnelInfo in query parameter serialization

            // Skipping sessionAmbr in query parameter serialization

            // Skipping qosFlowsSetupList in query parameter serialization

            // Skipping hSmfInstanceId in query parameter serialization

            // Skipping smfInstanceId in query parameter serialization
            self.pdu_session_id.as_ref().map(|pdu_session_id| {
                vec!["pduSessionId".to_string(), pdu_session_id.to_string()].join(",")
            }),
            // Skipping sNssai in query parameter serialization
            self.enable_pause_charging
                .as_ref()
                .map(|enable_pause_charging| {
                    vec![
                        "enablePauseCharging".to_string(),
                        enable_pause_charging.to_string(),
                    ]
                    .join(",")
                }),
            self.ue_ipv4_address.as_ref().map(|ue_ipv4_address| {
                vec!["ueIpv4Address".to_string(), ue_ipv4_address.to_string()].join(",")
            }),
            // Skipping ueIpv6Prefix in query parameter serialization

            // Skipping n1SmInfoToUe in query parameter serialization

            // Skipping epsPdnCnxInfo in query parameter serialization

            // Skipping epsBearerInfo in query parameter serialization
            self.supported_features.as_ref().map(|supported_features| {
                vec![
                    "supportedFeatures".to_string(),
                    supported_features.to_string(),
                ]
                .join(",")
            }),
            // Skipping maxIntegrityProtectedDataRate in query parameter serialization

            // Skipping maxIntegrityProtectedDataRateDl in query parameter serialization
            self.always_on_granted.as_ref().map(|always_on_granted| {
                vec!["alwaysOnGranted".to_string(), always_on_granted.to_string()].join(",")
            }),
            self.gpsi
                .as_ref()
                .map(|gpsi| vec!["gpsi".to_string(), gpsi.to_string()].join(",")),
            // Skipping upSecurity in query parameter serialization

            // Skipping roamingChargingProfile in query parameter serialization
            self.h_smf_service_instance_id
                .as_ref()
                .map(|h_smf_service_instance_id| {
                    vec![
                        "hSmfServiceInstanceId".to_string(),
                        h_smf_service_instance_id.to_string(),
                    ]
                    .join(",")
                }),
            self.smf_service_instance_id
                .as_ref()
                .map(|smf_service_instance_id| {
                    vec![
                        "smfServiceInstanceId".to_string(),
                        smf_service_instance_id.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping recoveryTime in query parameter serialization
            self.dnai_list.as_ref().map(|dnai_list| {
                vec![
                    "dnaiList".to_string(),
                    dnai_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.ipv6_multi_homing_ind
                .as_ref()
                .map(|ipv6_multi_homing_ind| {
                    vec![
                        "ipv6MultiHomingInd".to_string(),
                        ipv6_multi_homing_ind.to_string(),
                    ]
                    .join(",")
                }),
            self.ma_accepted_ind.as_ref().map(|ma_accepted_ind| {
                vec!["maAcceptedInd".to_string(), ma_accepted_ind.to_string()].join(",")
            }),
            self.home_provided_charging_id
                .as_ref()
                .map(|home_provided_charging_id| {
                    vec![
                        "homeProvidedChargingId".to_string(),
                        home_provided_charging_id.to_string(),
                    ]
                    .join(",")
                }),
            self.nef_ext_buf_support_ind
                .as_ref()
                .map(|nef_ext_buf_support_ind| {
                    vec![
                        "nefExtBufSupportInd".to_string(),
                        nef_ext_buf_support_ind.to_string(),
                    ]
                    .join(",")
                }),
            self.small_data_rate_control_enabled
                .as_ref()
                .map(|small_data_rate_control_enabled| {
                    vec![
                        "smallDataRateControlEnabled".to_string(),
                        small_data_rate_control_enabled.to_string(),
                    ]
                    .join(",")
                }),
            self.ue_ipv6_interface_id
                .as_ref()
                .map(|ue_ipv6_interface_id| {
                    vec![
                        "ueIpv6InterfaceId".to_string(),
                        ue_ipv6_interface_id.to_string(),
                    ]
                    .join(",")
                }),
            self.ipv6_index
                .as_ref()
                .map(|ipv6_index| vec!["ipv6Index".to_string(), ipv6_index.to_string()].join(",")),
            // Skipping dnAaaAddress in query parameter serialization

            // Skipping redundantPduSessionInfo in query parameter serialization
            self.nspu_support_ind.as_ref().map(|nspu_support_ind| {
                vec!["nspuSupportInd".to_string(), nspu_support_ind.to_string()].join(",")
            }),
            self.inter_plmn_api_root
                .as_ref()
                .map(|inter_plmn_api_root| {
                    vec![
                        "interPlmnApiRoot".to_string(),
                        inter_plmn_api_root.to_string(),
                    ]
                    .join(",")
                }),
            self.intra_plmn_api_root
                .as_ref()
                .map(|intra_plmn_api_root| {
                    vec![
                        "intraPlmnApiRoot".to_string(),
                        intra_plmn_api_root.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PduSessionCreatedData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PduSessionCreatedData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub pdu_session_type: Vec<models::PduSessionType>,
            pub ssc_mode: Vec<String>,
            pub hcn_tunnel_info: Vec<models::TunnelInfo>,
            pub cn_tunnel_info: Vec<models::TunnelInfo>,
            pub additional_cn_tunnel_info: Vec<models::TunnelInfo>,
            pub session_ambr: Vec<models::Ambr>,
            pub qos_flows_setup_list: Vec<Vec<models::QosFlowSetupItem>>,
            pub h_smf_instance_id: Vec<uuid::Uuid>,
            pub smf_instance_id: Vec<uuid::Uuid>,
            pub pdu_session_id: Vec<u8>,
            pub s_nssai: Vec<models::Snssai>,
            pub enable_pause_charging: Vec<bool>,
            pub ue_ipv4_address: Vec<String>,
            pub ue_ipv6_prefix: Vec<models::Ipv6Prefix>,
            pub n1_sm_info_to_ue: Vec<models::RefToBinaryData>,
            pub eps_pdn_cnx_info: Vec<models::EpsPdnCnxInfo>,
            pub eps_bearer_info: Vec<Vec<models::EpsBearerInfo>>,
            pub supported_features: Vec<String>,
            pub max_integrity_protected_data_rate: Vec<models::MaxIntegrityProtectedDataRate>,
            pub max_integrity_protected_data_rate_dl: Vec<models::MaxIntegrityProtectedDataRate>,
            pub always_on_granted: Vec<bool>,
            pub gpsi: Vec<String>,
            pub up_security: Vec<models::UpSecurity>,
            pub roaming_charging_profile: Vec<models::RoamingChargingProfile>,
            pub h_smf_service_instance_id: Vec<String>,
            pub smf_service_instance_id: Vec<String>,
            pub recovery_time: Vec<chrono::DateTime<chrono::Utc>>,
            pub dnai_list: Vec<Vec<models::Dnai>>,
            pub ipv6_multi_homing_ind: Vec<bool>,
            pub ma_accepted_ind: Vec<bool>,
            pub home_provided_charging_id: Vec<String>,
            pub nef_ext_buf_support_ind: Vec<bool>,
            pub small_data_rate_control_enabled: Vec<bool>,
            pub ue_ipv6_interface_id: Vec<String>,
            pub ipv6_index: Vec<i32>,
            pub dn_aaa_address: Vec<models::IpAddress>,
            pub redundant_pdu_session_info: Vec<models::RedundantPduSessionInformation>,
            pub nspu_support_ind: Vec<bool>,
            pub inter_plmn_api_root: Vec<String>,
            pub intra_plmn_api_root: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PduSessionCreatedData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "pduSessionType" => intermediate_rep.pdu_session_type.push(<models::PduSessionType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sscMode" => intermediate_rep.ssc_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hcnTunnelInfo" => intermediate_rep.hcn_tunnel_info.push(<models::TunnelInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cnTunnelInfo" => intermediate_rep.cn_tunnel_info.push(<models::TunnelInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "additionalCnTunnelInfo" => intermediate_rep.additional_cn_tunnel_info.push(<models::TunnelInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sessionAmbr" => intermediate_rep.session_ambr.push(<models::Ambr as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "qosFlowsSetupList" => return std::result::Result::Err("Parsing a container in this style is not supported in PduSessionCreatedData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "hSmfInstanceId" => intermediate_rep.h_smf_instance_id.push(<uuid::Uuid as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "smfInstanceId" => intermediate_rep.smf_instance_id.push(<uuid::Uuid as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pduSessionId" => intermediate_rep.pdu_session_id.push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sNssai" => intermediate_rep.s_nssai.push(<models::Snssai as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "enablePauseCharging" => intermediate_rep.enable_pause_charging.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ueIpv4Address" => intermediate_rep.ue_ipv4_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ueIpv6Prefix" => intermediate_rep.ue_ipv6_prefix.push(<models::Ipv6Prefix as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "n1SmInfoToUe" => intermediate_rep.n1_sm_info_to_ue.push(<models::RefToBinaryData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "epsPdnCnxInfo" => intermediate_rep.eps_pdn_cnx_info.push(<models::EpsPdnCnxInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "epsBearerInfo" => return std::result::Result::Err("Parsing a container in this style is not supported in PduSessionCreatedData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "supportedFeatures" => intermediate_rep.supported_features.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maxIntegrityProtectedDataRate" => intermediate_rep.max_integrity_protected_data_rate.push(<models::MaxIntegrityProtectedDataRate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maxIntegrityProtectedDataRateDl" => intermediate_rep.max_integrity_protected_data_rate_dl.push(<models::MaxIntegrityProtectedDataRate as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "alwaysOnGranted" => intermediate_rep.always_on_granted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "gpsi" => intermediate_rep.gpsi.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "upSecurity" => intermediate_rep.up_security.push(<models::UpSecurity as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "roamingChargingProfile" => intermediate_rep.roaming_charging_profile.push(<models::RoamingChargingProfile as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hSmfServiceInstanceId" => intermediate_rep.h_smf_service_instance_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "smfServiceInstanceId" => intermediate_rep.smf_service_instance_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "recoveryTime" => intermediate_rep.recovery_time.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "dnaiList" => return std::result::Result::Err("Parsing a container in this style is not supported in PduSessionCreatedData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "ipv6MultiHomingInd" => intermediate_rep.ipv6_multi_homing_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maAcceptedInd" => intermediate_rep.ma_accepted_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "homeProvidedChargingId" => intermediate_rep.home_provided_charging_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "nefExtBufSupportInd" => intermediate_rep.nef_ext_buf_support_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "smallDataRateControlEnabled" => intermediate_rep.small_data_rate_control_enabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ueIpv6InterfaceId" => intermediate_rep.ue_ipv6_interface_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ipv6Index" => intermediate_rep.ipv6_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dnAaaAddress" => intermediate_rep.dn_aaa_address.push(<models::IpAddress as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "redundantPduSessionInfo" => intermediate_rep.redundant_pdu_session_info.push(<models::RedundantPduSessionInformation as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "nspuSupportInd" => intermediate_rep.nspu_support_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "interPlmnApiRoot" => intermediate_rep.inter_plmn_api_root.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "intraPlmnApiRoot" => intermediate_rep.intra_plmn_api_root.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PduSessionCreatedData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PduSessionCreatedData {
            pdu_session_type: intermediate_rep
                .pdu_session_type
                .into_iter()
                .next()
                .ok_or_else(|| "pduSessionType missing in PduSessionCreatedData".to_string())?,
            ssc_mode: intermediate_rep
                .ssc_mode
                .into_iter()
                .next()
                .ok_or_else(|| "sscMode missing in PduSessionCreatedData".to_string())?,
            hcn_tunnel_info: intermediate_rep.hcn_tunnel_info.into_iter().next(),
            cn_tunnel_info: intermediate_rep.cn_tunnel_info.into_iter().next(),
            additional_cn_tunnel_info: intermediate_rep
                .additional_cn_tunnel_info
                .into_iter()
                .next(),
            session_ambr: intermediate_rep.session_ambr.into_iter().next(),
            qos_flows_setup_list: intermediate_rep.qos_flows_setup_list.into_iter().next(),
            h_smf_instance_id: intermediate_rep.h_smf_instance_id.into_iter().next(),
            smf_instance_id: intermediate_rep.smf_instance_id.into_iter().next(),
            pdu_session_id: intermediate_rep.pdu_session_id.into_iter().next(),
            s_nssai: intermediate_rep.s_nssai.into_iter().next(),
            enable_pause_charging: intermediate_rep.enable_pause_charging.into_iter().next(),
            ue_ipv4_address: intermediate_rep.ue_ipv4_address.into_iter().next(),
            ue_ipv6_prefix: intermediate_rep.ue_ipv6_prefix.into_iter().next(),
            n1_sm_info_to_ue: intermediate_rep.n1_sm_info_to_ue.into_iter().next(),
            eps_pdn_cnx_info: intermediate_rep.eps_pdn_cnx_info.into_iter().next(),
            eps_bearer_info: intermediate_rep.eps_bearer_info.into_iter().next(),
            supported_features: intermediate_rep.supported_features.into_iter().next(),
            max_integrity_protected_data_rate: intermediate_rep
                .max_integrity_protected_data_rate
                .into_iter()
                .next(),
            max_integrity_protected_data_rate_dl: intermediate_rep
                .max_integrity_protected_data_rate_dl
                .into_iter()
                .next(),
            always_on_granted: intermediate_rep.always_on_granted.into_iter().next(),
            gpsi: intermediate_rep.gpsi.into_iter().next(),
            up_security: intermediate_rep.up_security.into_iter().next(),
            roaming_charging_profile: intermediate_rep.roaming_charging_profile.into_iter().next(),
            h_smf_service_instance_id: intermediate_rep
                .h_smf_service_instance_id
                .into_iter()
                .next(),
            smf_service_instance_id: intermediate_rep.smf_service_instance_id.into_iter().next(),
            recovery_time: intermediate_rep.recovery_time.into_iter().next(),
            dnai_list: intermediate_rep.dnai_list.into_iter().next(),
            ipv6_multi_homing_ind: intermediate_rep.ipv6_multi_homing_ind.into_iter().next(),
            ma_accepted_ind: intermediate_rep.ma_accepted_ind.into_iter().next(),
            home_provided_charging_id: intermediate_rep
                .home_provided_charging_id
                .into_iter()
                .next(),
            nef_ext_buf_support_ind: intermediate_rep.nef_ext_buf_support_ind.into_iter().next(),
            small_data_rate_control_enabled: intermediate_rep
                .small_data_rate_control_enabled
                .into_iter()
                .next(),
            ue_ipv6_interface_id: intermediate_rep.ue_ipv6_interface_id.into_iter().next(),
            ipv6_index: intermediate_rep.ipv6_index.into_iter().next(),
            dn_aaa_address: intermediate_rep.dn_aaa_address.into_iter().next(),
            redundant_pdu_session_info: intermediate_rep
                .redundant_pdu_session_info
                .into_iter()
                .next(),
            nspu_support_ind: intermediate_rep.nspu_support_ind.into_iter().next(),
            inter_plmn_api_root: intermediate_rep.inter_plmn_api_root.into_iter().next(),
            intra_plmn_api_root: intermediate_rep.intra_plmn_api_root.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PduSessionCreatedData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PduSessionCreatedData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PduSessionCreatedData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PduSessionCreatedData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<PduSessionCreatedData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PduSessionCreatedData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PduSessionCreatedData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Unsigned integer identifying a PDU session, within the range 0 to 255, as specified in  clause 11.2.3.1b, bits 1 to 8, of 3GPP TS 24.007. If the PDU Session ID is allocated by the  Core Network for UEs not supporting N1 mode, reserved range 64 to 95 is used. PDU Session ID  within the reserved range is only visible in the Core Network.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PduSessionId(i32);

impl std::convert::From<i32> for PduSessionId {
    fn from(x: i32) -> Self {
        PduSessionId(x)
    }
}

impl std::convert::From<PduSessionId> for i32 {
    fn from(x: PduSessionId) -> Self {
        x.0
    }
}

impl std::ops::Deref for PduSessionId {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for PduSessionId {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// Notification related to a PDU session
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PduSessionNotifyItem {
    #[serde(rename = "notificationCause")]
    pub notification_cause: models::NotificationCause,
}

impl PduSessionNotifyItem {
    #[allow(clippy::new_without_default)]
    pub fn new(notification_cause: models::NotificationCause) -> PduSessionNotifyItem {
        PduSessionNotifyItem { notification_cause }
    }
}

/// Converts the PduSessionNotifyItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PduSessionNotifyItem {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping notificationCause in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PduSessionNotifyItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PduSessionNotifyItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub notification_cause: Vec<models::NotificationCause>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PduSessionNotifyItem".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "notificationCause" => intermediate_rep.notification_cause.push(
                        <models::NotificationCause as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PduSessionNotifyItem".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PduSessionNotifyItem {
            notification_cause: intermediate_rep
                .notification_cause
                .into_iter()
                .next()
                .ok_or_else(|| "notificationCause missing in PduSessionNotifyItem".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PduSessionNotifyItem> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PduSessionNotifyItem>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PduSessionNotifyItem>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PduSessionNotifyItem - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<PduSessionNotifyItem>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PduSessionNotifyItem as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PduSessionNotifyItem - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// PduSessionType indicates the type of a PDU session. It shall comply with the provisions defined in table 5.4.3.3-1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PduSessionType {}

impl PduSessionType {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PduSessionType {
        PduSessionType {}
    }
}

/// Converts the PduSessionType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PduSessionType {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PduSessionType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PduSessionType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PduSessionType".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PduSessionType".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PduSessionType {})
    }
}

// Methods for converting between header::IntoHeaderValue<PduSessionType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PduSessionType>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PduSessionType>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PduSessionType - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PduSessionType> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PduSessionType as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PduSessionType - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PduSessionTypeAnyOf {
    #[serde(rename = "IPV4")]
    Ipv4,
    #[serde(rename = "IPV6")]
    Ipv6,
    #[serde(rename = "IPV4V6")]
    Ipv4V6,
    #[serde(rename = "UNSTRUCTURED")]
    Unstructured,
    #[serde(rename = "ETHERNET")]
    Ethernet,
}

impl std::fmt::Display for PduSessionTypeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PduSessionTypeAnyOf::Ipv4 => write!(f, "IPV4"),
            PduSessionTypeAnyOf::Ipv6 => write!(f, "IPV6"),
            PduSessionTypeAnyOf::Ipv4V6 => write!(f, "IPV4V6"),
            PduSessionTypeAnyOf::Unstructured => write!(f, "UNSTRUCTURED"),
            PduSessionTypeAnyOf::Ethernet => write!(f, "ETHERNET"),
        }
    }
}

impl std::str::FromStr for PduSessionTypeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "IPV4" => std::result::Result::Ok(PduSessionTypeAnyOf::Ipv4),
            "IPV6" => std::result::Result::Ok(PduSessionTypeAnyOf::Ipv6),
            "IPV4V6" => std::result::Result::Ok(PduSessionTypeAnyOf::Ipv4V6),
            "UNSTRUCTURED" => std::result::Result::Ok(PduSessionTypeAnyOf::Unstructured),
            "ETHERNET" => std::result::Result::Ok(PduSessionTypeAnyOf::Ethernet),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// String representing a Permanent Equipment Identifier that may contain - an IMEI or IMEISV, as  specified in clause 6.2 of 3GPP TS 23.003; a MAC address for a 5G-RG or FN-RG via  wireline  access, with an indication that this address cannot be trusted for regulatory purpose if this  address cannot be used as an Equipment Identifier of the FN-RG, as specified in clause 4.7.7  of 3GPP TS23.316. Examples are imei-012345678901234 or imeisv-0123456789012345.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Pei(String);

impl std::convert::From<String> for Pei {
    fn from(x: String) -> Self {
        Pei(x)
    }
}

impl std::string::ToString for Pei {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Pei {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Pei(x.to_string()))
    }
}

impl std::convert::From<Pei> for String {
    fn from(x: Pei) -> Self {
        x.0
    }
}

impl std::ops::Deref for Pei {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Pei {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// When PlmnId needs to be converted to string (e.g. when used in maps as key), the string  shall be composed of three digits \"mcc\" followed by \"-\" and two or three digits \"mnc\".
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PlmnId {
    /// Mobile Country Code part of the PLMN, comprising 3 digits, as defined in clause 9.3.3.5 of 3GPP TS 38.413.
    #[serde(rename = "mcc")]
    pub mcc: String,

    /// Mobile Network Code part of the PLMN, comprising 2 or 3 digits, as defined in clause 9.3.3.5 of 3GPP TS 38.413.
    #[serde(rename = "mnc")]
    pub mnc: String,
}

impl PlmnId {
    #[allow(clippy::new_without_default)]
    pub fn new(mcc: String, mnc: String) -> PlmnId {
        PlmnId { mcc, mnc }
    }
}

/// Converts the PlmnId value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PlmnId {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("mcc".to_string()),
            Some(self.mcc.to_string()),
            Some("mnc".to_string()),
            Some(self.mnc.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PlmnId value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PlmnId {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub mcc: Vec<String>,
            pub mnc: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PlmnId".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "mcc" => intermediate_rep.mcc.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "mnc" => intermediate_rep.mnc.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PlmnId".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PlmnId {
            mcc: intermediate_rep
                .mcc
                .into_iter()
                .next()
                .ok_or_else(|| "mcc missing in PlmnId".to_string())?,
            mnc: intermediate_rep
                .mnc
                .into_iter()
                .next()
                .ok_or_else(|| "mnc missing in PlmnId".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PlmnId> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PlmnId>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PlmnId>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PlmnId - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PlmnId> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PlmnId as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PlmnId - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains the serving core network operator PLMN ID and, for an SNPN, the NID that together with the PLMN ID identifies the SNPN.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PlmnIdNid {
    /// Mobile Country Code part of the PLMN, comprising 3 digits, as defined in clause 9.3.3.5 of 3GPP TS 38.413.
    #[serde(rename = "mcc")]
    pub mcc: String,

    /// Mobile Network Code part of the PLMN, comprising 2 or 3 digits, as defined in clause 9.3.3.5 of 3GPP TS 38.413.
    #[serde(rename = "mnc")]
    pub mnc: String,

    /// This represents the Network Identifier, which together with a PLMN ID is used to identify an SNPN (see 3GPP TS 23.003 and 3GPP TS 23.501 clause 5.30.2.1).
    #[serde(rename = "nid")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nid: Option<String>,
}

impl PlmnIdNid {
    #[allow(clippy::new_without_default)]
    pub fn new(mcc: String, mnc: String) -> PlmnIdNid {
        PlmnIdNid {
            mcc,
            mnc,
            nid: None,
        }
    }
}

/// Converts the PlmnIdNid value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PlmnIdNid {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("mcc".to_string()),
            Some(self.mcc.to_string()),
            Some("mnc".to_string()),
            Some(self.mnc.to_string()),
            self.nid
                .as_ref()
                .map(|nid| vec!["nid".to_string(), nid.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PlmnIdNid value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PlmnIdNid {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub mcc: Vec<String>,
            pub mnc: Vec<String>,
            pub nid: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PlmnIdNid".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "mcc" => intermediate_rep.mcc.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "mnc" => intermediate_rep.mnc.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nid" => intermediate_rep.nid.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PlmnIdNid".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PlmnIdNid {
            mcc: intermediate_rep
                .mcc
                .into_iter()
                .next()
                .ok_or_else(|| "mcc missing in PlmnIdNid".to_string())?,
            mnc: intermediate_rep
                .mnc
                .into_iter()
                .next()
                .ok_or_else(|| "mnc missing in PlmnIdNid".to_string())?,
            nid: intermediate_rep.nid.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PlmnIdNid> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PlmnIdNid>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PlmnIdNid>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PlmnIdNid - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PlmnIdNid> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PlmnIdNid as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PlmnIdNid - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// The enumeration PreemptionCapability indicates the pre-emption capability of a request on other QoS flows. See clause 5.7.2.2 of 3GPP TS 23.501. It shall comply with the provisions defined in table 5.5.3.1-1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PreemptionCapability {}

impl PreemptionCapability {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PreemptionCapability {
        PreemptionCapability {}
    }
}

/// Converts the PreemptionCapability value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PreemptionCapability {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PreemptionCapability value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PreemptionCapability {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PreemptionCapability".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PreemptionCapability".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PreemptionCapability {})
    }
}

// Methods for converting between header::IntoHeaderValue<PreemptionCapability> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PreemptionCapability>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PreemptionCapability>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PreemptionCapability - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<PreemptionCapability>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PreemptionCapability as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PreemptionCapability - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PreemptionCapabilityAnyOf {
    #[serde(rename = "NOT_PREEMPT")]
    NotPreempt,
    #[serde(rename = "MAY_PREEMPT")]
    MayPreempt,
}

impl std::fmt::Display for PreemptionCapabilityAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PreemptionCapabilityAnyOf::NotPreempt => write!(f, "NOT_PREEMPT"),
            PreemptionCapabilityAnyOf::MayPreempt => write!(f, "MAY_PREEMPT"),
        }
    }
}

impl std::str::FromStr for PreemptionCapabilityAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "NOT_PREEMPT" => std::result::Result::Ok(PreemptionCapabilityAnyOf::NotPreempt),
            "MAY_PREEMPT" => std::result::Result::Ok(PreemptionCapabilityAnyOf::MayPreempt),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// The enumeration PreemptionVulnerability indicates the pre-emption vulnerability of the QoS flow to pre-emption from other QoS flows. See clause 5.7.2.2 of 3GPP TS 23.501. It shall comply with the provisions defined in table 5.5.3.2-1
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PreemptionVulnerability {}

impl PreemptionVulnerability {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PreemptionVulnerability {
        PreemptionVulnerability {}
    }
}

/// Converts the PreemptionVulnerability value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PreemptionVulnerability {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PreemptionVulnerability value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PreemptionVulnerability {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PreemptionVulnerability".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PreemptionVulnerability".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PreemptionVulnerability {})
    }
}

// Methods for converting between header::IntoHeaderValue<PreemptionVulnerability> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PreemptionVulnerability>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PreemptionVulnerability>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PreemptionVulnerability - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<PreemptionVulnerability>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PreemptionVulnerability as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PreemptionVulnerability - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PreemptionVulnerabilityAnyOf {
    #[serde(rename = "NOT_PREEMPTABLE")]
    NotPreemptable,
    #[serde(rename = "PREEMPTABLE")]
    Preemptable,
}

impl std::fmt::Display for PreemptionVulnerabilityAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PreemptionVulnerabilityAnyOf::NotPreemptable => write!(f, "NOT_PREEMPTABLE"),
            PreemptionVulnerabilityAnyOf::Preemptable => write!(f, "PREEMPTABLE"),
        }
    }
}

impl std::str::FromStr for PreemptionVulnerabilityAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "NOT_PREEMPTABLE" => {
                std::result::Result::Ok(PreemptionVulnerabilityAnyOf::NotPreemptable)
            }
            "PREEMPTABLE" => std::result::Result::Ok(PreemptionVulnerabilityAnyOf::Preemptable),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Possible values are: -IN_AREA: Indicates that the UE is inside or enters the presence reporting area. -OUT_OF_AREA: Indicates that the UE is outside or leaves the presence reporting area -UNKNOW: Indicates it is unknown whether the UE is in the presence reporting area or not -INACTIVE: Indicates that the presence reporting area is inactive in the serving node.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PresenceState {}

impl PresenceState {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PresenceState {
        PresenceState {}
    }
}

/// Converts the PresenceState value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PresenceState {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PresenceState value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PresenceState {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PresenceState".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PresenceState".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PresenceState {})
    }
}

// Methods for converting between header::IntoHeaderValue<PresenceState> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PresenceState>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PresenceState>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PresenceState - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PresenceState> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PresenceState as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PresenceState - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PresenceStateAnyOf {
    #[serde(rename = "IN_AREA")]
    InArea,
    #[serde(rename = "OUT_OF_AREA")]
    OutOfArea,
    #[serde(rename = "UNKNOWN")]
    Unknown,
    #[serde(rename = "INACTIVE")]
    Inactive,
}

impl std::fmt::Display for PresenceStateAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PresenceStateAnyOf::InArea => write!(f, "IN_AREA"),
            PresenceStateAnyOf::OutOfArea => write!(f, "OUT_OF_AREA"),
            PresenceStateAnyOf::Unknown => write!(f, "UNKNOWN"),
            PresenceStateAnyOf::Inactive => write!(f, "INACTIVE"),
        }
    }
}

impl std::str::FromStr for PresenceStateAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "IN_AREA" => std::result::Result::Ok(PresenceStateAnyOf::InArea),
            "OUT_OF_AREA" => std::result::Result::Ok(PresenceStateAnyOf::OutOfArea),
            "UNKNOWN" => std::result::Result::Ok(PresenceStateAnyOf::Unknown),
            "INACTIVE" => std::result::Result::Ok(PresenceStateAnyOf::Inactive),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Provides additional information in an error response.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProblemDetails {
    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub r#type: Option<String>,

    #[serde(rename = "title")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<i32>,

    /// A human-readable explanation specific to this occurrence of the problem.
    #[serde(rename = "detail")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub detail: Option<String>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "instance")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub instance: Option<String>,

    /// A machine-readable application error cause specific to this occurrence of the problem.  This IE should be present and provide application-related error information, if available.
    #[serde(rename = "cause")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cause: Option<String>,

    #[serde(rename = "invalidParams")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub invalid_params: Option<Vec<models::InvalidParam>>,

    /// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  table 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.
    #[serde(rename = "supportedFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_features: Option<String>,

    #[serde(rename = "accessTokenError")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub access_token_error: Option<models::AccessTokenErr>,

    #[serde(rename = "accessTokenRequest")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub access_token_request: Option<models::AccessTokenReq>,

    /// Fully Qualified Domain Name
    #[serde(rename = "nrfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nrf_id: Option<String>,
}

impl ProblemDetails {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ProblemDetails {
        ProblemDetails {
            r#type: None,
            title: None,
            status: None,
            detail: None,
            instance: None,
            cause: None,
            invalid_params: None,
            supported_features: None,
            access_token_error: None,
            access_token_request: None,
            nrf_id: None,
        }
    }
}

/// Converts the ProblemDetails value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ProblemDetails {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.r#type
                .as_ref()
                .map(|r#type| vec!["type".to_string(), r#type.to_string()].join(",")),
            self.title
                .as_ref()
                .map(|title| vec!["title".to_string(), title.to_string()].join(",")),
            self.status
                .as_ref()
                .map(|status| vec!["status".to_string(), status.to_string()].join(",")),
            self.detail
                .as_ref()
                .map(|detail| vec!["detail".to_string(), detail.to_string()].join(",")),
            self.instance
                .as_ref()
                .map(|instance| vec!["instance".to_string(), instance.to_string()].join(",")),
            self.cause
                .as_ref()
                .map(|cause| vec!["cause".to_string(), cause.to_string()].join(",")),
            // Skipping invalidParams in query parameter serialization
            self.supported_features.as_ref().map(|supported_features| {
                vec![
                    "supportedFeatures".to_string(),
                    supported_features.to_string(),
                ]
                .join(",")
            }),
            // Skipping accessTokenError in query parameter serialization

            // Skipping accessTokenRequest in query parameter serialization
            self.nrf_id
                .as_ref()
                .map(|nrf_id| vec!["nrfId".to_string(), nrf_id.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProblemDetails value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProblemDetails {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
            pub title: Vec<String>,
            pub status: Vec<i32>,
            pub detail: Vec<String>,
            pub instance: Vec<String>,
            pub cause: Vec<String>,
            pub invalid_params: Vec<Vec<models::InvalidParam>>,
            pub supported_features: Vec<String>,
            pub access_token_error: Vec<models::AccessTokenErr>,
            pub access_token_request: Vec<models::AccessTokenReq>,
            pub nrf_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ProblemDetails".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "title" => intermediate_rep.title.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "detail" => intermediate_rep.detail.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "instance" => intermediate_rep.instance.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "cause" => intermediate_rep.cause.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "invalidParams" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in ProblemDetails"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "supportedFeatures" => intermediate_rep.supported_features.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "accessTokenError" => intermediate_rep.access_token_error.push(
                        <models::AccessTokenErr as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "accessTokenRequest" => intermediate_rep.access_token_request.push(
                        <models::AccessTokenReq as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nrfId" => intermediate_rep.nrf_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ProblemDetails".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProblemDetails {
            r#type: intermediate_rep.r#type.into_iter().next(),
            title: intermediate_rep.title.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            detail: intermediate_rep.detail.into_iter().next(),
            instance: intermediate_rep.instance.into_iter().next(),
            cause: intermediate_rep.cause.into_iter().next(),
            invalid_params: intermediate_rep.invalid_params.into_iter().next(),
            supported_features: intermediate_rep.supported_features.into_iter().next(),
            access_token_error: intermediate_rep.access_token_error.into_iter().next(),
            access_token_request: intermediate_rep.access_token_request.into_iter().next(),
            nrf_id: intermediate_rep.nrf_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProblemDetails> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ProblemDetails>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ProblemDetails>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ProblemDetails - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ProblemDetails> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ProblemDetails as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ProblemDetails - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Problem Details Additional Information
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProblemDetailsAddInfo {
    #[serde(rename = "remoteError")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remote_error: Option<bool>,
}

impl ProblemDetailsAddInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ProblemDetailsAddInfo {
        ProblemDetailsAddInfo { remote_error: None }
    }
}

/// Converts the ProblemDetailsAddInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ProblemDetailsAddInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![self.remote_error.as_ref().map(|remote_error| {
            vec!["remoteError".to_string(), remote_error.to_string()].join(",")
        })];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProblemDetailsAddInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProblemDetailsAddInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub remote_error: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ProblemDetailsAddInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "remoteError" => intermediate_rep.remote_error.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ProblemDetailsAddInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProblemDetailsAddInfo {
            remote_error: intermediate_rep.remote_error.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProblemDetailsAddInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ProblemDetailsAddInfo>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ProblemDetailsAddInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ProblemDetailsAddInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ProblemDetailsAddInfo>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ProblemDetailsAddInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ProblemDetailsAddInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Procedure Transaction Identifier
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProcedureTransactionId(i32);

impl std::convert::From<i32> for ProcedureTransactionId {
    fn from(x: i32) -> Self {
        ProcedureTransactionId(x)
    }
}

impl std::convert::From<ProcedureTransactionId> for i32 {
    fn from(x: ProcedureTransactionId) -> Self {
        x.0
    }
}

impl std::ops::Deref for ProcedureTransactionId {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for ProcedureTransactionId {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// Protection Result of the security policy indicated as \"preferred\". Possible values are   - PERFORMED   - NOT_PERFORMED
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProtectionResult {}

impl ProtectionResult {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ProtectionResult {
        ProtectionResult {}
    }
}

/// Converts the ProtectionResult value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ProtectionResult {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProtectionResult value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProtectionResult {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ProtectionResult".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ProtectionResult".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProtectionResult {})
    }
}

// Methods for converting between header::IntoHeaderValue<ProtectionResult> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ProtectionResult>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ProtectionResult>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ProtectionResult - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ProtectionResult>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ProtectionResult as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ProtectionResult - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ProtectionResultAnyOf {
    #[serde(rename = "PERFORMED")]
    Performed,
    #[serde(rename = "NOT_PERFORMED")]
    NotPerformed,
}

impl std::fmt::Display for ProtectionResultAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ProtectionResultAnyOf::Performed => write!(f, "PERFORMED"),
            ProtectionResultAnyOf::NotPerformed => write!(f, "NOT_PERFORMED"),
        }
    }
}

impl std::str::FromStr for ProtectionResultAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "PERFORMED" => std::result::Result::Ok(ProtectionResultAnyOf::Performed),
            "NOT_PERFORMED" => std::result::Result::Ok(ProtectionResultAnyOf::NotPerformed),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Indication of whether a PSA is inserted or removed. Possible values are   - PSA_INSERTED   - PSA_REMOVED   - PSA_INSERTED_ONLY   - PSA_REMOVED_ONLY
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PsaIndication {}

impl PsaIndication {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PsaIndication {
        PsaIndication {}
    }
}

/// Converts the PsaIndication value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PsaIndication {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PsaIndication value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PsaIndication {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PsaIndication".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PsaIndication".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PsaIndication {})
    }
}

// Methods for converting between header::IntoHeaderValue<PsaIndication> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PsaIndication>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PsaIndication>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PsaIndication - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PsaIndication> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PsaIndication as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PsaIndication - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PsaIndicationAnyOf {
    #[serde(rename = "PSA_INSERTED")]
    Inserted,
    #[serde(rename = "PSA_REMOVED")]
    Removed,
    #[serde(rename = "PSA_INSERTED_ONLY")]
    InsertedOnly,
    #[serde(rename = "PSA_REMOVED_ONLY")]
    RemovedOnly,
}

impl std::fmt::Display for PsaIndicationAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PsaIndicationAnyOf::Inserted => write!(f, "PSA_INSERTED"),
            PsaIndicationAnyOf::Removed => write!(f, "PSA_REMOVED"),
            PsaIndicationAnyOf::InsertedOnly => write!(f, "PSA_INSERTED_ONLY"),
            PsaIndicationAnyOf::RemovedOnly => write!(f, "PSA_REMOVED_ONLY"),
        }
    }
}

impl std::str::FromStr for PsaIndicationAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "PSA_INSERTED" => std::result::Result::Ok(PsaIndicationAnyOf::Inserted),
            "PSA_REMOVED" => std::result::Result::Ok(PsaIndicationAnyOf::Removed),
            "PSA_INSERTED_ONLY" => std::result::Result::Ok(PsaIndicationAnyOf::InsertedOnly),
            "PSA_REMOVED_ONLY" => std::result::Result::Ok(PsaIndicationAnyOf::RemovedOnly),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// PSA Information
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PsaInformation {
    #[serde(rename = "psaInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub psa_ind: Option<models::PsaIndication>,

    #[serde(rename = "dnaiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dnai_list: Option<Vec<models::Dnai>>,

    #[serde(rename = "ueIpv6Prefix")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_ipv6_prefix: Option<models::Ipv6Prefix>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "psaUpfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub psa_upf_id: Option<uuid::Uuid>,
}

impl PsaInformation {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PsaInformation {
        PsaInformation {
            psa_ind: None,
            dnai_list: None,
            ue_ipv6_prefix: None,
            psa_upf_id: None,
        }
    }
}

/// Converts the PsaInformation value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PsaInformation {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping psaInd in query parameter serialization
            self.dnai_list.as_ref().map(|dnai_list| {
                vec![
                    "dnaiList".to_string(),
                    dnai_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping ueIpv6Prefix in query parameter serialization

            // Skipping psaUpfId in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PsaInformation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PsaInformation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub psa_ind: Vec<models::PsaIndication>,
            pub dnai_list: Vec<Vec<models::Dnai>>,
            pub ue_ipv6_prefix: Vec<models::Ipv6Prefix>,
            pub psa_upf_id: Vec<uuid::Uuid>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PsaInformation".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "psaInd" => intermediate_rep.psa_ind.push(
                        <models::PsaIndication as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "dnaiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PsaInformation"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "ueIpv6Prefix" => intermediate_rep.ue_ipv6_prefix.push(
                        <models::Ipv6Prefix as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "psaUpfId" => intermediate_rep.psa_upf_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PsaInformation".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PsaInformation {
            psa_ind: intermediate_rep.psa_ind.into_iter().next(),
            dnai_list: intermediate_rep.dnai_list.into_iter().next(),
            ue_ipv6_prefix: intermediate_rep.ue_ipv6_prefix.into_iter().next(),
            psa_upf_id: intermediate_rep.psa_upf_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PsaInformation> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PsaInformation>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PsaInformation>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PsaInformation - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PsaInformation> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PsaInformation as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PsaInformation - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Unsigned integer identifying a QoS flow, within the range 0 to 63.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Qfi(i32);

impl std::convert::From<i32> for Qfi {
    fn from(x: i32) -> Self {
        Qfi(x)
    }
}

impl std::convert::From<Qfi> for i32 {
    fn from(x: Qfi) -> Self {
        x.0
    }
}

impl std::ops::Deref for Qfi {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for Qfi {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// Access type associated with a QoS Flow. Possible values are   - 3GPP   - NON_3GPP   - 3GPP_AND_NON_3GPP
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct QosFlowAccessType {}

impl QosFlowAccessType {
    #[allow(clippy::new_without_default)]
    pub fn new() -> QosFlowAccessType {
        QosFlowAccessType {}
    }
}

/// Converts the QosFlowAccessType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for QosFlowAccessType {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a QosFlowAccessType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for QosFlowAccessType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing QosFlowAccessType".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing QosFlowAccessType".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(QosFlowAccessType {})
    }
}

// Methods for converting between header::IntoHeaderValue<QosFlowAccessType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<QosFlowAccessType>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<QosFlowAccessType>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for QosFlowAccessType - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<QosFlowAccessType>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <QosFlowAccessType as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into QosFlowAccessType - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum QosFlowAccessTypeAnyOf {
    #[serde(rename = "3GPP")]
    Variant3Gpp,
    #[serde(rename = "NON_3GPP")]
    Non3Gpp,
    #[serde(rename = "3GPP_AND_NON_3GPP")]
    Variant3GppAndNon3Gpp,
}

impl std::fmt::Display for QosFlowAccessTypeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            QosFlowAccessTypeAnyOf::Variant3Gpp => write!(f, "3GPP"),
            QosFlowAccessTypeAnyOf::Non3Gpp => write!(f, "NON_3GPP"),
            QosFlowAccessTypeAnyOf::Variant3GppAndNon3Gpp => write!(f, "3GPP_AND_NON_3GPP"),
        }
    }
}

impl std::str::FromStr for QosFlowAccessTypeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "3GPP" => std::result::Result::Ok(QosFlowAccessTypeAnyOf::Variant3Gpp),
            "NON_3GPP" => std::result::Result::Ok(QosFlowAccessTypeAnyOf::Non3Gpp),
            "3GPP_AND_NON_3GPP" => {
                std::result::Result::Ok(QosFlowAccessTypeAnyOf::Variant3GppAndNon3Gpp)
            }
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Individual QoS flow requested to be created or modified
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct QosFlowAddModifyRequestItem {
    /// Unsigned integer identifying a QoS flow, within the range 0 to 63.
    #[serde(rename = "qfi")]
    pub qfi: u8,

    /// EPS Bearer Identifier
    #[serde(rename = "ebi")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ebi: Option<u8>,

    /// string with format 'bytes' as defined in OpenAPI
    #[serde(rename = "qosRules")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub qos_rules: Option<swagger::ByteArray>,

    /// string with format 'bytes' as defined in OpenAPI
    #[serde(rename = "qosFlowDescription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub qos_flow_description: Option<swagger::ByteArray>,

    #[serde(rename = "qosFlowProfile")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub qos_flow_profile: Option<models::QosFlowProfile>,

    #[serde(rename = "associatedAnType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub associated_an_type: Option<models::QosFlowAccessType>,
}

impl QosFlowAddModifyRequestItem {
    #[allow(clippy::new_without_default)]
    pub fn new(qfi: u8) -> QosFlowAddModifyRequestItem {
        QosFlowAddModifyRequestItem {
            qfi,
            ebi: None,
            qos_rules: None,
            qos_flow_description: None,
            qos_flow_profile: None,
            associated_an_type: None,
        }
    }
}

/// Converts the QosFlowAddModifyRequestItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for QosFlowAddModifyRequestItem {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("qfi".to_string()),
            Some(self.qfi.to_string()),
            self.ebi
                .as_ref()
                .map(|ebi| vec!["ebi".to_string(), ebi.to_string()].join(",")),
            // Skipping qosRules in query parameter serialization
            // Skipping qosRules in query parameter serialization

            // Skipping qosFlowDescription in query parameter serialization
            // Skipping qosFlowDescription in query parameter serialization

            // Skipping qosFlowProfile in query parameter serialization

            // Skipping associatedAnType in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a QosFlowAddModifyRequestItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for QosFlowAddModifyRequestItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub qfi: Vec<u8>,
            pub ebi: Vec<u8>,
            pub qos_rules: Vec<swagger::ByteArray>,
            pub qos_flow_description: Vec<swagger::ByteArray>,
            pub qos_flow_profile: Vec<models::QosFlowProfile>,
            pub associated_an_type: Vec<models::QosFlowAccessType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing QosFlowAddModifyRequestItem".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "qfi" => intermediate_rep.qfi.push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ebi" => intermediate_rep.ebi.push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "qosRules" => return std::result::Result::Err("Parsing binary data in this style is not supported in QosFlowAddModifyRequestItem".to_string()),
                    "qosFlowDescription" => return std::result::Result::Err("Parsing binary data in this style is not supported in QosFlowAddModifyRequestItem".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "qosFlowProfile" => intermediate_rep.qos_flow_profile.push(<models::QosFlowProfile as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "associatedAnType" => intermediate_rep.associated_an_type.push(<models::QosFlowAccessType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing QosFlowAddModifyRequestItem".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(QosFlowAddModifyRequestItem {
            qfi: intermediate_rep
                .qfi
                .into_iter()
                .next()
                .ok_or_else(|| "qfi missing in QosFlowAddModifyRequestItem".to_string())?,
            ebi: intermediate_rep.ebi.into_iter().next(),
            qos_rules: intermediate_rep.qos_rules.into_iter().next(),
            qos_flow_description: intermediate_rep.qos_flow_description.into_iter().next(),
            qos_flow_profile: intermediate_rep.qos_flow_profile.into_iter().next(),
            associated_an_type: intermediate_rep.associated_an_type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<QosFlowAddModifyRequestItem> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<QosFlowAddModifyRequestItem>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<QosFlowAddModifyRequestItem>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for QosFlowAddModifyRequestItem - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<QosFlowAddModifyRequestItem>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <QosFlowAddModifyRequestItem as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into QosFlowAddModifyRequestItem - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Individual QoS flow
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct QosFlowItem {
    /// Unsigned integer identifying a QoS flow, within the range 0 to 63.
    #[serde(rename = "qfi")]
    pub qfi: u8,

    #[serde(rename = "cause")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cause: Option<models::Cause>,

    #[serde(rename = "currentQosProfileIndex")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub current_qos_profile_index: Option<u8>,

    #[serde(rename = "nullQoSProfileIndex")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub null_qo_s_profile_index: Option<bool>,

    #[serde(rename = "ngApCause")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ng_ap_cause: Option<models::NgApCause>,
}

impl QosFlowItem {
    #[allow(clippy::new_without_default)]
    pub fn new(qfi: u8) -> QosFlowItem {
        QosFlowItem {
            qfi,
            cause: None,
            current_qos_profile_index: None,
            null_qo_s_profile_index: None,
            ng_ap_cause: None,
        }
    }
}

/// Converts the QosFlowItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for QosFlowItem {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("qfi".to_string()),
            Some(self.qfi.to_string()),
            // Skipping cause in query parameter serialization
            self.current_qos_profile_index
                .as_ref()
                .map(|current_qos_profile_index| {
                    vec![
                        "currentQosProfileIndex".to_string(),
                        current_qos_profile_index.to_string(),
                    ]
                    .join(",")
                }),
            self.null_qo_s_profile_index
                .as_ref()
                .map(|null_qo_s_profile_index| {
                    vec![
                        "nullQoSProfileIndex".to_string(),
                        null_qo_s_profile_index.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping ngApCause in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a QosFlowItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for QosFlowItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub qfi: Vec<u8>,
            pub cause: Vec<models::Cause>,
            pub current_qos_profile_index: Vec<u8>,
            pub null_qo_s_profile_index: Vec<bool>,
            pub ng_ap_cause: Vec<models::NgApCause>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing QosFlowItem".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "qfi" => intermediate_rep
                        .qfi
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cause" => intermediate_rep.cause.push(
                        <models::Cause as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "currentQosProfileIndex" => intermediate_rep
                        .current_qos_profile_index
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "nullQoSProfileIndex" => intermediate_rep.null_qo_s_profile_index.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ngApCause" => intermediate_rep.ng_ap_cause.push(
                        <models::NgApCause as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing QosFlowItem".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(QosFlowItem {
            qfi: intermediate_rep
                .qfi
                .into_iter()
                .next()
                .ok_or_else(|| "qfi missing in QosFlowItem".to_string())?,
            cause: intermediate_rep.cause.into_iter().next(),
            current_qos_profile_index: intermediate_rep
                .current_qos_profile_index
                .into_iter()
                .next(),
            null_qo_s_profile_index: intermediate_rep.null_qo_s_profile_index.into_iter().next(),
            ng_ap_cause: intermediate_rep.ng_ap_cause.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<QosFlowItem> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<QosFlowItem>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<QosFlowItem>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for QosFlowItem - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<QosFlowItem> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <QosFlowItem as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into QosFlowItem - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Notification related to a QoS flow
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct QosFlowNotifyItem {
    /// Unsigned integer identifying a QoS flow, within the range 0 to 63.
    #[serde(rename = "qfi")]
    pub qfi: u8,

    #[serde(rename = "notificationCause")]
    pub notification_cause: models::NotificationCause,

    #[serde(rename = "currentQosProfileIndex")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub current_qos_profile_index: Option<u8>,

    #[serde(rename = "nullQoSProfileIndex")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub null_qo_s_profile_index: Option<bool>,
}

impl QosFlowNotifyItem {
    #[allow(clippy::new_without_default)]
    pub fn new(qfi: u8, notification_cause: models::NotificationCause) -> QosFlowNotifyItem {
        QosFlowNotifyItem {
            qfi,
            notification_cause,
            current_qos_profile_index: None,
            null_qo_s_profile_index: None,
        }
    }
}

/// Converts the QosFlowNotifyItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for QosFlowNotifyItem {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("qfi".to_string()),
            Some(self.qfi.to_string()),
            // Skipping notificationCause in query parameter serialization
            self.current_qos_profile_index
                .as_ref()
                .map(|current_qos_profile_index| {
                    vec![
                        "currentQosProfileIndex".to_string(),
                        current_qos_profile_index.to_string(),
                    ]
                    .join(",")
                }),
            self.null_qo_s_profile_index
                .as_ref()
                .map(|null_qo_s_profile_index| {
                    vec![
                        "nullQoSProfileIndex".to_string(),
                        null_qo_s_profile_index.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a QosFlowNotifyItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for QosFlowNotifyItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub qfi: Vec<u8>,
            pub notification_cause: Vec<models::NotificationCause>,
            pub current_qos_profile_index: Vec<u8>,
            pub null_qo_s_profile_index: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing QosFlowNotifyItem".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "qfi" => intermediate_rep
                        .qfi
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "notificationCause" => intermediate_rep.notification_cause.push(
                        <models::NotificationCause as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "currentQosProfileIndex" => intermediate_rep
                        .current_qos_profile_index
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "nullQoSProfileIndex" => intermediate_rep.null_qo_s_profile_index.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing QosFlowNotifyItem".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(QosFlowNotifyItem {
            qfi: intermediate_rep
                .qfi
                .into_iter()
                .next()
                .ok_or_else(|| "qfi missing in QosFlowNotifyItem".to_string())?,
            notification_cause: intermediate_rep
                .notification_cause
                .into_iter()
                .next()
                .ok_or_else(|| "notificationCause missing in QosFlowNotifyItem".to_string())?,
            current_qos_profile_index: intermediate_rep
                .current_qos_profile_index
                .into_iter()
                .next(),
            null_qo_s_profile_index: intermediate_rep.null_qo_s_profile_index.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<QosFlowNotifyItem> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<QosFlowNotifyItem>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<QosFlowNotifyItem>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for QosFlowNotifyItem - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<QosFlowNotifyItem>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <QosFlowNotifyItem as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into QosFlowNotifyItem - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// QoS flow profile
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct QosFlowProfile {
    /// Unsigned integer representing a 5G QoS Identifier (see clause 5.7.2.1 of 3GPP TS 23.501, within the range 0 to 255.
    #[serde(rename = "5qi")]
    pub param_5qi: u8,

    #[serde(rename = "nonDynamic5Qi")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub non_dynamic5_qi: Option<models::NonDynamic5Qi>,

    #[serde(rename = "dynamic5Qi")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dynamic5_qi: Option<models::Dynamic5Qi>,

    #[serde(rename = "arp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub arp: Option<models::Arp>,

    #[serde(rename = "gbrQosFlowInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gbr_qos_flow_info: Option<models::GbrQosFlowInformation>,

    #[serde(rename = "rqa")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rqa: Option<models::ReflectiveQoSAttribute>,

    #[serde(rename = "additionalQosFlowInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_qos_flow_info: Option<models::AdditionalQosFlowInfo>,

    #[serde(rename = "qosMonitoringReq")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub qos_monitoring_req: Option<models::QosMonitoringReq>,

    /// indicating a time in seconds.
    #[serde(rename = "qosRepPeriod")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub qos_rep_period: Option<i32>,
}

impl QosFlowProfile {
    #[allow(clippy::new_without_default)]
    pub fn new(param_5qi: u8) -> QosFlowProfile {
        QosFlowProfile {
            param_5qi,
            non_dynamic5_qi: None,
            dynamic5_qi: None,
            arp: None,
            gbr_qos_flow_info: None,
            rqa: None,
            additional_qos_flow_info: None,
            qos_monitoring_req: None,
            qos_rep_period: None,
        }
    }
}

/// Converts the QosFlowProfile value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for QosFlowProfile {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("5qi".to_string()),
            Some(self.param_5qi.to_string()),
            // Skipping nonDynamic5Qi in query parameter serialization

            // Skipping dynamic5Qi in query parameter serialization

            // Skipping arp in query parameter serialization

            // Skipping gbrQosFlowInfo in query parameter serialization

            // Skipping rqa in query parameter serialization

            // Skipping additionalQosFlowInfo in query parameter serialization

            // Skipping qosMonitoringReq in query parameter serialization
            self.qos_rep_period.as_ref().map(|qos_rep_period| {
                vec!["qosRepPeriod".to_string(), qos_rep_period.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a QosFlowProfile value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for QosFlowProfile {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub param_5qi: Vec<u8>,
            pub non_dynamic5_qi: Vec<models::NonDynamic5Qi>,
            pub dynamic5_qi: Vec<models::Dynamic5Qi>,
            pub arp: Vec<models::Arp>,
            pub gbr_qos_flow_info: Vec<models::GbrQosFlowInformation>,
            pub rqa: Vec<models::ReflectiveQoSAttribute>,
            pub additional_qos_flow_info: Vec<models::AdditionalQosFlowInfo>,
            pub qos_monitoring_req: Vec<models::QosMonitoringReq>,
            pub qos_rep_period: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing QosFlowProfile".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "5qi" => intermediate_rep
                        .param_5qi
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "nonDynamic5Qi" => intermediate_rep.non_dynamic5_qi.push(
                        <models::NonDynamic5Qi as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "dynamic5Qi" => intermediate_rep.dynamic5_qi.push(
                        <models::Dynamic5Qi as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "arp" => intermediate_rep.arp.push(
                        <models::Arp as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "gbrQosFlowInfo" => intermediate_rep.gbr_qos_flow_info.push(
                        <models::GbrQosFlowInformation as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "rqa" => intermediate_rep.rqa.push(
                        <models::ReflectiveQoSAttribute as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "additionalQosFlowInfo" => intermediate_rep.additional_qos_flow_info.push(
                        <models::AdditionalQosFlowInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "qosMonitoringReq" => intermediate_rep.qos_monitoring_req.push(
                        <models::QosMonitoringReq as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "qosRepPeriod" => intermediate_rep.qos_rep_period.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing QosFlowProfile".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(QosFlowProfile {
            param_5qi: intermediate_rep
                .param_5qi
                .into_iter()
                .next()
                .ok_or_else(|| "5qi missing in QosFlowProfile".to_string())?,
            non_dynamic5_qi: intermediate_rep.non_dynamic5_qi.into_iter().next(),
            dynamic5_qi: intermediate_rep.dynamic5_qi.into_iter().next(),
            arp: intermediate_rep.arp.into_iter().next(),
            gbr_qos_flow_info: intermediate_rep.gbr_qos_flow_info.into_iter().next(),
            rqa: intermediate_rep.rqa.into_iter().next(),
            additional_qos_flow_info: intermediate_rep.additional_qos_flow_info.into_iter().next(),
            qos_monitoring_req: intermediate_rep.qos_monitoring_req.into_iter().next(),
            qos_rep_period: intermediate_rep.qos_rep_period.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<QosFlowProfile> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<QosFlowProfile>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<QosFlowProfile>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for QosFlowProfile - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<QosFlowProfile> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <QosFlowProfile as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into QosFlowProfile - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Individual QoS flow requested to be released
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct QosFlowReleaseRequestItem {
    /// Unsigned integer identifying a QoS flow, within the range 0 to 63.
    #[serde(rename = "qfi")]
    pub qfi: u8,

    /// string with format 'bytes' as defined in OpenAPI
    #[serde(rename = "qosRules")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub qos_rules: Option<swagger::ByteArray>,

    /// string with format 'bytes' as defined in OpenAPI
    #[serde(rename = "qosFlowDescription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub qos_flow_description: Option<swagger::ByteArray>,
}

impl QosFlowReleaseRequestItem {
    #[allow(clippy::new_without_default)]
    pub fn new(qfi: u8) -> QosFlowReleaseRequestItem {
        QosFlowReleaseRequestItem {
            qfi,
            qos_rules: None,
            qos_flow_description: None,
        }
    }
}

/// Converts the QosFlowReleaseRequestItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for QosFlowReleaseRequestItem {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("qfi".to_string()),
            Some(self.qfi.to_string()),
            // Skipping qosRules in query parameter serialization
            // Skipping qosRules in query parameter serialization

            // Skipping qosFlowDescription in query parameter serialization
            // Skipping qosFlowDescription in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a QosFlowReleaseRequestItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for QosFlowReleaseRequestItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub qfi: Vec<u8>,
            pub qos_rules: Vec<swagger::ByteArray>,
            pub qos_flow_description: Vec<swagger::ByteArray>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing QosFlowReleaseRequestItem".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "qfi" => intermediate_rep.qfi.push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "qosRules" => return std::result::Result::Err("Parsing binary data in this style is not supported in QosFlowReleaseRequestItem".to_string()),
                    "qosFlowDescription" => return std::result::Result::Err("Parsing binary data in this style is not supported in QosFlowReleaseRequestItem".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing QosFlowReleaseRequestItem".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(QosFlowReleaseRequestItem {
            qfi: intermediate_rep
                .qfi
                .into_iter()
                .next()
                .ok_or_else(|| "qfi missing in QosFlowReleaseRequestItem".to_string())?,
            qos_rules: intermediate_rep.qos_rules.into_iter().next(),
            qos_flow_description: intermediate_rep.qos_flow_description.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<QosFlowReleaseRequestItem> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<QosFlowReleaseRequestItem>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<QosFlowReleaseRequestItem>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for QosFlowReleaseRequestItem - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<QosFlowReleaseRequestItem>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <QosFlowReleaseRequestItem as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into QosFlowReleaseRequestItem - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Individual QoS flow to setup
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct QosFlowSetupItem {
    /// Unsigned integer identifying a QoS flow, within the range 0 to 63.
    #[serde(rename = "qfi")]
    pub qfi: u8,

    /// string with format 'bytes' as defined in OpenAPI
    #[serde(rename = "qosRules")]
    pub qos_rules: swagger::ByteArray,

    /// EPS Bearer Identifier
    #[serde(rename = "ebi")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ebi: Option<u8>,

    /// string with format 'bytes' as defined in OpenAPI
    #[serde(rename = "qosFlowDescription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub qos_flow_description: Option<swagger::ByteArray>,

    #[serde(rename = "qosFlowProfile")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub qos_flow_profile: Option<models::QosFlowProfile>,

    #[serde(rename = "associatedAnType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub associated_an_type: Option<models::QosFlowAccessType>,

    #[serde(rename = "defaultQosRuleInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_qos_rule_ind: Option<bool>,
}

impl QosFlowSetupItem {
    #[allow(clippy::new_without_default)]
    pub fn new(qfi: u8, qos_rules: swagger::ByteArray) -> QosFlowSetupItem {
        QosFlowSetupItem {
            qfi,
            qos_rules,
            ebi: None,
            qos_flow_description: None,
            qos_flow_profile: None,
            associated_an_type: None,
            default_qos_rule_ind: None,
        }
    }
}

/// Converts the QosFlowSetupItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for QosFlowSetupItem {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("qfi".to_string()),
            Some(self.qfi.to_string()),
            // Skipping qosRules in query parameter serialization
            // Skipping qosRules in query parameter serialization
            self.ebi
                .as_ref()
                .map(|ebi| vec!["ebi".to_string(), ebi.to_string()].join(",")),
            // Skipping qosFlowDescription in query parameter serialization
            // Skipping qosFlowDescription in query parameter serialization

            // Skipping qosFlowProfile in query parameter serialization

            // Skipping associatedAnType in query parameter serialization
            self.default_qos_rule_ind
                .as_ref()
                .map(|default_qos_rule_ind| {
                    vec![
                        "defaultQosRuleInd".to_string(),
                        default_qos_rule_ind.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a QosFlowSetupItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for QosFlowSetupItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub qfi: Vec<u8>,
            pub qos_rules: Vec<swagger::ByteArray>,
            pub ebi: Vec<u8>,
            pub qos_flow_description: Vec<swagger::ByteArray>,
            pub qos_flow_profile: Vec<models::QosFlowProfile>,
            pub associated_an_type: Vec<models::QosFlowAccessType>,
            pub default_qos_rule_ind: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing QosFlowSetupItem".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "qfi" => intermediate_rep
                        .qfi
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "qosRules" => return std::result::Result::Err(
                        "Parsing binary data in this style is not supported in QosFlowSetupItem"
                            .to_string(),
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ebi" => intermediate_rep
                        .ebi
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "qosFlowDescription" => return std::result::Result::Err(
                        "Parsing binary data in this style is not supported in QosFlowSetupItem"
                            .to_string(),
                    ),
                    #[allow(clippy::redundant_clone)]
                    "qosFlowProfile" => intermediate_rep.qos_flow_profile.push(
                        <models::QosFlowProfile as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "associatedAnType" => intermediate_rep.associated_an_type.push(
                        <models::QosFlowAccessType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "defaultQosRuleInd" => intermediate_rep.default_qos_rule_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing QosFlowSetupItem".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(QosFlowSetupItem {
            qfi: intermediate_rep
                .qfi
                .into_iter()
                .next()
                .ok_or_else(|| "qfi missing in QosFlowSetupItem".to_string())?,
            qos_rules: intermediate_rep
                .qos_rules
                .into_iter()
                .next()
                .ok_or_else(|| "qosRules missing in QosFlowSetupItem".to_string())?,
            ebi: intermediate_rep.ebi.into_iter().next(),
            qos_flow_description: intermediate_rep.qos_flow_description.into_iter().next(),
            qos_flow_profile: intermediate_rep.qos_flow_profile.into_iter().next(),
            associated_an_type: intermediate_rep.associated_an_type.into_iter().next(),
            default_qos_rule_ind: intermediate_rep.default_qos_rule_ind.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<QosFlowSetupItem> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<QosFlowSetupItem>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<QosFlowSetupItem>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for QosFlowSetupItem - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<QosFlowSetupItem>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <QosFlowSetupItem as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into QosFlowSetupItem - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Tunnel Information per QoS Flow
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct QosFlowTunnel {
    #[serde(rename = "qfiList")]
    pub qfi_list: Vec<models::Qfi>,

    #[serde(rename = "tunnelInfo")]
    pub tunnel_info: models::TunnelInfo,
}

impl QosFlowTunnel {
    #[allow(clippy::new_without_default)]
    pub fn new(qfi_list: Vec<models::Qfi>, tunnel_info: models::TunnelInfo) -> QosFlowTunnel {
        QosFlowTunnel {
            qfi_list,
            tunnel_info,
        }
    }
}

/// Converts the QosFlowTunnel value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for QosFlowTunnel {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("qfiList".to_string()),
            Some(
                self.qfi_list
                    .iter()
                    .map(|x| x.to_string())
                    .collect::<Vec<_>>()
                    .join(","),
            ),
            // Skipping tunnelInfo in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a QosFlowTunnel value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for QosFlowTunnel {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub qfi_list: Vec<Vec<models::Qfi>>,
            pub tunnel_info: Vec<models::TunnelInfo>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing QosFlowTunnel".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "qfiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in QosFlowTunnel"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "tunnelInfo" => intermediate_rep.tunnel_info.push(
                        <models::TunnelInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing QosFlowTunnel".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(QosFlowTunnel {
            qfi_list: intermediate_rep
                .qfi_list
                .into_iter()
                .next()
                .ok_or_else(|| "qfiList missing in QosFlowTunnel".to_string())?,
            tunnel_info: intermediate_rep
                .tunnel_info
                .into_iter()
                .next()
                .ok_or_else(|| "tunnelInfo missing in QosFlowTunnel".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<QosFlowTunnel> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<QosFlowTunnel>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<QosFlowTunnel>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for QosFlowTunnel - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<QosFlowTunnel> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <QosFlowTunnel as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into QosFlowTunnel - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains QoS flows usage data information.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct QosFlowUsageReport {
    /// Unsigned integer identifying a QoS flow, within the range 0 to 63.
    #[serde(rename = "qfi")]
    pub qfi: u8,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "startTimeStamp")]
    pub start_time_stamp: chrono::DateTime<chrono::Utc>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "endTimeStamp")]
    pub end_time_stamp: chrono::DateTime<chrono::Utc>,

    /// string with format 'int64' as defined in OpenAPI.
    #[serde(rename = "downlinkVolume")]
    pub downlink_volume: i64,

    /// string with format 'int64' as defined in OpenAPI.
    #[serde(rename = "uplinkVolume")]
    pub uplink_volume: i64,
}

impl QosFlowUsageReport {
    #[allow(clippy::new_without_default)]
    pub fn new(
        qfi: u8,
        start_time_stamp: chrono::DateTime<chrono::Utc>,
        end_time_stamp: chrono::DateTime<chrono::Utc>,
        downlink_volume: i64,
        uplink_volume: i64,
    ) -> QosFlowUsageReport {
        QosFlowUsageReport {
            qfi,
            start_time_stamp,
            end_time_stamp,
            downlink_volume,
            uplink_volume,
        }
    }
}

/// Converts the QosFlowUsageReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for QosFlowUsageReport {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("qfi".to_string()),
            Some(self.qfi.to_string()),
            // Skipping startTimeStamp in query parameter serialization

            // Skipping endTimeStamp in query parameter serialization
            Some("downlinkVolume".to_string()),
            Some(self.downlink_volume.to_string()),
            Some("uplinkVolume".to_string()),
            Some(self.uplink_volume.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a QosFlowUsageReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for QosFlowUsageReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub qfi: Vec<u8>,
            pub start_time_stamp: Vec<chrono::DateTime<chrono::Utc>>,
            pub end_time_stamp: Vec<chrono::DateTime<chrono::Utc>>,
            pub downlink_volume: Vec<i64>,
            pub uplink_volume: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing QosFlowUsageReport".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "qfi" => intermediate_rep
                        .qfi
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "startTimeStamp" => intermediate_rep.start_time_stamp.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "endTimeStamp" => intermediate_rep.end_time_stamp.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "downlinkVolume" => intermediate_rep.downlink_volume.push(
                        <i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "uplinkVolume" => intermediate_rep.uplink_volume.push(
                        <i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing QosFlowUsageReport".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(QosFlowUsageReport {
            qfi: intermediate_rep
                .qfi
                .into_iter()
                .next()
                .ok_or_else(|| "qfi missing in QosFlowUsageReport".to_string())?,
            start_time_stamp: intermediate_rep
                .start_time_stamp
                .into_iter()
                .next()
                .ok_or_else(|| "startTimeStamp missing in QosFlowUsageReport".to_string())?,
            end_time_stamp: intermediate_rep
                .end_time_stamp
                .into_iter()
                .next()
                .ok_or_else(|| "endTimeStamp missing in QosFlowUsageReport".to_string())?,
            downlink_volume: intermediate_rep
                .downlink_volume
                .into_iter()
                .next()
                .ok_or_else(|| "downlinkVolume missing in QosFlowUsageReport".to_string())?,
            uplink_volume: intermediate_rep
                .uplink_volume
                .into_iter()
                .next()
                .ok_or_else(|| "uplinkVolume missing in QosFlowUsageReport".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<QosFlowUsageReport> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<QosFlowUsageReport>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<QosFlowUsageReport>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for QosFlowUsageReport - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<QosFlowUsageReport>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <QosFlowUsageReport as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into QosFlowUsageReport - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// QoS Monitoring Information
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct QosMonitoringInfo {
    #[serde(rename = "qosMonitoringInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub qos_monitoring_ind: Option<bool>,
}

impl QosMonitoringInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> QosMonitoringInfo {
        QosMonitoringInfo {
            qos_monitoring_ind: Some(false),
        }
    }
}

/// Converts the QosMonitoringInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for QosMonitoringInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> =
            vec![self.qos_monitoring_ind.as_ref().map(|qos_monitoring_ind| {
                vec![
                    "qosMonitoringInd".to_string(),
                    qos_monitoring_ind.to_string(),
                ]
                .join(",")
            })];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a QosMonitoringInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for QosMonitoringInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub qos_monitoring_ind: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing QosMonitoringInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "qosMonitoringInd" => intermediate_rep.qos_monitoring_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing QosMonitoringInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(QosMonitoringInfo {
            qos_monitoring_ind: intermediate_rep.qos_monitoring_ind.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<QosMonitoringInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<QosMonitoringInfo>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<QosMonitoringInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for QosMonitoringInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<QosMonitoringInfo>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <QosMonitoringInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into QosMonitoringInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// QoS monitoring request. Possible values are   - UL   - DL   - BOTH   - NONE
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct QosMonitoringReq {}

impl QosMonitoringReq {
    #[allow(clippy::new_without_default)]
    pub fn new() -> QosMonitoringReq {
        QosMonitoringReq {}
    }
}

/// Converts the QosMonitoringReq value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for QosMonitoringReq {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a QosMonitoringReq value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for QosMonitoringReq {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing QosMonitoringReq".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing QosMonitoringReq".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(QosMonitoringReq {})
    }
}

// Methods for converting between header::IntoHeaderValue<QosMonitoringReq> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<QosMonitoringReq>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<QosMonitoringReq>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for QosMonitoringReq - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<QosMonitoringReq>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <QosMonitoringReq as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into QosMonitoringReq - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum QosMonitoringReqAnyOf {
    #[serde(rename = "UL")]
    Ul,
    #[serde(rename = "DL")]
    Dl,
    #[serde(rename = "BOTH")]
    Both,
    #[serde(rename = "NONE")]
    None,
}

impl std::fmt::Display for QosMonitoringReqAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            QosMonitoringReqAnyOf::Ul => write!(f, "UL"),
            QosMonitoringReqAnyOf::Dl => write!(f, "DL"),
            QosMonitoringReqAnyOf::Both => write!(f, "BOTH"),
            QosMonitoringReqAnyOf::None => write!(f, "NONE"),
        }
    }
}

impl std::str::FromStr for QosMonitoringReqAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "UL" => std::result::Result::Ok(QosMonitoringReqAnyOf::Ul),
            "DL" => std::result::Result::Ok(QosMonitoringReqAnyOf::Dl),
            "BOTH" => std::result::Result::Ok(QosMonitoringReqAnyOf::Both),
            "NONE" => std::result::Result::Ok(QosMonitoringReqAnyOf::None),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// The enumeration QosResourceType indicates whether a QoS Flow is non-GBR, delay critical GBR, or non-delay critical GBR (see clauses 5.7.3.4 and 5.7.3.5 of 3GPP TS 23.501). It shall comply with the provisions defined in table 5.5.3.6-1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct QosResourceType {}

impl QosResourceType {
    #[allow(clippy::new_without_default)]
    pub fn new() -> QosResourceType {
        QosResourceType {}
    }
}

/// Converts the QosResourceType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for QosResourceType {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a QosResourceType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for QosResourceType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing QosResourceType".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing QosResourceType".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(QosResourceType {})
    }
}

// Methods for converting between header::IntoHeaderValue<QosResourceType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<QosResourceType>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<QosResourceType>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for QosResourceType - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<QosResourceType>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <QosResourceType as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into QosResourceType - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum QosResourceTypeAnyOf {
    #[serde(rename = "NON_GBR")]
    NonGbr,
    #[serde(rename = "NON_CRITICAL_GBR")]
    NonCriticalGbr,
    #[serde(rename = "CRITICAL_GBR")]
    CriticalGbr,
}

impl std::fmt::Display for QosResourceTypeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            QosResourceTypeAnyOf::NonGbr => write!(f, "NON_GBR"),
            QosResourceTypeAnyOf::NonCriticalGbr => write!(f, "NON_CRITICAL_GBR"),
            QosResourceTypeAnyOf::CriticalGbr => write!(f, "CRITICAL_GBR"),
        }
    }
}

impl std::str::FromStr for QosResourceTypeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "NON_GBR" => std::result::Result::Ok(QosResourceTypeAnyOf::NonGbr),
            "NON_CRITICAL_GBR" => std::result::Result::Ok(QosResourceTypeAnyOf::NonCriticalGbr),
            "CRITICAL_GBR" => std::result::Result::Ok(QosResourceTypeAnyOf::CriticalGbr),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Indicates the radio access used.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RatType(String);

impl RatType {
    #[allow(clippy::new_without_default)]
    pub fn new(s: String) -> RatType {
        RatType(s)
    }
}

/// Converts the RatType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RatType {
    fn to_string(&self) -> String {
        self.0.clone()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RatType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RatType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(RatType(s.to_string()))
    }
}

// Methods for converting between header::IntoHeaderValue<RatType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RatType>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<RatType>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for RatType - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<RatType> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <RatType as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into RatType - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum RatTypeAnyOf {
    #[serde(rename = "NR")]
    Nr,
    #[serde(rename = "EUTRA")]
    Eutra,
    #[serde(rename = "WLAN")]
    Wlan,
    #[serde(rename = "VIRTUAL")]
    Virtual,
    #[serde(rename = "NBIOT")]
    Nbiot,
    #[serde(rename = "WIRELINE")]
    Wireline,
    #[serde(rename = "WIRELINE_CABLE")]
    WirelineCable,
    #[serde(rename = "WIRELINE_BBF")]
    WirelineBbf,
    #[serde(rename = "LTE-M")]
    LteM,
    #[serde(rename = "NR_U")]
    NrU,
    #[serde(rename = "EUTRA_U")]
    EutraU,
    #[serde(rename = "TRUSTED_N3GA")]
    TrustedN3Ga,
    #[serde(rename = "TRUSTED_WLAN")]
    TrustedWlan,
    #[serde(rename = "UTRA")]
    Utra,
    #[serde(rename = "GERA")]
    Gera,
    #[serde(rename = "NR_LEO")]
    NrLeo,
    #[serde(rename = "NR_MEO")]
    NrMeo,
    #[serde(rename = "NR_GEO")]
    NrGeo,
    #[serde(rename = "NR_OTHER_SAT")]
    NrOtherSat,
    #[serde(rename = "NR_REDCAP")]
    NrRedcap,
}

impl std::fmt::Display for RatTypeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            RatTypeAnyOf::Nr => write!(f, "NR"),
            RatTypeAnyOf::Eutra => write!(f, "EUTRA"),
            RatTypeAnyOf::Wlan => write!(f, "WLAN"),
            RatTypeAnyOf::Virtual => write!(f, "VIRTUAL"),
            RatTypeAnyOf::Nbiot => write!(f, "NBIOT"),
            RatTypeAnyOf::Wireline => write!(f, "WIRELINE"),
            RatTypeAnyOf::WirelineCable => write!(f, "WIRELINE_CABLE"),
            RatTypeAnyOf::WirelineBbf => write!(f, "WIRELINE_BBF"),
            RatTypeAnyOf::LteM => write!(f, "LTE-M"),
            RatTypeAnyOf::NrU => write!(f, "NR_U"),
            RatTypeAnyOf::EutraU => write!(f, "EUTRA_U"),
            RatTypeAnyOf::TrustedN3Ga => write!(f, "TRUSTED_N3GA"),
            RatTypeAnyOf::TrustedWlan => write!(f, "TRUSTED_WLAN"),
            RatTypeAnyOf::Utra => write!(f, "UTRA"),
            RatTypeAnyOf::Gera => write!(f, "GERA"),
            RatTypeAnyOf::NrLeo => write!(f, "NR_LEO"),
            RatTypeAnyOf::NrMeo => write!(f, "NR_MEO"),
            RatTypeAnyOf::NrGeo => write!(f, "NR_GEO"),
            RatTypeAnyOf::NrOtherSat => write!(f, "NR_OTHER_SAT"),
            RatTypeAnyOf::NrRedcap => write!(f, "NR_REDCAP"),
        }
    }
}

impl std::str::FromStr for RatTypeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "NR" => std::result::Result::Ok(RatTypeAnyOf::Nr),
            "EUTRA" => std::result::Result::Ok(RatTypeAnyOf::Eutra),
            "WLAN" => std::result::Result::Ok(RatTypeAnyOf::Wlan),
            "VIRTUAL" => std::result::Result::Ok(RatTypeAnyOf::Virtual),
            "NBIOT" => std::result::Result::Ok(RatTypeAnyOf::Nbiot),
            "WIRELINE" => std::result::Result::Ok(RatTypeAnyOf::Wireline),
            "WIRELINE_CABLE" => std::result::Result::Ok(RatTypeAnyOf::WirelineCable),
            "WIRELINE_BBF" => std::result::Result::Ok(RatTypeAnyOf::WirelineBbf),
            "LTE-M" => std::result::Result::Ok(RatTypeAnyOf::LteM),
            "NR_U" => std::result::Result::Ok(RatTypeAnyOf::NrU),
            "EUTRA_U" => std::result::Result::Ok(RatTypeAnyOf::EutraU),
            "TRUSTED_N3GA" => std::result::Result::Ok(RatTypeAnyOf::TrustedN3Ga),
            "TRUSTED_WLAN" => std::result::Result::Ok(RatTypeAnyOf::TrustedWlan),
            "UTRA" => std::result::Result::Ok(RatTypeAnyOf::Utra),
            "GERA" => std::result::Result::Ok(RatTypeAnyOf::Gera),
            "NR_LEO" => std::result::Result::Ok(RatTypeAnyOf::NrLeo),
            "NR_MEO" => std::result::Result::Ok(RatTypeAnyOf::NrMeo),
            "NR_GEO" => std::result::Result::Ok(RatTypeAnyOf::NrGeo),
            "NR_OTHER_SAT" => std::result::Result::Ok(RatTypeAnyOf::NrOtherSat),
            "NR_REDCAP" => std::result::Result::Ok(RatTypeAnyOf::NrRedcap),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// The response shall include a Location header field containing a different URI  (pointing to a different URI of an other service instance), or the same URI if a request  is redirected to the same target resource via a different SCP.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RedirectResponse {
    #[serde(rename = "cause")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cause: Option<String>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "targetScp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_scp: Option<String>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "targetSepp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_sepp: Option<String>,
}

impl RedirectResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> RedirectResponse {
        RedirectResponse {
            cause: None,
            target_scp: None,
            target_sepp: None,
        }
    }
}

/// Converts the RedirectResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RedirectResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.cause
                .as_ref()
                .map(|cause| vec!["cause".to_string(), cause.to_string()].join(",")),
            self.target_scp
                .as_ref()
                .map(|target_scp| vec!["targetScp".to_string(), target_scp.to_string()].join(",")),
            self.target_sepp.as_ref().map(|target_sepp| {
                vec!["targetSepp".to_string(), target_sepp.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RedirectResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RedirectResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cause: Vec<String>,
            pub target_scp: Vec<String>,
            pub target_sepp: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing RedirectResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "cause" => intermediate_rep.cause.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "targetScp" => intermediate_rep.target_scp.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "targetSepp" => intermediate_rep.target_sepp.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing RedirectResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RedirectResponse {
            cause: intermediate_rep.cause.into_iter().next(),
            target_scp: intermediate_rep.target_scp.into_iter().next(),
            target_sepp: intermediate_rep.target_sepp.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RedirectResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RedirectResponse>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<RedirectResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for RedirectResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<RedirectResponse>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <RedirectResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into RedirectResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Redundant PDU Session Information
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RedundantPduSessionInformation {
    #[serde(rename = "rsn")]
    pub rsn: models::Rsn,

    #[serde(rename = "pduSessionPairId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pdu_session_pair_id: Option<u8>,
}

impl RedundantPduSessionInformation {
    #[allow(clippy::new_without_default)]
    pub fn new(rsn: models::Rsn) -> RedundantPduSessionInformation {
        RedundantPduSessionInformation {
            rsn,
            pdu_session_pair_id: None,
        }
    }
}

/// Converts the RedundantPduSessionInformation value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RedundantPduSessionInformation {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping rsn in query parameter serialization
            self.pdu_session_pair_id
                .as_ref()
                .map(|pdu_session_pair_id| {
                    vec![
                        "pduSessionPairId".to_string(),
                        pdu_session_pair_id.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RedundantPduSessionInformation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RedundantPduSessionInformation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub rsn: Vec<models::Rsn>,
            pub pdu_session_pair_id: Vec<u8>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing RedundantPduSessionInformation".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "rsn" => intermediate_rep.rsn.push(
                        <models::Rsn as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "pduSessionPairId" => intermediate_rep
                        .pdu_session_pair_id
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing RedundantPduSessionInformation"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RedundantPduSessionInformation {
            rsn: intermediate_rep
                .rsn
                .into_iter()
                .next()
                .ok_or_else(|| "rsn missing in RedundantPduSessionInformation".to_string())?,
            pdu_session_pair_id: intermediate_rep.pdu_session_pair_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RedundantPduSessionInformation> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RedundantPduSessionInformation>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<RedundantPduSessionInformation>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for RedundantPduSessionInformation - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<RedundantPduSessionInformation>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RedundantPduSessionInformation as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RedundantPduSessionInformation - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

/// This parameter provides information about the referenced binary body data.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RefToBinaryData {
    /// This IE shall contain the value of the Content-ID header of the referenced binary body part.
    #[serde(rename = "contentId")]
    pub content_id: String,
}

impl RefToBinaryData {
    #[allow(clippy::new_without_default)]
    pub fn new(content_id: String) -> RefToBinaryData {
        RefToBinaryData { content_id }
    }
}

/// Converts the RefToBinaryData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RefToBinaryData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("contentId".to_string()),
            Some(self.content_id.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RefToBinaryData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RefToBinaryData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub content_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing RefToBinaryData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "contentId" => intermediate_rep.content_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing RefToBinaryData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RefToBinaryData {
            content_id: intermediate_rep
                .content_id
                .into_iter()
                .next()
                .ok_or_else(|| "contentId missing in RefToBinaryData".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RefToBinaryData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RefToBinaryData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<RefToBinaryData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for RefToBinaryData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<RefToBinaryData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <RefToBinaryData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into RefToBinaryData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// The enumeration ReflectiveQosAttribute indicates whether certain traffic of the QoS flow may be subject to Reflective QoS (see clause 5.7.2.3 of 3GPP TS 23.501). It shall comply with the provisions defined in table 5.5.3.3-1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ReflectiveQoSAttribute {}

impl ReflectiveQoSAttribute {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ReflectiveQoSAttribute {
        ReflectiveQoSAttribute {}
    }
}

/// Converts the ReflectiveQoSAttribute value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ReflectiveQoSAttribute {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ReflectiveQoSAttribute value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ReflectiveQoSAttribute {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ReflectiveQoSAttribute".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ReflectiveQoSAttribute".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ReflectiveQoSAttribute {})
    }
}

// Methods for converting between header::IntoHeaderValue<ReflectiveQoSAttribute> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ReflectiveQoSAttribute>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ReflectiveQoSAttribute>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ReflectiveQoSAttribute - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ReflectiveQoSAttribute>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ReflectiveQoSAttribute as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ReflectiveQoSAttribute - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ReflectiveQoSAttributeAnyOf {
    #[serde(rename = "RQOS")]
    Rqos,
    #[serde(rename = "NO_RQOS")]
    NoRqos,
}

impl std::fmt::Display for ReflectiveQoSAttributeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ReflectiveQoSAttributeAnyOf::Rqos => write!(f, "RQOS"),
            ReflectiveQoSAttributeAnyOf::NoRqos => write!(f, "NO_RQOS"),
        }
    }
}

impl std::str::FromStr for ReflectiveQoSAttributeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "RQOS" => std::result::Result::Ok(ReflectiveQoSAttributeAnyOf::Rqos),
            "NO_RQOS" => std::result::Result::Ok(ReflectiveQoSAttributeAnyOf::NoRqos),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Data within Release Request
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ReleaseData {
    #[serde(rename = "cause")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cause: Option<models::Cause>,

    #[serde(rename = "ngApCause")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ng_ap_cause: Option<models::NgApCause>,

    /// Unsigned Integer, i.e. only value 0 and integers above 0 are permissible.
    #[serde(rename = "5gMmCauseValue")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub param_5g_mm_cause_value: Option<u32>,

    #[serde(rename = "ueLocation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_location: Option<models::UserLocation>,

    /// String with format \"time-numoffset\" optionally appended by \"daylightSavingTime\", where  - \"time-numoffset\" shall represent the time zone adjusted for daylight saving time and be    encoded as time-numoffset as defined in clause 5.6 of IETF RFC 3339;  - \"daylightSavingTime\" shall represent the adjustment that has been made and shall be    encoded as \"+1\" or \"+2\" for a +1 or +2 hours adjustment.   The example is for 8 hours behind UTC, +1 hour adjustment for Daylight Saving Time.
    #[serde(rename = "ueTimeZone")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_time_zone: Option<String>,

    #[serde(rename = "addUeLocation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub add_ue_location: Option<models::UserLocation>,

    #[serde(rename = "secondaryRatUsageReport")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub secondary_rat_usage_report: Option<Vec<models::SecondaryRatUsageReport>>,

    #[serde(rename = "secondaryRatUsageInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub secondary_rat_usage_info: Option<Vec<models::SecondaryRatUsageInfo>>,

    #[serde(rename = "n4Info")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n4_info: Option<models::N4Information>,

    #[serde(rename = "n4InfoExt1")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n4_info_ext1: Option<models::N4Information>,

    #[serde(rename = "n4InfoExt2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n4_info_ext2: Option<models::N4Information>,
}

impl ReleaseData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ReleaseData {
        ReleaseData {
            cause: None,
            ng_ap_cause: None,
            param_5g_mm_cause_value: None,
            ue_location: None,
            ue_time_zone: None,
            add_ue_location: None,
            secondary_rat_usage_report: None,
            secondary_rat_usage_info: None,
            n4_info: None,
            n4_info_ext1: None,
            n4_info_ext2: None,
        }
    }
}

/// Converts the ReleaseData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ReleaseData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping cause in query parameter serialization

            // Skipping ngApCause in query parameter serialization
            self.param_5g_mm_cause_value
                .as_ref()
                .map(|param_5g_mm_cause_value| {
                    vec![
                        "5gMmCauseValue".to_string(),
                        param_5g_mm_cause_value.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping ueLocation in query parameter serialization
            self.ue_time_zone.as_ref().map(|ue_time_zone| {
                vec!["ueTimeZone".to_string(), ue_time_zone.to_string()].join(",")
            }),
            // Skipping addUeLocation in query parameter serialization

            // Skipping secondaryRatUsageReport in query parameter serialization

            // Skipping secondaryRatUsageInfo in query parameter serialization

            // Skipping n4Info in query parameter serialization

            // Skipping n4InfoExt1 in query parameter serialization

            // Skipping n4InfoExt2 in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ReleaseData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ReleaseData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cause: Vec<models::Cause>,
            pub ng_ap_cause: Vec<models::NgApCause>,
            pub param_5g_mm_cause_value: Vec<u32>,
            pub ue_location: Vec<models::UserLocation>,
            pub ue_time_zone: Vec<String>,
            pub add_ue_location: Vec<models::UserLocation>,
            pub secondary_rat_usage_report: Vec<Vec<models::SecondaryRatUsageReport>>,
            pub secondary_rat_usage_info: Vec<Vec<models::SecondaryRatUsageInfo>>,
            pub n4_info: Vec<models::N4Information>,
            pub n4_info_ext1: Vec<models::N4Information>,
            pub n4_info_ext2: Vec<models::N4Information>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ReleaseData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "cause" => intermediate_rep.cause.push(
                        <models::Cause as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ngApCause" => intermediate_rep.ng_ap_cause.push(
                        <models::NgApCause as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "5gMmCauseValue" => intermediate_rep.param_5g_mm_cause_value.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ueLocation" => intermediate_rep.ue_location.push(
                        <models::UserLocation as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ueTimeZone" => intermediate_rep.ue_time_zone.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "addUeLocation" => intermediate_rep.add_ue_location.push(
                        <models::UserLocation as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "secondaryRatUsageReport" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in ReleaseData"
                                .to_string(),
                        )
                    }
                    "secondaryRatUsageInfo" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in ReleaseData"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "n4Info" => intermediate_rep.n4_info.push(
                        <models::N4Information as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n4InfoExt1" => intermediate_rep.n4_info_ext1.push(
                        <models::N4Information as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n4InfoExt2" => intermediate_rep.n4_info_ext2.push(
                        <models::N4Information as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ReleaseData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ReleaseData {
            cause: intermediate_rep.cause.into_iter().next(),
            ng_ap_cause: intermediate_rep.ng_ap_cause.into_iter().next(),
            param_5g_mm_cause_value: intermediate_rep.param_5g_mm_cause_value.into_iter().next(),
            ue_location: intermediate_rep.ue_location.into_iter().next(),
            ue_time_zone: intermediate_rep.ue_time_zone.into_iter().next(),
            add_ue_location: intermediate_rep.add_ue_location.into_iter().next(),
            secondary_rat_usage_report: intermediate_rep
                .secondary_rat_usage_report
                .into_iter()
                .next(),
            secondary_rat_usage_info: intermediate_rep.secondary_rat_usage_info.into_iter().next(),
            n4_info: intermediate_rep.n4_info.into_iter().next(),
            n4_info_ext1: intermediate_rep.n4_info_ext1.into_iter().next(),
            n4_info_ext2: intermediate_rep.n4_info_ext2.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ReleaseData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ReleaseData>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ReleaseData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ReleaseData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ReleaseData> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ReleaseData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ReleaseData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ReleasePduSession200Response {
    #[serde(rename = "jsonData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub json_data: Option<models::ReleasedData>,

    #[serde(rename = "binaryDataN4Information")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub binary_data_n4_information: Option<swagger::ByteArray>,

    #[serde(rename = "binaryDataN4InformationExt1")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub binary_data_n4_information_ext1: Option<swagger::ByteArray>,

    #[serde(rename = "binaryDataN4InformationExt2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub binary_data_n4_information_ext2: Option<swagger::ByteArray>,
}

impl ReleasePduSession200Response {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ReleasePduSession200Response {
        ReleasePduSession200Response {
            json_data: None,
            binary_data_n4_information: None,
            binary_data_n4_information_ext1: None,
            binary_data_n4_information_ext2: None,
        }
    }
}

/// Converts the ReleasePduSession200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ReleasePduSession200Response {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping jsonData in query parameter serialization

            // Skipping binaryDataN4Information in query parameter serialization
            // Skipping binaryDataN4Information in query parameter serialization

            // Skipping binaryDataN4InformationExt1 in query parameter serialization
            // Skipping binaryDataN4InformationExt1 in query parameter serialization

            // Skipping binaryDataN4InformationExt2 in query parameter serialization
            // Skipping binaryDataN4InformationExt2 in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ReleasePduSession200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ReleasePduSession200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub json_data: Vec<models::ReleasedData>,
            pub binary_data_n4_information: Vec<swagger::ByteArray>,
            pub binary_data_n4_information_ext1: Vec<swagger::ByteArray>,
            pub binary_data_n4_information_ext2: Vec<swagger::ByteArray>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ReleasePduSession200Response".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "jsonData" => intermediate_rep.json_data.push(<models::ReleasedData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "binaryDataN4Information" => return std::result::Result::Err("Parsing binary data in this style is not supported in ReleasePduSession200Response".to_string()),
                    "binaryDataN4InformationExt1" => return std::result::Result::Err("Parsing binary data in this style is not supported in ReleasePduSession200Response".to_string()),
                    "binaryDataN4InformationExt2" => return std::result::Result::Err("Parsing binary data in this style is not supported in ReleasePduSession200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ReleasePduSession200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ReleasePduSession200Response {
            json_data: intermediate_rep.json_data.into_iter().next(),
            binary_data_n4_information: intermediate_rep
                .binary_data_n4_information
                .into_iter()
                .next(),
            binary_data_n4_information_ext1: intermediate_rep
                .binary_data_n4_information_ext1
                .into_iter()
                .next(),
            binary_data_n4_information_ext2: intermediate_rep
                .binary_data_n4_information_ext2
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ReleasePduSession200Response> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ReleasePduSession200Response>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ReleasePduSession200Response>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ReleasePduSession200Response - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ReleasePduSession200Response>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ReleasePduSession200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ReleasePduSession200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ReleasePduSessionRequest {
    #[serde(rename = "jsonData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub json_data: Option<models::ReleaseData>,

    #[serde(rename = "binaryDataN4Information")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub binary_data_n4_information: Option<swagger::ByteArray>,

    #[serde(rename = "binaryDataN4InformationExt1")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub binary_data_n4_information_ext1: Option<swagger::ByteArray>,

    #[serde(rename = "binaryDataN4InformationExt2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub binary_data_n4_information_ext2: Option<swagger::ByteArray>,
}

impl ReleasePduSessionRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ReleasePduSessionRequest {
        ReleasePduSessionRequest {
            json_data: None,
            binary_data_n4_information: None,
            binary_data_n4_information_ext1: None,
            binary_data_n4_information_ext2: None,
        }
    }
}

/// Converts the ReleasePduSessionRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ReleasePduSessionRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping jsonData in query parameter serialization

            // Skipping binaryDataN4Information in query parameter serialization
            // Skipping binaryDataN4Information in query parameter serialization

            // Skipping binaryDataN4InformationExt1 in query parameter serialization
            // Skipping binaryDataN4InformationExt1 in query parameter serialization

            // Skipping binaryDataN4InformationExt2 in query parameter serialization
            // Skipping binaryDataN4InformationExt2 in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ReleasePduSessionRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ReleasePduSessionRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub json_data: Vec<models::ReleaseData>,
            pub binary_data_n4_information: Vec<swagger::ByteArray>,
            pub binary_data_n4_information_ext1: Vec<swagger::ByteArray>,
            pub binary_data_n4_information_ext2: Vec<swagger::ByteArray>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ReleasePduSessionRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "jsonData" => intermediate_rep.json_data.push(<models::ReleaseData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "binaryDataN4Information" => return std::result::Result::Err("Parsing binary data in this style is not supported in ReleasePduSessionRequest".to_string()),
                    "binaryDataN4InformationExt1" => return std::result::Result::Err("Parsing binary data in this style is not supported in ReleasePduSessionRequest".to_string()),
                    "binaryDataN4InformationExt2" => return std::result::Result::Err("Parsing binary data in this style is not supported in ReleasePduSessionRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ReleasePduSessionRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ReleasePduSessionRequest {
            json_data: intermediate_rep.json_data.into_iter().next(),
            binary_data_n4_information: intermediate_rep
                .binary_data_n4_information
                .into_iter()
                .next(),
            binary_data_n4_information_ext1: intermediate_rep
                .binary_data_n4_information_ext1
                .into_iter()
                .next(),
            binary_data_n4_information_ext2: intermediate_rep
                .binary_data_n4_information_ext2
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ReleasePduSessionRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ReleasePduSessionRequest>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ReleasePduSessionRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ReleasePduSessionRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ReleasePduSessionRequest>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ReleasePduSessionRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ReleasePduSessionRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ReleaseSmContextRequest {
    #[serde(rename = "jsonData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub json_data: Option<models::SmContextReleaseData>,

    #[serde(rename = "binaryDataN2SmInformation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub binary_data_n2_sm_information: Option<swagger::ByteArray>,
}

impl ReleaseSmContextRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ReleaseSmContextRequest {
        ReleaseSmContextRequest {
            json_data: None,
            binary_data_n2_sm_information: None,
        }
    }
}

/// Converts the ReleaseSmContextRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ReleaseSmContextRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping jsonData in query parameter serialization

            // Skipping binaryDataN2SmInformation in query parameter serialization
            // Skipping binaryDataN2SmInformation in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ReleaseSmContextRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ReleaseSmContextRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub json_data: Vec<models::SmContextReleaseData>,
            pub binary_data_n2_sm_information: Vec<swagger::ByteArray>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ReleaseSmContextRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "jsonData" => intermediate_rep.json_data.push(<models::SmContextReleaseData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "binaryDataN2SmInformation" => return std::result::Result::Err("Parsing binary data in this style is not supported in ReleaseSmContextRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ReleaseSmContextRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ReleaseSmContextRequest {
            json_data: intermediate_rep.json_data.into_iter().next(),
            binary_data_n2_sm_information: intermediate_rep
                .binary_data_n2_sm_information
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ReleaseSmContextRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ReleaseSmContextRequest>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ReleaseSmContextRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ReleaseSmContextRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ReleaseSmContextRequest>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ReleaseSmContextRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ReleaseSmContextRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Data within Release Response
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ReleasedData {
    #[serde(rename = "smallDataRateStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub small_data_rate_status: Option<models::SmallDataRateStatus>,

    #[serde(rename = "apnRateStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub apn_rate_status: Option<models::ApnRateStatus>,

    #[serde(rename = "n4Info")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n4_info: Option<models::N4Information>,

    #[serde(rename = "n4InfoExt1")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n4_info_ext1: Option<models::N4Information>,

    #[serde(rename = "n4InfoExt2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n4_info_ext2: Option<models::N4Information>,
}

impl ReleasedData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ReleasedData {
        ReleasedData {
            small_data_rate_status: None,
            apn_rate_status: None,
            n4_info: None,
            n4_info_ext1: None,
            n4_info_ext2: None,
        }
    }
}

/// Converts the ReleasedData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ReleasedData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping smallDataRateStatus in query parameter serialization

            // Skipping apnRateStatus in query parameter serialization

            // Skipping n4Info in query parameter serialization

            // Skipping n4InfoExt1 in query parameter serialization

            // Skipping n4InfoExt2 in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ReleasedData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ReleasedData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub small_data_rate_status: Vec<models::SmallDataRateStatus>,
            pub apn_rate_status: Vec<models::ApnRateStatus>,
            pub n4_info: Vec<models::N4Information>,
            pub n4_info_ext1: Vec<models::N4Information>,
            pub n4_info_ext2: Vec<models::N4Information>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ReleasedData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "smallDataRateStatus" => intermediate_rep.small_data_rate_status.push(
                        <models::SmallDataRateStatus as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "apnRateStatus" => intermediate_rep.apn_rate_status.push(
                        <models::ApnRateStatus as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n4Info" => intermediate_rep.n4_info.push(
                        <models::N4Information as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n4InfoExt1" => intermediate_rep.n4_info_ext1.push(
                        <models::N4Information as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n4InfoExt2" => intermediate_rep.n4_info_ext2.push(
                        <models::N4Information as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ReleasedData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ReleasedData {
            small_data_rate_status: intermediate_rep.small_data_rate_status.into_iter().next(),
            apn_rate_status: intermediate_rep.apn_rate_status.into_iter().next(),
            n4_info: intermediate_rep.n4_info.into_iter().next(),
            n4_info_ext1: intermediate_rep.n4_info_ext1.into_iter().next(),
            n4_info_ext2: intermediate_rep.n4_info_ext2.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ReleasedData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ReleasedData>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ReleasedData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ReleasedData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ReleasedData> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ReleasedData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ReleasedData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Request Indication in Update (SM context) service operation. Possible values are - UE_REQ_PDU_SES_MOD - UE_REQ_PDU_SES_REL - PDU_SES_MOB - NW_REQ_PDU_SES_AUTH - NW_REQ_PDU_SES_MOD - NW_REQ_PDU_SES_REL - EBI_ASSIGNMENT_REQ - REL_DUE_TO_5G_AN_REQUEST
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RequestIndication {}

impl RequestIndication {
    #[allow(clippy::new_without_default)]
    pub fn new() -> RequestIndication {
        RequestIndication {}
    }
}

/// Converts the RequestIndication value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RequestIndication {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RequestIndication value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RequestIndication {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing RequestIndication".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing RequestIndication".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RequestIndication {})
    }
}

// Methods for converting between header::IntoHeaderValue<RequestIndication> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RequestIndication>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<RequestIndication>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for RequestIndication - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<RequestIndication>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <RequestIndication as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into RequestIndication - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum RequestIndicationAnyOf {
    #[serde(rename = "UE_REQ_PDU_SES_MOD")]
    UeReqPduSesMod,
    #[serde(rename = "UE_REQ_PDU_SES_REL")]
    UeReqPduSesRel,
    #[serde(rename = "PDU_SES_MOB")]
    PduSesMob,
    #[serde(rename = "NW_REQ_PDU_SES_AUTH")]
    NwReqPduSesAuth,
    #[serde(rename = "NW_REQ_PDU_SES_MOD")]
    NwReqPduSesMod,
    #[serde(rename = "NW_REQ_PDU_SES_REL")]
    NwReqPduSesRel,
    #[serde(rename = "EBI_ASSIGNMENT_REQ")]
    EbiAssignmentReq,
    #[serde(rename = "REL_DUE_TO_5G_AN_REQUEST")]
    RelDueTo5GAnRequest,
}

impl std::fmt::Display for RequestIndicationAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            RequestIndicationAnyOf::UeReqPduSesMod => write!(f, "UE_REQ_PDU_SES_MOD"),
            RequestIndicationAnyOf::UeReqPduSesRel => write!(f, "UE_REQ_PDU_SES_REL"),
            RequestIndicationAnyOf::PduSesMob => write!(f, "PDU_SES_MOB"),
            RequestIndicationAnyOf::NwReqPduSesAuth => write!(f, "NW_REQ_PDU_SES_AUTH"),
            RequestIndicationAnyOf::NwReqPduSesMod => write!(f, "NW_REQ_PDU_SES_MOD"),
            RequestIndicationAnyOf::NwReqPduSesRel => write!(f, "NW_REQ_PDU_SES_REL"),
            RequestIndicationAnyOf::EbiAssignmentReq => write!(f, "EBI_ASSIGNMENT_REQ"),
            RequestIndicationAnyOf::RelDueTo5GAnRequest => write!(f, "REL_DUE_TO_5G_AN_REQUEST"),
        }
    }
}

impl std::str::FromStr for RequestIndicationAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "UE_REQ_PDU_SES_MOD" => std::result::Result::Ok(RequestIndicationAnyOf::UeReqPduSesMod),
            "UE_REQ_PDU_SES_REL" => std::result::Result::Ok(RequestIndicationAnyOf::UeReqPduSesRel),
            "PDU_SES_MOB" => std::result::Result::Ok(RequestIndicationAnyOf::PduSesMob),
            "NW_REQ_PDU_SES_AUTH" => {
                std::result::Result::Ok(RequestIndicationAnyOf::NwReqPduSesAuth)
            }
            "NW_REQ_PDU_SES_MOD" => std::result::Result::Ok(RequestIndicationAnyOf::NwReqPduSesMod),
            "NW_REQ_PDU_SES_REL" => std::result::Result::Ok(RequestIndicationAnyOf::NwReqPduSesRel),
            "EBI_ASSIGNMENT_REQ" => {
                std::result::Result::Ok(RequestIndicationAnyOf::EbiAssignmentReq)
            }
            "REL_DUE_TO_5G_AN_REQUEST" => {
                std::result::Result::Ok(RequestIndicationAnyOf::RelDueTo5GAnRequest)
            }
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Request Type in Create (SM context) service operation. Possible values are - INITIAL_REQUEST - EXISTING_PDU_SESSION - INITIAL_EMERGENCY_REQUEST - EXISTING_EMERGENCY_PDU_SESSION
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RequestType {}

impl RequestType {
    #[allow(clippy::new_without_default)]
    pub fn new() -> RequestType {
        RequestType {}
    }
}

/// Converts the RequestType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RequestType {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RequestType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RequestType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing RequestType".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing RequestType".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RequestType {})
    }
}

// Methods for converting between header::IntoHeaderValue<RequestType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RequestType>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<RequestType>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for RequestType - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<RequestType> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <RequestType as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into RequestType - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum RequestTypeAnyOf {
    #[serde(rename = "INITIAL_REQUEST")]
    InitialRequest,
    #[serde(rename = "EXISTING_PDU_SESSION")]
    ExistingPduSession,
    #[serde(rename = "INITIAL_EMERGENCY_REQUEST")]
    InitialEmergencyRequest,
    #[serde(rename = "EXISTING_EMERGENCY_PDU_SESSION")]
    ExistingEmergencyPduSession,
}

impl std::fmt::Display for RequestTypeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            RequestTypeAnyOf::InitialRequest => write!(f, "INITIAL_REQUEST"),
            RequestTypeAnyOf::ExistingPduSession => write!(f, "EXISTING_PDU_SESSION"),
            RequestTypeAnyOf::InitialEmergencyRequest => write!(f, "INITIAL_EMERGENCY_REQUEST"),
            RequestTypeAnyOf::ExistingEmergencyPduSession => {
                write!(f, "EXISTING_EMERGENCY_PDU_SESSION")
            }
        }
    }
}

impl std::str::FromStr for RequestTypeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "INITIAL_REQUEST" => std::result::Result::Ok(RequestTypeAnyOf::InitialRequest),
            "EXISTING_PDU_SESSION" => std::result::Result::Ok(RequestTypeAnyOf::ExistingPduSession),
            "INITIAL_EMERGENCY_REQUEST" => {
                std::result::Result::Ok(RequestTypeAnyOf::InitialEmergencyRequest)
            }
            "EXISTING_EMERGENCY_PDU_SESSION" => {
                std::result::Result::Ok(RequestTypeAnyOf::ExistingEmergencyPduSession)
            }
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Status of SM context or PDU session resource. Possible values are - RELEASED - UNCHANGED - TRANSFERRED - UPDATED - ALT_ANCHOR_SMF
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ResourceStatus {}

impl ResourceStatus {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ResourceStatus {
        ResourceStatus {}
    }
}

/// Converts the ResourceStatus value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ResourceStatus {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ResourceStatus value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ResourceStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ResourceStatus".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ResourceStatus".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ResourceStatus {})
    }
}

// Methods for converting between header::IntoHeaderValue<ResourceStatus> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ResourceStatus>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ResourceStatus>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ResourceStatus - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ResourceStatus> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ResourceStatus as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ResourceStatus - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ResourceStatusAnyOf {
    #[serde(rename = "RELEASED")]
    Released,
    #[serde(rename = "UNCHANGED")]
    Unchanged,
    #[serde(rename = "TRANSFERRED")]
    Transferred,
    #[serde(rename = "UPDATED")]
    Updated,
    #[serde(rename = "ALT_ANCHOR_SMF")]
    AltAnchorSmf,
}

impl std::fmt::Display for ResourceStatusAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ResourceStatusAnyOf::Released => write!(f, "RELEASED"),
            ResourceStatusAnyOf::Unchanged => write!(f, "UNCHANGED"),
            ResourceStatusAnyOf::Transferred => write!(f, "TRANSFERRED"),
            ResourceStatusAnyOf::Updated => write!(f, "UPDATED"),
            ResourceStatusAnyOf::AltAnchorSmf => write!(f, "ALT_ANCHOR_SMF"),
        }
    }
}

impl std::str::FromStr for ResourceStatusAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "RELEASED" => std::result::Result::Ok(ResourceStatusAnyOf::Released),
            "UNCHANGED" => std::result::Result::Ok(ResourceStatusAnyOf::Unchanged),
            "TRANSFERRED" => std::result::Result::Ok(ResourceStatusAnyOf::Transferred),
            "UPDATED" => std::result::Result::Ok(ResourceStatusAnyOf::Updated),
            "ALT_ANCHOR_SMF" => std::result::Result::Ok(ResourceStatusAnyOf::AltAnchorSmf),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Data within Retrieve Request
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RetrieveData {
    #[serde(rename = "smallDataRateStatusReq")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub small_data_rate_status_req: Option<bool>,

    #[serde(rename = "pduSessionContextType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pdu_session_context_type: Option<models::PduSessionContextType>,
}

impl RetrieveData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> RetrieveData {
        RetrieveData {
            small_data_rate_status_req: Some(false),
            pdu_session_context_type: None,
        }
    }
}

/// Converts the RetrieveData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RetrieveData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.small_data_rate_status_req
                .as_ref()
                .map(|small_data_rate_status_req| {
                    vec![
                        "smallDataRateStatusReq".to_string(),
                        small_data_rate_status_req.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping pduSessionContextType in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RetrieveData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RetrieveData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub small_data_rate_status_req: Vec<bool>,
            pub pdu_session_context_type: Vec<models::PduSessionContextType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing RetrieveData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "smallDataRateStatusReq" => intermediate_rep.small_data_rate_status_req.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "pduSessionContextType" => intermediate_rep.pdu_session_context_type.push(
                        <models::PduSessionContextType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing RetrieveData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RetrieveData {
            small_data_rate_status_req: intermediate_rep
                .small_data_rate_status_req
                .into_iter()
                .next(),
            pdu_session_context_type: intermediate_rep.pdu_session_context_type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RetrieveData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RetrieveData>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<RetrieveData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for RetrieveData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<RetrieveData> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <RetrieveData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into RetrieveData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Data within Retrieve Response
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RetrievedData {
    #[serde(rename = "smallDataRateStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub small_data_rate_status: Option<models::SmallDataRateStatus>,

    #[serde(rename = "afCoordinationInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub af_coordination_info: Option<models::AfCoordinationInfo>,
}

impl RetrievedData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> RetrievedData {
        RetrievedData {
            small_data_rate_status: None,
            af_coordination_info: None,
        }
    }
}

/// Converts the RetrievedData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RetrievedData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping smallDataRateStatus in query parameter serialization

            // Skipping afCoordinationInfo in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RetrievedData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RetrievedData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub small_data_rate_status: Vec<models::SmallDataRateStatus>,
            pub af_coordination_info: Vec<models::AfCoordinationInfo>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing RetrievedData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "smallDataRateStatus" => intermediate_rep.small_data_rate_status.push(
                        <models::SmallDataRateStatus as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "afCoordinationInfo" => intermediate_rep.af_coordination_info.push(
                        <models::AfCoordinationInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing RetrievedData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RetrievedData {
            small_data_rate_status: intermediate_rep.small_data_rate_status.into_iter().next(),
            af_coordination_info: intermediate_rep.af_coordination_info.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RetrievedData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RetrievedData>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<RetrievedData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for RetrievedData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<RetrievedData> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <RetrievedData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into RetrievedData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RoamingChargingProfile {
    #[serde(rename = "triggers")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub triggers: Option<Vec<models::Trigger>>,

    #[serde(rename = "partialRecordMethod")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub partial_record_method: Option<models::PartialRecordMethod>,
}

impl RoamingChargingProfile {
    #[allow(clippy::new_without_default)]
    pub fn new() -> RoamingChargingProfile {
        RoamingChargingProfile {
            triggers: None,
            partial_record_method: None,
        }
    }
}

/// Converts the RoamingChargingProfile value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RoamingChargingProfile {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping triggers in query parameter serialization

            // Skipping partialRecordMethod in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RoamingChargingProfile value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RoamingChargingProfile {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub triggers: Vec<Vec<models::Trigger>>,
            pub partial_record_method: Vec<models::PartialRecordMethod>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing RoamingChargingProfile".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "triggers" => return std::result::Result::Err("Parsing a container in this style is not supported in RoamingChargingProfile".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "partialRecordMethod" => intermediate_rep.partial_record_method.push(<models::PartialRecordMethod as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RoamingChargingProfile".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RoamingChargingProfile {
            triggers: intermediate_rep.triggers.into_iter().next(),
            partial_record_method: intermediate_rep.partial_record_method.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RoamingChargingProfile> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RoamingChargingProfile>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<RoamingChargingProfile>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for RoamingChargingProfile - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<RoamingChargingProfile>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <RoamingChargingProfile as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into RoamingChargingProfile - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains a Routing Area Identification as defined in 3GPP TS 23.003, clause 4.2.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RoutingAreaId {
    #[serde(rename = "plmnId")]
    pub plmn_id: models::PlmnId,

    /// Location Area Code
    #[serde(rename = "lac")]
    pub lac: String,

    /// Routing Area Code
    #[serde(rename = "rac")]
    pub rac: String,
}

impl RoutingAreaId {
    #[allow(clippy::new_without_default)]
    pub fn new(plmn_id: models::PlmnId, lac: String, rac: String) -> RoutingAreaId {
        RoutingAreaId { plmn_id, lac, rac }
    }
}

/// Converts the RoutingAreaId value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RoutingAreaId {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping plmnId in query parameter serialization
            Some("lac".to_string()),
            Some(self.lac.to_string()),
            Some("rac".to_string()),
            Some(self.rac.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RoutingAreaId value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RoutingAreaId {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub plmn_id: Vec<models::PlmnId>,
            pub lac: Vec<String>,
            pub rac: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing RoutingAreaId".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "plmnId" => intermediate_rep.plmn_id.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "lac" => intermediate_rep.lac.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "rac" => intermediate_rep.rac.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing RoutingAreaId".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RoutingAreaId {
            plmn_id: intermediate_rep
                .plmn_id
                .into_iter()
                .next()
                .ok_or_else(|| "plmnId missing in RoutingAreaId".to_string())?,
            lac: intermediate_rep
                .lac
                .into_iter()
                .next()
                .ok_or_else(|| "lac missing in RoutingAreaId".to_string())?,
            rac: intermediate_rep
                .rac
                .into_iter()
                .next()
                .ok_or_else(|| "rac missing in RoutingAreaId".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RoutingAreaId> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RoutingAreaId>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<RoutingAreaId>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for RoutingAreaId - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<RoutingAreaId> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <RoutingAreaId as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into RoutingAreaId - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Redundancy Sequence Number. Possible values are   - V1   - V2   - NONE
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Rsn {}

impl Rsn {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Rsn {
        Rsn {}
    }
}

/// Converts the Rsn value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Rsn {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Rsn value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Rsn {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err("Missing value while parsing Rsn".to_string())
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Rsn".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Rsn {})
    }
}

// Methods for converting between header::IntoHeaderValue<Rsn> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Rsn>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Rsn>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Rsn - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Rsn> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Rsn as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Rsn - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum RsnAnyOf {
    #[serde(rename = "V1")]
    V1,
    #[serde(rename = "V2")]
    V2,
    #[serde(rename = "NONE")]
    None,
}

impl std::fmt::Display for RsnAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            RsnAnyOf::V1 => write!(f, "V1"),
            RsnAnyOf::V2 => write!(f, "V2"),
            RsnAnyOf::None => write!(f, "NONE"),
        }
    }
}

impl std::str::FromStr for RsnAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "V1" => std::result::Result::Ok(RsnAnyOf::V1),
            "V2" => std::result::Result::Ok(RsnAnyOf::V2),
            "NONE" => std::result::Result::Ok(RsnAnyOf::None),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Indicates the satellite backhaul used.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SatelliteBackhaulCategory {}

impl SatelliteBackhaulCategory {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SatelliteBackhaulCategory {
        SatelliteBackhaulCategory {}
    }
}

/// Converts the SatelliteBackhaulCategory value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SatelliteBackhaulCategory {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SatelliteBackhaulCategory value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SatelliteBackhaulCategory {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SatelliteBackhaulCategory".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SatelliteBackhaulCategory".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SatelliteBackhaulCategory {})
    }
}

// Methods for converting between header::IntoHeaderValue<SatelliteBackhaulCategory> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SatelliteBackhaulCategory>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SatelliteBackhaulCategory>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SatelliteBackhaulCategory - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SatelliteBackhaulCategory>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SatelliteBackhaulCategory as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SatelliteBackhaulCategory - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum SatelliteBackhaulCategoryAnyOf {
    #[serde(rename = "GEO")]
    Geo,
    #[serde(rename = "MEO")]
    Meo,
    #[serde(rename = "LEO")]
    Leo,
    #[serde(rename = "OTHER_SAT")]
    OtherSat,
    #[serde(rename = "NON_SATELLITE")]
    NonSatellite,
}

impl std::fmt::Display for SatelliteBackhaulCategoryAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            SatelliteBackhaulCategoryAnyOf::Geo => write!(f, "GEO"),
            SatelliteBackhaulCategoryAnyOf::Meo => write!(f, "MEO"),
            SatelliteBackhaulCategoryAnyOf::Leo => write!(f, "LEO"),
            SatelliteBackhaulCategoryAnyOf::OtherSat => write!(f, "OTHER_SAT"),
            SatelliteBackhaulCategoryAnyOf::NonSatellite => write!(f, "NON_SATELLITE"),
        }
    }
}

impl std::str::FromStr for SatelliteBackhaulCategoryAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "GEO" => std::result::Result::Ok(SatelliteBackhaulCategoryAnyOf::Geo),
            "MEO" => std::result::Result::Ok(SatelliteBackhaulCategoryAnyOf::Meo),
            "LEO" => std::result::Result::Ok(SatelliteBackhaulCategoryAnyOf::Leo),
            "OTHER_SAT" => std::result::Result::Ok(SatelliteBackhaulCategoryAnyOf::OtherSat),
            "NON_SATELLITE" => {
                std::result::Result::Ok(SatelliteBackhaulCategoryAnyOf::NonSatellite)
            }
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// SBI Binding Level
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SbiBindingLevel {}

impl SbiBindingLevel {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SbiBindingLevel {
        SbiBindingLevel {}
    }
}

/// Converts the SbiBindingLevel value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SbiBindingLevel {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SbiBindingLevel value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SbiBindingLevel {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SbiBindingLevel".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SbiBindingLevel".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SbiBindingLevel {})
    }
}

// Methods for converting between header::IntoHeaderValue<SbiBindingLevel> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SbiBindingLevel>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SbiBindingLevel>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SbiBindingLevel - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SbiBindingLevel>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SbiBindingLevel as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SbiBindingLevel - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum SbiBindingLevelAnyOf {
    #[serde(rename = "NF_INSTANCE_BINDING")]
    InstanceBinding,
    #[serde(rename = "NF_SET_BINDING")]
    SetBinding,
    #[serde(rename = "NF_SERVICE_SET_BINDING")]
    ServiceSetBinding,
    #[serde(rename = "NF_SERVICE_INSTANCE_BINDING")]
    ServiceInstanceBinding,
}

impl std::fmt::Display for SbiBindingLevelAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            SbiBindingLevelAnyOf::InstanceBinding => write!(f, "NF_INSTANCE_BINDING"),
            SbiBindingLevelAnyOf::SetBinding => write!(f, "NF_SET_BINDING"),
            SbiBindingLevelAnyOf::ServiceSetBinding => write!(f, "NF_SERVICE_SET_BINDING"),
            SbiBindingLevelAnyOf::ServiceInstanceBinding => {
                write!(f, "NF_SERVICE_INSTANCE_BINDING")
            }
        }
    }
}

impl std::str::FromStr for SbiBindingLevelAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "NF_INSTANCE_BINDING" => std::result::Result::Ok(SbiBindingLevelAnyOf::InstanceBinding),
            "NF_SET_BINDING" => std::result::Result::Ok(SbiBindingLevelAnyOf::SetBinding),
            "NF_SERVICE_SET_BINDING" => {
                std::result::Result::Ok(SbiBindingLevelAnyOf::ServiceSetBinding)
            }
            "NF_SERVICE_INSTANCE_BINDING" => {
                std::result::Result::Ok(SbiBindingLevelAnyOf::ServiceInstanceBinding)
            }
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Identifies time and day of the week when the UE is available for communication.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ScheduledCommunicationTime {
    /// Identifies the day(s) of the week. If absent, it indicates every day of the week.
    #[serde(rename = "daysOfWeek")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub days_of_week: Option<Vec<models::DayOfWeek>>,

    /// String with format partial-time or full-time as defined in clause 5.6 of IETF RFC 3339. Examples, 20:15:00, 20:15:00-08:00 (for 8 hours behind UTC).
    #[serde(rename = "timeOfDayStart")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub time_of_day_start: Option<String>,

    /// String with format partial-time or full-time as defined in clause 5.6 of IETF RFC 3339. Examples, 20:15:00, 20:15:00-08:00 (for 8 hours behind UTC).
    #[serde(rename = "timeOfDayEnd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub time_of_day_end: Option<String>,
}

impl ScheduledCommunicationTime {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ScheduledCommunicationTime {
        ScheduledCommunicationTime {
            days_of_week: None,
            time_of_day_start: None,
            time_of_day_end: None,
        }
    }
}

/// Converts the ScheduledCommunicationTime value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ScheduledCommunicationTime {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.days_of_week.as_ref().map(|days_of_week| {
                vec![
                    "daysOfWeek".to_string(),
                    days_of_week
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.time_of_day_start.as_ref().map(|time_of_day_start| {
                vec!["timeOfDayStart".to_string(), time_of_day_start.to_string()].join(",")
            }),
            self.time_of_day_end.as_ref().map(|time_of_day_end| {
                vec!["timeOfDayEnd".to_string(), time_of_day_end.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ScheduledCommunicationTime value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ScheduledCommunicationTime {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub days_of_week: Vec<Vec<models::DayOfWeek>>,
            pub time_of_day_start: Vec<String>,
            pub time_of_day_end: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ScheduledCommunicationTime".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "daysOfWeek" => return std::result::Result::Err("Parsing a container in this style is not supported in ScheduledCommunicationTime".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "timeOfDayStart" => intermediate_rep.time_of_day_start.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "timeOfDayEnd" => intermediate_rep.time_of_day_end.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ScheduledCommunicationTime".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ScheduledCommunicationTime {
            days_of_week: intermediate_rep.days_of_week.into_iter().next(),
            time_of_day_start: intermediate_rep.time_of_day_start.into_iter().next(),
            time_of_day_end: intermediate_rep.time_of_day_end.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ScheduledCommunicationTime> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ScheduledCommunicationTime>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ScheduledCommunicationTime>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ScheduledCommunicationTime - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ScheduledCommunicationTime>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ScheduledCommunicationTime as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ScheduledCommunicationTime - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Possible values are: -DOWNLINK_ONLY: Downlink only -UPLINK_ONLY: Uplink only -BIDIRECTIONA: Bi-directional
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ScheduledCommunicationType {}

impl ScheduledCommunicationType {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ScheduledCommunicationType {
        ScheduledCommunicationType {}
    }
}

/// Converts the ScheduledCommunicationType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ScheduledCommunicationType {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ScheduledCommunicationType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ScheduledCommunicationType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ScheduledCommunicationType".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ScheduledCommunicationType".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ScheduledCommunicationType {})
    }
}

// Methods for converting between header::IntoHeaderValue<ScheduledCommunicationType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ScheduledCommunicationType>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ScheduledCommunicationType>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ScheduledCommunicationType - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ScheduledCommunicationType>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ScheduledCommunicationType as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ScheduledCommunicationType - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ScheduledCommunicationTypeAnyOf {
    #[serde(rename = "DOWNLINK_ONLY")]
    DownlinkOnly,
    #[serde(rename = "UPLINK_ONLY")]
    UplinkOnly,
    #[serde(rename = "BIDIRECTIONAL")]
    Bidirectional,
}

impl std::fmt::Display for ScheduledCommunicationTypeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ScheduledCommunicationTypeAnyOf::DownlinkOnly => write!(f, "DOWNLINK_ONLY"),
            ScheduledCommunicationTypeAnyOf::UplinkOnly => write!(f, "UPLINK_ONLY"),
            ScheduledCommunicationTypeAnyOf::Bidirectional => write!(f, "BIDIRECTIONAL"),
        }
    }
}

impl std::str::FromStr for ScheduledCommunicationTypeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "DOWNLINK_ONLY" => {
                std::result::Result::Ok(ScheduledCommunicationTypeAnyOf::DownlinkOnly)
            }
            "UPLINK_ONLY" => std::result::Result::Ok(ScheduledCommunicationTypeAnyOf::UplinkOnly),
            "BIDIRECTIONAL" => {
                std::result::Result::Ok(ScheduledCommunicationTypeAnyOf::Bidirectional)
            }
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Secondary Rat Usage Data Report Container
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SecondaryRatUsageDataReportContainer(swagger::ByteArray);

impl std::convert::From<swagger::ByteArray> for SecondaryRatUsageDataReportContainer {
    fn from(x: swagger::ByteArray) -> Self {
        SecondaryRatUsageDataReportContainer(x)
    }
}

impl std::convert::From<SecondaryRatUsageDataReportContainer> for swagger::ByteArray {
    fn from(x: SecondaryRatUsageDataReportContainer) -> Self {
        x.0
    }
}

impl std::ops::Deref for SecondaryRatUsageDataReportContainer {
    type Target = swagger::ByteArray;
    fn deref(&self) -> &swagger::ByteArray {
        &self.0
    }
}

impl std::ops::DerefMut for SecondaryRatUsageDataReportContainer {
    fn deref_mut(&mut self) -> &mut swagger::ByteArray {
        &mut self.0
    }
}

/// Secondary RAT Usage Information to report usage data for a secondary RAT for QoS flows and/or the whole PDU session.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SecondaryRatUsageInfo {
    #[serde(rename = "secondaryRatType")]
    pub secondary_rat_type: models::RatType,

    #[serde(rename = "qosFlowsUsageData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub qos_flows_usage_data: Option<Vec<models::QosFlowUsageReport>>,

    #[serde(rename = "pduSessionUsageData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pdu_session_usage_data: Option<Vec<models::VolumeTimedReport>>,
}

impl SecondaryRatUsageInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(secondary_rat_type: models::RatType) -> SecondaryRatUsageInfo {
        SecondaryRatUsageInfo {
            secondary_rat_type,
            qos_flows_usage_data: None,
            pdu_session_usage_data: None,
        }
    }
}

/// Converts the SecondaryRatUsageInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SecondaryRatUsageInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping secondaryRatType in query parameter serialization

            // Skipping qosFlowsUsageData in query parameter serialization

            // Skipping pduSessionUsageData in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SecondaryRatUsageInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SecondaryRatUsageInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub secondary_rat_type: Vec<models::RatType>,
            pub qos_flows_usage_data: Vec<Vec<models::QosFlowUsageReport>>,
            pub pdu_session_usage_data: Vec<Vec<models::VolumeTimedReport>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SecondaryRatUsageInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "secondaryRatType" => intermediate_rep.secondary_rat_type.push(<models::RatType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "qosFlowsUsageData" => return std::result::Result::Err("Parsing a container in this style is not supported in SecondaryRatUsageInfo".to_string()),
                    "pduSessionUsageData" => return std::result::Result::Err("Parsing a container in this style is not supported in SecondaryRatUsageInfo".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing SecondaryRatUsageInfo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SecondaryRatUsageInfo {
            secondary_rat_type: intermediate_rep
                .secondary_rat_type
                .into_iter()
                .next()
                .ok_or_else(|| "secondaryRatType missing in SecondaryRatUsageInfo".to_string())?,
            qos_flows_usage_data: intermediate_rep.qos_flows_usage_data.into_iter().next(),
            pdu_session_usage_data: intermediate_rep.pdu_session_usage_data.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SecondaryRatUsageInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SecondaryRatUsageInfo>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SecondaryRatUsageInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SecondaryRatUsageInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SecondaryRatUsageInfo>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SecondaryRatUsageInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SecondaryRatUsageInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Secondary RAT Usage Report to report usage data for a secondary RAT for QoS flows.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SecondaryRatUsageReport {
    #[serde(rename = "secondaryRatType")]
    pub secondary_rat_type: models::RatType,

    #[serde(rename = "qosFlowsUsageData")]
    pub qos_flows_usage_data: Vec<models::QosFlowUsageReport>,
}

impl SecondaryRatUsageReport {
    #[allow(clippy::new_without_default)]
    pub fn new(
        secondary_rat_type: models::RatType,
        qos_flows_usage_data: Vec<models::QosFlowUsageReport>,
    ) -> SecondaryRatUsageReport {
        SecondaryRatUsageReport {
            secondary_rat_type,
            qos_flows_usage_data,
        }
    }
}

/// Converts the SecondaryRatUsageReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SecondaryRatUsageReport {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping secondaryRatType in query parameter serialization

            // Skipping qosFlowsUsageData in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SecondaryRatUsageReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SecondaryRatUsageReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub secondary_rat_type: Vec<models::RatType>,
            pub qos_flows_usage_data: Vec<Vec<models::QosFlowUsageReport>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SecondaryRatUsageReport".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "secondaryRatType" => intermediate_rep.secondary_rat_type.push(<models::RatType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "qosFlowsUsageData" => return std::result::Result::Err("Parsing a container in this style is not supported in SecondaryRatUsageReport".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing SecondaryRatUsageReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SecondaryRatUsageReport {
            secondary_rat_type: intermediate_rep
                .secondary_rat_type
                .into_iter()
                .next()
                .ok_or_else(|| "secondaryRatType missing in SecondaryRatUsageReport".to_string())?,
            qos_flows_usage_data: intermediate_rep
                .qos_flows_usage_data
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "qosFlowsUsageData missing in SecondaryRatUsageReport".to_string()
                })?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SecondaryRatUsageReport> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SecondaryRatUsageReport>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SecondaryRatUsageReport>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SecondaryRatUsageReport - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SecondaryRatUsageReport>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SecondaryRatUsageReport as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SecondaryRatUsageReport - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Security Result
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SecurityResult {
    #[serde(rename = "integrityProtectionResult")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub integrity_protection_result: Option<models::ProtectionResult>,

    #[serde(rename = "confidentialityProtectionResult")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub confidentiality_protection_result: Option<models::ProtectionResult>,
}

impl SecurityResult {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SecurityResult {
        SecurityResult {
            integrity_protection_result: None,
            confidentiality_protection_result: None,
        }
    }
}

/// Converts the SecurityResult value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SecurityResult {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping integrityProtectionResult in query parameter serialization

            // Skipping confidentialityProtectionResult in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SecurityResult value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SecurityResult {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub integrity_protection_result: Vec<models::ProtectionResult>,
            pub confidentiality_protection_result: Vec<models::ProtectionResult>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SecurityResult".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "integrityProtectionResult" => {
                        intermediate_rep.integrity_protection_result.push(
                            <models::ProtectionResult as std::str::FromStr>::from_str(val)
                                .map_err(|x| x.to_string())?,
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "confidentialityProtectionResult" => {
                        intermediate_rep.confidentiality_protection_result.push(
                            <models::ProtectionResult as std::str::FromStr>::from_str(val)
                                .map_err(|x| x.to_string())?,
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SecurityResult".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SecurityResult {
            integrity_protection_result: intermediate_rep
                .integrity_protection_result
                .into_iter()
                .next(),
            confidentiality_protection_result: intermediate_rep
                .confidentiality_protection_result
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SecurityResult> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SecurityResult>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SecurityResult>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SecurityResult - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SecurityResult> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SecurityResult as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SecurityResult - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Data within Send MO Data Request
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SendMoDataReqData {
    #[serde(rename = "moData")]
    pub mo_data: models::RefToBinaryData,

    #[serde(rename = "moExpDataCounter")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mo_exp_data_counter: Option<models::MoExpDataCounter>,

    #[serde(rename = "ueLocation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_location: Option<models::UserLocation>,
}

impl SendMoDataReqData {
    #[allow(clippy::new_without_default)]
    pub fn new(mo_data: models::RefToBinaryData) -> SendMoDataReqData {
        SendMoDataReqData {
            mo_data,
            mo_exp_data_counter: None,
            ue_location: None,
        }
    }
}

/// Converts the SendMoDataReqData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SendMoDataReqData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping moData in query parameter serialization

            // Skipping moExpDataCounter in query parameter serialization

            // Skipping ueLocation in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SendMoDataReqData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SendMoDataReqData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub mo_data: Vec<models::RefToBinaryData>,
            pub mo_exp_data_counter: Vec<models::MoExpDataCounter>,
            pub ue_location: Vec<models::UserLocation>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SendMoDataReqData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "moData" => intermediate_rep.mo_data.push(
                        <models::RefToBinaryData as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "moExpDataCounter" => intermediate_rep.mo_exp_data_counter.push(
                        <models::MoExpDataCounter as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ueLocation" => intermediate_rep.ue_location.push(
                        <models::UserLocation as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SendMoDataReqData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SendMoDataReqData {
            mo_data: intermediate_rep
                .mo_data
                .into_iter()
                .next()
                .ok_or_else(|| "moData missing in SendMoDataReqData".to_string())?,
            mo_exp_data_counter: intermediate_rep.mo_exp_data_counter.into_iter().next(),
            ue_location: intermediate_rep.ue_location.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SendMoDataReqData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SendMoDataReqData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SendMoDataReqData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SendMoDataReqData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SendMoDataReqData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SendMoDataReqData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SendMoDataReqData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SendMoDataRequest {
    #[serde(rename = "jsonData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub json_data: Option<models::SendMoDataReqData>,

    #[serde(rename = "binaryMoData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub binary_mo_data: Option<swagger::ByteArray>,
}

impl SendMoDataRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SendMoDataRequest {
        SendMoDataRequest {
            json_data: None,
            binary_mo_data: None,
        }
    }
}

/// Converts the SendMoDataRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SendMoDataRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping jsonData in query parameter serialization

            // Skipping binaryMoData in query parameter serialization
            // Skipping binaryMoData in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SendMoDataRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SendMoDataRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub json_data: Vec<models::SendMoDataReqData>,
            pub binary_mo_data: Vec<swagger::ByteArray>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SendMoDataRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "jsonData" => intermediate_rep.json_data.push(
                        <models::SendMoDataReqData as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "binaryMoData" => return std::result::Result::Err(
                        "Parsing binary data in this style is not supported in SendMoDataRequest"
                            .to_string(),
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SendMoDataRequest".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SendMoDataRequest {
            json_data: intermediate_rep.json_data.into_iter().next(),
            binary_mo_data: intermediate_rep.binary_mo_data.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SendMoDataRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SendMoDataRequest>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SendMoDataRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SendMoDataRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SendMoDataRequest>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SendMoDataRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SendMoDataRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains addressing information (IP addresses and/or FQDNs) of a server.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ServerAddressingInfo {
    #[serde(rename = "ipv4Addresses")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv4_addresses: Option<Vec<models::Ipv4Addr>>,

    #[serde(rename = "ipv6Addresses")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_addresses: Option<Vec<models::Ipv6Addr>>,

    #[serde(rename = "fqdnList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fqdn_list: Option<Vec<models::Fqdn>>,
}

impl ServerAddressingInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ServerAddressingInfo {
        ServerAddressingInfo {
            ipv4_addresses: None,
            ipv6_addresses: None,
            fqdn_list: None,
        }
    }
}

/// Converts the ServerAddressingInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ServerAddressingInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.ipv4_addresses.as_ref().map(|ipv4_addresses| {
                vec![
                    "ipv4Addresses".to_string(),
                    ipv4_addresses
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping ipv6Addresses in query parameter serialization
            self.fqdn_list.as_ref().map(|fqdn_list| {
                vec![
                    "fqdnList".to_string(),
                    fqdn_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ServerAddressingInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ServerAddressingInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ipv4_addresses: Vec<Vec<models::Ipv4Addr>>,
            pub ipv6_addresses: Vec<Vec<models::Ipv6Addr>>,
            pub fqdn_list: Vec<Vec<models::Fqdn>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ServerAddressingInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "ipv4Addresses" => return std::result::Result::Err("Parsing a container in this style is not supported in ServerAddressingInfo".to_string()),
                    "ipv6Addresses" => return std::result::Result::Err("Parsing a container in this style is not supported in ServerAddressingInfo".to_string()),
                    "fqdnList" => return std::result::Result::Err("Parsing a container in this style is not supported in ServerAddressingInfo".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ServerAddressingInfo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ServerAddressingInfo {
            ipv4_addresses: intermediate_rep.ipv4_addresses.into_iter().next(),
            ipv6_addresses: intermediate_rep.ipv6_addresses.into_iter().next(),
            fqdn_list: intermediate_rep.fqdn_list.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ServerAddressingInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ServerAddressingInfo>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ServerAddressingInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ServerAddressingInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ServerAddressingInfo>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ServerAddressingInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ServerAddressingInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains a Service Area Identifier as defined in 3GPP TS 23.003, clause 12.5.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ServiceAreaId {
    #[serde(rename = "plmnId")]
    pub plmn_id: models::PlmnId,

    /// Location Area Code.
    #[serde(rename = "lac")]
    pub lac: String,

    /// Service Area Code.
    #[serde(rename = "sac")]
    pub sac: String,
}

impl ServiceAreaId {
    #[allow(clippy::new_without_default)]
    pub fn new(plmn_id: models::PlmnId, lac: String, sac: String) -> ServiceAreaId {
        ServiceAreaId { plmn_id, lac, sac }
    }
}

/// Converts the ServiceAreaId value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ServiceAreaId {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping plmnId in query parameter serialization
            Some("lac".to_string()),
            Some(self.lac.to_string()),
            Some("sac".to_string()),
            Some(self.sac.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ServiceAreaId value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ServiceAreaId {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub plmn_id: Vec<models::PlmnId>,
            pub lac: Vec<String>,
            pub sac: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ServiceAreaId".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "plmnId" => intermediate_rep.plmn_id.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "lac" => intermediate_rep.lac.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "sac" => intermediate_rep.sac.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ServiceAreaId".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ServiceAreaId {
            plmn_id: intermediate_rep
                .plmn_id
                .into_iter()
                .next()
                .ok_or_else(|| "plmnId missing in ServiceAreaId".to_string())?,
            lac: intermediate_rep
                .lac
                .into_iter()
                .next()
                .ok_or_else(|| "lac missing in ServiceAreaId".to_string())?,
            sac: intermediate_rep
                .sac
                .into_iter()
                .next()
                .ok_or_else(|| "sac missing in ServiceAreaId".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ServiceAreaId> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ServiceAreaId>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ServiceAreaId>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ServiceAreaId - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ServiceAreaId> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ServiceAreaId as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ServiceAreaId - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Service names known to NRF
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ServiceName {}

impl ServiceName {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ServiceName {
        ServiceName {}
    }
}

/// Converts the ServiceName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ServiceName {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ServiceName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ServiceName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ServiceName".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ServiceName".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ServiceName {})
    }
}

// Methods for converting between header::IntoHeaderValue<ServiceName> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ServiceName>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ServiceName>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ServiceName - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ServiceName> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ServiceName as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ServiceName - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ServiceNameAnyOf {
    #[serde(rename = "nnrf-nfm")]
    NnrfNfm,
    #[serde(rename = "nnrf-disc")]
    NnrfDisc,
    #[serde(rename = "nnrf-oauth2")]
    NnrfOauth2,
    #[serde(rename = "nudm-sdm")]
    NudmSdm,
    #[serde(rename = "nudm-uecm")]
    NudmUecm,
    #[serde(rename = "nudm-ueau")]
    NudmUeau,
    #[serde(rename = "nudm-ee")]
    NudmEe,
    #[serde(rename = "nudm-pp")]
    NudmPp,
    #[serde(rename = "nudm-niddau")]
    NudmNiddau,
    #[serde(rename = "nudm-mt")]
    NudmMt,
    #[serde(rename = "nudm-ssau")]
    NudmSsau,
    #[serde(rename = "nudm-rsds")]
    NudmRsds,
    #[serde(rename = "namf-comm")]
    NamfComm,
    #[serde(rename = "namf-evts")]
    NamfEvts,
    #[serde(rename = "namf-mt")]
    NamfMt,
    #[serde(rename = "namf-loc")]
    NamfLoc,
    #[serde(rename = "namf-mbs-comm")]
    NamfMbsComm,
    #[serde(rename = "namf-mbs-bc")]
    NamfMbsBc,
    #[serde(rename = "nsmf-pdusession")]
    NsmfPdusession,
    #[serde(rename = "nsmf-event-exposure")]
    NsmfEventExposure,
    #[serde(rename = "nsmf-nidd")]
    NsmfNidd,
    #[serde(rename = "nausf-auth")]
    NausfAuth,
    #[serde(rename = "nausf-sorprotection")]
    NausfSorprotection,
    #[serde(rename = "nausf-upuprotection")]
    NausfUpuprotection,
    #[serde(rename = "nnef-pfdmanagement")]
    NnefPfdmanagement,
    #[serde(rename = "nnef-smcontext")]
    NnefSmcontext,
    #[serde(rename = "nnef-eventexposure")]
    NnefEventexposure,
    #[serde(rename = "nnef-eas-deployment-info")]
    NnefEasDeploymentInfo,
    #[serde(rename = "3gpp-cp-parameter-provisioning")]
    Variant3gppCpParameterProvisioning,
    #[serde(rename = "3gpp-device-triggering")]
    Variant3gppDeviceTriggering,
    #[serde(rename = "3gpp-bdt")]
    Variant3gppBdt,
    #[serde(rename = "3gpp-traffic-influence")]
    Variant3gppTrafficInfluence,
    #[serde(rename = "3gpp-chargeable-party")]
    Variant3gppChargeableParty,
    #[serde(rename = "3gpp-as-session-with-qos")]
    Variant3gppAsSessionWithQos,
    #[serde(rename = "3gpp-msisdn-less-mo-sms")]
    Variant3gppMsisdnLessMoSms,
    #[serde(rename = "3gpp-service-parameter")]
    Variant3gppServiceParameter,
    #[serde(rename = "3gpp-monitoring-event")]
    Variant3gppMonitoringEvent,
    #[serde(rename = "3gpp-nidd-configuration-trigger")]
    Variant3gppNiddConfigurationTrigger,
    #[serde(rename = "3gpp-nidd")]
    Variant3gppNidd,
    #[serde(rename = "3gpp-analyticsexposure")]
    Variant3gppAnalyticsexposure,
    #[serde(rename = "3gpp-racs-parameter-provisioning")]
    Variant3gppRacsParameterProvisioning,
    #[serde(rename = "3gpp-ecr-control")]
    Variant3gppEcrControl,
    #[serde(rename = "3gpp-applying-bdt-policy")]
    Variant3gppApplyingBdtPolicy,
    #[serde(rename = "3gpp-mo-lcs-notify")]
    Variant3gppMoLcsNotify,
    #[serde(rename = "3gpp-time-sync")]
    Variant3gppTimeSync,
    #[serde(rename = "3gpp-am-influence")]
    Variant3gppAmInfluence,
    #[serde(rename = "3gpp-am-policyauthorization")]
    Variant3gppAmPolicyauthorization,
    #[serde(rename = "3gpp-akma")]
    Variant3gppAkma,
    #[serde(rename = "3gpp-eas-deployment")]
    Variant3gppEasDeployment,
    #[serde(rename = "3gpp-iptvconfiguration")]
    Variant3gppIptvconfiguration,
    #[serde(rename = "3gpp-mbs-tmgi")]
    Variant3gppMbsTmgi,
    #[serde(rename = "3gpp-mbs-session")]
    Variant3gppMbsSession,
    #[serde(rename = "3gpp-authentication")]
    Variant3gppAuthentication,
    #[serde(rename = "3gpp-asti")]
    Variant3gppAsti,
    #[serde(rename = "npcf-am-policy-control")]
    NpcfAmPolicyControl,
    #[serde(rename = "npcf-smpolicycontrol")]
    NpcfSmpolicycontrol,
    #[serde(rename = "npcf-policyauthorization")]
    NpcfPolicyauthorization,
    #[serde(rename = "npcf-bdtpolicycontrol")]
    NpcfBdtpolicycontrol,
    #[serde(rename = "npcf-eventexposure")]
    NpcfEventexposure,
    #[serde(rename = "npcf-ue-policy-control")]
    NpcfUePolicyControl,
    #[serde(rename = "npcf-am-policyauthorization")]
    NpcfAmPolicyauthorization,
    #[serde(rename = "nsmsf-sms")]
    NsmsfSms,
    #[serde(rename = "nnssf-nsselection")]
    NnssfNsselection,
    #[serde(rename = "nnssf-nssaiavailability")]
    NnssfNssaiavailability,
    #[serde(rename = "nudr-dr")]
    NudrDr,
    #[serde(rename = "nudr-group-id-map")]
    NudrGroupIdMap,
    #[serde(rename = "nlmf-loc")]
    NlmfLoc,
    #[serde(rename = "n5g-eir-eic")]
    N5gEirEic,
    #[serde(rename = "nbsf-management")]
    NbsfManagement,
    #[serde(rename = "nchf-spendinglimitcontrol")]
    NchfSpendinglimitcontrol,
    #[serde(rename = "nchf-convergedcharging")]
    NchfConvergedcharging,
    #[serde(rename = "nchf-offlineonlycharging")]
    NchfOfflineonlycharging,
    #[serde(rename = "nnwdaf-eventssubscription")]
    NnwdafEventssubscription,
    #[serde(rename = "nnwdaf-analyticsinfo")]
    NnwdafAnalyticsinfo,
    #[serde(rename = "nnwdaf-datamanagement")]
    NnwdafDatamanagement,
    #[serde(rename = "nnwdaf-mlmodelprovision")]
    NnwdafMlmodelprovision,
    #[serde(rename = "ngmlc-loc")]
    NgmlcLoc,
    #[serde(rename = "nucmf-provisioning")]
    NucmfProvisioning,
    #[serde(rename = "nucmf-uecapabilitymanagement")]
    NucmfUecapabilitymanagement,
    #[serde(rename = "nhss-sdm")]
    NhssSdm,
    #[serde(rename = "nhss-uecm")]
    NhssUecm,
    #[serde(rename = "nhss-ueau")]
    NhssUeau,
    #[serde(rename = "nhss-ee")]
    NhssEe,
    #[serde(rename = "nhss-ims-sdm")]
    NhssImsSdm,
    #[serde(rename = "nhss-ims-uecm")]
    NhssImsUecm,
    #[serde(rename = "nhss-ims-ueau")]
    NhssImsUeau,
    #[serde(rename = "nhss-gba-sdm")]
    NhssGbaSdm,
    #[serde(rename = "nhss-gba-ueau")]
    NhssGbaUeau,
    #[serde(rename = "nsepp-telescopic")]
    NseppTelescopic,
    #[serde(rename = "nsoraf-sor")]
    NsorafSor,
    #[serde(rename = "nspaf-secured-packet")]
    NspafSecuredPacket,
    #[serde(rename = "nudsf-dr")]
    NudsfDr,
    #[serde(rename = "nudsf-timer")]
    NudsfTimer,
    #[serde(rename = "nnssaaf-nssaa")]
    NnssaafNssaa,
    #[serde(rename = "nnssaaf-aiw")]
    NnssaafAiw,
    #[serde(rename = "naanf-akma")]
    NaanfAkma,
    #[serde(rename = "n5gddnmf-discovery")]
    N5gddnmfDiscovery,
    #[serde(rename = "nmfaf-3dadm")]
    Nmfaf3dadm,
    #[serde(rename = "nmfaf-3cadm")]
    Nmfaf3cadm,
    #[serde(rename = "neasdf-dnscontext")]
    NeasdfDnscontext,
    #[serde(rename = "neasdf-baselinednspattern")]
    NeasdfBaselinednspattern,
    #[serde(rename = "ndccf-dm")]
    NdccfDm,
    #[serde(rename = "ndccf-cm")]
    NdccfCm,
    #[serde(rename = "nnsacf-nsac")]
    NnsacfNsac,
    #[serde(rename = "nnsacf-slice-ee")]
    NnsacfSliceEe,
    #[serde(rename = "nmbsmf-tmgi")]
    NmbsmfTmgi,
    #[serde(rename = "nmbsmf-mbssession")]
    NmbsmfMbssession,
    #[serde(rename = "nadrf-dm")]
    NadrfDm,
    #[serde(rename = "nbsp-gba")]
    NbspGba,
    #[serde(rename = "ntsctsf-time-sync")]
    NtsctsfTimeSync,
    #[serde(rename = "ntsctsf-qos-tscai")]
    NtsctsfQosTscai,
    #[serde(rename = "ntsctsf-asti")]
    NtsctsfAsti,
    #[serde(rename = "npkmf-keyreq")]
    NpkmfKeyreq,
    #[serde(rename = "nmnpf-npstatus")]
    NmnpfNpstatus,
    #[serde(rename = "niwmsc-smservice")]
    NiwmscSmservice,
    #[serde(rename = "nmbsf-mbsuserserv")]
    NmbsfMbsuserserv,
    #[serde(rename = "nmbsf-mbsuserdataing")]
    NmbsfMbsuserdataing,
    #[serde(rename = "nmbstf-distsession")]
    NmbstfDistsession,
    #[serde(rename = "npanf-prosekey")]
    NpanfProsekey,
}

impl std::fmt::Display for ServiceNameAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ServiceNameAnyOf::NnrfNfm => write!(f, "nnrf-nfm"),
            ServiceNameAnyOf::NnrfDisc => write!(f, "nnrf-disc"),
            ServiceNameAnyOf::NnrfOauth2 => write!(f, "nnrf-oauth2"),
            ServiceNameAnyOf::NudmSdm => write!(f, "nudm-sdm"),
            ServiceNameAnyOf::NudmUecm => write!(f, "nudm-uecm"),
            ServiceNameAnyOf::NudmUeau => write!(f, "nudm-ueau"),
            ServiceNameAnyOf::NudmEe => write!(f, "nudm-ee"),
            ServiceNameAnyOf::NudmPp => write!(f, "nudm-pp"),
            ServiceNameAnyOf::NudmNiddau => write!(f, "nudm-niddau"),
            ServiceNameAnyOf::NudmMt => write!(f, "nudm-mt"),
            ServiceNameAnyOf::NudmSsau => write!(f, "nudm-ssau"),
            ServiceNameAnyOf::NudmRsds => write!(f, "nudm-rsds"),
            ServiceNameAnyOf::NamfComm => write!(f, "namf-comm"),
            ServiceNameAnyOf::NamfEvts => write!(f, "namf-evts"),
            ServiceNameAnyOf::NamfMt => write!(f, "namf-mt"),
            ServiceNameAnyOf::NamfLoc => write!(f, "namf-loc"),
            ServiceNameAnyOf::NamfMbsComm => write!(f, "namf-mbs-comm"),
            ServiceNameAnyOf::NamfMbsBc => write!(f, "namf-mbs-bc"),
            ServiceNameAnyOf::NsmfPdusession => write!(f, "nsmf-pdusession"),
            ServiceNameAnyOf::NsmfEventExposure => write!(f, "nsmf-event-exposure"),
            ServiceNameAnyOf::NsmfNidd => write!(f, "nsmf-nidd"),
            ServiceNameAnyOf::NausfAuth => write!(f, "nausf-auth"),
            ServiceNameAnyOf::NausfSorprotection => write!(f, "nausf-sorprotection"),
            ServiceNameAnyOf::NausfUpuprotection => write!(f, "nausf-upuprotection"),
            ServiceNameAnyOf::NnefPfdmanagement => write!(f, "nnef-pfdmanagement"),
            ServiceNameAnyOf::NnefSmcontext => write!(f, "nnef-smcontext"),
            ServiceNameAnyOf::NnefEventexposure => write!(f, "nnef-eventexposure"),
            ServiceNameAnyOf::NnefEasDeploymentInfo => write!(f, "nnef-eas-deployment-info"),
            ServiceNameAnyOf::Variant3gppCpParameterProvisioning => {
                write!(f, "3gpp-cp-parameter-provisioning")
            }
            ServiceNameAnyOf::Variant3gppDeviceTriggering => write!(f, "3gpp-device-triggering"),
            ServiceNameAnyOf::Variant3gppBdt => write!(f, "3gpp-bdt"),
            ServiceNameAnyOf::Variant3gppTrafficInfluence => write!(f, "3gpp-traffic-influence"),
            ServiceNameAnyOf::Variant3gppChargeableParty => write!(f, "3gpp-chargeable-party"),
            ServiceNameAnyOf::Variant3gppAsSessionWithQos => write!(f, "3gpp-as-session-with-qos"),
            ServiceNameAnyOf::Variant3gppMsisdnLessMoSms => write!(f, "3gpp-msisdn-less-mo-sms"),
            ServiceNameAnyOf::Variant3gppServiceParameter => write!(f, "3gpp-service-parameter"),
            ServiceNameAnyOf::Variant3gppMonitoringEvent => write!(f, "3gpp-monitoring-event"),
            ServiceNameAnyOf::Variant3gppNiddConfigurationTrigger => {
                write!(f, "3gpp-nidd-configuration-trigger")
            }
            ServiceNameAnyOf::Variant3gppNidd => write!(f, "3gpp-nidd"),
            ServiceNameAnyOf::Variant3gppAnalyticsexposure => write!(f, "3gpp-analyticsexposure"),
            ServiceNameAnyOf::Variant3gppRacsParameterProvisioning => {
                write!(f, "3gpp-racs-parameter-provisioning")
            }
            ServiceNameAnyOf::Variant3gppEcrControl => write!(f, "3gpp-ecr-control"),
            ServiceNameAnyOf::Variant3gppApplyingBdtPolicy => write!(f, "3gpp-applying-bdt-policy"),
            ServiceNameAnyOf::Variant3gppMoLcsNotify => write!(f, "3gpp-mo-lcs-notify"),
            ServiceNameAnyOf::Variant3gppTimeSync => write!(f, "3gpp-time-sync"),
            ServiceNameAnyOf::Variant3gppAmInfluence => write!(f, "3gpp-am-influence"),
            ServiceNameAnyOf::Variant3gppAmPolicyauthorization => {
                write!(f, "3gpp-am-policyauthorization")
            }
            ServiceNameAnyOf::Variant3gppAkma => write!(f, "3gpp-akma"),
            ServiceNameAnyOf::Variant3gppEasDeployment => write!(f, "3gpp-eas-deployment"),
            ServiceNameAnyOf::Variant3gppIptvconfiguration => write!(f, "3gpp-iptvconfiguration"),
            ServiceNameAnyOf::Variant3gppMbsTmgi => write!(f, "3gpp-mbs-tmgi"),
            ServiceNameAnyOf::Variant3gppMbsSession => write!(f, "3gpp-mbs-session"),
            ServiceNameAnyOf::Variant3gppAuthentication => write!(f, "3gpp-authentication"),
            ServiceNameAnyOf::Variant3gppAsti => write!(f, "3gpp-asti"),
            ServiceNameAnyOf::NpcfAmPolicyControl => write!(f, "npcf-am-policy-control"),
            ServiceNameAnyOf::NpcfSmpolicycontrol => write!(f, "npcf-smpolicycontrol"),
            ServiceNameAnyOf::NpcfPolicyauthorization => write!(f, "npcf-policyauthorization"),
            ServiceNameAnyOf::NpcfBdtpolicycontrol => write!(f, "npcf-bdtpolicycontrol"),
            ServiceNameAnyOf::NpcfEventexposure => write!(f, "npcf-eventexposure"),
            ServiceNameAnyOf::NpcfUePolicyControl => write!(f, "npcf-ue-policy-control"),
            ServiceNameAnyOf::NpcfAmPolicyauthorization => write!(f, "npcf-am-policyauthorization"),
            ServiceNameAnyOf::NsmsfSms => write!(f, "nsmsf-sms"),
            ServiceNameAnyOf::NnssfNsselection => write!(f, "nnssf-nsselection"),
            ServiceNameAnyOf::NnssfNssaiavailability => write!(f, "nnssf-nssaiavailability"),
            ServiceNameAnyOf::NudrDr => write!(f, "nudr-dr"),
            ServiceNameAnyOf::NudrGroupIdMap => write!(f, "nudr-group-id-map"),
            ServiceNameAnyOf::NlmfLoc => write!(f, "nlmf-loc"),
            ServiceNameAnyOf::N5gEirEic => write!(f, "n5g-eir-eic"),
            ServiceNameAnyOf::NbsfManagement => write!(f, "nbsf-management"),
            ServiceNameAnyOf::NchfSpendinglimitcontrol => write!(f, "nchf-spendinglimitcontrol"),
            ServiceNameAnyOf::NchfConvergedcharging => write!(f, "nchf-convergedcharging"),
            ServiceNameAnyOf::NchfOfflineonlycharging => write!(f, "nchf-offlineonlycharging"),
            ServiceNameAnyOf::NnwdafEventssubscription => write!(f, "nnwdaf-eventssubscription"),
            ServiceNameAnyOf::NnwdafAnalyticsinfo => write!(f, "nnwdaf-analyticsinfo"),
            ServiceNameAnyOf::NnwdafDatamanagement => write!(f, "nnwdaf-datamanagement"),
            ServiceNameAnyOf::NnwdafMlmodelprovision => write!(f, "nnwdaf-mlmodelprovision"),
            ServiceNameAnyOf::NgmlcLoc => write!(f, "ngmlc-loc"),
            ServiceNameAnyOf::NucmfProvisioning => write!(f, "nucmf-provisioning"),
            ServiceNameAnyOf::NucmfUecapabilitymanagement => {
                write!(f, "nucmf-uecapabilitymanagement")
            }
            ServiceNameAnyOf::NhssSdm => write!(f, "nhss-sdm"),
            ServiceNameAnyOf::NhssUecm => write!(f, "nhss-uecm"),
            ServiceNameAnyOf::NhssUeau => write!(f, "nhss-ueau"),
            ServiceNameAnyOf::NhssEe => write!(f, "nhss-ee"),
            ServiceNameAnyOf::NhssImsSdm => write!(f, "nhss-ims-sdm"),
            ServiceNameAnyOf::NhssImsUecm => write!(f, "nhss-ims-uecm"),
            ServiceNameAnyOf::NhssImsUeau => write!(f, "nhss-ims-ueau"),
            ServiceNameAnyOf::NhssGbaSdm => write!(f, "nhss-gba-sdm"),
            ServiceNameAnyOf::NhssGbaUeau => write!(f, "nhss-gba-ueau"),
            ServiceNameAnyOf::NseppTelescopic => write!(f, "nsepp-telescopic"),
            ServiceNameAnyOf::NsorafSor => write!(f, "nsoraf-sor"),
            ServiceNameAnyOf::NspafSecuredPacket => write!(f, "nspaf-secured-packet"),
            ServiceNameAnyOf::NudsfDr => write!(f, "nudsf-dr"),
            ServiceNameAnyOf::NudsfTimer => write!(f, "nudsf-timer"),
            ServiceNameAnyOf::NnssaafNssaa => write!(f, "nnssaaf-nssaa"),
            ServiceNameAnyOf::NnssaafAiw => write!(f, "nnssaaf-aiw"),
            ServiceNameAnyOf::NaanfAkma => write!(f, "naanf-akma"),
            ServiceNameAnyOf::N5gddnmfDiscovery => write!(f, "n5gddnmf-discovery"),
            ServiceNameAnyOf::Nmfaf3dadm => write!(f, "nmfaf-3dadm"),
            ServiceNameAnyOf::Nmfaf3cadm => write!(f, "nmfaf-3cadm"),
            ServiceNameAnyOf::NeasdfDnscontext => write!(f, "neasdf-dnscontext"),
            ServiceNameAnyOf::NeasdfBaselinednspattern => write!(f, "neasdf-baselinednspattern"),
            ServiceNameAnyOf::NdccfDm => write!(f, "ndccf-dm"),
            ServiceNameAnyOf::NdccfCm => write!(f, "ndccf-cm"),
            ServiceNameAnyOf::NnsacfNsac => write!(f, "nnsacf-nsac"),
            ServiceNameAnyOf::NnsacfSliceEe => write!(f, "nnsacf-slice-ee"),
            ServiceNameAnyOf::NmbsmfTmgi => write!(f, "nmbsmf-tmgi"),
            ServiceNameAnyOf::NmbsmfMbssession => write!(f, "nmbsmf-mbssession"),
            ServiceNameAnyOf::NadrfDm => write!(f, "nadrf-dm"),
            ServiceNameAnyOf::NbspGba => write!(f, "nbsp-gba"),
            ServiceNameAnyOf::NtsctsfTimeSync => write!(f, "ntsctsf-time-sync"),
            ServiceNameAnyOf::NtsctsfQosTscai => write!(f, "ntsctsf-qos-tscai"),
            ServiceNameAnyOf::NtsctsfAsti => write!(f, "ntsctsf-asti"),
            ServiceNameAnyOf::NpkmfKeyreq => write!(f, "npkmf-keyreq"),
            ServiceNameAnyOf::NmnpfNpstatus => write!(f, "nmnpf-npstatus"),
            ServiceNameAnyOf::NiwmscSmservice => write!(f, "niwmsc-smservice"),
            ServiceNameAnyOf::NmbsfMbsuserserv => write!(f, "nmbsf-mbsuserserv"),
            ServiceNameAnyOf::NmbsfMbsuserdataing => write!(f, "nmbsf-mbsuserdataing"),
            ServiceNameAnyOf::NmbstfDistsession => write!(f, "nmbstf-distsession"),
            ServiceNameAnyOf::NpanfProsekey => write!(f, "npanf-prosekey"),
        }
    }
}

impl std::str::FromStr for ServiceNameAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "nnrf-nfm" => std::result::Result::Ok(ServiceNameAnyOf::NnrfNfm),
            "nnrf-disc" => std::result::Result::Ok(ServiceNameAnyOf::NnrfDisc),
            "nnrf-oauth2" => std::result::Result::Ok(ServiceNameAnyOf::NnrfOauth2),
            "nudm-sdm" => std::result::Result::Ok(ServiceNameAnyOf::NudmSdm),
            "nudm-uecm" => std::result::Result::Ok(ServiceNameAnyOf::NudmUecm),
            "nudm-ueau" => std::result::Result::Ok(ServiceNameAnyOf::NudmUeau),
            "nudm-ee" => std::result::Result::Ok(ServiceNameAnyOf::NudmEe),
            "nudm-pp" => std::result::Result::Ok(ServiceNameAnyOf::NudmPp),
            "nudm-niddau" => std::result::Result::Ok(ServiceNameAnyOf::NudmNiddau),
            "nudm-mt" => std::result::Result::Ok(ServiceNameAnyOf::NudmMt),
            "nudm-ssau" => std::result::Result::Ok(ServiceNameAnyOf::NudmSsau),
            "nudm-rsds" => std::result::Result::Ok(ServiceNameAnyOf::NudmRsds),
            "namf-comm" => std::result::Result::Ok(ServiceNameAnyOf::NamfComm),
            "namf-evts" => std::result::Result::Ok(ServiceNameAnyOf::NamfEvts),
            "namf-mt" => std::result::Result::Ok(ServiceNameAnyOf::NamfMt),
            "namf-loc" => std::result::Result::Ok(ServiceNameAnyOf::NamfLoc),
            "namf-mbs-comm" => std::result::Result::Ok(ServiceNameAnyOf::NamfMbsComm),
            "namf-mbs-bc" => std::result::Result::Ok(ServiceNameAnyOf::NamfMbsBc),
            "nsmf-pdusession" => std::result::Result::Ok(ServiceNameAnyOf::NsmfPdusession),
            "nsmf-event-exposure" => std::result::Result::Ok(ServiceNameAnyOf::NsmfEventExposure),
            "nsmf-nidd" => std::result::Result::Ok(ServiceNameAnyOf::NsmfNidd),
            "nausf-auth" => std::result::Result::Ok(ServiceNameAnyOf::NausfAuth),
            "nausf-sorprotection" => std::result::Result::Ok(ServiceNameAnyOf::NausfSorprotection),
            "nausf-upuprotection" => std::result::Result::Ok(ServiceNameAnyOf::NausfUpuprotection),
            "nnef-pfdmanagement" => std::result::Result::Ok(ServiceNameAnyOf::NnefPfdmanagement),
            "nnef-smcontext" => std::result::Result::Ok(ServiceNameAnyOf::NnefSmcontext),
            "nnef-eventexposure" => std::result::Result::Ok(ServiceNameAnyOf::NnefEventexposure),
            "nnef-eas-deployment-info" => {
                std::result::Result::Ok(ServiceNameAnyOf::NnefEasDeploymentInfo)
            }
            "3gpp-cp-parameter-provisioning" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppCpParameterProvisioning)
            }
            "3gpp-device-triggering" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppDeviceTriggering)
            }
            "3gpp-bdt" => std::result::Result::Ok(ServiceNameAnyOf::Variant3gppBdt),
            "3gpp-traffic-influence" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppTrafficInfluence)
            }
            "3gpp-chargeable-party" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppChargeableParty)
            }
            "3gpp-as-session-with-qos" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppAsSessionWithQos)
            }
            "3gpp-msisdn-less-mo-sms" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppMsisdnLessMoSms)
            }
            "3gpp-service-parameter" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppServiceParameter)
            }
            "3gpp-monitoring-event" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppMonitoringEvent)
            }
            "3gpp-nidd-configuration-trigger" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppNiddConfigurationTrigger)
            }
            "3gpp-nidd" => std::result::Result::Ok(ServiceNameAnyOf::Variant3gppNidd),
            "3gpp-analyticsexposure" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppAnalyticsexposure)
            }
            "3gpp-racs-parameter-provisioning" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppRacsParameterProvisioning)
            }
            "3gpp-ecr-control" => std::result::Result::Ok(ServiceNameAnyOf::Variant3gppEcrControl),
            "3gpp-applying-bdt-policy" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppApplyingBdtPolicy)
            }
            "3gpp-mo-lcs-notify" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppMoLcsNotify)
            }
            "3gpp-time-sync" => std::result::Result::Ok(ServiceNameAnyOf::Variant3gppTimeSync),
            "3gpp-am-influence" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppAmInfluence)
            }
            "3gpp-am-policyauthorization" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppAmPolicyauthorization)
            }
            "3gpp-akma" => std::result::Result::Ok(ServiceNameAnyOf::Variant3gppAkma),
            "3gpp-eas-deployment" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppEasDeployment)
            }
            "3gpp-iptvconfiguration" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppIptvconfiguration)
            }
            "3gpp-mbs-tmgi" => std::result::Result::Ok(ServiceNameAnyOf::Variant3gppMbsTmgi),
            "3gpp-mbs-session" => std::result::Result::Ok(ServiceNameAnyOf::Variant3gppMbsSession),
            "3gpp-authentication" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppAuthentication)
            }
            "3gpp-asti" => std::result::Result::Ok(ServiceNameAnyOf::Variant3gppAsti),
            "npcf-am-policy-control" => {
                std::result::Result::Ok(ServiceNameAnyOf::NpcfAmPolicyControl)
            }
            "npcf-smpolicycontrol" => {
                std::result::Result::Ok(ServiceNameAnyOf::NpcfSmpolicycontrol)
            }
            "npcf-policyauthorization" => {
                std::result::Result::Ok(ServiceNameAnyOf::NpcfPolicyauthorization)
            }
            "npcf-bdtpolicycontrol" => {
                std::result::Result::Ok(ServiceNameAnyOf::NpcfBdtpolicycontrol)
            }
            "npcf-eventexposure" => std::result::Result::Ok(ServiceNameAnyOf::NpcfEventexposure),
            "npcf-ue-policy-control" => {
                std::result::Result::Ok(ServiceNameAnyOf::NpcfUePolicyControl)
            }
            "npcf-am-policyauthorization" => {
                std::result::Result::Ok(ServiceNameAnyOf::NpcfAmPolicyauthorization)
            }
            "nsmsf-sms" => std::result::Result::Ok(ServiceNameAnyOf::NsmsfSms),
            "nnssf-nsselection" => std::result::Result::Ok(ServiceNameAnyOf::NnssfNsselection),
            "nnssf-nssaiavailability" => {
                std::result::Result::Ok(ServiceNameAnyOf::NnssfNssaiavailability)
            }
            "nudr-dr" => std::result::Result::Ok(ServiceNameAnyOf::NudrDr),
            "nudr-group-id-map" => std::result::Result::Ok(ServiceNameAnyOf::NudrGroupIdMap),
            "nlmf-loc" => std::result::Result::Ok(ServiceNameAnyOf::NlmfLoc),
            "n5g-eir-eic" => std::result::Result::Ok(ServiceNameAnyOf::N5gEirEic),
            "nbsf-management" => std::result::Result::Ok(ServiceNameAnyOf::NbsfManagement),
            "nchf-spendinglimitcontrol" => {
                std::result::Result::Ok(ServiceNameAnyOf::NchfSpendinglimitcontrol)
            }
            "nchf-convergedcharging" => {
                std::result::Result::Ok(ServiceNameAnyOf::NchfConvergedcharging)
            }
            "nchf-offlineonlycharging" => {
                std::result::Result::Ok(ServiceNameAnyOf::NchfOfflineonlycharging)
            }
            "nnwdaf-eventssubscription" => {
                std::result::Result::Ok(ServiceNameAnyOf::NnwdafEventssubscription)
            }
            "nnwdaf-analyticsinfo" => {
                std::result::Result::Ok(ServiceNameAnyOf::NnwdafAnalyticsinfo)
            }
            "nnwdaf-datamanagement" => {
                std::result::Result::Ok(ServiceNameAnyOf::NnwdafDatamanagement)
            }
            "nnwdaf-mlmodelprovision" => {
                std::result::Result::Ok(ServiceNameAnyOf::NnwdafMlmodelprovision)
            }
            "ngmlc-loc" => std::result::Result::Ok(ServiceNameAnyOf::NgmlcLoc),
            "nucmf-provisioning" => std::result::Result::Ok(ServiceNameAnyOf::NucmfProvisioning),
            "nucmf-uecapabilitymanagement" => {
                std::result::Result::Ok(ServiceNameAnyOf::NucmfUecapabilitymanagement)
            }
            "nhss-sdm" => std::result::Result::Ok(ServiceNameAnyOf::NhssSdm),
            "nhss-uecm" => std::result::Result::Ok(ServiceNameAnyOf::NhssUecm),
            "nhss-ueau" => std::result::Result::Ok(ServiceNameAnyOf::NhssUeau),
            "nhss-ee" => std::result::Result::Ok(ServiceNameAnyOf::NhssEe),
            "nhss-ims-sdm" => std::result::Result::Ok(ServiceNameAnyOf::NhssImsSdm),
            "nhss-ims-uecm" => std::result::Result::Ok(ServiceNameAnyOf::NhssImsUecm),
            "nhss-ims-ueau" => std::result::Result::Ok(ServiceNameAnyOf::NhssImsUeau),
            "nhss-gba-sdm" => std::result::Result::Ok(ServiceNameAnyOf::NhssGbaSdm),
            "nhss-gba-ueau" => std::result::Result::Ok(ServiceNameAnyOf::NhssGbaUeau),
            "nsepp-telescopic" => std::result::Result::Ok(ServiceNameAnyOf::NseppTelescopic),
            "nsoraf-sor" => std::result::Result::Ok(ServiceNameAnyOf::NsorafSor),
            "nspaf-secured-packet" => std::result::Result::Ok(ServiceNameAnyOf::NspafSecuredPacket),
            "nudsf-dr" => std::result::Result::Ok(ServiceNameAnyOf::NudsfDr),
            "nudsf-timer" => std::result::Result::Ok(ServiceNameAnyOf::NudsfTimer),
            "nnssaaf-nssaa" => std::result::Result::Ok(ServiceNameAnyOf::NnssaafNssaa),
            "nnssaaf-aiw" => std::result::Result::Ok(ServiceNameAnyOf::NnssaafAiw),
            "naanf-akma" => std::result::Result::Ok(ServiceNameAnyOf::NaanfAkma),
            "n5gddnmf-discovery" => std::result::Result::Ok(ServiceNameAnyOf::N5gddnmfDiscovery),
            "nmfaf-3dadm" => std::result::Result::Ok(ServiceNameAnyOf::Nmfaf3dadm),
            "nmfaf-3cadm" => std::result::Result::Ok(ServiceNameAnyOf::Nmfaf3cadm),
            "neasdf-dnscontext" => std::result::Result::Ok(ServiceNameAnyOf::NeasdfDnscontext),
            "neasdf-baselinednspattern" => {
                std::result::Result::Ok(ServiceNameAnyOf::NeasdfBaselinednspattern)
            }
            "ndccf-dm" => std::result::Result::Ok(ServiceNameAnyOf::NdccfDm),
            "ndccf-cm" => std::result::Result::Ok(ServiceNameAnyOf::NdccfCm),
            "nnsacf-nsac" => std::result::Result::Ok(ServiceNameAnyOf::NnsacfNsac),
            "nnsacf-slice-ee" => std::result::Result::Ok(ServiceNameAnyOf::NnsacfSliceEe),
            "nmbsmf-tmgi" => std::result::Result::Ok(ServiceNameAnyOf::NmbsmfTmgi),
            "nmbsmf-mbssession" => std::result::Result::Ok(ServiceNameAnyOf::NmbsmfMbssession),
            "nadrf-dm" => std::result::Result::Ok(ServiceNameAnyOf::NadrfDm),
            "nbsp-gba" => std::result::Result::Ok(ServiceNameAnyOf::NbspGba),
            "ntsctsf-time-sync" => std::result::Result::Ok(ServiceNameAnyOf::NtsctsfTimeSync),
            "ntsctsf-qos-tscai" => std::result::Result::Ok(ServiceNameAnyOf::NtsctsfQosTscai),
            "ntsctsf-asti" => std::result::Result::Ok(ServiceNameAnyOf::NtsctsfAsti),
            "npkmf-keyreq" => std::result::Result::Ok(ServiceNameAnyOf::NpkmfKeyreq),
            "nmnpf-npstatus" => std::result::Result::Ok(ServiceNameAnyOf::NmnpfNpstatus),
            "niwmsc-smservice" => std::result::Result::Ok(ServiceNameAnyOf::NiwmscSmservice),
            "nmbsf-mbsuserserv" => std::result::Result::Ok(ServiceNameAnyOf::NmbsfMbsuserserv),
            "nmbsf-mbsuserdataing" => {
                std::result::Result::Ok(ServiceNameAnyOf::NmbsfMbsuserdataing)
            }
            "nmbstf-distsession" => std::result::Result::Ok(ServiceNameAnyOf::NmbstfDistsession),
            "npanf-prosekey" => std::result::Result::Ok(ServiceNameAnyOf::NpanfProsekey),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Complete SM Context
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SmContext {
    /// Unsigned integer identifying a PDU session, within the range 0 to 255, as specified in  clause 11.2.3.1b, bits 1 to 8, of 3GPP TS 24.007. If the PDU Session ID is allocated by the  Core Network for UEs not supporting N1 mode, reserved range 64 to 95 is used. PDU Session ID  within the reserved range is only visible in the Core Network.
    #[serde(rename = "pduSessionId")]
    pub pdu_session_id: u8,

    /// String representing a Data Network as defined in clause 9A of 3GPP TS 23.003;  it shall contain either a DNN Network Identifier, or a full DNN with both the Network  Identifier and Operator Identifier, as specified in 3GPP TS 23.003 clause 9.1.1 and 9.1.2. It shall be coded as string in which the labels are separated by dots  (e.g. \"Label1.Label2.Label3\").
    #[serde(rename = "dnn")]
    pub dnn: String,

    /// String representing a Data Network as defined in clause 9A of 3GPP TS 23.003;  it shall contain either a DNN Network Identifier, or a full DNN with both the Network  Identifier and Operator Identifier, as specified in 3GPP TS 23.003 clause 9.1.1 and 9.1.2. It shall be coded as string in which the labels are separated by dots  (e.g. \"Label1.Label2.Label3\").
    #[serde(rename = "selectedDnn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub selected_dnn: Option<String>,

    #[serde(rename = "sNssai")]
    pub s_nssai: models::Snssai,

    #[serde(rename = "hplmnSnssai")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hplmn_snssai: Option<models::Snssai>,

    #[serde(rename = "pduSessionType")]
    pub pdu_session_type: models::PduSessionType,

    /// String identifying a Gpsi shall contain either an External Id or an MSISDN.  It shall be formatted as follows -External Identifier= \"extid-'extid', where 'extid'  shall be formatted according to clause 19.7.2 of 3GPP TS 23.003 that describes an  External Identifier.
    #[serde(rename = "gpsi")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gpsi: Option<String>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "hSmfUri")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub h_smf_uri: Option<String>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "smfUri")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub smf_uri: Option<String>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "pduSessionRef")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pdu_session_ref: Option<String>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "interPlmnApiRoot")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub inter_plmn_api_root: Option<String>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "intraPlmnApiRoot")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub intra_plmn_api_root: Option<String>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "pcfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pcf_id: Option<uuid::Uuid>,

    /// Identifier of a group of NFs.
    #[serde(rename = "pcfGroupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pcf_group_id: Option<String>,

    /// NF Set Identifier (see clause 28.12 of 3GPP TS 23.003), formatted as the following string \"set<Set ID>.<nftype>set.5gc.mnc<MNC>.mcc<MCC>\", or  \"set<SetID>.<NFType>set.5gc.nid<NID>.mnc<MNC>.mcc<MCC>\" with  <MCC> encoded as defined in clause 5.4.2 (\"Mcc\" data type definition)  <MNC> encoding the Mobile Network Code part of the PLMN, comprising 3 digits.    If there are only 2 significant digits in the MNC, one \"0\" digit shall be inserted    at the left side to fill the 3 digits coding of MNC.  Pattern: '^[0-9]{3}$' <NFType> encoded as a value defined in Table 6.1.6.3.3-1 of 3GPP TS 29.510 but    with lower case characters <Set ID> encoded as a string of characters consisting of    alphabetic characters (A-Z and a-z), digits (0-9) and/or the hyphen (-) and that    shall end with either an alphabetic character or a digit.
    #[serde(rename = "pcfSetId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pcf_set_id: Option<String>,

    #[serde(rename = "selMode")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sel_mode: Option<models::DnnSelectionMode>,

    /// Identifier of a group of NFs.
    #[serde(rename = "udmGroupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub udm_group_id: Option<String>,

    #[serde(rename = "routingIndicator")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub routing_indicator: Option<String>,

    #[serde(rename = "hNwPubKeyId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub h_nw_pub_key_id: Option<i32>,

    #[serde(rename = "sessionAmbr")]
    pub session_ambr: models::Ambr,

    #[serde(rename = "qosFlowsList")]
    pub qos_flows_list: Vec<models::QosFlowSetupItem>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "hSmfInstanceId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub h_smf_instance_id: Option<uuid::Uuid>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "smfInstanceId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub smf_instance_id: Option<uuid::Uuid>,

    /// NF Set Identifier (see clause 28.12 of 3GPP TS 23.003), formatted as the following string \"set<Set ID>.<nftype>set.5gc.mnc<MNC>.mcc<MCC>\", or  \"set<SetID>.<NFType>set.5gc.nid<NID>.mnc<MNC>.mcc<MCC>\" with  <MCC> encoded as defined in clause 5.4.2 (\"Mcc\" data type definition)  <MNC> encoding the Mobile Network Code part of the PLMN, comprising 3 digits.    If there are only 2 significant digits in the MNC, one \"0\" digit shall be inserted    at the left side to fill the 3 digits coding of MNC.  Pattern: '^[0-9]{3}$' <NFType> encoded as a value defined in Table 6.1.6.3.3-1 of 3GPP TS 29.510 but    with lower case characters <Set ID> encoded as a string of characters consisting of    alphabetic characters (A-Z and a-z), digits (0-9) and/or the hyphen (-) and that    shall end with either an alphabetic character or a digit.
    #[serde(rename = "pduSessionSmfSetId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pdu_session_smf_set_id: Option<String>,

    /// NF Service Set Identifier (see clause 28.12 of 3GPP TS 23.003) formatted as the following  string \"set<Set ID>.sn<Service Name>.nfi<NF Instance ID>.5gc.mnc<MNC>.mcc<MCC>\", or  \"set<SetID>.sn<ServiceName>.nfi<NFInstanceID>.5gc.nid<NID>.mnc<MNC>.mcc<MCC>\" with  <MCC> encoded as defined in clause 5.4.2 (\"Mcc\" data type definition)   <MNC> encoding the Mobile Network Code part of the PLMN, comprising 3 digits.    If there are only 2 significant digits in the MNC, one \"0\" digit shall be inserted    at the left side to fill the 3 digits coding of MNC.  Pattern: '^[0-9]{3}$' <NID> encoded as defined in clause 5.4.2 (\"Nid\" data type definition)  <NFInstanceId> encoded as defined in clause 5.3.2  <ServiceName> encoded as defined in 3GPP TS 29.510  <Set ID> encoded as a string of characters consisting of alphabetic    characters (A-Z and a-z), digits (0-9) and/or the hyphen (-) and that shall end    with either an alphabetic character or a digit.
    #[serde(rename = "pduSessionSmfServiceSetId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pdu_session_smf_service_set_id: Option<String>,

    #[serde(rename = "pduSessionSmfBinding")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pdu_session_smf_binding: Option<models::SbiBindingLevel>,

    #[serde(rename = "enablePauseCharging")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enable_pause_charging: Option<bool>,

    /// String identifying a IPv4 address formatted in the 'dotted decimal' notation as defined in RFC 1166.
    #[serde(rename = "ueIpv4Address")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_ipv4_address: Option<String>,

    #[serde(rename = "ueIpv6Prefix")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_ipv6_prefix: Option<models::Ipv6Prefix>,

    #[serde(rename = "epsPdnCnxInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub eps_pdn_cnx_info: Option<models::EpsPdnCnxInfo>,

    #[serde(rename = "epsBearerInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub eps_bearer_info: Option<Vec<models::EpsBearerInfo>>,

    #[serde(rename = "maxIntegrityProtectedDataRate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_integrity_protected_data_rate: Option<models::MaxIntegrityProtectedDataRate>,

    #[serde(rename = "maxIntegrityProtectedDataRateDl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_integrity_protected_data_rate_dl: Option<models::MaxIntegrityProtectedDataRate>,

    #[serde(rename = "alwaysOnGranted")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub always_on_granted: Option<bool>,

    #[serde(rename = "upSecurity")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub up_security: Option<models::UpSecurity>,

    #[serde(rename = "hSmfServiceInstanceId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub h_smf_service_instance_id: Option<String>,

    #[serde(rename = "smfServiceInstanceId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub smf_service_instance_id: Option<String>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "recoveryTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recovery_time: Option<chrono::DateTime<chrono::Utc>>,

    #[serde(rename = "forwardingInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub forwarding_ind: Option<bool>,

    #[serde(rename = "psaTunnelInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub psa_tunnel_info: Option<models::TunnelInfo>,

    #[serde(rename = "chargingId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub charging_id: Option<String>,

    #[serde(rename = "chargingInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub charging_info: Option<models::ChargingInformation>,

    #[serde(rename = "roamingChargingProfile")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub roaming_charging_profile: Option<models::RoamingChargingProfile>,

    #[serde(rename = "nefExtBufSupportInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nef_ext_buf_support_ind: Option<bool>,

    /// Represents information that identifies which IP pool or external server is used to allocate the IP address.
    #[serde(rename = "ipv6Index")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_index: Option<i32>,

    #[serde(rename = "dnAaaAddress")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dn_aaa_address: Option<models::IpAddress>,

    #[serde(rename = "redundantPduSessionInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub redundant_pdu_session_info: Option<models::RedundantPduSessionInformation>,

    #[serde(rename = "ranTunnelInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ran_tunnel_info: Option<models::QosFlowTunnel>,

    #[serde(rename = "addRanTunnelInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub add_ran_tunnel_info: Option<Vec<models::QosFlowTunnel>>,

    #[serde(rename = "redRanTunnelInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub red_ran_tunnel_info: Option<models::QosFlowTunnel>,

    #[serde(rename = "addRedRanTunnelInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub add_red_ran_tunnel_info: Option<Vec<models::QosFlowTunnel>>,

    #[serde(rename = "nspuSupportInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nspu_support_ind: Option<bool>,

    #[serde(rename = "smfBindingInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub smf_binding_info: Option<String>,

    #[serde(rename = "satelliteBackhaulCat")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub satellite_backhaul_cat: Option<models::SatelliteBackhaulCategory>,

    #[serde(rename = "sscMode")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ssc_mode: Option<String>,

    #[serde(rename = "dlsetSupportInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dlset_support_ind: Option<bool>,

    #[serde(rename = "n9fscSupportInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n9fsc_support_ind: Option<bool>,

    #[serde(rename = "disasterRoamingInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub disaster_roaming_ind: Option<bool>,

    #[serde(rename = "anchorSmfOauth2Required")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub anchor_smf_oauth2_required: Option<bool>,
}

impl SmContext {
    #[allow(clippy::new_without_default)]
    pub fn new(
        pdu_session_id: u8,
        dnn: String,
        s_nssai: models::Snssai,
        pdu_session_type: models::PduSessionType,
        session_ambr: models::Ambr,
        qos_flows_list: Vec<models::QosFlowSetupItem>,
    ) -> SmContext {
        SmContext {
            pdu_session_id,
            dnn,
            selected_dnn: None,
            s_nssai,
            hplmn_snssai: None,
            pdu_session_type,
            gpsi: None,
            h_smf_uri: None,
            smf_uri: None,
            pdu_session_ref: None,
            inter_plmn_api_root: None,
            intra_plmn_api_root: None,
            pcf_id: None,
            pcf_group_id: None,
            pcf_set_id: None,
            sel_mode: None,
            udm_group_id: None,
            routing_indicator: None,
            h_nw_pub_key_id: None,
            session_ambr,
            qos_flows_list,
            h_smf_instance_id: None,
            smf_instance_id: None,
            pdu_session_smf_set_id: None,
            pdu_session_smf_service_set_id: None,
            pdu_session_smf_binding: None,
            enable_pause_charging: Some(false),
            ue_ipv4_address: None,
            ue_ipv6_prefix: None,
            eps_pdn_cnx_info: None,
            eps_bearer_info: None,
            max_integrity_protected_data_rate: None,
            max_integrity_protected_data_rate_dl: None,
            always_on_granted: Some(false),
            up_security: None,
            h_smf_service_instance_id: None,
            smf_service_instance_id: None,
            recovery_time: None,
            forwarding_ind: Some(false),
            psa_tunnel_info: None,
            charging_id: None,
            charging_info: None,
            roaming_charging_profile: None,
            nef_ext_buf_support_ind: Some(false),
            ipv6_index: None,
            dn_aaa_address: None,
            redundant_pdu_session_info: None,
            ran_tunnel_info: None,
            add_ran_tunnel_info: None,
            red_ran_tunnel_info: None,
            add_red_ran_tunnel_info: None,
            nspu_support_ind: None,
            smf_binding_info: None,
            satellite_backhaul_cat: None,
            ssc_mode: None,
            dlset_support_ind: None,
            n9fsc_support_ind: None,
            disaster_roaming_ind: Some(false),
            anchor_smf_oauth2_required: None,
        }
    }
}

/// Converts the SmContext value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SmContext {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("pduSessionId".to_string()),
            Some(self.pdu_session_id.to_string()),
            Some("dnn".to_string()),
            Some(self.dnn.to_string()),
            self.selected_dnn.as_ref().map(|selected_dnn| {
                vec!["selectedDnn".to_string(), selected_dnn.to_string()].join(",")
            }),
            // Skipping sNssai in query parameter serialization

            // Skipping hplmnSnssai in query parameter serialization

            // Skipping pduSessionType in query parameter serialization
            self.gpsi
                .as_ref()
                .map(|gpsi| vec!["gpsi".to_string(), gpsi.to_string()].join(",")),
            self.h_smf_uri
                .as_ref()
                .map(|h_smf_uri| vec!["hSmfUri".to_string(), h_smf_uri.to_string()].join(",")),
            self.smf_uri
                .as_ref()
                .map(|smf_uri| vec!["smfUri".to_string(), smf_uri.to_string()].join(",")),
            self.pdu_session_ref.as_ref().map(|pdu_session_ref| {
                vec!["pduSessionRef".to_string(), pdu_session_ref.to_string()].join(",")
            }),
            self.inter_plmn_api_root
                .as_ref()
                .map(|inter_plmn_api_root| {
                    vec![
                        "interPlmnApiRoot".to_string(),
                        inter_plmn_api_root.to_string(),
                    ]
                    .join(",")
                }),
            self.intra_plmn_api_root
                .as_ref()
                .map(|intra_plmn_api_root| {
                    vec![
                        "intraPlmnApiRoot".to_string(),
                        intra_plmn_api_root.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping pcfId in query parameter serialization
            self.pcf_group_id.as_ref().map(|pcf_group_id| {
                vec!["pcfGroupId".to_string(), pcf_group_id.to_string()].join(",")
            }),
            self.pcf_set_id
                .as_ref()
                .map(|pcf_set_id| vec!["pcfSetId".to_string(), pcf_set_id.to_string()].join(",")),
            // Skipping selMode in query parameter serialization
            self.udm_group_id.as_ref().map(|udm_group_id| {
                vec!["udmGroupId".to_string(), udm_group_id.to_string()].join(",")
            }),
            self.routing_indicator.as_ref().map(|routing_indicator| {
                vec![
                    "routingIndicator".to_string(),
                    routing_indicator.to_string(),
                ]
                .join(",")
            }),
            self.h_nw_pub_key_id.as_ref().map(|h_nw_pub_key_id| {
                vec!["hNwPubKeyId".to_string(), h_nw_pub_key_id.to_string()].join(",")
            }),
            // Skipping sessionAmbr in query parameter serialization

            // Skipping qosFlowsList in query parameter serialization

            // Skipping hSmfInstanceId in query parameter serialization

            // Skipping smfInstanceId in query parameter serialization
            self.pdu_session_smf_set_id
                .as_ref()
                .map(|pdu_session_smf_set_id| {
                    vec![
                        "pduSessionSmfSetId".to_string(),
                        pdu_session_smf_set_id.to_string(),
                    ]
                    .join(",")
                }),
            self.pdu_session_smf_service_set_id
                .as_ref()
                .map(|pdu_session_smf_service_set_id| {
                    vec![
                        "pduSessionSmfServiceSetId".to_string(),
                        pdu_session_smf_service_set_id.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping pduSessionSmfBinding in query parameter serialization
            self.enable_pause_charging
                .as_ref()
                .map(|enable_pause_charging| {
                    vec![
                        "enablePauseCharging".to_string(),
                        enable_pause_charging.to_string(),
                    ]
                    .join(",")
                }),
            self.ue_ipv4_address.as_ref().map(|ue_ipv4_address| {
                vec!["ueIpv4Address".to_string(), ue_ipv4_address.to_string()].join(",")
            }),
            // Skipping ueIpv6Prefix in query parameter serialization

            // Skipping epsPdnCnxInfo in query parameter serialization

            // Skipping epsBearerInfo in query parameter serialization

            // Skipping maxIntegrityProtectedDataRate in query parameter serialization

            // Skipping maxIntegrityProtectedDataRateDl in query parameter serialization
            self.always_on_granted.as_ref().map(|always_on_granted| {
                vec!["alwaysOnGranted".to_string(), always_on_granted.to_string()].join(",")
            }),
            // Skipping upSecurity in query parameter serialization
            self.h_smf_service_instance_id
                .as_ref()
                .map(|h_smf_service_instance_id| {
                    vec![
                        "hSmfServiceInstanceId".to_string(),
                        h_smf_service_instance_id.to_string(),
                    ]
                    .join(",")
                }),
            self.smf_service_instance_id
                .as_ref()
                .map(|smf_service_instance_id| {
                    vec![
                        "smfServiceInstanceId".to_string(),
                        smf_service_instance_id.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping recoveryTime in query parameter serialization
            self.forwarding_ind.as_ref().map(|forwarding_ind| {
                vec!["forwardingInd".to_string(), forwarding_ind.to_string()].join(",")
            }),
            // Skipping psaTunnelInfo in query parameter serialization
            self.charging_id.as_ref().map(|charging_id| {
                vec!["chargingId".to_string(), charging_id.to_string()].join(",")
            }),
            // Skipping chargingInfo in query parameter serialization

            // Skipping roamingChargingProfile in query parameter serialization
            self.nef_ext_buf_support_ind
                .as_ref()
                .map(|nef_ext_buf_support_ind| {
                    vec![
                        "nefExtBufSupportInd".to_string(),
                        nef_ext_buf_support_ind.to_string(),
                    ]
                    .join(",")
                }),
            self.ipv6_index
                .as_ref()
                .map(|ipv6_index| vec!["ipv6Index".to_string(), ipv6_index.to_string()].join(",")),
            // Skipping dnAaaAddress in query parameter serialization

            // Skipping redundantPduSessionInfo in query parameter serialization

            // Skipping ranTunnelInfo in query parameter serialization

            // Skipping addRanTunnelInfo in query parameter serialization

            // Skipping redRanTunnelInfo in query parameter serialization

            // Skipping addRedRanTunnelInfo in query parameter serialization
            self.nspu_support_ind.as_ref().map(|nspu_support_ind| {
                vec!["nspuSupportInd".to_string(), nspu_support_ind.to_string()].join(",")
            }),
            self.smf_binding_info.as_ref().map(|smf_binding_info| {
                vec!["smfBindingInfo".to_string(), smf_binding_info.to_string()].join(",")
            }),
            // Skipping satelliteBackhaulCat in query parameter serialization
            self.ssc_mode
                .as_ref()
                .map(|ssc_mode| vec!["sscMode".to_string(), ssc_mode.to_string()].join(",")),
            self.dlset_support_ind.as_ref().map(|dlset_support_ind| {
                vec!["dlsetSupportInd".to_string(), dlset_support_ind.to_string()].join(",")
            }),
            self.n9fsc_support_ind.as_ref().map(|n9fsc_support_ind| {
                vec!["n9fscSupportInd".to_string(), n9fsc_support_ind.to_string()].join(",")
            }),
            self.disaster_roaming_ind
                .as_ref()
                .map(|disaster_roaming_ind| {
                    vec![
                        "disasterRoamingInd".to_string(),
                        disaster_roaming_ind.to_string(),
                    ]
                    .join(",")
                }),
            self.anchor_smf_oauth2_required
                .as_ref()
                .map(|anchor_smf_oauth2_required| {
                    vec![
                        "anchorSmfOauth2Required".to_string(),
                        anchor_smf_oauth2_required.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SmContext value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SmContext {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub pdu_session_id: Vec<u8>,
            pub dnn: Vec<String>,
            pub selected_dnn: Vec<String>,
            pub s_nssai: Vec<models::Snssai>,
            pub hplmn_snssai: Vec<models::Snssai>,
            pub pdu_session_type: Vec<models::PduSessionType>,
            pub gpsi: Vec<String>,
            pub h_smf_uri: Vec<String>,
            pub smf_uri: Vec<String>,
            pub pdu_session_ref: Vec<String>,
            pub inter_plmn_api_root: Vec<String>,
            pub intra_plmn_api_root: Vec<String>,
            pub pcf_id: Vec<uuid::Uuid>,
            pub pcf_group_id: Vec<String>,
            pub pcf_set_id: Vec<String>,
            pub sel_mode: Vec<models::DnnSelectionMode>,
            pub udm_group_id: Vec<String>,
            pub routing_indicator: Vec<String>,
            pub h_nw_pub_key_id: Vec<i32>,
            pub session_ambr: Vec<models::Ambr>,
            pub qos_flows_list: Vec<Vec<models::QosFlowSetupItem>>,
            pub h_smf_instance_id: Vec<uuid::Uuid>,
            pub smf_instance_id: Vec<uuid::Uuid>,
            pub pdu_session_smf_set_id: Vec<String>,
            pub pdu_session_smf_service_set_id: Vec<String>,
            pub pdu_session_smf_binding: Vec<models::SbiBindingLevel>,
            pub enable_pause_charging: Vec<bool>,
            pub ue_ipv4_address: Vec<String>,
            pub ue_ipv6_prefix: Vec<models::Ipv6Prefix>,
            pub eps_pdn_cnx_info: Vec<models::EpsPdnCnxInfo>,
            pub eps_bearer_info: Vec<Vec<models::EpsBearerInfo>>,
            pub max_integrity_protected_data_rate: Vec<models::MaxIntegrityProtectedDataRate>,
            pub max_integrity_protected_data_rate_dl: Vec<models::MaxIntegrityProtectedDataRate>,
            pub always_on_granted: Vec<bool>,
            pub up_security: Vec<models::UpSecurity>,
            pub h_smf_service_instance_id: Vec<String>,
            pub smf_service_instance_id: Vec<String>,
            pub recovery_time: Vec<chrono::DateTime<chrono::Utc>>,
            pub forwarding_ind: Vec<bool>,
            pub psa_tunnel_info: Vec<models::TunnelInfo>,
            pub charging_id: Vec<String>,
            pub charging_info: Vec<models::ChargingInformation>,
            pub roaming_charging_profile: Vec<models::RoamingChargingProfile>,
            pub nef_ext_buf_support_ind: Vec<bool>,
            pub ipv6_index: Vec<i32>,
            pub dn_aaa_address: Vec<models::IpAddress>,
            pub redundant_pdu_session_info: Vec<models::RedundantPduSessionInformation>,
            pub ran_tunnel_info: Vec<models::QosFlowTunnel>,
            pub add_ran_tunnel_info: Vec<Vec<models::QosFlowTunnel>>,
            pub red_ran_tunnel_info: Vec<models::QosFlowTunnel>,
            pub add_red_ran_tunnel_info: Vec<Vec<models::QosFlowTunnel>>,
            pub nspu_support_ind: Vec<bool>,
            pub smf_binding_info: Vec<String>,
            pub satellite_backhaul_cat: Vec<models::SatelliteBackhaulCategory>,
            pub ssc_mode: Vec<String>,
            pub dlset_support_ind: Vec<bool>,
            pub n9fsc_support_ind: Vec<bool>,
            pub disaster_roaming_ind: Vec<bool>,
            pub anchor_smf_oauth2_required: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SmContext".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "pduSessionId" => intermediate_rep
                        .pdu_session_id
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dnn" => intermediate_rep.dnn.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "selectedDnn" => intermediate_rep.selected_dnn.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "sNssai" => intermediate_rep.s_nssai.push(
                        <models::Snssai as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "hplmnSnssai" => intermediate_rep.hplmn_snssai.push(
                        <models::Snssai as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "pduSessionType" => intermediate_rep.pdu_session_type.push(
                        <models::PduSessionType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "gpsi" => intermediate_rep.gpsi.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "hSmfUri" => intermediate_rep.h_smf_uri.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "smfUri" => intermediate_rep.smf_uri.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "pduSessionRef" => intermediate_rep.pdu_session_ref.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "interPlmnApiRoot" => intermediate_rep.inter_plmn_api_root.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "intraPlmnApiRoot" => intermediate_rep.intra_plmn_api_root.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "pcfId" => intermediate_rep.pcf_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "pcfGroupId" => intermediate_rep.pcf_group_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "pcfSetId" => intermediate_rep.pcf_set_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "selMode" => intermediate_rep.sel_mode.push(
                        <models::DnnSelectionMode as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "udmGroupId" => intermediate_rep.udm_group_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "routingIndicator" => intermediate_rep.routing_indicator.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "hNwPubKeyId" => intermediate_rep.h_nw_pub_key_id.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "sessionAmbr" => intermediate_rep.session_ambr.push(
                        <models::Ambr as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "qosFlowsList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SmContext"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "hSmfInstanceId" => intermediate_rep.h_smf_instance_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "smfInstanceId" => intermediate_rep.smf_instance_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "pduSessionSmfSetId" => intermediate_rep.pdu_session_smf_set_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "pduSessionSmfServiceSetId" => {
                        intermediate_rep.pdu_session_smf_service_set_id.push(
                            <String as std::str::FromStr>::from_str(val)
                                .map_err(|x| x.to_string())?,
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "pduSessionSmfBinding" => intermediate_rep.pdu_session_smf_binding.push(
                        <models::SbiBindingLevel as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "enablePauseCharging" => intermediate_rep.enable_pause_charging.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ueIpv4Address" => intermediate_rep.ue_ipv4_address.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ueIpv6Prefix" => intermediate_rep.ue_ipv6_prefix.push(
                        <models::Ipv6Prefix as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "epsPdnCnxInfo" => intermediate_rep.eps_pdn_cnx_info.push(
                        <models::EpsPdnCnxInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "epsBearerInfo" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SmContext"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "maxIntegrityProtectedDataRate" => {
                        intermediate_rep.max_integrity_protected_data_rate.push(
                            <models::MaxIntegrityProtectedDataRate as std::str::FromStr>::from_str(
                                val,
                            )
                            .map_err(|x| x.to_string())?,
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "maxIntegrityProtectedDataRateDl" => {
                        intermediate_rep.max_integrity_protected_data_rate_dl.push(
                            <models::MaxIntegrityProtectedDataRate as std::str::FromStr>::from_str(
                                val,
                            )
                            .map_err(|x| x.to_string())?,
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "alwaysOnGranted" => intermediate_rep.always_on_granted.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "upSecurity" => intermediate_rep.up_security.push(
                        <models::UpSecurity as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "hSmfServiceInstanceId" => intermediate_rep.h_smf_service_instance_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "smfServiceInstanceId" => intermediate_rep.smf_service_instance_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "recoveryTime" => intermediate_rep.recovery_time.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "forwardingInd" => intermediate_rep.forwarding_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "psaTunnelInfo" => intermediate_rep.psa_tunnel_info.push(
                        <models::TunnelInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "chargingId" => intermediate_rep.charging_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "chargingInfo" => intermediate_rep.charging_info.push(
                        <models::ChargingInformation as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "roamingChargingProfile" => intermediate_rep.roaming_charging_profile.push(
                        <models::RoamingChargingProfile as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nefExtBufSupportInd" => intermediate_rep.nef_ext_buf_support_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ipv6Index" => intermediate_rep.ipv6_index.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "dnAaaAddress" => intermediate_rep.dn_aaa_address.push(
                        <models::IpAddress as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "redundantPduSessionInfo" => intermediate_rep.redundant_pdu_session_info.push(
                        <models::RedundantPduSessionInformation as std::str::FromStr>::from_str(
                            val,
                        )
                        .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ranTunnelInfo" => intermediate_rep.ran_tunnel_info.push(
                        <models::QosFlowTunnel as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "addRanTunnelInfo" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SmContext"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "redRanTunnelInfo" => intermediate_rep.red_ran_tunnel_info.push(
                        <models::QosFlowTunnel as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "addRedRanTunnelInfo" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SmContext"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "nspuSupportInd" => intermediate_rep.nspu_support_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "smfBindingInfo" => intermediate_rep.smf_binding_info.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "satelliteBackhaulCat" => intermediate_rep.satellite_backhaul_cat.push(
                        <models::SatelliteBackhaulCategory as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "sscMode" => intermediate_rep.ssc_mode.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "dlsetSupportInd" => intermediate_rep.dlset_support_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n9fscSupportInd" => intermediate_rep.n9fsc_support_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "disasterRoamingInd" => intermediate_rep.disaster_roaming_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "anchorSmfOauth2Required" => intermediate_rep.anchor_smf_oauth2_required.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SmContext".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SmContext {
            pdu_session_id: intermediate_rep
                .pdu_session_id
                .into_iter()
                .next()
                .ok_or_else(|| "pduSessionId missing in SmContext".to_string())?,
            dnn: intermediate_rep
                .dnn
                .into_iter()
                .next()
                .ok_or_else(|| "dnn missing in SmContext".to_string())?,
            selected_dnn: intermediate_rep.selected_dnn.into_iter().next(),
            s_nssai: intermediate_rep
                .s_nssai
                .into_iter()
                .next()
                .ok_or_else(|| "sNssai missing in SmContext".to_string())?,
            hplmn_snssai: intermediate_rep.hplmn_snssai.into_iter().next(),
            pdu_session_type: intermediate_rep
                .pdu_session_type
                .into_iter()
                .next()
                .ok_or_else(|| "pduSessionType missing in SmContext".to_string())?,
            gpsi: intermediate_rep.gpsi.into_iter().next(),
            h_smf_uri: intermediate_rep.h_smf_uri.into_iter().next(),
            smf_uri: intermediate_rep.smf_uri.into_iter().next(),
            pdu_session_ref: intermediate_rep.pdu_session_ref.into_iter().next(),
            inter_plmn_api_root: intermediate_rep.inter_plmn_api_root.into_iter().next(),
            intra_plmn_api_root: intermediate_rep.intra_plmn_api_root.into_iter().next(),
            pcf_id: intermediate_rep.pcf_id.into_iter().next(),
            pcf_group_id: intermediate_rep.pcf_group_id.into_iter().next(),
            pcf_set_id: intermediate_rep.pcf_set_id.into_iter().next(),
            sel_mode: intermediate_rep.sel_mode.into_iter().next(),
            udm_group_id: intermediate_rep.udm_group_id.into_iter().next(),
            routing_indicator: intermediate_rep.routing_indicator.into_iter().next(),
            h_nw_pub_key_id: intermediate_rep.h_nw_pub_key_id.into_iter().next(),
            session_ambr: intermediate_rep
                .session_ambr
                .into_iter()
                .next()
                .ok_or_else(|| "sessionAmbr missing in SmContext".to_string())?,
            qos_flows_list: intermediate_rep
                .qos_flows_list
                .into_iter()
                .next()
                .ok_or_else(|| "qosFlowsList missing in SmContext".to_string())?,
            h_smf_instance_id: intermediate_rep.h_smf_instance_id.into_iter().next(),
            smf_instance_id: intermediate_rep.smf_instance_id.into_iter().next(),
            pdu_session_smf_set_id: intermediate_rep.pdu_session_smf_set_id.into_iter().next(),
            pdu_session_smf_service_set_id: intermediate_rep
                .pdu_session_smf_service_set_id
                .into_iter()
                .next(),
            pdu_session_smf_binding: intermediate_rep.pdu_session_smf_binding.into_iter().next(),
            enable_pause_charging: intermediate_rep.enable_pause_charging.into_iter().next(),
            ue_ipv4_address: intermediate_rep.ue_ipv4_address.into_iter().next(),
            ue_ipv6_prefix: intermediate_rep.ue_ipv6_prefix.into_iter().next(),
            eps_pdn_cnx_info: intermediate_rep.eps_pdn_cnx_info.into_iter().next(),
            eps_bearer_info: intermediate_rep.eps_bearer_info.into_iter().next(),
            max_integrity_protected_data_rate: intermediate_rep
                .max_integrity_protected_data_rate
                .into_iter()
                .next(),
            max_integrity_protected_data_rate_dl: intermediate_rep
                .max_integrity_protected_data_rate_dl
                .into_iter()
                .next(),
            always_on_granted: intermediate_rep.always_on_granted.into_iter().next(),
            up_security: intermediate_rep.up_security.into_iter().next(),
            h_smf_service_instance_id: intermediate_rep
                .h_smf_service_instance_id
                .into_iter()
                .next(),
            smf_service_instance_id: intermediate_rep.smf_service_instance_id.into_iter().next(),
            recovery_time: intermediate_rep.recovery_time.into_iter().next(),
            forwarding_ind: intermediate_rep.forwarding_ind.into_iter().next(),
            psa_tunnel_info: intermediate_rep.psa_tunnel_info.into_iter().next(),
            charging_id: intermediate_rep.charging_id.into_iter().next(),
            charging_info: intermediate_rep.charging_info.into_iter().next(),
            roaming_charging_profile: intermediate_rep.roaming_charging_profile.into_iter().next(),
            nef_ext_buf_support_ind: intermediate_rep.nef_ext_buf_support_ind.into_iter().next(),
            ipv6_index: intermediate_rep.ipv6_index.into_iter().next(),
            dn_aaa_address: intermediate_rep.dn_aaa_address.into_iter().next(),
            redundant_pdu_session_info: intermediate_rep
                .redundant_pdu_session_info
                .into_iter()
                .next(),
            ran_tunnel_info: intermediate_rep.ran_tunnel_info.into_iter().next(),
            add_ran_tunnel_info: intermediate_rep.add_ran_tunnel_info.into_iter().next(),
            red_ran_tunnel_info: intermediate_rep.red_ran_tunnel_info.into_iter().next(),
            add_red_ran_tunnel_info: intermediate_rep.add_red_ran_tunnel_info.into_iter().next(),
            nspu_support_ind: intermediate_rep.nspu_support_ind.into_iter().next(),
            smf_binding_info: intermediate_rep.smf_binding_info.into_iter().next(),
            satellite_backhaul_cat: intermediate_rep.satellite_backhaul_cat.into_iter().next(),
            ssc_mode: intermediate_rep.ssc_mode.into_iter().next(),
            dlset_support_ind: intermediate_rep.dlset_support_ind.into_iter().next(),
            n9fsc_support_ind: intermediate_rep.n9fsc_support_ind.into_iter().next(),
            disaster_roaming_ind: intermediate_rep.disaster_roaming_ind.into_iter().next(),
            anchor_smf_oauth2_required: intermediate_rep
                .anchor_smf_oauth2_required
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SmContext> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SmContext>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SmContext>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SmContext - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SmContext> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SmContext as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SmContext - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Data within Create SM Context Request
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SmContextCreateData {
    /// String identifying a Supi that shall contain either an IMSI, a network specific identifier, a Global Cable Identifier (GCI) or a Global Line Identifier (GLI) as specified in clause  2.2A of 3GPP TS 23.003. It shall be formatted as follows  - for an IMSI \"imsi-<imsi>\", where <imsi> shall be formatted according to clause 2.2    of 3GPP TS 23.003 that describes an IMSI.  - for a network specific identifier \"nai-<nai>, where <nai> shall be formatted    according to clause 28.7.2 of 3GPP TS 23.003 that describes an NAI.  - for a GCI \"gci-<gci>\", where <gci> shall be formatted according to clause 28.15.2    of 3GPP TS 23.003.  - for a GLI \"gli-<gli>\", where <gli> shall be formatted according to clause 28.16.2 of    3GPP TS 23.003.To enable that the value is used as part of an URI, the string shall    only contain characters allowed according to the \"lower-with-hyphen\" naming convention    defined in 3GPP TS 29.501.
    #[serde(rename = "supi")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supi: Option<String>,

    #[serde(rename = "unauthenticatedSupi")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unauthenticated_supi: Option<bool>,

    /// String representing a Permanent Equipment Identifier that may contain - an IMEI or IMEISV, as  specified in clause 6.2 of 3GPP TS 23.003; a MAC address for a 5G-RG or FN-RG via  wireline  access, with an indication that this address cannot be trusted for regulatory purpose if this  address cannot be used as an Equipment Identifier of the FN-RG, as specified in clause 4.7.7  of 3GPP TS23.316. Examples are imei-012345678901234 or imeisv-0123456789012345.
    #[serde(rename = "pei")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pei: Option<String>,

    /// String identifying a Gpsi shall contain either an External Id or an MSISDN.  It shall be formatted as follows -External Identifier= \"extid-'extid', where 'extid'  shall be formatted according to clause 19.7.2 of 3GPP TS 23.003 that describes an  External Identifier.
    #[serde(rename = "gpsi")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gpsi: Option<String>,

    /// Unsigned integer identifying a PDU session, within the range 0 to 255, as specified in  clause 11.2.3.1b, bits 1 to 8, of 3GPP TS 24.007. If the PDU Session ID is allocated by the  Core Network for UEs not supporting N1 mode, reserved range 64 to 95 is used. PDU Session ID  within the reserved range is only visible in the Core Network.
    #[serde(rename = "pduSessionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pdu_session_id: Option<u8>,

    /// String representing a Data Network as defined in clause 9A of 3GPP TS 23.003;  it shall contain either a DNN Network Identifier, or a full DNN with both the Network  Identifier and Operator Identifier, as specified in 3GPP TS 23.003 clause 9.1.1 and 9.1.2. It shall be coded as string in which the labels are separated by dots  (e.g. \"Label1.Label2.Label3\").
    #[serde(rename = "dnn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dnn: Option<String>,

    /// String representing a Data Network as defined in clause 9A of 3GPP TS 23.003;  it shall contain either a DNN Network Identifier, or a full DNN with both the Network  Identifier and Operator Identifier, as specified in 3GPP TS 23.003 clause 9.1.1 and 9.1.2. It shall be coded as string in which the labels are separated by dots  (e.g. \"Label1.Label2.Label3\").
    #[serde(rename = "selectedDnn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub selected_dnn: Option<String>,

    #[serde(rename = "sNssai")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub s_nssai: Option<models::Snssai>,

    #[serde(rename = "hplmnSnssai")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hplmn_snssai: Option<models::Snssai>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "servingNfId")]
    pub serving_nf_id: uuid::Uuid,

    #[serde(rename = "guami")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub guami: Option<models::Guami>,

    #[serde(rename = "serviceName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_name: Option<models::ServiceName>,

    #[serde(rename = "servingNetwork")]
    pub serving_network: models::PlmnIdNid,

    #[serde(rename = "requestType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub request_type: Option<models::RequestType>,

    #[serde(rename = "n1SmMsg")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n1_sm_msg: Option<models::RefToBinaryData>,

    #[serde(rename = "anType")]
    pub an_type: models::AccessType,

    #[serde(rename = "additionalAnType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_an_type: Option<models::AccessType>,

    #[serde(rename = "ratType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rat_type: Option<models::RatType>,

    #[serde(rename = "presenceInLadn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub presence_in_ladn: Option<models::PresenceState>,

    #[serde(rename = "ueLocation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_location: Option<models::UserLocation>,

    /// String with format \"time-numoffset\" optionally appended by \"daylightSavingTime\", where  - \"time-numoffset\" shall represent the time zone adjusted for daylight saving time and be    encoded as time-numoffset as defined in clause 5.6 of IETF RFC 3339;  - \"daylightSavingTime\" shall represent the adjustment that has been made and shall be    encoded as \"+1\" or \"+2\" for a +1 or +2 hours adjustment.   The example is for 8 hours behind UTC, +1 hour adjustment for Daylight Saving Time.
    #[serde(rename = "ueTimeZone")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_time_zone: Option<String>,

    #[serde(rename = "addUeLocation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub add_ue_location: Option<models::UserLocation>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "smContextStatusUri")]
    pub sm_context_status_uri: String,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "hSmfUri")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub h_smf_uri: Option<String>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "hSmfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub h_smf_id: Option<uuid::Uuid>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "smfUri")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub smf_uri: Option<String>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "smfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub smf_id: Option<uuid::Uuid>,

    #[serde(rename = "additionalHsmfUri")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_hsmf_uri: Option<Vec<models::Uri>>,

    #[serde(rename = "additionalHsmfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_hsmf_id: Option<Vec<models::NfInstanceId>>,

    #[serde(rename = "additionalSmfUri")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_smf_uri: Option<Vec<models::Uri>>,

    #[serde(rename = "additionalSmfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_smf_id: Option<Vec<models::NfInstanceId>>,

    /// Unsigned integer identifying a PDU session, within the range 0 to 255, as specified in  clause 11.2.3.1b, bits 1 to 8, of 3GPP TS 24.007. If the PDU Session ID is allocated by the  Core Network for UEs not supporting N1 mode, reserved range 64 to 95 is used. PDU Session ID  within the reserved range is only visible in the Core Network.
    #[serde(rename = "oldPduSessionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub old_pdu_session_id: Option<u8>,

    #[serde(rename = "pduSessionsActivateList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pdu_sessions_activate_list: Option<Vec<models::PduSessionId>>,

    /// UE EPS PDN Connection container from SMF to AMF
    #[serde(rename = "ueEpsPdnConnection")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_eps_pdn_connection: Option<String>,

    #[serde(rename = "hoState")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ho_state: Option<models::HoState>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "pcfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pcf_id: Option<uuid::Uuid>,

    /// Identifier of a group of NFs.
    #[serde(rename = "pcfGroupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pcf_group_id: Option<String>,

    /// NF Set Identifier (see clause 28.12 of 3GPP TS 23.003), formatted as the following string \"set<Set ID>.<nftype>set.5gc.mnc<MNC>.mcc<MCC>\", or  \"set<SetID>.<NFType>set.5gc.nid<NID>.mnc<MNC>.mcc<MCC>\" with  <MCC> encoded as defined in clause 5.4.2 (\"Mcc\" data type definition)  <MNC> encoding the Mobile Network Code part of the PLMN, comprising 3 digits.    If there are only 2 significant digits in the MNC, one \"0\" digit shall be inserted    at the left side to fill the 3 digits coding of MNC.  Pattern: '^[0-9]{3}$' <NFType> encoded as a value defined in Table 6.1.6.3.3-1 of 3GPP TS 29.510 but    with lower case characters <Set ID> encoded as a string of characters consisting of    alphabetic characters (A-Z and a-z), digits (0-9) and/or the hyphen (-) and that    shall end with either an alphabetic character or a digit.
    #[serde(rename = "pcfSetId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pcf_set_id: Option<String>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "nrfUri")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nrf_uri: Option<String>,

    /// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  table 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.
    #[serde(rename = "supportedFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_features: Option<String>,

    #[serde(rename = "selMode")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sel_mode: Option<models::DnnSelectionMode>,

    #[serde(rename = "backupAmfInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub backup_amf_info: Option<Vec<models::BackupAmfInfo>>,

    #[serde(rename = "traceData")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trace_data: Option<swagger::Nullable<models::TraceData>>,

    /// Identifier of a group of NFs.
    #[serde(rename = "udmGroupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub udm_group_id: Option<String>,

    #[serde(rename = "routingIndicator")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub routing_indicator: Option<String>,

    #[serde(rename = "hNwPubKeyId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub h_nw_pub_key_id: Option<i32>,

    #[serde(rename = "epsInterworkingInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub eps_interworking_ind: Option<models::EpsInterworkingIndication>,

    #[serde(rename = "indirectForwardingFlag")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub indirect_forwarding_flag: Option<bool>,

    #[serde(rename = "directForwardingFlag")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub direct_forwarding_flag: Option<bool>,

    #[serde(rename = "targetId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_id: Option<models::NgRanTargetId>,

    /// EPS bearer context status
    #[serde(rename = "epsBearerCtxStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub eps_bearer_ctx_status: Option<String>,

    #[serde(rename = "cpCiotEnabled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cp_ciot_enabled: Option<bool>,

    #[serde(rename = "cpOnlyInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cp_only_ind: Option<bool>,

    #[serde(rename = "invokeNef")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub invoke_nef: Option<bool>,

    #[serde(rename = "maRequestInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ma_request_ind: Option<bool>,

    #[serde(rename = "maNwUpgradeInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ma_nw_upgrade_ind: Option<bool>,

    #[serde(rename = "n2SmInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n2_sm_info: Option<models::RefToBinaryData>,

    #[serde(rename = "n2SmInfoType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n2_sm_info_type: Option<models::N2SmInfoType>,

    #[serde(rename = "n2SmInfoExt1")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n2_sm_info_ext1: Option<models::RefToBinaryData>,

    #[serde(rename = "n2SmInfoTypeExt1")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n2_sm_info_type_ext1: Option<models::N2SmInfoType>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "smContextRef")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sm_context_ref: Option<String>,

    #[serde(rename = "smContextSmfPlmnId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sm_context_smf_plmn_id: Option<models::PlmnIdNid>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "smContextSmfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sm_context_smf_id: Option<uuid::Uuid>,

    /// NF Set Identifier (see clause 28.12 of 3GPP TS 23.003), formatted as the following string \"set<Set ID>.<nftype>set.5gc.mnc<MNC>.mcc<MCC>\", or  \"set<SetID>.<NFType>set.5gc.nid<NID>.mnc<MNC>.mcc<MCC>\" with  <MCC> encoded as defined in clause 5.4.2 (\"Mcc\" data type definition)  <MNC> encoding the Mobile Network Code part of the PLMN, comprising 3 digits.    If there are only 2 significant digits in the MNC, one \"0\" digit shall be inserted    at the left side to fill the 3 digits coding of MNC.  Pattern: '^[0-9]{3}$' <NFType> encoded as a value defined in Table 6.1.6.3.3-1 of 3GPP TS 29.510 but    with lower case characters <Set ID> encoded as a string of characters consisting of    alphabetic characters (A-Z and a-z), digits (0-9) and/or the hyphen (-) and that    shall end with either an alphabetic character or a digit.
    #[serde(rename = "smContextSmfSetId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sm_context_smf_set_id: Option<String>,

    /// NF Service Set Identifier (see clause 28.12 of 3GPP TS 23.003) formatted as the following  string \"set<Set ID>.sn<Service Name>.nfi<NF Instance ID>.5gc.mnc<MNC>.mcc<MCC>\", or  \"set<SetID>.sn<ServiceName>.nfi<NFInstanceID>.5gc.nid<NID>.mnc<MNC>.mcc<MCC>\" with  <MCC> encoded as defined in clause 5.4.2 (\"Mcc\" data type definition)   <MNC> encoding the Mobile Network Code part of the PLMN, comprising 3 digits.    If there are only 2 significant digits in the MNC, one \"0\" digit shall be inserted    at the left side to fill the 3 digits coding of MNC.  Pattern: '^[0-9]{3}$' <NID> encoded as defined in clause 5.4.2 (\"Nid\" data type definition)  <NFInstanceId> encoded as defined in clause 5.3.2  <ServiceName> encoded as defined in 3GPP TS 29.510  <Set ID> encoded as a string of characters consisting of alphabetic    characters (A-Z and a-z), digits (0-9) and/or the hyphen (-) and that shall end    with either an alphabetic character or a digit.
    #[serde(rename = "smContextSmfServiceSetId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sm_context_smf_service_set_id: Option<String>,

    #[serde(rename = "smContextSmfBinding")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sm_context_smf_binding: Option<models::SbiBindingLevel>,

    #[serde(rename = "upCnxState")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub up_cnx_state: Option<models::UpCnxState>,

    #[serde(rename = "smallDataRateStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub small_data_rate_status: Option<models::SmallDataRateStatus>,

    #[serde(rename = "apnRateStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub apn_rate_status: Option<models::ApnRateStatus>,

    #[serde(rename = "extendedNasSmTimerInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub extended_nas_sm_timer_ind: Option<bool>,

    #[serde(rename = "dlDataWaitingInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dl_data_waiting_ind: Option<bool>,

    #[serde(rename = "ddnFailureSubs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ddn_failure_subs: Option<models::DdnFailureSubs>,

    #[serde(rename = "smfTransferInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub smf_transfer_ind: Option<bool>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "oldSmfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub old_smf_id: Option<uuid::Uuid>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "oldSmContextRef")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub old_sm_context_ref: Option<String>,

    #[serde(rename = "wAgfInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub w_agf_info: Option<models::WAgfInfo>,

    #[serde(rename = "tngfInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tngf_info: Option<models::TngfInfo>,

    #[serde(rename = "twifInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub twif_info: Option<models::TwifInfo>,

    #[serde(rename = "ranUnchangedInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ran_unchanged_ind: Option<bool>,

    #[serde(rename = "samePcfSelectionInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub same_pcf_selection_ind: Option<bool>,

    /// DNAI (Data network access identifier), see clause 5.6.7 of 3GPP TS 23.501.
    #[serde(rename = "targetDnai")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_dnai: Option<String>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "nrfManagementUri")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nrf_management_uri: Option<String>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "nrfDiscoveryUri")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nrf_discovery_uri: Option<String>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "nrfAccessTokenUri")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nrf_access_token_uri: Option<String>,

    /// Map indicating whether the NRF requires Oauth2-based authorization for accessing its services. The key of the map shall be the name of an NRF service, e.g. \"nnrf-nfm\" or \"nnrf-disc\"
    #[serde(rename = "nrfOauth2Required")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nrf_oauth2_required: Option<std::collections::HashMap<String, bool>>,

    #[serde(rename = "smfBindingInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub smf_binding_info: Option<String>,

    #[serde(rename = "pvsInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pvs_info: Option<Vec<models::ServerAddressingInfo>>,

    #[serde(rename = "onboardingInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub onboarding_ind: Option<bool>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "oldPduSessionRef")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub old_pdu_session_ref: Option<String>,

    #[serde(rename = "smPolicyNotifyInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sm_policy_notify_ind: Option<bool>,

    #[serde(rename = "pcfUeCallbackInfo")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pcf_ue_callback_info: Option<swagger::Nullable<models::PcfUeCallbackInfo>>,

    #[serde(rename = "satelliteBackhaulCat")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub satellite_backhaul_cat: Option<models::SatelliteBackhaulCategory>,

    #[serde(rename = "upipSupported")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub upip_supported: Option<bool>,

    #[serde(rename = "uavAuthenticated")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub uav_authenticated: Option<bool>,

    #[serde(rename = "disasterRoamingInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub disaster_roaming_ind: Option<bool>,

    #[serde(rename = "anchorSmfOauth2Required")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub anchor_smf_oauth2_required: Option<bool>,

    #[serde(rename = "smContextSmfOauth2Required")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sm_context_smf_oauth2_required: Option<bool>,
}

impl SmContextCreateData {
    #[allow(clippy::new_without_default)]
    pub fn new(
        serving_nf_id: uuid::Uuid,
        serving_network: models::PlmnIdNid,
        an_type: models::AccessType,
        sm_context_status_uri: String,
    ) -> SmContextCreateData {
        SmContextCreateData {
            supi: None,
            unauthenticated_supi: Some(false),
            pei: None,
            gpsi: None,
            pdu_session_id: None,
            dnn: None,
            selected_dnn: None,
            s_nssai: None,
            hplmn_snssai: None,
            serving_nf_id,
            guami: None,
            service_name: None,
            serving_network,
            request_type: None,
            n1_sm_msg: None,
            an_type,
            additional_an_type: None,
            rat_type: None,
            presence_in_ladn: None,
            ue_location: None,
            ue_time_zone: None,
            add_ue_location: None,
            sm_context_status_uri,
            h_smf_uri: None,
            h_smf_id: None,
            smf_uri: None,
            smf_id: None,
            additional_hsmf_uri: None,
            additional_hsmf_id: None,
            additional_smf_uri: None,
            additional_smf_id: None,
            old_pdu_session_id: None,
            pdu_sessions_activate_list: None,
            ue_eps_pdn_connection: None,
            ho_state: None,
            pcf_id: None,
            pcf_group_id: None,
            pcf_set_id: None,
            nrf_uri: None,
            supported_features: None,
            sel_mode: None,
            backup_amf_info: None,
            trace_data: None,
            udm_group_id: None,
            routing_indicator: None,
            h_nw_pub_key_id: None,
            eps_interworking_ind: None,
            indirect_forwarding_flag: None,
            direct_forwarding_flag: None,
            target_id: None,
            eps_bearer_ctx_status: None,
            cp_ciot_enabled: Some(false),
            cp_only_ind: Some(false),
            invoke_nef: Some(false),
            ma_request_ind: Some(false),
            ma_nw_upgrade_ind: Some(false),
            n2_sm_info: None,
            n2_sm_info_type: None,
            n2_sm_info_ext1: None,
            n2_sm_info_type_ext1: None,
            sm_context_ref: None,
            sm_context_smf_plmn_id: None,
            sm_context_smf_id: None,
            sm_context_smf_set_id: None,
            sm_context_smf_service_set_id: None,
            sm_context_smf_binding: None,
            up_cnx_state: None,
            small_data_rate_status: None,
            apn_rate_status: None,
            extended_nas_sm_timer_ind: Some(false),
            dl_data_waiting_ind: Some(false),
            ddn_failure_subs: None,
            smf_transfer_ind: Some(false),
            old_smf_id: None,
            old_sm_context_ref: None,
            w_agf_info: None,
            tngf_info: None,
            twif_info: None,
            ran_unchanged_ind: None,
            same_pcf_selection_ind: Some(false),
            target_dnai: None,
            nrf_management_uri: None,
            nrf_discovery_uri: None,
            nrf_access_token_uri: None,
            nrf_oauth2_required: None,
            smf_binding_info: None,
            pvs_info: None,
            onboarding_ind: Some(false),
            old_pdu_session_ref: None,
            sm_policy_notify_ind: Some(false),
            pcf_ue_callback_info: None,
            satellite_backhaul_cat: None,
            upip_supported: Some(false),
            uav_authenticated: None,
            disaster_roaming_ind: Some(false),
            anchor_smf_oauth2_required: None,
            sm_context_smf_oauth2_required: None,
        }
    }
}

/// Converts the SmContextCreateData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SmContextCreateData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.supi
                .as_ref()
                .map(|supi| vec!["supi".to_string(), supi.to_string()].join(",")),
            self.unauthenticated_supi
                .as_ref()
                .map(|unauthenticated_supi| {
                    vec![
                        "unauthenticatedSupi".to_string(),
                        unauthenticated_supi.to_string(),
                    ]
                    .join(",")
                }),
            self.pei
                .as_ref()
                .map(|pei| vec!["pei".to_string(), pei.to_string()].join(",")),
            self.gpsi
                .as_ref()
                .map(|gpsi| vec!["gpsi".to_string(), gpsi.to_string()].join(",")),
            self.pdu_session_id.as_ref().map(|pdu_session_id| {
                vec!["pduSessionId".to_string(), pdu_session_id.to_string()].join(",")
            }),
            self.dnn
                .as_ref()
                .map(|dnn| vec!["dnn".to_string(), dnn.to_string()].join(",")),
            self.selected_dnn.as_ref().map(|selected_dnn| {
                vec!["selectedDnn".to_string(), selected_dnn.to_string()].join(",")
            }),
            // Skipping sNssai in query parameter serialization

            // Skipping hplmnSnssai in query parameter serialization

            // Skipping servingNfId in query parameter serialization

            // Skipping guami in query parameter serialization

            // Skipping serviceName in query parameter serialization

            // Skipping servingNetwork in query parameter serialization

            // Skipping requestType in query parameter serialization

            // Skipping n1SmMsg in query parameter serialization

            // Skipping anType in query parameter serialization

            // Skipping additionalAnType in query parameter serialization

            // Skipping ratType in query parameter serialization

            // Skipping presenceInLadn in query parameter serialization

            // Skipping ueLocation in query parameter serialization
            self.ue_time_zone.as_ref().map(|ue_time_zone| {
                vec!["ueTimeZone".to_string(), ue_time_zone.to_string()].join(",")
            }),
            // Skipping addUeLocation in query parameter serialization
            Some("smContextStatusUri".to_string()),
            Some(self.sm_context_status_uri.to_string()),
            self.h_smf_uri
                .as_ref()
                .map(|h_smf_uri| vec!["hSmfUri".to_string(), h_smf_uri.to_string()].join(",")),
            // Skipping hSmfId in query parameter serialization
            self.smf_uri
                .as_ref()
                .map(|smf_uri| vec!["smfUri".to_string(), smf_uri.to_string()].join(",")),
            // Skipping smfId in query parameter serialization
            self.additional_hsmf_uri
                .as_ref()
                .map(|additional_hsmf_uri| {
                    vec![
                        "additionalHsmfUri".to_string(),
                        additional_hsmf_uri
                            .iter()
                            .map(|x| x.to_string())
                            .collect::<Vec<_>>()
                            .join(","),
                    ]
                    .join(",")
                }),
            // Skipping additionalHsmfId in query parameter serialization
            self.additional_smf_uri.as_ref().map(|additional_smf_uri| {
                vec![
                    "additionalSmfUri".to_string(),
                    additional_smf_uri
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping additionalSmfId in query parameter serialization
            self.old_pdu_session_id.as_ref().map(|old_pdu_session_id| {
                vec![
                    "oldPduSessionId".to_string(),
                    old_pdu_session_id.to_string(),
                ]
                .join(",")
            }),
            self.pdu_sessions_activate_list
                .as_ref()
                .map(|pdu_sessions_activate_list| {
                    vec![
                        "pduSessionsActivateList".to_string(),
                        pdu_sessions_activate_list
                            .iter()
                            .map(|x| x.to_string())
                            .collect::<Vec<_>>()
                            .join(","),
                    ]
                    .join(",")
                }),
            self.ue_eps_pdn_connection
                .as_ref()
                .map(|ue_eps_pdn_connection| {
                    vec![
                        "ueEpsPdnConnection".to_string(),
                        ue_eps_pdn_connection.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping hoState in query parameter serialization

            // Skipping pcfId in query parameter serialization
            self.pcf_group_id.as_ref().map(|pcf_group_id| {
                vec!["pcfGroupId".to_string(), pcf_group_id.to_string()].join(",")
            }),
            self.pcf_set_id
                .as_ref()
                .map(|pcf_set_id| vec!["pcfSetId".to_string(), pcf_set_id.to_string()].join(",")),
            self.nrf_uri
                .as_ref()
                .map(|nrf_uri| vec!["nrfUri".to_string(), nrf_uri.to_string()].join(",")),
            self.supported_features.as_ref().map(|supported_features| {
                vec![
                    "supportedFeatures".to_string(),
                    supported_features.to_string(),
                ]
                .join(",")
            }),
            // Skipping selMode in query parameter serialization

            // Skipping backupAmfInfo in query parameter serialization

            // Skipping traceData in query parameter serialization
            self.udm_group_id.as_ref().map(|udm_group_id| {
                vec!["udmGroupId".to_string(), udm_group_id.to_string()].join(",")
            }),
            self.routing_indicator.as_ref().map(|routing_indicator| {
                vec![
                    "routingIndicator".to_string(),
                    routing_indicator.to_string(),
                ]
                .join(",")
            }),
            self.h_nw_pub_key_id.as_ref().map(|h_nw_pub_key_id| {
                vec!["hNwPubKeyId".to_string(), h_nw_pub_key_id.to_string()].join(",")
            }),
            // Skipping epsInterworkingInd in query parameter serialization
            self.indirect_forwarding_flag
                .as_ref()
                .map(|indirect_forwarding_flag| {
                    vec![
                        "indirectForwardingFlag".to_string(),
                        indirect_forwarding_flag.to_string(),
                    ]
                    .join(",")
                }),
            self.direct_forwarding_flag
                .as_ref()
                .map(|direct_forwarding_flag| {
                    vec![
                        "directForwardingFlag".to_string(),
                        direct_forwarding_flag.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping targetId in query parameter serialization
            self.eps_bearer_ctx_status
                .as_ref()
                .map(|eps_bearer_ctx_status| {
                    vec![
                        "epsBearerCtxStatus".to_string(),
                        eps_bearer_ctx_status.to_string(),
                    ]
                    .join(",")
                }),
            self.cp_ciot_enabled.as_ref().map(|cp_ciot_enabled| {
                vec!["cpCiotEnabled".to_string(), cp_ciot_enabled.to_string()].join(",")
            }),
            self.cp_only_ind.as_ref().map(|cp_only_ind| {
                vec!["cpOnlyInd".to_string(), cp_only_ind.to_string()].join(",")
            }),
            self.invoke_nef
                .as_ref()
                .map(|invoke_nef| vec!["invokeNef".to_string(), invoke_nef.to_string()].join(",")),
            self.ma_request_ind.as_ref().map(|ma_request_ind| {
                vec!["maRequestInd".to_string(), ma_request_ind.to_string()].join(",")
            }),
            self.ma_nw_upgrade_ind.as_ref().map(|ma_nw_upgrade_ind| {
                vec!["maNwUpgradeInd".to_string(), ma_nw_upgrade_ind.to_string()].join(",")
            }),
            // Skipping n2SmInfo in query parameter serialization

            // Skipping n2SmInfoType in query parameter serialization

            // Skipping n2SmInfoExt1 in query parameter serialization

            // Skipping n2SmInfoTypeExt1 in query parameter serialization
            self.sm_context_ref.as_ref().map(|sm_context_ref| {
                vec!["smContextRef".to_string(), sm_context_ref.to_string()].join(",")
            }),
            // Skipping smContextSmfPlmnId in query parameter serialization

            // Skipping smContextSmfId in query parameter serialization
            self.sm_context_smf_set_id
                .as_ref()
                .map(|sm_context_smf_set_id| {
                    vec![
                        "smContextSmfSetId".to_string(),
                        sm_context_smf_set_id.to_string(),
                    ]
                    .join(",")
                }),
            self.sm_context_smf_service_set_id
                .as_ref()
                .map(|sm_context_smf_service_set_id| {
                    vec![
                        "smContextSmfServiceSetId".to_string(),
                        sm_context_smf_service_set_id.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping smContextSmfBinding in query parameter serialization

            // Skipping upCnxState in query parameter serialization

            // Skipping smallDataRateStatus in query parameter serialization

            // Skipping apnRateStatus in query parameter serialization
            self.extended_nas_sm_timer_ind
                .as_ref()
                .map(|extended_nas_sm_timer_ind| {
                    vec![
                        "extendedNasSmTimerInd".to_string(),
                        extended_nas_sm_timer_ind.to_string(),
                    ]
                    .join(",")
                }),
            self.dl_data_waiting_ind
                .as_ref()
                .map(|dl_data_waiting_ind| {
                    vec![
                        "dlDataWaitingInd".to_string(),
                        dl_data_waiting_ind.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping ddnFailureSubs in query parameter serialization
            self.smf_transfer_ind.as_ref().map(|smf_transfer_ind| {
                vec!["smfTransferInd".to_string(), smf_transfer_ind.to_string()].join(",")
            }),
            // Skipping oldSmfId in query parameter serialization
            self.old_sm_context_ref.as_ref().map(|old_sm_context_ref| {
                vec![
                    "oldSmContextRef".to_string(),
                    old_sm_context_ref.to_string(),
                ]
                .join(",")
            }),
            // Skipping wAgfInfo in query parameter serialization

            // Skipping tngfInfo in query parameter serialization

            // Skipping twifInfo in query parameter serialization
            self.ran_unchanged_ind.as_ref().map(|ran_unchanged_ind| {
                vec!["ranUnchangedInd".to_string(), ran_unchanged_ind.to_string()].join(",")
            }),
            self.same_pcf_selection_ind
                .as_ref()
                .map(|same_pcf_selection_ind| {
                    vec![
                        "samePcfSelectionInd".to_string(),
                        same_pcf_selection_ind.to_string(),
                    ]
                    .join(",")
                }),
            self.target_dnai.as_ref().map(|target_dnai| {
                vec!["targetDnai".to_string(), target_dnai.to_string()].join(",")
            }),
            self.nrf_management_uri.as_ref().map(|nrf_management_uri| {
                vec![
                    "nrfManagementUri".to_string(),
                    nrf_management_uri.to_string(),
                ]
                .join(",")
            }),
            self.nrf_discovery_uri.as_ref().map(|nrf_discovery_uri| {
                vec!["nrfDiscoveryUri".to_string(), nrf_discovery_uri.to_string()].join(",")
            }),
            self.nrf_access_token_uri
                .as_ref()
                .map(|nrf_access_token_uri| {
                    vec![
                        "nrfAccessTokenUri".to_string(),
                        nrf_access_token_uri.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping nrfOauth2Required in query parameter serialization
            self.smf_binding_info.as_ref().map(|smf_binding_info| {
                vec!["smfBindingInfo".to_string(), smf_binding_info.to_string()].join(",")
            }),
            // Skipping pvsInfo in query parameter serialization
            self.onboarding_ind.as_ref().map(|onboarding_ind| {
                vec!["onboardingInd".to_string(), onboarding_ind.to_string()].join(",")
            }),
            self.old_pdu_session_ref
                .as_ref()
                .map(|old_pdu_session_ref| {
                    vec![
                        "oldPduSessionRef".to_string(),
                        old_pdu_session_ref.to_string(),
                    ]
                    .join(",")
                }),
            self.sm_policy_notify_ind
                .as_ref()
                .map(|sm_policy_notify_ind| {
                    vec![
                        "smPolicyNotifyInd".to_string(),
                        sm_policy_notify_ind.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping pcfUeCallbackInfo in query parameter serialization

            // Skipping satelliteBackhaulCat in query parameter serialization
            self.upip_supported.as_ref().map(|upip_supported| {
                vec!["upipSupported".to_string(), upip_supported.to_string()].join(",")
            }),
            self.uav_authenticated.as_ref().map(|uav_authenticated| {
                vec![
                    "uavAuthenticated".to_string(),
                    uav_authenticated.to_string(),
                ]
                .join(",")
            }),
            self.disaster_roaming_ind
                .as_ref()
                .map(|disaster_roaming_ind| {
                    vec![
                        "disasterRoamingInd".to_string(),
                        disaster_roaming_ind.to_string(),
                    ]
                    .join(",")
                }),
            self.anchor_smf_oauth2_required
                .as_ref()
                .map(|anchor_smf_oauth2_required| {
                    vec![
                        "anchorSmfOauth2Required".to_string(),
                        anchor_smf_oauth2_required.to_string(),
                    ]
                    .join(",")
                }),
            self.sm_context_smf_oauth2_required
                .as_ref()
                .map(|sm_context_smf_oauth2_required| {
                    vec![
                        "smContextSmfOauth2Required".to_string(),
                        sm_context_smf_oauth2_required.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SmContextCreateData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SmContextCreateData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub supi: Vec<String>,
            pub unauthenticated_supi: Vec<bool>,
            pub pei: Vec<String>,
            pub gpsi: Vec<String>,
            pub pdu_session_id: Vec<u8>,
            pub dnn: Vec<String>,
            pub selected_dnn: Vec<String>,
            pub s_nssai: Vec<models::Snssai>,
            pub hplmn_snssai: Vec<models::Snssai>,
            pub serving_nf_id: Vec<uuid::Uuid>,
            pub guami: Vec<models::Guami>,
            pub service_name: Vec<models::ServiceName>,
            pub serving_network: Vec<models::PlmnIdNid>,
            pub request_type: Vec<models::RequestType>,
            pub n1_sm_msg: Vec<models::RefToBinaryData>,
            pub an_type: Vec<models::AccessType>,
            pub additional_an_type: Vec<models::AccessType>,
            pub rat_type: Vec<models::RatType>,
            pub presence_in_ladn: Vec<models::PresenceState>,
            pub ue_location: Vec<models::UserLocation>,
            pub ue_time_zone: Vec<String>,
            pub add_ue_location: Vec<models::UserLocation>,
            pub sm_context_status_uri: Vec<String>,
            pub h_smf_uri: Vec<String>,
            pub h_smf_id: Vec<uuid::Uuid>,
            pub smf_uri: Vec<String>,
            pub smf_id: Vec<uuid::Uuid>,
            pub additional_hsmf_uri: Vec<Vec<models::Uri>>,
            pub additional_hsmf_id: Vec<Vec<models::NfInstanceId>>,
            pub additional_smf_uri: Vec<Vec<models::Uri>>,
            pub additional_smf_id: Vec<Vec<models::NfInstanceId>>,
            pub old_pdu_session_id: Vec<u8>,
            pub pdu_sessions_activate_list: Vec<Vec<models::PduSessionId>>,
            pub ue_eps_pdn_connection: Vec<String>,
            pub ho_state: Vec<models::HoState>,
            pub pcf_id: Vec<uuid::Uuid>,
            pub pcf_group_id: Vec<String>,
            pub pcf_set_id: Vec<String>,
            pub nrf_uri: Vec<String>,
            pub supported_features: Vec<String>,
            pub sel_mode: Vec<models::DnnSelectionMode>,
            pub backup_amf_info: Vec<Vec<models::BackupAmfInfo>>,
            pub trace_data: Vec<models::TraceData>,
            pub udm_group_id: Vec<String>,
            pub routing_indicator: Vec<String>,
            pub h_nw_pub_key_id: Vec<i32>,
            pub eps_interworking_ind: Vec<models::EpsInterworkingIndication>,
            pub indirect_forwarding_flag: Vec<bool>,
            pub direct_forwarding_flag: Vec<bool>,
            pub target_id: Vec<models::NgRanTargetId>,
            pub eps_bearer_ctx_status: Vec<String>,
            pub cp_ciot_enabled: Vec<bool>,
            pub cp_only_ind: Vec<bool>,
            pub invoke_nef: Vec<bool>,
            pub ma_request_ind: Vec<bool>,
            pub ma_nw_upgrade_ind: Vec<bool>,
            pub n2_sm_info: Vec<models::RefToBinaryData>,
            pub n2_sm_info_type: Vec<models::N2SmInfoType>,
            pub n2_sm_info_ext1: Vec<models::RefToBinaryData>,
            pub n2_sm_info_type_ext1: Vec<models::N2SmInfoType>,
            pub sm_context_ref: Vec<String>,
            pub sm_context_smf_plmn_id: Vec<models::PlmnIdNid>,
            pub sm_context_smf_id: Vec<uuid::Uuid>,
            pub sm_context_smf_set_id: Vec<String>,
            pub sm_context_smf_service_set_id: Vec<String>,
            pub sm_context_smf_binding: Vec<models::SbiBindingLevel>,
            pub up_cnx_state: Vec<models::UpCnxState>,
            pub small_data_rate_status: Vec<models::SmallDataRateStatus>,
            pub apn_rate_status: Vec<models::ApnRateStatus>,
            pub extended_nas_sm_timer_ind: Vec<bool>,
            pub dl_data_waiting_ind: Vec<bool>,
            pub ddn_failure_subs: Vec<models::DdnFailureSubs>,
            pub smf_transfer_ind: Vec<bool>,
            pub old_smf_id: Vec<uuid::Uuid>,
            pub old_sm_context_ref: Vec<String>,
            pub w_agf_info: Vec<models::WAgfInfo>,
            pub tngf_info: Vec<models::TngfInfo>,
            pub twif_info: Vec<models::TwifInfo>,
            pub ran_unchanged_ind: Vec<bool>,
            pub same_pcf_selection_ind: Vec<bool>,
            pub target_dnai: Vec<String>,
            pub nrf_management_uri: Vec<String>,
            pub nrf_discovery_uri: Vec<String>,
            pub nrf_access_token_uri: Vec<String>,
            pub nrf_oauth2_required: Vec<std::collections::HashMap<String, bool>>,
            pub smf_binding_info: Vec<String>,
            pub pvs_info: Vec<Vec<models::ServerAddressingInfo>>,
            pub onboarding_ind: Vec<bool>,
            pub old_pdu_session_ref: Vec<String>,
            pub sm_policy_notify_ind: Vec<bool>,
            pub pcf_ue_callback_info: Vec<models::PcfUeCallbackInfo>,
            pub satellite_backhaul_cat: Vec<models::SatelliteBackhaulCategory>,
            pub upip_supported: Vec<bool>,
            pub uav_authenticated: Vec<bool>,
            pub disaster_roaming_ind: Vec<bool>,
            pub anchor_smf_oauth2_required: Vec<bool>,
            pub sm_context_smf_oauth2_required: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SmContextCreateData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "supi" => intermediate_rep.supi.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "unauthenticatedSupi" => intermediate_rep.unauthenticated_supi.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pei" => intermediate_rep.pei.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "gpsi" => intermediate_rep.gpsi.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pduSessionId" => intermediate_rep.pdu_session_id.push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dnn" => intermediate_rep.dnn.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "selectedDnn" => intermediate_rep.selected_dnn.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sNssai" => intermediate_rep.s_nssai.push(<models::Snssai as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hplmnSnssai" => intermediate_rep.hplmn_snssai.push(<models::Snssai as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "servingNfId" => intermediate_rep.serving_nf_id.push(<uuid::Uuid as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "guami" => intermediate_rep.guami.push(<models::Guami as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "serviceName" => intermediate_rep.service_name.push(<models::ServiceName as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "servingNetwork" => intermediate_rep.serving_network.push(<models::PlmnIdNid as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "requestType" => intermediate_rep.request_type.push(<models::RequestType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "n1SmMsg" => intermediate_rep.n1_sm_msg.push(<models::RefToBinaryData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "anType" => intermediate_rep.an_type.push(<models::AccessType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "additionalAnType" => intermediate_rep.additional_an_type.push(<models::AccessType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ratType" => intermediate_rep.rat_type.push(<models::RatType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "presenceInLadn" => intermediate_rep.presence_in_ladn.push(<models::PresenceState as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ueLocation" => intermediate_rep.ue_location.push(<models::UserLocation as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ueTimeZone" => intermediate_rep.ue_time_zone.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "addUeLocation" => intermediate_rep.add_ue_location.push(<models::UserLocation as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "smContextStatusUri" => intermediate_rep.sm_context_status_uri.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hSmfUri" => intermediate_rep.h_smf_uri.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hSmfId" => intermediate_rep.h_smf_id.push(<uuid::Uuid as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "smfUri" => intermediate_rep.smf_uri.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "smfId" => intermediate_rep.smf_id.push(<uuid::Uuid as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "additionalHsmfUri" => return std::result::Result::Err("Parsing a container in this style is not supported in SmContextCreateData".to_string()),
                    "additionalHsmfId" => return std::result::Result::Err("Parsing a container in this style is not supported in SmContextCreateData".to_string()),
                    "additionalSmfUri" => return std::result::Result::Err("Parsing a container in this style is not supported in SmContextCreateData".to_string()),
                    "additionalSmfId" => return std::result::Result::Err("Parsing a container in this style is not supported in SmContextCreateData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "oldPduSessionId" => intermediate_rep.old_pdu_session_id.push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "pduSessionsActivateList" => return std::result::Result::Err("Parsing a container in this style is not supported in SmContextCreateData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "ueEpsPdnConnection" => intermediate_rep.ue_eps_pdn_connection.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hoState" => intermediate_rep.ho_state.push(<models::HoState as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pcfId" => intermediate_rep.pcf_id.push(<uuid::Uuid as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pcfGroupId" => intermediate_rep.pcf_group_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pcfSetId" => intermediate_rep.pcf_set_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "nrfUri" => intermediate_rep.nrf_uri.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "supportedFeatures" => intermediate_rep.supported_features.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "selMode" => intermediate_rep.sel_mode.push(<models::DnnSelectionMode as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "backupAmfInfo" => return std::result::Result::Err("Parsing a container in this style is not supported in SmContextCreateData".to_string()),
                    "traceData" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SmContextCreateData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "udmGroupId" => intermediate_rep.udm_group_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "routingIndicator" => intermediate_rep.routing_indicator.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hNwPubKeyId" => intermediate_rep.h_nw_pub_key_id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "epsInterworkingInd" => intermediate_rep.eps_interworking_ind.push(<models::EpsInterworkingIndication as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "indirectForwardingFlag" => intermediate_rep.indirect_forwarding_flag.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "directForwardingFlag" => intermediate_rep.direct_forwarding_flag.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "targetId" => intermediate_rep.target_id.push(<models::NgRanTargetId as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "epsBearerCtxStatus" => intermediate_rep.eps_bearer_ctx_status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cpCiotEnabled" => intermediate_rep.cp_ciot_enabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cpOnlyInd" => intermediate_rep.cp_only_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "invokeNef" => intermediate_rep.invoke_nef.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maRequestInd" => intermediate_rep.ma_request_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maNwUpgradeInd" => intermediate_rep.ma_nw_upgrade_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "n2SmInfo" => intermediate_rep.n2_sm_info.push(<models::RefToBinaryData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "n2SmInfoType" => intermediate_rep.n2_sm_info_type.push(<models::N2SmInfoType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "n2SmInfoExt1" => intermediate_rep.n2_sm_info_ext1.push(<models::RefToBinaryData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "n2SmInfoTypeExt1" => intermediate_rep.n2_sm_info_type_ext1.push(<models::N2SmInfoType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "smContextRef" => intermediate_rep.sm_context_ref.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "smContextSmfPlmnId" => intermediate_rep.sm_context_smf_plmn_id.push(<models::PlmnIdNid as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "smContextSmfId" => intermediate_rep.sm_context_smf_id.push(<uuid::Uuid as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "smContextSmfSetId" => intermediate_rep.sm_context_smf_set_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "smContextSmfServiceSetId" => intermediate_rep.sm_context_smf_service_set_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "smContextSmfBinding" => intermediate_rep.sm_context_smf_binding.push(<models::SbiBindingLevel as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "upCnxState" => intermediate_rep.up_cnx_state.push(<models::UpCnxState as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "smallDataRateStatus" => intermediate_rep.small_data_rate_status.push(<models::SmallDataRateStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "apnRateStatus" => intermediate_rep.apn_rate_status.push(<models::ApnRateStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "extendedNasSmTimerInd" => intermediate_rep.extended_nas_sm_timer_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dlDataWaitingInd" => intermediate_rep.dl_data_waiting_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ddnFailureSubs" => intermediate_rep.ddn_failure_subs.push(<models::DdnFailureSubs as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "smfTransferInd" => intermediate_rep.smf_transfer_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "oldSmfId" => intermediate_rep.old_smf_id.push(<uuid::Uuid as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "oldSmContextRef" => intermediate_rep.old_sm_context_ref.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "wAgfInfo" => intermediate_rep.w_agf_info.push(<models::WAgfInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tngfInfo" => intermediate_rep.tngf_info.push(<models::TngfInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "twifInfo" => intermediate_rep.twif_info.push(<models::TwifInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ranUnchangedInd" => intermediate_rep.ran_unchanged_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "samePcfSelectionInd" => intermediate_rep.same_pcf_selection_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "targetDnai" => intermediate_rep.target_dnai.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "nrfManagementUri" => intermediate_rep.nrf_management_uri.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "nrfDiscoveryUri" => intermediate_rep.nrf_discovery_uri.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "nrfAccessTokenUri" => intermediate_rep.nrf_access_token_uri.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "nrfOauth2Required" => return std::result::Result::Err("Parsing a container in this style is not supported in SmContextCreateData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "smfBindingInfo" => intermediate_rep.smf_binding_info.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "pvsInfo" => return std::result::Result::Err("Parsing a container in this style is not supported in SmContextCreateData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "onboardingInd" => intermediate_rep.onboarding_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "oldPduSessionRef" => intermediate_rep.old_pdu_session_ref.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "smPolicyNotifyInd" => intermediate_rep.sm_policy_notify_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "pcfUeCallbackInfo" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SmContextCreateData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "satelliteBackhaulCat" => intermediate_rep.satellite_backhaul_cat.push(<models::SatelliteBackhaulCategory as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "upipSupported" => intermediate_rep.upip_supported.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "uavAuthenticated" => intermediate_rep.uav_authenticated.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "disasterRoamingInd" => intermediate_rep.disaster_roaming_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "anchorSmfOauth2Required" => intermediate_rep.anchor_smf_oauth2_required.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "smContextSmfOauth2Required" => intermediate_rep.sm_context_smf_oauth2_required.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SmContextCreateData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SmContextCreateData {
            supi: intermediate_rep.supi.into_iter().next(),
            unauthenticated_supi: intermediate_rep.unauthenticated_supi.into_iter().next(),
            pei: intermediate_rep.pei.into_iter().next(),
            gpsi: intermediate_rep.gpsi.into_iter().next(),
            pdu_session_id: intermediate_rep.pdu_session_id.into_iter().next(),
            dnn: intermediate_rep.dnn.into_iter().next(),
            selected_dnn: intermediate_rep.selected_dnn.into_iter().next(),
            s_nssai: intermediate_rep.s_nssai.into_iter().next(),
            hplmn_snssai: intermediate_rep.hplmn_snssai.into_iter().next(),
            serving_nf_id: intermediate_rep
                .serving_nf_id
                .into_iter()
                .next()
                .ok_or_else(|| "servingNfId missing in SmContextCreateData".to_string())?,
            guami: intermediate_rep.guami.into_iter().next(),
            service_name: intermediate_rep.service_name.into_iter().next(),
            serving_network: intermediate_rep
                .serving_network
                .into_iter()
                .next()
                .ok_or_else(|| "servingNetwork missing in SmContextCreateData".to_string())?,
            request_type: intermediate_rep.request_type.into_iter().next(),
            n1_sm_msg: intermediate_rep.n1_sm_msg.into_iter().next(),
            an_type: intermediate_rep
                .an_type
                .into_iter()
                .next()
                .ok_or_else(|| "anType missing in SmContextCreateData".to_string())?,
            additional_an_type: intermediate_rep.additional_an_type.into_iter().next(),
            rat_type: intermediate_rep.rat_type.into_iter().next(),
            presence_in_ladn: intermediate_rep.presence_in_ladn.into_iter().next(),
            ue_location: intermediate_rep.ue_location.into_iter().next(),
            ue_time_zone: intermediate_rep.ue_time_zone.into_iter().next(),
            add_ue_location: intermediate_rep.add_ue_location.into_iter().next(),
            sm_context_status_uri: intermediate_rep
                .sm_context_status_uri
                .into_iter()
                .next()
                .ok_or_else(|| "smContextStatusUri missing in SmContextCreateData".to_string())?,
            h_smf_uri: intermediate_rep.h_smf_uri.into_iter().next(),
            h_smf_id: intermediate_rep.h_smf_id.into_iter().next(),
            smf_uri: intermediate_rep.smf_uri.into_iter().next(),
            smf_id: intermediate_rep.smf_id.into_iter().next(),
            additional_hsmf_uri: intermediate_rep.additional_hsmf_uri.into_iter().next(),
            additional_hsmf_id: intermediate_rep.additional_hsmf_id.into_iter().next(),
            additional_smf_uri: intermediate_rep.additional_smf_uri.into_iter().next(),
            additional_smf_id: intermediate_rep.additional_smf_id.into_iter().next(),
            old_pdu_session_id: intermediate_rep.old_pdu_session_id.into_iter().next(),
            pdu_sessions_activate_list: intermediate_rep
                .pdu_sessions_activate_list
                .into_iter()
                .next(),
            ue_eps_pdn_connection: intermediate_rep.ue_eps_pdn_connection.into_iter().next(),
            ho_state: intermediate_rep.ho_state.into_iter().next(),
            pcf_id: intermediate_rep.pcf_id.into_iter().next(),
            pcf_group_id: intermediate_rep.pcf_group_id.into_iter().next(),
            pcf_set_id: intermediate_rep.pcf_set_id.into_iter().next(),
            nrf_uri: intermediate_rep.nrf_uri.into_iter().next(),
            supported_features: intermediate_rep.supported_features.into_iter().next(),
            sel_mode: intermediate_rep.sel_mode.into_iter().next(),
            backup_amf_info: intermediate_rep.backup_amf_info.into_iter().next(),
            trace_data: std::result::Result::Err(
                "Nullable types not supported in SmContextCreateData".to_string(),
            )?,
            udm_group_id: intermediate_rep.udm_group_id.into_iter().next(),
            routing_indicator: intermediate_rep.routing_indicator.into_iter().next(),
            h_nw_pub_key_id: intermediate_rep.h_nw_pub_key_id.into_iter().next(),
            eps_interworking_ind: intermediate_rep.eps_interworking_ind.into_iter().next(),
            indirect_forwarding_flag: intermediate_rep.indirect_forwarding_flag.into_iter().next(),
            direct_forwarding_flag: intermediate_rep.direct_forwarding_flag.into_iter().next(),
            target_id: intermediate_rep.target_id.into_iter().next(),
            eps_bearer_ctx_status: intermediate_rep.eps_bearer_ctx_status.into_iter().next(),
            cp_ciot_enabled: intermediate_rep.cp_ciot_enabled.into_iter().next(),
            cp_only_ind: intermediate_rep.cp_only_ind.into_iter().next(),
            invoke_nef: intermediate_rep.invoke_nef.into_iter().next(),
            ma_request_ind: intermediate_rep.ma_request_ind.into_iter().next(),
            ma_nw_upgrade_ind: intermediate_rep.ma_nw_upgrade_ind.into_iter().next(),
            n2_sm_info: intermediate_rep.n2_sm_info.into_iter().next(),
            n2_sm_info_type: intermediate_rep.n2_sm_info_type.into_iter().next(),
            n2_sm_info_ext1: intermediate_rep.n2_sm_info_ext1.into_iter().next(),
            n2_sm_info_type_ext1: intermediate_rep.n2_sm_info_type_ext1.into_iter().next(),
            sm_context_ref: intermediate_rep.sm_context_ref.into_iter().next(),
            sm_context_smf_plmn_id: intermediate_rep.sm_context_smf_plmn_id.into_iter().next(),
            sm_context_smf_id: intermediate_rep.sm_context_smf_id.into_iter().next(),
            sm_context_smf_set_id: intermediate_rep.sm_context_smf_set_id.into_iter().next(),
            sm_context_smf_service_set_id: intermediate_rep
                .sm_context_smf_service_set_id
                .into_iter()
                .next(),
            sm_context_smf_binding: intermediate_rep.sm_context_smf_binding.into_iter().next(),
            up_cnx_state: intermediate_rep.up_cnx_state.into_iter().next(),
            small_data_rate_status: intermediate_rep.small_data_rate_status.into_iter().next(),
            apn_rate_status: intermediate_rep.apn_rate_status.into_iter().next(),
            extended_nas_sm_timer_ind: intermediate_rep
                .extended_nas_sm_timer_ind
                .into_iter()
                .next(),
            dl_data_waiting_ind: intermediate_rep.dl_data_waiting_ind.into_iter().next(),
            ddn_failure_subs: intermediate_rep.ddn_failure_subs.into_iter().next(),
            smf_transfer_ind: intermediate_rep.smf_transfer_ind.into_iter().next(),
            old_smf_id: intermediate_rep.old_smf_id.into_iter().next(),
            old_sm_context_ref: intermediate_rep.old_sm_context_ref.into_iter().next(),
            w_agf_info: intermediate_rep.w_agf_info.into_iter().next(),
            tngf_info: intermediate_rep.tngf_info.into_iter().next(),
            twif_info: intermediate_rep.twif_info.into_iter().next(),
            ran_unchanged_ind: intermediate_rep.ran_unchanged_ind.into_iter().next(),
            same_pcf_selection_ind: intermediate_rep.same_pcf_selection_ind.into_iter().next(),
            target_dnai: intermediate_rep.target_dnai.into_iter().next(),
            nrf_management_uri: intermediate_rep.nrf_management_uri.into_iter().next(),
            nrf_discovery_uri: intermediate_rep.nrf_discovery_uri.into_iter().next(),
            nrf_access_token_uri: intermediate_rep.nrf_access_token_uri.into_iter().next(),
            nrf_oauth2_required: intermediate_rep.nrf_oauth2_required.into_iter().next(),
            smf_binding_info: intermediate_rep.smf_binding_info.into_iter().next(),
            pvs_info: intermediate_rep.pvs_info.into_iter().next(),
            onboarding_ind: intermediate_rep.onboarding_ind.into_iter().next(),
            old_pdu_session_ref: intermediate_rep.old_pdu_session_ref.into_iter().next(),
            sm_policy_notify_ind: intermediate_rep.sm_policy_notify_ind.into_iter().next(),
            pcf_ue_callback_info: std::result::Result::Err(
                "Nullable types not supported in SmContextCreateData".to_string(),
            )?,
            satellite_backhaul_cat: intermediate_rep.satellite_backhaul_cat.into_iter().next(),
            upip_supported: intermediate_rep.upip_supported.into_iter().next(),
            uav_authenticated: intermediate_rep.uav_authenticated.into_iter().next(),
            disaster_roaming_ind: intermediate_rep.disaster_roaming_ind.into_iter().next(),
            anchor_smf_oauth2_required: intermediate_rep
                .anchor_smf_oauth2_required
                .into_iter()
                .next(),
            sm_context_smf_oauth2_required: intermediate_rep
                .sm_context_smf_oauth2_required
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SmContextCreateData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SmContextCreateData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SmContextCreateData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SmContextCreateData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SmContextCreateData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SmContextCreateData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SmContextCreateData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Error within Create SM Context Response
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SmContextCreateError {
    #[serde(rename = "error")]
    pub error: models::ExtProblemDetails,

    #[serde(rename = "n1SmMsg")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n1_sm_msg: Option<models::RefToBinaryData>,

    #[serde(rename = "n2SmInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n2_sm_info: Option<models::RefToBinaryData>,

    #[serde(rename = "n2SmInfoType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n2_sm_info_type: Option<models::N2SmInfoType>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "recoveryTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recovery_time: Option<chrono::DateTime<chrono::Utc>>,
}

impl SmContextCreateError {
    #[allow(clippy::new_without_default)]
    pub fn new(error: models::ExtProblemDetails) -> SmContextCreateError {
        SmContextCreateError {
            error,
            n1_sm_msg: None,
            n2_sm_info: None,
            n2_sm_info_type: None,
            recovery_time: None,
        }
    }
}

/// Converts the SmContextCreateError value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SmContextCreateError {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping error in query parameter serialization

            // Skipping n1SmMsg in query parameter serialization

            // Skipping n2SmInfo in query parameter serialization

            // Skipping n2SmInfoType in query parameter serialization

            // Skipping recoveryTime in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SmContextCreateError value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SmContextCreateError {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub error: Vec<models::ExtProblemDetails>,
            pub n1_sm_msg: Vec<models::RefToBinaryData>,
            pub n2_sm_info: Vec<models::RefToBinaryData>,
            pub n2_sm_info_type: Vec<models::N2SmInfoType>,
            pub recovery_time: Vec<chrono::DateTime<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SmContextCreateError".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "error" => intermediate_rep.error.push(
                        <models::ExtProblemDetails as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n1SmMsg" => intermediate_rep.n1_sm_msg.push(
                        <models::RefToBinaryData as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n2SmInfo" => intermediate_rep.n2_sm_info.push(
                        <models::RefToBinaryData as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n2SmInfoType" => intermediate_rep.n2_sm_info_type.push(
                        <models::N2SmInfoType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "recoveryTime" => intermediate_rep.recovery_time.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SmContextCreateError".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SmContextCreateError {
            error: intermediate_rep
                .error
                .into_iter()
                .next()
                .ok_or_else(|| "error missing in SmContextCreateError".to_string())?,
            n1_sm_msg: intermediate_rep.n1_sm_msg.into_iter().next(),
            n2_sm_info: intermediate_rep.n2_sm_info.into_iter().next(),
            n2_sm_info_type: intermediate_rep.n2_sm_info_type.into_iter().next(),
            recovery_time: intermediate_rep.recovery_time.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SmContextCreateError> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SmContextCreateError>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SmContextCreateError>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SmContextCreateError - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SmContextCreateError>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SmContextCreateError as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SmContextCreateError - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Data within Create SM Context Response
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SmContextCreatedData {
    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "hSmfUri")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub h_smf_uri: Option<String>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "smfUri")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub smf_uri: Option<String>,

    /// Unsigned integer identifying a PDU session, within the range 0 to 255, as specified in  clause 11.2.3.1b, bits 1 to 8, of 3GPP TS 24.007. If the PDU Session ID is allocated by the  Core Network for UEs not supporting N1 mode, reserved range 64 to 95 is used. PDU Session ID  within the reserved range is only visible in the Core Network.
    #[serde(rename = "pduSessionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pdu_session_id: Option<u8>,

    #[serde(rename = "sNssai")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub s_nssai: Option<models::Snssai>,

    #[serde(rename = "upCnxState")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub up_cnx_state: Option<models::UpCnxState>,

    #[serde(rename = "n2SmInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n2_sm_info: Option<models::RefToBinaryData>,

    #[serde(rename = "n2SmInfoType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n2_sm_info_type: Option<models::N2SmInfoType>,

    #[serde(rename = "allocatedEbiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allocated_ebi_list: Option<Vec<models::EbiArpMapping>>,

    #[serde(rename = "hoState")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ho_state: Option<models::HoState>,

    /// String identifying a Gpsi shall contain either an External Id or an MSISDN.  It shall be formatted as follows -External Identifier= \"extid-'extid', where 'extid'  shall be formatted according to clause 19.7.2 of 3GPP TS 23.003 that describes an  External Identifier.
    #[serde(rename = "gpsi")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gpsi: Option<String>,

    #[serde(rename = "smfServiceInstanceId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub smf_service_instance_id: Option<String>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "recoveryTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recovery_time: Option<chrono::DateTime<chrono::Utc>>,

    /// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  table 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.
    #[serde(rename = "supportedFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_features: Option<String>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "selectedSmfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub selected_smf_id: Option<uuid::Uuid>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "selectedOldSmfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub selected_old_smf_id: Option<uuid::Uuid>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "interPlmnApiRoot")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub inter_plmn_api_root: Option<String>,
}

impl SmContextCreatedData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SmContextCreatedData {
        SmContextCreatedData {
            h_smf_uri: None,
            smf_uri: None,
            pdu_session_id: None,
            s_nssai: None,
            up_cnx_state: None,
            n2_sm_info: None,
            n2_sm_info_type: None,
            allocated_ebi_list: None,
            ho_state: None,
            gpsi: None,
            smf_service_instance_id: None,
            recovery_time: None,
            supported_features: None,
            selected_smf_id: None,
            selected_old_smf_id: None,
            inter_plmn_api_root: None,
        }
    }
}

/// Converts the SmContextCreatedData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SmContextCreatedData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.h_smf_uri
                .as_ref()
                .map(|h_smf_uri| vec!["hSmfUri".to_string(), h_smf_uri.to_string()].join(",")),
            self.smf_uri
                .as_ref()
                .map(|smf_uri| vec!["smfUri".to_string(), smf_uri.to_string()].join(",")),
            self.pdu_session_id.as_ref().map(|pdu_session_id| {
                vec!["pduSessionId".to_string(), pdu_session_id.to_string()].join(",")
            }),
            // Skipping sNssai in query parameter serialization

            // Skipping upCnxState in query parameter serialization

            // Skipping n2SmInfo in query parameter serialization

            // Skipping n2SmInfoType in query parameter serialization

            // Skipping allocatedEbiList in query parameter serialization

            // Skipping hoState in query parameter serialization
            self.gpsi
                .as_ref()
                .map(|gpsi| vec!["gpsi".to_string(), gpsi.to_string()].join(",")),
            self.smf_service_instance_id
                .as_ref()
                .map(|smf_service_instance_id| {
                    vec![
                        "smfServiceInstanceId".to_string(),
                        smf_service_instance_id.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping recoveryTime in query parameter serialization
            self.supported_features.as_ref().map(|supported_features| {
                vec![
                    "supportedFeatures".to_string(),
                    supported_features.to_string(),
                ]
                .join(",")
            }),
            // Skipping selectedSmfId in query parameter serialization

            // Skipping selectedOldSmfId in query parameter serialization
            self.inter_plmn_api_root
                .as_ref()
                .map(|inter_plmn_api_root| {
                    vec![
                        "interPlmnApiRoot".to_string(),
                        inter_plmn_api_root.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SmContextCreatedData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SmContextCreatedData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub h_smf_uri: Vec<String>,
            pub smf_uri: Vec<String>,
            pub pdu_session_id: Vec<u8>,
            pub s_nssai: Vec<models::Snssai>,
            pub up_cnx_state: Vec<models::UpCnxState>,
            pub n2_sm_info: Vec<models::RefToBinaryData>,
            pub n2_sm_info_type: Vec<models::N2SmInfoType>,
            pub allocated_ebi_list: Vec<Vec<models::EbiArpMapping>>,
            pub ho_state: Vec<models::HoState>,
            pub gpsi: Vec<String>,
            pub smf_service_instance_id: Vec<String>,
            pub recovery_time: Vec<chrono::DateTime<chrono::Utc>>,
            pub supported_features: Vec<String>,
            pub selected_smf_id: Vec<uuid::Uuid>,
            pub selected_old_smf_id: Vec<uuid::Uuid>,
            pub inter_plmn_api_root: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SmContextCreatedData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "hSmfUri" => intermediate_rep.h_smf_uri.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "smfUri" => intermediate_rep.smf_uri.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pduSessionId" => intermediate_rep.pdu_session_id.push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sNssai" => intermediate_rep.s_nssai.push(<models::Snssai as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "upCnxState" => intermediate_rep.up_cnx_state.push(<models::UpCnxState as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "n2SmInfo" => intermediate_rep.n2_sm_info.push(<models::RefToBinaryData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "n2SmInfoType" => intermediate_rep.n2_sm_info_type.push(<models::N2SmInfoType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "allocatedEbiList" => return std::result::Result::Err("Parsing a container in this style is not supported in SmContextCreatedData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "hoState" => intermediate_rep.ho_state.push(<models::HoState as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "gpsi" => intermediate_rep.gpsi.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "smfServiceInstanceId" => intermediate_rep.smf_service_instance_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "recoveryTime" => intermediate_rep.recovery_time.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "supportedFeatures" => intermediate_rep.supported_features.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "selectedSmfId" => intermediate_rep.selected_smf_id.push(<uuid::Uuid as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "selectedOldSmfId" => intermediate_rep.selected_old_smf_id.push(<uuid::Uuid as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "interPlmnApiRoot" => intermediate_rep.inter_plmn_api_root.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SmContextCreatedData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SmContextCreatedData {
            h_smf_uri: intermediate_rep.h_smf_uri.into_iter().next(),
            smf_uri: intermediate_rep.smf_uri.into_iter().next(),
            pdu_session_id: intermediate_rep.pdu_session_id.into_iter().next(),
            s_nssai: intermediate_rep.s_nssai.into_iter().next(),
            up_cnx_state: intermediate_rep.up_cnx_state.into_iter().next(),
            n2_sm_info: intermediate_rep.n2_sm_info.into_iter().next(),
            n2_sm_info_type: intermediate_rep.n2_sm_info_type.into_iter().next(),
            allocated_ebi_list: intermediate_rep.allocated_ebi_list.into_iter().next(),
            ho_state: intermediate_rep.ho_state.into_iter().next(),
            gpsi: intermediate_rep.gpsi.into_iter().next(),
            smf_service_instance_id: intermediate_rep.smf_service_instance_id.into_iter().next(),
            recovery_time: intermediate_rep.recovery_time.into_iter().next(),
            supported_features: intermediate_rep.supported_features.into_iter().next(),
            selected_smf_id: intermediate_rep.selected_smf_id.into_iter().next(),
            selected_old_smf_id: intermediate_rep.selected_old_smf_id.into_iter().next(),
            inter_plmn_api_root: intermediate_rep.inter_plmn_api_root.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SmContextCreatedData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SmContextCreatedData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SmContextCreatedData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SmContextCreatedData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SmContextCreatedData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SmContextCreatedData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SmContextCreatedData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Data within Release SM Context Request
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SmContextReleaseData {
    #[serde(rename = "cause")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cause: Option<models::Cause>,

    #[serde(rename = "ngApCause")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ng_ap_cause: Option<models::NgApCause>,

    /// Unsigned Integer, i.e. only value 0 and integers above 0 are permissible.
    #[serde(rename = "5gMmCauseValue")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub param_5g_mm_cause_value: Option<u32>,

    #[serde(rename = "ueLocation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_location: Option<models::UserLocation>,

    /// String with format \"time-numoffset\" optionally appended by \"daylightSavingTime\", where  - \"time-numoffset\" shall represent the time zone adjusted for daylight saving time and be    encoded as time-numoffset as defined in clause 5.6 of IETF RFC 3339;  - \"daylightSavingTime\" shall represent the adjustment that has been made and shall be    encoded as \"+1\" or \"+2\" for a +1 or +2 hours adjustment.   The example is for 8 hours behind UTC, +1 hour adjustment for Daylight Saving Time.
    #[serde(rename = "ueTimeZone")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_time_zone: Option<String>,

    #[serde(rename = "addUeLocation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub add_ue_location: Option<models::UserLocation>,

    #[serde(rename = "vsmfReleaseOnly")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub vsmf_release_only: Option<bool>,

    #[serde(rename = "n2SmInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n2_sm_info: Option<models::RefToBinaryData>,

    #[serde(rename = "n2SmInfoType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n2_sm_info_type: Option<models::N2SmInfoType>,

    #[serde(rename = "ismfReleaseOnly")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ismf_release_only: Option<bool>,
}

impl SmContextReleaseData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SmContextReleaseData {
        SmContextReleaseData {
            cause: None,
            ng_ap_cause: None,
            param_5g_mm_cause_value: None,
            ue_location: None,
            ue_time_zone: None,
            add_ue_location: None,
            vsmf_release_only: Some(false),
            n2_sm_info: None,
            n2_sm_info_type: None,
            ismf_release_only: Some(false),
        }
    }
}

/// Converts the SmContextReleaseData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SmContextReleaseData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping cause in query parameter serialization

            // Skipping ngApCause in query parameter serialization
            self.param_5g_mm_cause_value
                .as_ref()
                .map(|param_5g_mm_cause_value| {
                    vec![
                        "5gMmCauseValue".to_string(),
                        param_5g_mm_cause_value.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping ueLocation in query parameter serialization
            self.ue_time_zone.as_ref().map(|ue_time_zone| {
                vec!["ueTimeZone".to_string(), ue_time_zone.to_string()].join(",")
            }),
            // Skipping addUeLocation in query parameter serialization
            self.vsmf_release_only.as_ref().map(|vsmf_release_only| {
                vec!["vsmfReleaseOnly".to_string(), vsmf_release_only.to_string()].join(",")
            }),
            // Skipping n2SmInfo in query parameter serialization

            // Skipping n2SmInfoType in query parameter serialization
            self.ismf_release_only.as_ref().map(|ismf_release_only| {
                vec!["ismfReleaseOnly".to_string(), ismf_release_only.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SmContextReleaseData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SmContextReleaseData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cause: Vec<models::Cause>,
            pub ng_ap_cause: Vec<models::NgApCause>,
            pub param_5g_mm_cause_value: Vec<u32>,
            pub ue_location: Vec<models::UserLocation>,
            pub ue_time_zone: Vec<String>,
            pub add_ue_location: Vec<models::UserLocation>,
            pub vsmf_release_only: Vec<bool>,
            pub n2_sm_info: Vec<models::RefToBinaryData>,
            pub n2_sm_info_type: Vec<models::N2SmInfoType>,
            pub ismf_release_only: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SmContextReleaseData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "cause" => intermediate_rep.cause.push(
                        <models::Cause as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ngApCause" => intermediate_rep.ng_ap_cause.push(
                        <models::NgApCause as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "5gMmCauseValue" => intermediate_rep.param_5g_mm_cause_value.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ueLocation" => intermediate_rep.ue_location.push(
                        <models::UserLocation as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ueTimeZone" => intermediate_rep.ue_time_zone.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "addUeLocation" => intermediate_rep.add_ue_location.push(
                        <models::UserLocation as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "vsmfReleaseOnly" => intermediate_rep.vsmf_release_only.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n2SmInfo" => intermediate_rep.n2_sm_info.push(
                        <models::RefToBinaryData as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n2SmInfoType" => intermediate_rep.n2_sm_info_type.push(
                        <models::N2SmInfoType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ismfReleaseOnly" => intermediate_rep.ismf_release_only.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SmContextReleaseData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SmContextReleaseData {
            cause: intermediate_rep.cause.into_iter().next(),
            ng_ap_cause: intermediate_rep.ng_ap_cause.into_iter().next(),
            param_5g_mm_cause_value: intermediate_rep.param_5g_mm_cause_value.into_iter().next(),
            ue_location: intermediate_rep.ue_location.into_iter().next(),
            ue_time_zone: intermediate_rep.ue_time_zone.into_iter().next(),
            add_ue_location: intermediate_rep.add_ue_location.into_iter().next(),
            vsmf_release_only: intermediate_rep.vsmf_release_only.into_iter().next(),
            n2_sm_info: intermediate_rep.n2_sm_info.into_iter().next(),
            n2_sm_info_type: intermediate_rep.n2_sm_info_type.into_iter().next(),
            ismf_release_only: intermediate_rep.ismf_release_only.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SmContextReleaseData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SmContextReleaseData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SmContextReleaseData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SmContextReleaseData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SmContextReleaseData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SmContextReleaseData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SmContextReleaseData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Data within Release SM Context Response
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SmContextReleasedData {
    #[serde(rename = "smallDataRateStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub small_data_rate_status: Option<models::SmallDataRateStatus>,

    #[serde(rename = "apnRateStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub apn_rate_status: Option<models::ApnRateStatus>,
}

impl SmContextReleasedData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SmContextReleasedData {
        SmContextReleasedData {
            small_data_rate_status: None,
            apn_rate_status: None,
        }
    }
}

/// Converts the SmContextReleasedData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SmContextReleasedData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping smallDataRateStatus in query parameter serialization

            // Skipping apnRateStatus in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SmContextReleasedData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SmContextReleasedData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub small_data_rate_status: Vec<models::SmallDataRateStatus>,
            pub apn_rate_status: Vec<models::ApnRateStatus>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SmContextReleasedData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "smallDataRateStatus" => intermediate_rep.small_data_rate_status.push(
                        <models::SmallDataRateStatus as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "apnRateStatus" => intermediate_rep.apn_rate_status.push(
                        <models::ApnRateStatus as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SmContextReleasedData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SmContextReleasedData {
            small_data_rate_status: intermediate_rep.small_data_rate_status.into_iter().next(),
            apn_rate_status: intermediate_rep.apn_rate_status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SmContextReleasedData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SmContextReleasedData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SmContextReleasedData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SmContextReleasedData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SmContextReleasedData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SmContextReleasedData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SmContextReleasedData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Data within Retrieve SM Context Request
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SmContextRetrieveData {
    #[serde(rename = "targetMmeCap")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_mme_cap: Option<models::MmeCapabilities>,

    #[serde(rename = "smContextType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sm_context_type: Option<models::SmContextType>,

    #[serde(rename = "servingNetwork")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub serving_network: Option<models::PlmnId>,

    #[serde(rename = "notToTransferEbiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub not_to_transfer_ebi_list: Option<Vec<models::EpsBearerId>>,

    #[serde(rename = "ranUnchangedInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ran_unchanged_ind: Option<bool>,
}

impl SmContextRetrieveData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SmContextRetrieveData {
        SmContextRetrieveData {
            target_mme_cap: None,
            sm_context_type: None,
            serving_network: None,
            not_to_transfer_ebi_list: None,
            ran_unchanged_ind: Some(false),
        }
    }
}

/// Converts the SmContextRetrieveData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SmContextRetrieveData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping targetMmeCap in query parameter serialization

            // Skipping smContextType in query parameter serialization

            // Skipping servingNetwork in query parameter serialization
            self.not_to_transfer_ebi_list
                .as_ref()
                .map(|not_to_transfer_ebi_list| {
                    vec![
                        "notToTransferEbiList".to_string(),
                        not_to_transfer_ebi_list
                            .iter()
                            .map(|x| x.to_string())
                            .collect::<Vec<_>>()
                            .join(","),
                    ]
                    .join(",")
                }),
            self.ran_unchanged_ind.as_ref().map(|ran_unchanged_ind| {
                vec!["ranUnchangedInd".to_string(), ran_unchanged_ind.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SmContextRetrieveData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SmContextRetrieveData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub target_mme_cap: Vec<models::MmeCapabilities>,
            pub sm_context_type: Vec<models::SmContextType>,
            pub serving_network: Vec<models::PlmnId>,
            pub not_to_transfer_ebi_list: Vec<Vec<models::EpsBearerId>>,
            pub ran_unchanged_ind: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SmContextRetrieveData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "targetMmeCap" => intermediate_rep.target_mme_cap.push(<models::MmeCapabilities as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "smContextType" => intermediate_rep.sm_context_type.push(<models::SmContextType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "servingNetwork" => intermediate_rep.serving_network.push(<models::PlmnId as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "notToTransferEbiList" => return std::result::Result::Err("Parsing a container in this style is not supported in SmContextRetrieveData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "ranUnchangedInd" => intermediate_rep.ran_unchanged_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SmContextRetrieveData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SmContextRetrieveData {
            target_mme_cap: intermediate_rep.target_mme_cap.into_iter().next(),
            sm_context_type: intermediate_rep.sm_context_type.into_iter().next(),
            serving_network: intermediate_rep.serving_network.into_iter().next(),
            not_to_transfer_ebi_list: intermediate_rep.not_to_transfer_ebi_list.into_iter().next(),
            ran_unchanged_ind: intermediate_rep.ran_unchanged_ind.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SmContextRetrieveData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SmContextRetrieveData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SmContextRetrieveData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SmContextRetrieveData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SmContextRetrieveData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SmContextRetrieveData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SmContextRetrieveData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Data within Retrieve SM Context Response
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SmContextRetrievedData {
    /// UE EPS PDN Connection container from SMF to AMF
    #[serde(rename = "ueEpsPdnConnection")]
    pub ue_eps_pdn_connection: String,

    #[serde(rename = "smContext")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sm_context: Option<models::SmContext>,

    #[serde(rename = "smallDataRateStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub small_data_rate_status: Option<models::SmallDataRateStatus>,

    #[serde(rename = "apnRateStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub apn_rate_status: Option<models::ApnRateStatus>,

    #[serde(rename = "dlDataWaitingInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dl_data_waiting_ind: Option<bool>,

    #[serde(rename = "afCoordinationInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub af_coordination_info: Option<models::AfCoordinationInfo>,
}

impl SmContextRetrievedData {
    #[allow(clippy::new_without_default)]
    pub fn new(ue_eps_pdn_connection: String) -> SmContextRetrievedData {
        SmContextRetrievedData {
            ue_eps_pdn_connection,
            sm_context: None,
            small_data_rate_status: None,
            apn_rate_status: None,
            dl_data_waiting_ind: Some(false),
            af_coordination_info: None,
        }
    }
}

/// Converts the SmContextRetrievedData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SmContextRetrievedData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("ueEpsPdnConnection".to_string()),
            Some(self.ue_eps_pdn_connection.to_string()),
            // Skipping smContext in query parameter serialization

            // Skipping smallDataRateStatus in query parameter serialization

            // Skipping apnRateStatus in query parameter serialization
            self.dl_data_waiting_ind
                .as_ref()
                .map(|dl_data_waiting_ind| {
                    vec![
                        "dlDataWaitingInd".to_string(),
                        dl_data_waiting_ind.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping afCoordinationInfo in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SmContextRetrievedData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SmContextRetrievedData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ue_eps_pdn_connection: Vec<String>,
            pub sm_context: Vec<models::SmContext>,
            pub small_data_rate_status: Vec<models::SmallDataRateStatus>,
            pub apn_rate_status: Vec<models::ApnRateStatus>,
            pub dl_data_waiting_ind: Vec<bool>,
            pub af_coordination_info: Vec<models::AfCoordinationInfo>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SmContextRetrievedData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ueEpsPdnConnection" => intermediate_rep.ue_eps_pdn_connection.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "smContext" => intermediate_rep.sm_context.push(
                        <models::SmContext as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "smallDataRateStatus" => intermediate_rep.small_data_rate_status.push(
                        <models::SmallDataRateStatus as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "apnRateStatus" => intermediate_rep.apn_rate_status.push(
                        <models::ApnRateStatus as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "dlDataWaitingInd" => intermediate_rep.dl_data_waiting_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "afCoordinationInfo" => intermediate_rep.af_coordination_info.push(
                        <models::AfCoordinationInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SmContextRetrievedData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SmContextRetrievedData {
            ue_eps_pdn_connection: intermediate_rep
                .ue_eps_pdn_connection
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "ueEpsPdnConnection missing in SmContextRetrievedData".to_string()
                })?,
            sm_context: intermediate_rep.sm_context.into_iter().next(),
            small_data_rate_status: intermediate_rep.small_data_rate_status.into_iter().next(),
            apn_rate_status: intermediate_rep.apn_rate_status.into_iter().next(),
            dl_data_waiting_ind: intermediate_rep.dl_data_waiting_ind.into_iter().next(),
            af_coordination_info: intermediate_rep.af_coordination_info.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SmContextRetrievedData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SmContextRetrievedData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SmContextRetrievedData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SmContextRetrievedData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SmContextRetrievedData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SmContextRetrievedData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SmContextRetrievedData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Data within Notify SM Context Status Request
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SmContextStatusNotification {
    #[serde(rename = "statusInfo")]
    pub status_info: models::StatusInfo,

    #[serde(rename = "smallDataRateStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub small_data_rate_status: Option<models::SmallDataRateStatus>,

    #[serde(rename = "apnRateStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub apn_rate_status: Option<models::ApnRateStatus>,

    #[serde(rename = "ddnFailureStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ddn_failure_status: Option<bool>,

    #[serde(rename = "notifyCorrelationIdsForddnFailure")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notify_correlation_ids_forddn_failure: Option<Vec<String>>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "newIntermediateSmfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub new_intermediate_smf_id: Option<uuid::Uuid>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "newSmfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub new_smf_id: Option<uuid::Uuid>,

    /// NF Set Identifier (see clause 28.12 of 3GPP TS 23.003), formatted as the following string \"set<Set ID>.<nftype>set.5gc.mnc<MNC>.mcc<MCC>\", or  \"set<SetID>.<NFType>set.5gc.nid<NID>.mnc<MNC>.mcc<MCC>\" with  <MCC> encoded as defined in clause 5.4.2 (\"Mcc\" data type definition)  <MNC> encoding the Mobile Network Code part of the PLMN, comprising 3 digits.    If there are only 2 significant digits in the MNC, one \"0\" digit shall be inserted    at the left side to fill the 3 digits coding of MNC.  Pattern: '^[0-9]{3}$' <NFType> encoded as a value defined in Table 6.1.6.3.3-1 of 3GPP TS 29.510 but    with lower case characters <Set ID> encoded as a string of characters consisting of    alphabetic characters (A-Z and a-z), digits (0-9) and/or the hyphen (-) and that    shall end with either an alphabetic character or a digit.
    #[serde(rename = "newSmfSetId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub new_smf_set_id: Option<String>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "oldSmfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub old_smf_id: Option<uuid::Uuid>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "oldSmContextRef")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub old_sm_context_ref: Option<String>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "altAnchorSmfUri")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub alt_anchor_smf_uri: Option<String>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "altAnchorSmfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub alt_anchor_smf_id: Option<uuid::Uuid>,

    #[serde(rename = "targetDnaiInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_dnai_info: Option<models::TargetDnaiInfo>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "oldPduSessionRef")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub old_pdu_session_ref: Option<String>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "interPlmnApiRoot")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub inter_plmn_api_root: Option<String>,
}

impl SmContextStatusNotification {
    #[allow(clippy::new_without_default)]
    pub fn new(status_info: models::StatusInfo) -> SmContextStatusNotification {
        SmContextStatusNotification {
            status_info,
            small_data_rate_status: None,
            apn_rate_status: None,
            ddn_failure_status: Some(false),
            notify_correlation_ids_forddn_failure: None,
            new_intermediate_smf_id: None,
            new_smf_id: None,
            new_smf_set_id: None,
            old_smf_id: None,
            old_sm_context_ref: None,
            alt_anchor_smf_uri: None,
            alt_anchor_smf_id: None,
            target_dnai_info: None,
            old_pdu_session_ref: None,
            inter_plmn_api_root: None,
        }
    }
}

/// Converts the SmContextStatusNotification value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SmContextStatusNotification {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping statusInfo in query parameter serialization

            // Skipping smallDataRateStatus in query parameter serialization

            // Skipping apnRateStatus in query parameter serialization
            self.ddn_failure_status.as_ref().map(|ddn_failure_status| {
                vec![
                    "ddnFailureStatus".to_string(),
                    ddn_failure_status.to_string(),
                ]
                .join(",")
            }),
            self.notify_correlation_ids_forddn_failure.as_ref().map(
                |notify_correlation_ids_forddn_failure| {
                    vec![
                        "notifyCorrelationIdsForddnFailure".to_string(),
                        notify_correlation_ids_forddn_failure
                            .iter()
                            .map(|x| x.to_string())
                            .collect::<Vec<_>>()
                            .join(","),
                    ]
                    .join(",")
                },
            ),
            // Skipping newIntermediateSmfId in query parameter serialization

            // Skipping newSmfId in query parameter serialization
            self.new_smf_set_id.as_ref().map(|new_smf_set_id| {
                vec!["newSmfSetId".to_string(), new_smf_set_id.to_string()].join(",")
            }),
            // Skipping oldSmfId in query parameter serialization
            self.old_sm_context_ref.as_ref().map(|old_sm_context_ref| {
                vec![
                    "oldSmContextRef".to_string(),
                    old_sm_context_ref.to_string(),
                ]
                .join(",")
            }),
            self.alt_anchor_smf_uri.as_ref().map(|alt_anchor_smf_uri| {
                vec![
                    "altAnchorSmfUri".to_string(),
                    alt_anchor_smf_uri.to_string(),
                ]
                .join(",")
            }),
            // Skipping altAnchorSmfId in query parameter serialization

            // Skipping targetDnaiInfo in query parameter serialization
            self.old_pdu_session_ref
                .as_ref()
                .map(|old_pdu_session_ref| {
                    vec![
                        "oldPduSessionRef".to_string(),
                        old_pdu_session_ref.to_string(),
                    ]
                    .join(",")
                }),
            self.inter_plmn_api_root
                .as_ref()
                .map(|inter_plmn_api_root| {
                    vec![
                        "interPlmnApiRoot".to_string(),
                        inter_plmn_api_root.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SmContextStatusNotification value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SmContextStatusNotification {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status_info: Vec<models::StatusInfo>,
            pub small_data_rate_status: Vec<models::SmallDataRateStatus>,
            pub apn_rate_status: Vec<models::ApnRateStatus>,
            pub ddn_failure_status: Vec<bool>,
            pub notify_correlation_ids_forddn_failure: Vec<Vec<String>>,
            pub new_intermediate_smf_id: Vec<uuid::Uuid>,
            pub new_smf_id: Vec<uuid::Uuid>,
            pub new_smf_set_id: Vec<String>,
            pub old_smf_id: Vec<uuid::Uuid>,
            pub old_sm_context_ref: Vec<String>,
            pub alt_anchor_smf_uri: Vec<String>,
            pub alt_anchor_smf_id: Vec<uuid::Uuid>,
            pub target_dnai_info: Vec<models::TargetDnaiInfo>,
            pub old_pdu_session_ref: Vec<String>,
            pub inter_plmn_api_root: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SmContextStatusNotification".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "statusInfo" => intermediate_rep.status_info.push(<models::StatusInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "smallDataRateStatus" => intermediate_rep.small_data_rate_status.push(<models::SmallDataRateStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "apnRateStatus" => intermediate_rep.apn_rate_status.push(<models::ApnRateStatus as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ddnFailureStatus" => intermediate_rep.ddn_failure_status.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "notifyCorrelationIdsForddnFailure" => return std::result::Result::Err("Parsing a container in this style is not supported in SmContextStatusNotification".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "newIntermediateSmfId" => intermediate_rep.new_intermediate_smf_id.push(<uuid::Uuid as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "newSmfId" => intermediate_rep.new_smf_id.push(<uuid::Uuid as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "newSmfSetId" => intermediate_rep.new_smf_set_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "oldSmfId" => intermediate_rep.old_smf_id.push(<uuid::Uuid as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "oldSmContextRef" => intermediate_rep.old_sm_context_ref.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "altAnchorSmfUri" => intermediate_rep.alt_anchor_smf_uri.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "altAnchorSmfId" => intermediate_rep.alt_anchor_smf_id.push(<uuid::Uuid as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "targetDnaiInfo" => intermediate_rep.target_dnai_info.push(<models::TargetDnaiInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "oldPduSessionRef" => intermediate_rep.old_pdu_session_ref.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "interPlmnApiRoot" => intermediate_rep.inter_plmn_api_root.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SmContextStatusNotification".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SmContextStatusNotification {
            status_info: intermediate_rep
                .status_info
                .into_iter()
                .next()
                .ok_or_else(|| "statusInfo missing in SmContextStatusNotification".to_string())?,
            small_data_rate_status: intermediate_rep.small_data_rate_status.into_iter().next(),
            apn_rate_status: intermediate_rep.apn_rate_status.into_iter().next(),
            ddn_failure_status: intermediate_rep.ddn_failure_status.into_iter().next(),
            notify_correlation_ids_forddn_failure: intermediate_rep
                .notify_correlation_ids_forddn_failure
                .into_iter()
                .next(),
            new_intermediate_smf_id: intermediate_rep.new_intermediate_smf_id.into_iter().next(),
            new_smf_id: intermediate_rep.new_smf_id.into_iter().next(),
            new_smf_set_id: intermediate_rep.new_smf_set_id.into_iter().next(),
            old_smf_id: intermediate_rep.old_smf_id.into_iter().next(),
            old_sm_context_ref: intermediate_rep.old_sm_context_ref.into_iter().next(),
            alt_anchor_smf_uri: intermediate_rep.alt_anchor_smf_uri.into_iter().next(),
            alt_anchor_smf_id: intermediate_rep.alt_anchor_smf_id.into_iter().next(),
            target_dnai_info: intermediate_rep.target_dnai_info.into_iter().next(),
            old_pdu_session_ref: intermediate_rep.old_pdu_session_ref.into_iter().next(),
            inter_plmn_api_root: intermediate_rep.inter_plmn_api_root.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SmContextStatusNotification> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SmContextStatusNotification>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SmContextStatusNotification>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SmContextStatusNotification - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SmContextStatusNotification>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SmContextStatusNotification as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SmContextStatusNotification - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Type of SM Context information. Possible values are   - EPS_PDN_CONNECTION   - SM_CONTEXT   - AF_COORDINATION_INFO
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SmContextType {}

impl SmContextType {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SmContextType {
        SmContextType {}
    }
}

/// Converts the SmContextType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SmContextType {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SmContextType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SmContextType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SmContextType".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SmContextType".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SmContextType {})
    }
}

// Methods for converting between header::IntoHeaderValue<SmContextType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SmContextType>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SmContextType>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SmContextType - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SmContextType> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SmContextType as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SmContextType - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum SmContextTypeAnyOf {
    #[serde(rename = "EPS_PDN_CONNECTION")]
    EpsPdnConnection,
    #[serde(rename = "SM_CONTEXT")]
    SmContext,
    #[serde(rename = "AF_COORDINATION_INFO")]
    AfCoordinationInfo,
}

impl std::fmt::Display for SmContextTypeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            SmContextTypeAnyOf::EpsPdnConnection => write!(f, "EPS_PDN_CONNECTION"),
            SmContextTypeAnyOf::SmContext => write!(f, "SM_CONTEXT"),
            SmContextTypeAnyOf::AfCoordinationInfo => write!(f, "AF_COORDINATION_INFO"),
        }
    }
}

impl std::str::FromStr for SmContextTypeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "EPS_PDN_CONNECTION" => std::result::Result::Ok(SmContextTypeAnyOf::EpsPdnConnection),
            "SM_CONTEXT" => std::result::Result::Ok(SmContextTypeAnyOf::SmContext),
            "AF_COORDINATION_INFO" => {
                std::result::Result::Ok(SmContextTypeAnyOf::AfCoordinationInfo)
            }
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Data within Update SM Context Request
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SmContextUpdateData {
    /// String representing a Permanent Equipment Identifier that may contain - an IMEI or IMEISV, as  specified in clause 6.2 of 3GPP TS 23.003; a MAC address for a 5G-RG or FN-RG via  wireline  access, with an indication that this address cannot be trusted for regulatory purpose if this  address cannot be used as an Equipment Identifier of the FN-RG, as specified in clause 4.7.7  of 3GPP TS23.316. Examples are imei-012345678901234 or imeisv-0123456789012345.
    #[serde(rename = "pei")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pei: Option<String>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "servingNfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub serving_nf_id: Option<uuid::Uuid>,

    #[serde(rename = "guami")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub guami: Option<models::Guami>,

    #[serde(rename = "servingNetwork")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub serving_network: Option<models::PlmnIdNid>,

    #[serde(rename = "backupAmfInfo")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub backup_amf_info: Option<swagger::Nullable<Vec<models::BackupAmfInfo>>>,

    #[serde(rename = "anType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub an_type: Option<models::AccessType>,

    #[serde(rename = "additionalAnType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_an_type: Option<models::AccessType>,

    #[serde(rename = "anTypeToReactivate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub an_type_to_reactivate: Option<models::AccessType>,

    #[serde(rename = "ratType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rat_type: Option<models::RatType>,

    #[serde(rename = "presenceInLadn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub presence_in_ladn: Option<models::PresenceState>,

    #[serde(rename = "ueLocation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_location: Option<models::UserLocation>,

    /// String with format \"time-numoffset\" optionally appended by \"daylightSavingTime\", where  - \"time-numoffset\" shall represent the time zone adjusted for daylight saving time and be    encoded as time-numoffset as defined in clause 5.6 of IETF RFC 3339;  - \"daylightSavingTime\" shall represent the adjustment that has been made and shall be    encoded as \"+1\" or \"+2\" for a +1 or +2 hours adjustment.   The example is for 8 hours behind UTC, +1 hour adjustment for Daylight Saving Time.
    #[serde(rename = "ueTimeZone")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_time_zone: Option<String>,

    #[serde(rename = "addUeLocation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub add_ue_location: Option<models::UserLocation>,

    #[serde(rename = "upCnxState")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub up_cnx_state: Option<models::UpCnxState>,

    #[serde(rename = "hoState")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ho_state: Option<models::HoState>,

    #[serde(rename = "toBeSwitched")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub to_be_switched: Option<bool>,

    #[serde(rename = "failedToBeSwitched")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub failed_to_be_switched: Option<bool>,

    #[serde(rename = "n1SmMsg")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n1_sm_msg: Option<models::RefToBinaryData>,

    #[serde(rename = "n2SmInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n2_sm_info: Option<models::RefToBinaryData>,

    #[serde(rename = "n2SmInfoType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n2_sm_info_type: Option<models::N2SmInfoType>,

    #[serde(rename = "targetId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_id: Option<models::NgRanTargetId>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "targetServingNfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_serving_nf_id: Option<uuid::Uuid>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "smContextStatusUri")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sm_context_status_uri: Option<String>,

    #[serde(rename = "dataForwarding")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data_forwarding: Option<bool>,

    #[serde(rename = "n9ForwardingTunnel")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n9_forwarding_tunnel: Option<models::TunnelInfo>,

    #[serde(rename = "n9DlForwardingTnlList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n9_dl_forwarding_tnl_list: Option<Vec<models::IndirectDataForwardingTunnelInfo>>,

    #[serde(rename = "n9UlForwardingTnlList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n9_ul_forwarding_tnl_list: Option<Vec<models::IndirectDataForwardingTunnelInfo>>,

    #[serde(rename = "n9DlForwardingTunnel")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n9_dl_forwarding_tunnel: Option<models::TunnelInfo>,

    /// indicating a time in seconds.
    #[serde(rename = "n9InactivityTimer")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n9_inactivity_timer: Option<i32>,

    #[serde(rename = "epsBearerSetup")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub eps_bearer_setup: Option<Vec<models::EpsBearerContainer>>,

    #[serde(rename = "revokeEbiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub revoke_ebi_list: Option<Vec<models::EpsBearerId>>,

    #[serde(rename = "release")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub release: Option<bool>,

    #[serde(rename = "cause")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cause: Option<models::Cause>,

    #[serde(rename = "ngApCause")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ng_ap_cause: Option<models::NgApCause>,

    /// Unsigned Integer, i.e. only value 0 and integers above 0 are permissible.
    #[serde(rename = "5gMmCauseValue")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub param_5g_mm_cause_value: Option<u32>,

    #[serde(rename = "sNssai")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub s_nssai: Option<models::Snssai>,

    #[serde(rename = "traceData")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trace_data: Option<swagger::Nullable<models::TraceData>>,

    #[serde(rename = "epsInterworkingInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub eps_interworking_ind: Option<models::EpsInterworkingIndication>,

    #[serde(rename = "anTypeCanBeChanged")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub an_type_can_be_changed: Option<bool>,

    #[serde(rename = "n2SmInfoExt1")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n2_sm_info_ext1: Option<models::RefToBinaryData>,

    #[serde(rename = "n2SmInfoTypeExt1")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n2_sm_info_type_ext1: Option<models::N2SmInfoType>,

    #[serde(rename = "maReleaseInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ma_release_ind: Option<models::MaReleaseIndication>,

    #[serde(rename = "maNwUpgradeInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ma_nw_upgrade_ind: Option<bool>,

    #[serde(rename = "maRequestInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ma_request_ind: Option<bool>,

    #[serde(rename = "exemptionInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub exemption_ind: Option<models::ExemptionInd>,

    /// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  table 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.
    #[serde(rename = "supportedFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_features: Option<String>,

    #[serde(rename = "moExpDataCounter")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mo_exp_data_counter: Option<models::MoExpDataCounter>,

    #[serde(rename = "extendedNasSmTimerInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub extended_nas_sm_timer_ind: Option<bool>,

    /// string with format 'bytes' as defined in OpenAPI
    #[serde(rename = "forwardingFTeid")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub forwarding_f_teid: Option<swagger::ByteArray>,

    #[serde(rename = "forwardingBearerContexts")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub forwarding_bearer_contexts: Option<Vec<models::ForwardingBearerContainer>>,

    #[serde(rename = "ddnFailureSubs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ddn_failure_subs: Option<models::DdnFailureSubs>,

    #[serde(rename = "skipN2PduSessionResRelInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub skip_n2_pdu_session_res_rel_ind: Option<bool>,

    #[serde(rename = "secondaryRatUsageDataReportContainer")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub secondary_rat_usage_data_report_container:
        Option<Vec<models::SecondaryRatUsageDataReportContainer>>,

    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "smPolicyNotifyInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sm_policy_notify_ind: Option<bool>,

    #[serde(rename = "pcfUeCallbackInfo")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pcf_ue_callback_info: Option<swagger::Nullable<models::PcfUeCallbackInfo>>,

    #[serde(rename = "satelliteBackhaulCat")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub satellite_backhaul_cat: Option<models::SatelliteBackhaulCategory>,
}

impl SmContextUpdateData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SmContextUpdateData {
        SmContextUpdateData {
            pei: None,
            serving_nf_id: None,
            guami: None,
            serving_network: None,
            backup_amf_info: None,
            an_type: None,
            additional_an_type: None,
            an_type_to_reactivate: None,
            rat_type: None,
            presence_in_ladn: None,
            ue_location: None,
            ue_time_zone: None,
            add_ue_location: None,
            up_cnx_state: None,
            ho_state: None,
            to_be_switched: Some(false),
            failed_to_be_switched: None,
            n1_sm_msg: None,
            n2_sm_info: None,
            n2_sm_info_type: None,
            target_id: None,
            target_serving_nf_id: None,
            sm_context_status_uri: None,
            data_forwarding: Some(false),
            n9_forwarding_tunnel: None,
            n9_dl_forwarding_tnl_list: None,
            n9_ul_forwarding_tnl_list: None,
            n9_dl_forwarding_tunnel: None,
            n9_inactivity_timer: None,
            eps_bearer_setup: None,
            revoke_ebi_list: None,
            release: Some(false),
            cause: None,
            ng_ap_cause: None,
            param_5g_mm_cause_value: None,
            s_nssai: None,
            trace_data: None,
            eps_interworking_ind: None,
            an_type_can_be_changed: Some(false),
            n2_sm_info_ext1: None,
            n2_sm_info_type_ext1: None,
            ma_release_ind: None,
            ma_nw_upgrade_ind: Some(false),
            ma_request_ind: Some(false),
            exemption_ind: None,
            supported_features: None,
            mo_exp_data_counter: None,
            extended_nas_sm_timer_ind: None,
            forwarding_f_teid: None,
            forwarding_bearer_contexts: None,
            ddn_failure_subs: None,
            skip_n2_pdu_session_res_rel_ind: Some(false),
            secondary_rat_usage_data_report_container: None,
            sm_policy_notify_ind: None,
            pcf_ue_callback_info: None,
            satellite_backhaul_cat: None,
        }
    }
}

/// Converts the SmContextUpdateData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SmContextUpdateData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.pei
                .as_ref()
                .map(|pei| vec!["pei".to_string(), pei.to_string()].join(",")),
            // Skipping servingNfId in query parameter serialization

            // Skipping guami in query parameter serialization

            // Skipping servingNetwork in query parameter serialization

            // Skipping backupAmfInfo in query parameter serialization

            // Skipping anType in query parameter serialization

            // Skipping additionalAnType in query parameter serialization

            // Skipping anTypeToReactivate in query parameter serialization

            // Skipping ratType in query parameter serialization

            // Skipping presenceInLadn in query parameter serialization

            // Skipping ueLocation in query parameter serialization
            self.ue_time_zone.as_ref().map(|ue_time_zone| {
                vec!["ueTimeZone".to_string(), ue_time_zone.to_string()].join(",")
            }),
            // Skipping addUeLocation in query parameter serialization

            // Skipping upCnxState in query parameter serialization

            // Skipping hoState in query parameter serialization
            self.to_be_switched.as_ref().map(|to_be_switched| {
                vec!["toBeSwitched".to_string(), to_be_switched.to_string()].join(",")
            }),
            self.failed_to_be_switched
                .as_ref()
                .map(|failed_to_be_switched| {
                    vec![
                        "failedToBeSwitched".to_string(),
                        failed_to_be_switched.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping n1SmMsg in query parameter serialization

            // Skipping n2SmInfo in query parameter serialization

            // Skipping n2SmInfoType in query parameter serialization

            // Skipping targetId in query parameter serialization

            // Skipping targetServingNfId in query parameter serialization
            self.sm_context_status_uri
                .as_ref()
                .map(|sm_context_status_uri| {
                    vec![
                        "smContextStatusUri".to_string(),
                        sm_context_status_uri.to_string(),
                    ]
                    .join(",")
                }),
            self.data_forwarding.as_ref().map(|data_forwarding| {
                vec!["dataForwarding".to_string(), data_forwarding.to_string()].join(",")
            }),
            // Skipping n9ForwardingTunnel in query parameter serialization

            // Skipping n9DlForwardingTnlList in query parameter serialization

            // Skipping n9UlForwardingTnlList in query parameter serialization

            // Skipping n9DlForwardingTunnel in query parameter serialization
            self.n9_inactivity_timer
                .as_ref()
                .map(|n9_inactivity_timer| {
                    vec![
                        "n9InactivityTimer".to_string(),
                        n9_inactivity_timer.to_string(),
                    ]
                    .join(",")
                }),
            self.eps_bearer_setup.as_ref().map(|eps_bearer_setup| {
                vec![
                    "epsBearerSetup".to_string(),
                    eps_bearer_setup
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.revoke_ebi_list.as_ref().map(|revoke_ebi_list| {
                vec![
                    "revokeEbiList".to_string(),
                    revoke_ebi_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.release
                .as_ref()
                .map(|release| vec!["release".to_string(), release.to_string()].join(",")),
            // Skipping cause in query parameter serialization

            // Skipping ngApCause in query parameter serialization
            self.param_5g_mm_cause_value
                .as_ref()
                .map(|param_5g_mm_cause_value| {
                    vec![
                        "5gMmCauseValue".to_string(),
                        param_5g_mm_cause_value.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping sNssai in query parameter serialization

            // Skipping traceData in query parameter serialization

            // Skipping epsInterworkingInd in query parameter serialization
            self.an_type_can_be_changed
                .as_ref()
                .map(|an_type_can_be_changed| {
                    vec![
                        "anTypeCanBeChanged".to_string(),
                        an_type_can_be_changed.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping n2SmInfoExt1 in query parameter serialization

            // Skipping n2SmInfoTypeExt1 in query parameter serialization

            // Skipping maReleaseInd in query parameter serialization
            self.ma_nw_upgrade_ind.as_ref().map(|ma_nw_upgrade_ind| {
                vec!["maNwUpgradeInd".to_string(), ma_nw_upgrade_ind.to_string()].join(",")
            }),
            self.ma_request_ind.as_ref().map(|ma_request_ind| {
                vec!["maRequestInd".to_string(), ma_request_ind.to_string()].join(",")
            }),
            // Skipping exemptionInd in query parameter serialization
            self.supported_features.as_ref().map(|supported_features| {
                vec![
                    "supportedFeatures".to_string(),
                    supported_features.to_string(),
                ]
                .join(",")
            }),
            // Skipping moExpDataCounter in query parameter serialization
            self.extended_nas_sm_timer_ind
                .as_ref()
                .map(|extended_nas_sm_timer_ind| {
                    vec![
                        "extendedNasSmTimerInd".to_string(),
                        extended_nas_sm_timer_ind.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping forwardingFTeid in query parameter serialization
            // Skipping forwardingFTeid in query parameter serialization
            self.forwarding_bearer_contexts
                .as_ref()
                .map(|forwarding_bearer_contexts| {
                    vec![
                        "forwardingBearerContexts".to_string(),
                        forwarding_bearer_contexts
                            .iter()
                            .map(|x| x.to_string())
                            .collect::<Vec<_>>()
                            .join(","),
                    ]
                    .join(",")
                }),
            // Skipping ddnFailureSubs in query parameter serialization
            self.skip_n2_pdu_session_res_rel_ind
                .as_ref()
                .map(|skip_n2_pdu_session_res_rel_ind| {
                    vec![
                        "skipN2PduSessionResRelInd".to_string(),
                        skip_n2_pdu_session_res_rel_ind.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping secondaryRatUsageDataReportContainer in query parameter serialization
            self.sm_policy_notify_ind
                .as_ref()
                .map(|sm_policy_notify_ind| {
                    vec![
                        "smPolicyNotifyInd".to_string(),
                        sm_policy_notify_ind.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping pcfUeCallbackInfo in query parameter serialization

            // Skipping satelliteBackhaulCat in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SmContextUpdateData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SmContextUpdateData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub pei: Vec<String>,
            pub serving_nf_id: Vec<uuid::Uuid>,
            pub guami: Vec<models::Guami>,
            pub serving_network: Vec<models::PlmnIdNid>,
            pub backup_amf_info: Vec<Vec<models::BackupAmfInfo>>,
            pub an_type: Vec<models::AccessType>,
            pub additional_an_type: Vec<models::AccessType>,
            pub an_type_to_reactivate: Vec<models::AccessType>,
            pub rat_type: Vec<models::RatType>,
            pub presence_in_ladn: Vec<models::PresenceState>,
            pub ue_location: Vec<models::UserLocation>,
            pub ue_time_zone: Vec<String>,
            pub add_ue_location: Vec<models::UserLocation>,
            pub up_cnx_state: Vec<models::UpCnxState>,
            pub ho_state: Vec<models::HoState>,
            pub to_be_switched: Vec<bool>,
            pub failed_to_be_switched: Vec<bool>,
            pub n1_sm_msg: Vec<models::RefToBinaryData>,
            pub n2_sm_info: Vec<models::RefToBinaryData>,
            pub n2_sm_info_type: Vec<models::N2SmInfoType>,
            pub target_id: Vec<models::NgRanTargetId>,
            pub target_serving_nf_id: Vec<uuid::Uuid>,
            pub sm_context_status_uri: Vec<String>,
            pub data_forwarding: Vec<bool>,
            pub n9_forwarding_tunnel: Vec<models::TunnelInfo>,
            pub n9_dl_forwarding_tnl_list: Vec<Vec<models::IndirectDataForwardingTunnelInfo>>,
            pub n9_ul_forwarding_tnl_list: Vec<Vec<models::IndirectDataForwardingTunnelInfo>>,
            pub n9_dl_forwarding_tunnel: Vec<models::TunnelInfo>,
            pub n9_inactivity_timer: Vec<i32>,
            pub eps_bearer_setup: Vec<Vec<models::EpsBearerContainer>>,
            pub revoke_ebi_list: Vec<Vec<models::EpsBearerId>>,
            pub release: Vec<bool>,
            pub cause: Vec<models::Cause>,
            pub ng_ap_cause: Vec<models::NgApCause>,
            pub param_5g_mm_cause_value: Vec<u32>,
            pub s_nssai: Vec<models::Snssai>,
            pub trace_data: Vec<models::TraceData>,
            pub eps_interworking_ind: Vec<models::EpsInterworkingIndication>,
            pub an_type_can_be_changed: Vec<bool>,
            pub n2_sm_info_ext1: Vec<models::RefToBinaryData>,
            pub n2_sm_info_type_ext1: Vec<models::N2SmInfoType>,
            pub ma_release_ind: Vec<models::MaReleaseIndication>,
            pub ma_nw_upgrade_ind: Vec<bool>,
            pub ma_request_ind: Vec<bool>,
            pub exemption_ind: Vec<models::ExemptionInd>,
            pub supported_features: Vec<String>,
            pub mo_exp_data_counter: Vec<models::MoExpDataCounter>,
            pub extended_nas_sm_timer_ind: Vec<bool>,
            pub forwarding_f_teid: Vec<swagger::ByteArray>,
            pub forwarding_bearer_contexts: Vec<Vec<models::ForwardingBearerContainer>>,
            pub ddn_failure_subs: Vec<models::DdnFailureSubs>,
            pub skip_n2_pdu_session_res_rel_ind: Vec<bool>,
            pub secondary_rat_usage_data_report_container:
                Vec<Vec<models::SecondaryRatUsageDataReportContainer>>,
            pub sm_policy_notify_ind: Vec<bool>,
            pub pcf_ue_callback_info: Vec<models::PcfUeCallbackInfo>,
            pub satellite_backhaul_cat: Vec<models::SatelliteBackhaulCategory>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SmContextUpdateData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "pei" => intermediate_rep.pei.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "servingNfId" => intermediate_rep.serving_nf_id.push(<uuid::Uuid as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "guami" => intermediate_rep.guami.push(<models::Guami as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "servingNetwork" => intermediate_rep.serving_network.push(<models::PlmnIdNid as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "backupAmfInfo" => return std::result::Result::Err("Parsing a container in this style is not supported in SmContextUpdateData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "anType" => intermediate_rep.an_type.push(<models::AccessType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "additionalAnType" => intermediate_rep.additional_an_type.push(<models::AccessType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "anTypeToReactivate" => intermediate_rep.an_type_to_reactivate.push(<models::AccessType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ratType" => intermediate_rep.rat_type.push(<models::RatType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "presenceInLadn" => intermediate_rep.presence_in_ladn.push(<models::PresenceState as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ueLocation" => intermediate_rep.ue_location.push(<models::UserLocation as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ueTimeZone" => intermediate_rep.ue_time_zone.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "addUeLocation" => intermediate_rep.add_ue_location.push(<models::UserLocation as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "upCnxState" => intermediate_rep.up_cnx_state.push(<models::UpCnxState as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hoState" => intermediate_rep.ho_state.push(<models::HoState as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "toBeSwitched" => intermediate_rep.to_be_switched.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "failedToBeSwitched" => intermediate_rep.failed_to_be_switched.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "n1SmMsg" => intermediate_rep.n1_sm_msg.push(<models::RefToBinaryData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "n2SmInfo" => intermediate_rep.n2_sm_info.push(<models::RefToBinaryData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "n2SmInfoType" => intermediate_rep.n2_sm_info_type.push(<models::N2SmInfoType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "targetId" => intermediate_rep.target_id.push(<models::NgRanTargetId as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "targetServingNfId" => intermediate_rep.target_serving_nf_id.push(<uuid::Uuid as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "smContextStatusUri" => intermediate_rep.sm_context_status_uri.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dataForwarding" => intermediate_rep.data_forwarding.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "n9ForwardingTunnel" => intermediate_rep.n9_forwarding_tunnel.push(<models::TunnelInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "n9DlForwardingTnlList" => return std::result::Result::Err("Parsing a container in this style is not supported in SmContextUpdateData".to_string()),
                    "n9UlForwardingTnlList" => return std::result::Result::Err("Parsing a container in this style is not supported in SmContextUpdateData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "n9DlForwardingTunnel" => intermediate_rep.n9_dl_forwarding_tunnel.push(<models::TunnelInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "n9InactivityTimer" => intermediate_rep.n9_inactivity_timer.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "epsBearerSetup" => return std::result::Result::Err("Parsing a container in this style is not supported in SmContextUpdateData".to_string()),
                    "revokeEbiList" => return std::result::Result::Err("Parsing a container in this style is not supported in SmContextUpdateData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "release" => intermediate_rep.release.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cause" => intermediate_rep.cause.push(<models::Cause as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ngApCause" => intermediate_rep.ng_ap_cause.push(<models::NgApCause as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "5gMmCauseValue" => intermediate_rep.param_5g_mm_cause_value.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sNssai" => intermediate_rep.s_nssai.push(<models::Snssai as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "traceData" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SmContextUpdateData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "epsInterworkingInd" => intermediate_rep.eps_interworking_ind.push(<models::EpsInterworkingIndication as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "anTypeCanBeChanged" => intermediate_rep.an_type_can_be_changed.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "n2SmInfoExt1" => intermediate_rep.n2_sm_info_ext1.push(<models::RefToBinaryData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "n2SmInfoTypeExt1" => intermediate_rep.n2_sm_info_type_ext1.push(<models::N2SmInfoType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maReleaseInd" => intermediate_rep.ma_release_ind.push(<models::MaReleaseIndication as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maNwUpgradeInd" => intermediate_rep.ma_nw_upgrade_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maRequestInd" => intermediate_rep.ma_request_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "exemptionInd" => intermediate_rep.exemption_ind.push(<models::ExemptionInd as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "supportedFeatures" => intermediate_rep.supported_features.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "moExpDataCounter" => intermediate_rep.mo_exp_data_counter.push(<models::MoExpDataCounter as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "extendedNasSmTimerInd" => intermediate_rep.extended_nas_sm_timer_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "forwardingFTeid" => return std::result::Result::Err("Parsing binary data in this style is not supported in SmContextUpdateData".to_string()),
                    "forwardingBearerContexts" => return std::result::Result::Err("Parsing a container in this style is not supported in SmContextUpdateData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "ddnFailureSubs" => intermediate_rep.ddn_failure_subs.push(<models::DdnFailureSubs as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "skipN2PduSessionResRelInd" => intermediate_rep.skip_n2_pdu_session_res_rel_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "secondaryRatUsageDataReportContainer" => return std::result::Result::Err("Parsing a container in this style is not supported in SmContextUpdateData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "smPolicyNotifyInd" => intermediate_rep.sm_policy_notify_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "pcfUeCallbackInfo" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SmContextUpdateData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "satelliteBackhaulCat" => intermediate_rep.satellite_backhaul_cat.push(<models::SatelliteBackhaulCategory as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SmContextUpdateData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SmContextUpdateData {
            pei: intermediate_rep.pei.into_iter().next(),
            serving_nf_id: intermediate_rep.serving_nf_id.into_iter().next(),
            guami: intermediate_rep.guami.into_iter().next(),
            serving_network: intermediate_rep.serving_network.into_iter().next(),
            backup_amf_info: std::result::Result::Err(
                "Nullable types not supported in SmContextUpdateData".to_string(),
            )?,
            an_type: intermediate_rep.an_type.into_iter().next(),
            additional_an_type: intermediate_rep.additional_an_type.into_iter().next(),
            an_type_to_reactivate: intermediate_rep.an_type_to_reactivate.into_iter().next(),
            rat_type: intermediate_rep.rat_type.into_iter().next(),
            presence_in_ladn: intermediate_rep.presence_in_ladn.into_iter().next(),
            ue_location: intermediate_rep.ue_location.into_iter().next(),
            ue_time_zone: intermediate_rep.ue_time_zone.into_iter().next(),
            add_ue_location: intermediate_rep.add_ue_location.into_iter().next(),
            up_cnx_state: intermediate_rep.up_cnx_state.into_iter().next(),
            ho_state: intermediate_rep.ho_state.into_iter().next(),
            to_be_switched: intermediate_rep.to_be_switched.into_iter().next(),
            failed_to_be_switched: intermediate_rep.failed_to_be_switched.into_iter().next(),
            n1_sm_msg: intermediate_rep.n1_sm_msg.into_iter().next(),
            n2_sm_info: intermediate_rep.n2_sm_info.into_iter().next(),
            n2_sm_info_type: intermediate_rep.n2_sm_info_type.into_iter().next(),
            target_id: intermediate_rep.target_id.into_iter().next(),
            target_serving_nf_id: intermediate_rep.target_serving_nf_id.into_iter().next(),
            sm_context_status_uri: intermediate_rep.sm_context_status_uri.into_iter().next(),
            data_forwarding: intermediate_rep.data_forwarding.into_iter().next(),
            n9_forwarding_tunnel: intermediate_rep.n9_forwarding_tunnel.into_iter().next(),
            n9_dl_forwarding_tnl_list: intermediate_rep
                .n9_dl_forwarding_tnl_list
                .into_iter()
                .next(),
            n9_ul_forwarding_tnl_list: intermediate_rep
                .n9_ul_forwarding_tnl_list
                .into_iter()
                .next(),
            n9_dl_forwarding_tunnel: intermediate_rep.n9_dl_forwarding_tunnel.into_iter().next(),
            n9_inactivity_timer: intermediate_rep.n9_inactivity_timer.into_iter().next(),
            eps_bearer_setup: intermediate_rep.eps_bearer_setup.into_iter().next(),
            revoke_ebi_list: intermediate_rep.revoke_ebi_list.into_iter().next(),
            release: intermediate_rep.release.into_iter().next(),
            cause: intermediate_rep.cause.into_iter().next(),
            ng_ap_cause: intermediate_rep.ng_ap_cause.into_iter().next(),
            param_5g_mm_cause_value: intermediate_rep.param_5g_mm_cause_value.into_iter().next(),
            s_nssai: intermediate_rep.s_nssai.into_iter().next(),
            trace_data: std::result::Result::Err(
                "Nullable types not supported in SmContextUpdateData".to_string(),
            )?,
            eps_interworking_ind: intermediate_rep.eps_interworking_ind.into_iter().next(),
            an_type_can_be_changed: intermediate_rep.an_type_can_be_changed.into_iter().next(),
            n2_sm_info_ext1: intermediate_rep.n2_sm_info_ext1.into_iter().next(),
            n2_sm_info_type_ext1: intermediate_rep.n2_sm_info_type_ext1.into_iter().next(),
            ma_release_ind: intermediate_rep.ma_release_ind.into_iter().next(),
            ma_nw_upgrade_ind: intermediate_rep.ma_nw_upgrade_ind.into_iter().next(),
            ma_request_ind: intermediate_rep.ma_request_ind.into_iter().next(),
            exemption_ind: intermediate_rep.exemption_ind.into_iter().next(),
            supported_features: intermediate_rep.supported_features.into_iter().next(),
            mo_exp_data_counter: intermediate_rep.mo_exp_data_counter.into_iter().next(),
            extended_nas_sm_timer_ind: intermediate_rep
                .extended_nas_sm_timer_ind
                .into_iter()
                .next(),
            forwarding_f_teid: intermediate_rep.forwarding_f_teid.into_iter().next(),
            forwarding_bearer_contexts: intermediate_rep
                .forwarding_bearer_contexts
                .into_iter()
                .next(),
            ddn_failure_subs: intermediate_rep.ddn_failure_subs.into_iter().next(),
            skip_n2_pdu_session_res_rel_ind: intermediate_rep
                .skip_n2_pdu_session_res_rel_ind
                .into_iter()
                .next(),
            secondary_rat_usage_data_report_container: intermediate_rep
                .secondary_rat_usage_data_report_container
                .into_iter()
                .next(),
            sm_policy_notify_ind: intermediate_rep.sm_policy_notify_ind.into_iter().next(),
            pcf_ue_callback_info: std::result::Result::Err(
                "Nullable types not supported in SmContextUpdateData".to_string(),
            )?,
            satellite_backhaul_cat: intermediate_rep.satellite_backhaul_cat.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SmContextUpdateData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SmContextUpdateData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SmContextUpdateData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SmContextUpdateData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SmContextUpdateData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SmContextUpdateData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SmContextUpdateData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Error within Update SM Context Response
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SmContextUpdateError {
    #[serde(rename = "error")]
    pub error: models::ExtProblemDetails,

    #[serde(rename = "n1SmMsg")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n1_sm_msg: Option<models::RefToBinaryData>,

    #[serde(rename = "n2SmInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n2_sm_info: Option<models::RefToBinaryData>,

    #[serde(rename = "n2SmInfoType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n2_sm_info_type: Option<models::N2SmInfoType>,

    #[serde(rename = "upCnxState")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub up_cnx_state: Option<models::UpCnxState>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "recoveryTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recovery_time: Option<chrono::DateTime<chrono::Utc>>,
}

impl SmContextUpdateError {
    #[allow(clippy::new_without_default)]
    pub fn new(error: models::ExtProblemDetails) -> SmContextUpdateError {
        SmContextUpdateError {
            error,
            n1_sm_msg: None,
            n2_sm_info: None,
            n2_sm_info_type: None,
            up_cnx_state: None,
            recovery_time: None,
        }
    }
}

/// Converts the SmContextUpdateError value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SmContextUpdateError {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping error in query parameter serialization

            // Skipping n1SmMsg in query parameter serialization

            // Skipping n2SmInfo in query parameter serialization

            // Skipping n2SmInfoType in query parameter serialization

            // Skipping upCnxState in query parameter serialization

            // Skipping recoveryTime in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SmContextUpdateError value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SmContextUpdateError {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub error: Vec<models::ExtProblemDetails>,
            pub n1_sm_msg: Vec<models::RefToBinaryData>,
            pub n2_sm_info: Vec<models::RefToBinaryData>,
            pub n2_sm_info_type: Vec<models::N2SmInfoType>,
            pub up_cnx_state: Vec<models::UpCnxState>,
            pub recovery_time: Vec<chrono::DateTime<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SmContextUpdateError".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "error" => intermediate_rep.error.push(
                        <models::ExtProblemDetails as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n1SmMsg" => intermediate_rep.n1_sm_msg.push(
                        <models::RefToBinaryData as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n2SmInfo" => intermediate_rep.n2_sm_info.push(
                        <models::RefToBinaryData as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n2SmInfoType" => intermediate_rep.n2_sm_info_type.push(
                        <models::N2SmInfoType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "upCnxState" => intermediate_rep.up_cnx_state.push(
                        <models::UpCnxState as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "recoveryTime" => intermediate_rep.recovery_time.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SmContextUpdateError".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SmContextUpdateError {
            error: intermediate_rep
                .error
                .into_iter()
                .next()
                .ok_or_else(|| "error missing in SmContextUpdateError".to_string())?,
            n1_sm_msg: intermediate_rep.n1_sm_msg.into_iter().next(),
            n2_sm_info: intermediate_rep.n2_sm_info.into_iter().next(),
            n2_sm_info_type: intermediate_rep.n2_sm_info_type.into_iter().next(),
            up_cnx_state: intermediate_rep.up_cnx_state.into_iter().next(),
            recovery_time: intermediate_rep.recovery_time.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SmContextUpdateError> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SmContextUpdateError>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SmContextUpdateError>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SmContextUpdateError - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SmContextUpdateError>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SmContextUpdateError as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SmContextUpdateError - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Data within Update SM Context Response
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SmContextUpdatedData {
    #[serde(rename = "upCnxState")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub up_cnx_state: Option<models::UpCnxState>,

    #[serde(rename = "hoState")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ho_state: Option<models::HoState>,

    #[serde(rename = "releaseEbiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub release_ebi_list: Option<Vec<models::EpsBearerId>>,

    #[serde(rename = "allocatedEbiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allocated_ebi_list: Option<Vec<models::EbiArpMapping>>,

    #[serde(rename = "modifiedEbiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub modified_ebi_list: Option<Vec<models::EbiArpMapping>>,

    #[serde(rename = "n1SmMsg")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n1_sm_msg: Option<models::RefToBinaryData>,

    #[serde(rename = "n2SmInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n2_sm_info: Option<models::RefToBinaryData>,

    #[serde(rename = "n2SmInfoType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n2_sm_info_type: Option<models::N2SmInfoType>,

    #[serde(rename = "epsBearerSetup")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub eps_bearer_setup: Option<Vec<models::EpsBearerContainer>>,

    #[serde(rename = "dataForwarding")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data_forwarding: Option<bool>,

    #[serde(rename = "n3DlForwardingTnlList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n3_dl_forwarding_tnl_list: Option<Vec<models::IndirectDataForwardingTunnelInfo>>,

    #[serde(rename = "n3UlForwardingTnlList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n3_ul_forwarding_tnl_list: Option<Vec<models::IndirectDataForwardingTunnelInfo>>,

    #[serde(rename = "n9UlForwardingTunnel")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n9_ul_forwarding_tunnel: Option<models::TunnelInfo>,

    #[serde(rename = "cause")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cause: Option<models::Cause>,

    #[serde(rename = "maAcceptedInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ma_accepted_ind: Option<bool>,

    /// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  table 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.
    #[serde(rename = "supportedFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_features: Option<String>,

    /// string with format 'bytes' as defined in OpenAPI
    #[serde(rename = "forwardingFTeid")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub forwarding_f_teid: Option<swagger::ByteArray>,

    #[serde(rename = "forwardingBearerContexts")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub forwarding_bearer_contexts: Option<Vec<models::ForwardingBearerContainer>>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "selectedSmfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub selected_smf_id: Option<uuid::Uuid>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "selectedOldSmfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub selected_old_smf_id: Option<uuid::Uuid>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "interPlmnApiRoot")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub inter_plmn_api_root: Option<String>,

    #[serde(rename = "anchorSmfFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub anchor_smf_features: Option<models::AnchorSmfFeatures>,
}

impl SmContextUpdatedData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SmContextUpdatedData {
        SmContextUpdatedData {
            up_cnx_state: None,
            ho_state: None,
            release_ebi_list: None,
            allocated_ebi_list: None,
            modified_ebi_list: None,
            n1_sm_msg: None,
            n2_sm_info: None,
            n2_sm_info_type: None,
            eps_bearer_setup: None,
            data_forwarding: None,
            n3_dl_forwarding_tnl_list: None,
            n3_ul_forwarding_tnl_list: None,
            n9_ul_forwarding_tunnel: None,
            cause: None,
            ma_accepted_ind: Some(false),
            supported_features: None,
            forwarding_f_teid: None,
            forwarding_bearer_contexts: None,
            selected_smf_id: None,
            selected_old_smf_id: None,
            inter_plmn_api_root: None,
            anchor_smf_features: None,
        }
    }
}

/// Converts the SmContextUpdatedData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SmContextUpdatedData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping upCnxState in query parameter serialization

            // Skipping hoState in query parameter serialization
            self.release_ebi_list.as_ref().map(|release_ebi_list| {
                vec![
                    "releaseEbiList".to_string(),
                    release_ebi_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping allocatedEbiList in query parameter serialization

            // Skipping modifiedEbiList in query parameter serialization

            // Skipping n1SmMsg in query parameter serialization

            // Skipping n2SmInfo in query parameter serialization

            // Skipping n2SmInfoType in query parameter serialization
            self.eps_bearer_setup.as_ref().map(|eps_bearer_setup| {
                vec![
                    "epsBearerSetup".to_string(),
                    eps_bearer_setup
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.data_forwarding.as_ref().map(|data_forwarding| {
                vec!["dataForwarding".to_string(), data_forwarding.to_string()].join(",")
            }),
            // Skipping n3DlForwardingTnlList in query parameter serialization

            // Skipping n3UlForwardingTnlList in query parameter serialization

            // Skipping n9UlForwardingTunnel in query parameter serialization

            // Skipping cause in query parameter serialization
            self.ma_accepted_ind.as_ref().map(|ma_accepted_ind| {
                vec!["maAcceptedInd".to_string(), ma_accepted_ind.to_string()].join(",")
            }),
            self.supported_features.as_ref().map(|supported_features| {
                vec![
                    "supportedFeatures".to_string(),
                    supported_features.to_string(),
                ]
                .join(",")
            }),
            // Skipping forwardingFTeid in query parameter serialization
            // Skipping forwardingFTeid in query parameter serialization
            self.forwarding_bearer_contexts
                .as_ref()
                .map(|forwarding_bearer_contexts| {
                    vec![
                        "forwardingBearerContexts".to_string(),
                        forwarding_bearer_contexts
                            .iter()
                            .map(|x| x.to_string())
                            .collect::<Vec<_>>()
                            .join(","),
                    ]
                    .join(",")
                }),
            // Skipping selectedSmfId in query parameter serialization

            // Skipping selectedOldSmfId in query parameter serialization
            self.inter_plmn_api_root
                .as_ref()
                .map(|inter_plmn_api_root| {
                    vec![
                        "interPlmnApiRoot".to_string(),
                        inter_plmn_api_root.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping anchorSmfFeatures in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SmContextUpdatedData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SmContextUpdatedData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub up_cnx_state: Vec<models::UpCnxState>,
            pub ho_state: Vec<models::HoState>,
            pub release_ebi_list: Vec<Vec<models::EpsBearerId>>,
            pub allocated_ebi_list: Vec<Vec<models::EbiArpMapping>>,
            pub modified_ebi_list: Vec<Vec<models::EbiArpMapping>>,
            pub n1_sm_msg: Vec<models::RefToBinaryData>,
            pub n2_sm_info: Vec<models::RefToBinaryData>,
            pub n2_sm_info_type: Vec<models::N2SmInfoType>,
            pub eps_bearer_setup: Vec<Vec<models::EpsBearerContainer>>,
            pub data_forwarding: Vec<bool>,
            pub n3_dl_forwarding_tnl_list: Vec<Vec<models::IndirectDataForwardingTunnelInfo>>,
            pub n3_ul_forwarding_tnl_list: Vec<Vec<models::IndirectDataForwardingTunnelInfo>>,
            pub n9_ul_forwarding_tunnel: Vec<models::TunnelInfo>,
            pub cause: Vec<models::Cause>,
            pub ma_accepted_ind: Vec<bool>,
            pub supported_features: Vec<String>,
            pub forwarding_f_teid: Vec<swagger::ByteArray>,
            pub forwarding_bearer_contexts: Vec<Vec<models::ForwardingBearerContainer>>,
            pub selected_smf_id: Vec<uuid::Uuid>,
            pub selected_old_smf_id: Vec<uuid::Uuid>,
            pub inter_plmn_api_root: Vec<String>,
            pub anchor_smf_features: Vec<models::AnchorSmfFeatures>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SmContextUpdatedData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "upCnxState" => intermediate_rep.up_cnx_state.push(<models::UpCnxState as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hoState" => intermediate_rep.ho_state.push(<models::HoState as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "releaseEbiList" => return std::result::Result::Err("Parsing a container in this style is not supported in SmContextUpdatedData".to_string()),
                    "allocatedEbiList" => return std::result::Result::Err("Parsing a container in this style is not supported in SmContextUpdatedData".to_string()),
                    "modifiedEbiList" => return std::result::Result::Err("Parsing a container in this style is not supported in SmContextUpdatedData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "n1SmMsg" => intermediate_rep.n1_sm_msg.push(<models::RefToBinaryData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "n2SmInfo" => intermediate_rep.n2_sm_info.push(<models::RefToBinaryData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "n2SmInfoType" => intermediate_rep.n2_sm_info_type.push(<models::N2SmInfoType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "epsBearerSetup" => return std::result::Result::Err("Parsing a container in this style is not supported in SmContextUpdatedData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "dataForwarding" => intermediate_rep.data_forwarding.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "n3DlForwardingTnlList" => return std::result::Result::Err("Parsing a container in this style is not supported in SmContextUpdatedData".to_string()),
                    "n3UlForwardingTnlList" => return std::result::Result::Err("Parsing a container in this style is not supported in SmContextUpdatedData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "n9UlForwardingTunnel" => intermediate_rep.n9_ul_forwarding_tunnel.push(<models::TunnelInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cause" => intermediate_rep.cause.push(<models::Cause as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "maAcceptedInd" => intermediate_rep.ma_accepted_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "supportedFeatures" => intermediate_rep.supported_features.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "forwardingFTeid" => return std::result::Result::Err("Parsing binary data in this style is not supported in SmContextUpdatedData".to_string()),
                    "forwardingBearerContexts" => return std::result::Result::Err("Parsing a container in this style is not supported in SmContextUpdatedData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "selectedSmfId" => intermediate_rep.selected_smf_id.push(<uuid::Uuid as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "selectedOldSmfId" => intermediate_rep.selected_old_smf_id.push(<uuid::Uuid as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "interPlmnApiRoot" => intermediate_rep.inter_plmn_api_root.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "anchorSmfFeatures" => intermediate_rep.anchor_smf_features.push(<models::AnchorSmfFeatures as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SmContextUpdatedData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SmContextUpdatedData {
            up_cnx_state: intermediate_rep.up_cnx_state.into_iter().next(),
            ho_state: intermediate_rep.ho_state.into_iter().next(),
            release_ebi_list: intermediate_rep.release_ebi_list.into_iter().next(),
            allocated_ebi_list: intermediate_rep.allocated_ebi_list.into_iter().next(),
            modified_ebi_list: intermediate_rep.modified_ebi_list.into_iter().next(),
            n1_sm_msg: intermediate_rep.n1_sm_msg.into_iter().next(),
            n2_sm_info: intermediate_rep.n2_sm_info.into_iter().next(),
            n2_sm_info_type: intermediate_rep.n2_sm_info_type.into_iter().next(),
            eps_bearer_setup: intermediate_rep.eps_bearer_setup.into_iter().next(),
            data_forwarding: intermediate_rep.data_forwarding.into_iter().next(),
            n3_dl_forwarding_tnl_list: intermediate_rep
                .n3_dl_forwarding_tnl_list
                .into_iter()
                .next(),
            n3_ul_forwarding_tnl_list: intermediate_rep
                .n3_ul_forwarding_tnl_list
                .into_iter()
                .next(),
            n9_ul_forwarding_tunnel: intermediate_rep.n9_ul_forwarding_tunnel.into_iter().next(),
            cause: intermediate_rep.cause.into_iter().next(),
            ma_accepted_ind: intermediate_rep.ma_accepted_ind.into_iter().next(),
            supported_features: intermediate_rep.supported_features.into_iter().next(),
            forwarding_f_teid: intermediate_rep.forwarding_f_teid.into_iter().next(),
            forwarding_bearer_contexts: intermediate_rep
                .forwarding_bearer_contexts
                .into_iter()
                .next(),
            selected_smf_id: intermediate_rep.selected_smf_id.into_iter().next(),
            selected_old_smf_id: intermediate_rep.selected_old_smf_id.into_iter().next(),
            inter_plmn_api_root: intermediate_rep.inter_plmn_api_root.into_iter().next(),
            anchor_smf_features: intermediate_rep.anchor_smf_features.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SmContextUpdatedData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SmContextUpdatedData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SmContextUpdatedData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SmContextUpdatedData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SmContextUpdatedData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SmContextUpdatedData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SmContextUpdatedData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// It indicates theSmall Data Rate Control Status
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SmallDataRateStatus {
    /// When present, it shall contain the number of packets the UE is allowed to send uplink in the given time unit for the given PDU session (see clause 5.31.14.3 of 3GPP TS 23.501.
    #[serde(rename = "remainPacketsUl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remain_packets_ul: Option<u32>,

    /// When present it shall contain the number of packets the AF is allowed to send downlink in the given time unit for the given PDU session (see clause 5.31.14.3 of 3GPP TS 23.501.
    #[serde(rename = "remainPacketsDl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remain_packets_dl: Option<u32>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "validityTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub validity_time: Option<chrono::DateTime<chrono::Utc>>,

    /// When present, it shall indicate number of additional exception reports the UE is allowed to send uplink in the given time  unit for  the given PDU session (see clause 5.31.14.3 of 3GPP TS 23.501.
    #[serde(rename = "remainExReportsUl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remain_ex_reports_ul: Option<u32>,

    /// When present, it shall indicate number of additional exception reports the AF is allowed to send downlink  in the given time unit for the given PDU session (see clause 5.31.14.3 in 3GPP TS 23.501
    #[serde(rename = "remainExReportsDl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remain_ex_reports_dl: Option<u32>,
}

impl SmallDataRateStatus {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SmallDataRateStatus {
        SmallDataRateStatus {
            remain_packets_ul: None,
            remain_packets_dl: None,
            validity_time: None,
            remain_ex_reports_ul: None,
            remain_ex_reports_dl: None,
        }
    }
}

/// Converts the SmallDataRateStatus value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SmallDataRateStatus {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.remain_packets_ul.as_ref().map(|remain_packets_ul| {
                vec!["remainPacketsUl".to_string(), remain_packets_ul.to_string()].join(",")
            }),
            self.remain_packets_dl.as_ref().map(|remain_packets_dl| {
                vec!["remainPacketsDl".to_string(), remain_packets_dl.to_string()].join(",")
            }),
            // Skipping validityTime in query parameter serialization
            self.remain_ex_reports_ul
                .as_ref()
                .map(|remain_ex_reports_ul| {
                    vec![
                        "remainExReportsUl".to_string(),
                        remain_ex_reports_ul.to_string(),
                    ]
                    .join(",")
                }),
            self.remain_ex_reports_dl
                .as_ref()
                .map(|remain_ex_reports_dl| {
                    vec![
                        "remainExReportsDl".to_string(),
                        remain_ex_reports_dl.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SmallDataRateStatus value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SmallDataRateStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub remain_packets_ul: Vec<u32>,
            pub remain_packets_dl: Vec<u32>,
            pub validity_time: Vec<chrono::DateTime<chrono::Utc>>,
            pub remain_ex_reports_ul: Vec<u32>,
            pub remain_ex_reports_dl: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SmallDataRateStatus".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "remainPacketsUl" => intermediate_rep.remain_packets_ul.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "remainPacketsDl" => intermediate_rep.remain_packets_dl.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "validityTime" => intermediate_rep.validity_time.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "remainExReportsUl" => intermediate_rep.remain_ex_reports_ul.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "remainExReportsDl" => intermediate_rep.remain_ex_reports_dl.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SmallDataRateStatus".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SmallDataRateStatus {
            remain_packets_ul: intermediate_rep.remain_packets_ul.into_iter().next(),
            remain_packets_dl: intermediate_rep.remain_packets_dl.into_iter().next(),
            validity_time: intermediate_rep.validity_time.into_iter().next(),
            remain_ex_reports_ul: intermediate_rep.remain_ex_reports_ul.into_iter().next(),
            remain_ex_reports_dl: intermediate_rep.remain_ex_reports_dl.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SmallDataRateStatus> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SmallDataRateStatus>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SmallDataRateStatus>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SmallDataRateStatus - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SmallDataRateStatus>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SmallDataRateStatus as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SmallDataRateStatus - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Smf Selection Type. Possible values are   - CURRENT_PDU_SESSION   - NEXT_PDU_SESSION
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SmfSelectionType {}

impl SmfSelectionType {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SmfSelectionType {
        SmfSelectionType {}
    }
}

/// Converts the SmfSelectionType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SmfSelectionType {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SmfSelectionType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SmfSelectionType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SmfSelectionType".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SmfSelectionType".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SmfSelectionType {})
    }
}

// Methods for converting between header::IntoHeaderValue<SmfSelectionType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SmfSelectionType>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SmfSelectionType>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SmfSelectionType - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SmfSelectionType>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SmfSelectionType as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SmfSelectionType - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum SmfSelectionTypeAnyOf {
    #[serde(rename = "CURRENT_PDU_SESSION")]
    CurrentPduSession,
    #[serde(rename = "NEXT_PDU_SESSION")]
    NextPduSession,
}

impl std::fmt::Display for SmfSelectionTypeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            SmfSelectionTypeAnyOf::CurrentPduSession => write!(f, "CURRENT_PDU_SESSION"),
            SmfSelectionTypeAnyOf::NextPduSession => write!(f, "NEXT_PDU_SESSION"),
        }
    }
}

impl std::str::FromStr for SmfSelectionTypeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "CURRENT_PDU_SESSION" => {
                std::result::Result::Ok(SmfSelectionTypeAnyOf::CurrentPduSession)
            }
            "NEXT_PDU_SESSION" => std::result::Result::Ok(SmfSelectionTypeAnyOf::NextPduSession),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// When Snssai needs to be converted to string (e.g. when used in maps as key), the string shall be composed of one to three digits \"sst\" optionally followed by \"-\" and 6 hexadecimal digits \"sd\".
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Snssai {
    /// Unsigned integer, within the range 0 to 255, representing the Slice/Service Type.  It indicates the expected Network Slice behaviour in terms of features and services. Values 0 to 127 correspond to the standardized SST range. Values 128 to 255 correspond  to the Operator-specific range. See clause 28.4.2 of 3GPP TS 23.003. Standardized values are defined in clause 5.15.2.2 of 3GPP TS 23.501.
    #[serde(rename = "sst")]
    pub sst: u8,

    /// 3-octet string, representing the Slice Differentiator, in hexadecimal representation. Each character in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character representing the 4 most significant bits of the SD shall appear first in the string, and the character representing the 4 least significant bit of the SD shall appear last in the string. This is an optional parameter that complements the Slice/Service type(s) to allow to  differentiate amongst multiple Network Slices of the same Slice/Service type. This IE shall be absent if no SD value is associated with the SST.
    #[serde(rename = "sd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sd: Option<String>,
}

impl Snssai {
    #[allow(clippy::new_without_default)]
    pub fn new(sst: u8) -> Snssai {
        Snssai { sst, sd: None }
    }
}

/// Converts the Snssai value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Snssai {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("sst".to_string()),
            Some(self.sst.to_string()),
            self.sd
                .as_ref()
                .map(|sd| vec!["sd".to_string(), sd.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Snssai value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Snssai {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub sst: Vec<u8>,
            pub sd: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Snssai".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "sst" => intermediate_rep
                        .sst
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sd" => intermediate_rep.sd.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Snssai".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Snssai {
            sst: intermediate_rep
                .sst
                .into_iter()
                .next()
                .ok_or_else(|| "sst missing in Snssai".to_string())?,
            sd: intermediate_rep.sd.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Snssai> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Snssai>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Snssai>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Snssai - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Snssai> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <Snssai as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into Snssai - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Possible values are: - STATIONARY: Identifies the UE is stationary - MOBILE: Identifies the UE is mobile
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct StationaryIndication {}

impl StationaryIndication {
    #[allow(clippy::new_without_default)]
    pub fn new() -> StationaryIndication {
        StationaryIndication {}
    }
}

/// Converts the StationaryIndication value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for StationaryIndication {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a StationaryIndication value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for StationaryIndication {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing StationaryIndication".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing StationaryIndication".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(StationaryIndication {})
    }
}

// Methods for converting between header::IntoHeaderValue<StationaryIndication> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<StationaryIndication>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<StationaryIndication>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for StationaryIndication - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<StationaryIndication>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <StationaryIndication as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into StationaryIndication - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum StationaryIndicationAnyOf {
    #[serde(rename = "STATIONARY")]
    Stationary,
    #[serde(rename = "MOBILE")]
    Mobile,
}

impl std::fmt::Display for StationaryIndicationAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            StationaryIndicationAnyOf::Stationary => write!(f, "STATIONARY"),
            StationaryIndicationAnyOf::Mobile => write!(f, "MOBILE"),
        }
    }
}

impl std::str::FromStr for StationaryIndicationAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "STATIONARY" => std::result::Result::Ok(StationaryIndicationAnyOf::Stationary),
            "MOBILE" => std::result::Result::Ok(StationaryIndicationAnyOf::Mobile),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Status of SM context or of PDU session
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct StatusInfo {
    #[serde(rename = "resourceStatus")]
    pub resource_status: models::ResourceStatus,

    #[serde(rename = "cause")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cause: Option<models::Cause>,

    #[serde(rename = "cnAssistedRanPara")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cn_assisted_ran_para: Option<models::CnAssistedRanPara>,

    #[serde(rename = "anType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub an_type: Option<models::AccessType>,
}

impl StatusInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(resource_status: models::ResourceStatus) -> StatusInfo {
        StatusInfo {
            resource_status,
            cause: None,
            cn_assisted_ran_para: None,
            an_type: None,
        }
    }
}

/// Converts the StatusInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for StatusInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping resourceStatus in query parameter serialization

            // Skipping cause in query parameter serialization

            // Skipping cnAssistedRanPara in query parameter serialization

            // Skipping anType in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a StatusInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for StatusInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub resource_status: Vec<models::ResourceStatus>,
            pub cause: Vec<models::Cause>,
            pub cn_assisted_ran_para: Vec<models::CnAssistedRanPara>,
            pub an_type: Vec<models::AccessType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing StatusInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "resourceStatus" => intermediate_rep.resource_status.push(
                        <models::ResourceStatus as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "cause" => intermediate_rep.cause.push(
                        <models::Cause as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "cnAssistedRanPara" => intermediate_rep.cn_assisted_ran_para.push(
                        <models::CnAssistedRanPara as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "anType" => intermediate_rep.an_type.push(
                        <models::AccessType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing StatusInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(StatusInfo {
            resource_status: intermediate_rep
                .resource_status
                .into_iter()
                .next()
                .ok_or_else(|| "resourceStatus missing in StatusInfo".to_string())?,
            cause: intermediate_rep.cause.into_iter().next(),
            cn_assisted_ran_para: intermediate_rep.cn_assisted_ran_para.into_iter().next(),
            an_type: intermediate_rep.an_type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<StatusInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<StatusInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<StatusInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for StatusInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<StatusInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <StatusInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into StatusInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Data within Notify Status Request
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct StatusNotification {
    #[serde(rename = "statusInfo")]
    pub status_info: models::StatusInfo,

    #[serde(rename = "smallDataRateStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub small_data_rate_status: Option<models::SmallDataRateStatus>,

    #[serde(rename = "apnRateStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub apn_rate_status: Option<models::ApnRateStatus>,

    #[serde(rename = "targetDnaiInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_dnai_info: Option<models::TargetDnaiInfo>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "oldPduSessionRef")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub old_pdu_session_ref: Option<String>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "newSmfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub new_smf_id: Option<uuid::Uuid>,

    #[serde(rename = "epsPdnCnxInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub eps_pdn_cnx_info: Option<models::EpsPdnCnxInfo>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "interPlmnApiRoot")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub inter_plmn_api_root: Option<String>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "intraPlmnApiRoot")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub intra_plmn_api_root: Option<String>,
}

impl StatusNotification {
    #[allow(clippy::new_without_default)]
    pub fn new(status_info: models::StatusInfo) -> StatusNotification {
        StatusNotification {
            status_info,
            small_data_rate_status: None,
            apn_rate_status: None,
            target_dnai_info: None,
            old_pdu_session_ref: None,
            new_smf_id: None,
            eps_pdn_cnx_info: None,
            inter_plmn_api_root: None,
            intra_plmn_api_root: None,
        }
    }
}

/// Converts the StatusNotification value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for StatusNotification {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping statusInfo in query parameter serialization

            // Skipping smallDataRateStatus in query parameter serialization

            // Skipping apnRateStatus in query parameter serialization

            // Skipping targetDnaiInfo in query parameter serialization
            self.old_pdu_session_ref
                .as_ref()
                .map(|old_pdu_session_ref| {
                    vec![
                        "oldPduSessionRef".to_string(),
                        old_pdu_session_ref.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping newSmfId in query parameter serialization

            // Skipping epsPdnCnxInfo in query parameter serialization
            self.inter_plmn_api_root
                .as_ref()
                .map(|inter_plmn_api_root| {
                    vec![
                        "interPlmnApiRoot".to_string(),
                        inter_plmn_api_root.to_string(),
                    ]
                    .join(",")
                }),
            self.intra_plmn_api_root
                .as_ref()
                .map(|intra_plmn_api_root| {
                    vec![
                        "intraPlmnApiRoot".to_string(),
                        intra_plmn_api_root.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a StatusNotification value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for StatusNotification {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status_info: Vec<models::StatusInfo>,
            pub small_data_rate_status: Vec<models::SmallDataRateStatus>,
            pub apn_rate_status: Vec<models::ApnRateStatus>,
            pub target_dnai_info: Vec<models::TargetDnaiInfo>,
            pub old_pdu_session_ref: Vec<String>,
            pub new_smf_id: Vec<uuid::Uuid>,
            pub eps_pdn_cnx_info: Vec<models::EpsPdnCnxInfo>,
            pub inter_plmn_api_root: Vec<String>,
            pub intra_plmn_api_root: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing StatusNotification".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "statusInfo" => intermediate_rep.status_info.push(
                        <models::StatusInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "smallDataRateStatus" => intermediate_rep.small_data_rate_status.push(
                        <models::SmallDataRateStatus as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "apnRateStatus" => intermediate_rep.apn_rate_status.push(
                        <models::ApnRateStatus as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "targetDnaiInfo" => intermediate_rep.target_dnai_info.push(
                        <models::TargetDnaiInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "oldPduSessionRef" => intermediate_rep.old_pdu_session_ref.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "newSmfId" => intermediate_rep.new_smf_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "epsPdnCnxInfo" => intermediate_rep.eps_pdn_cnx_info.push(
                        <models::EpsPdnCnxInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "interPlmnApiRoot" => intermediate_rep.inter_plmn_api_root.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "intraPlmnApiRoot" => intermediate_rep.intra_plmn_api_root.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing StatusNotification".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(StatusNotification {
            status_info: intermediate_rep
                .status_info
                .into_iter()
                .next()
                .ok_or_else(|| "statusInfo missing in StatusNotification".to_string())?,
            small_data_rate_status: intermediate_rep.small_data_rate_status.into_iter().next(),
            apn_rate_status: intermediate_rep.apn_rate_status.into_iter().next(),
            target_dnai_info: intermediate_rep.target_dnai_info.into_iter().next(),
            old_pdu_session_ref: intermediate_rep.old_pdu_session_ref.into_iter().next(),
            new_smf_id: intermediate_rep.new_smf_id.into_iter().next(),
            eps_pdn_cnx_info: intermediate_rep.eps_pdn_cnx_info.into_iter().next(),
            inter_plmn_api_root: intermediate_rep.inter_plmn_api_root.into_iter().next(),
            intra_plmn_api_root: intermediate_rep.intra_plmn_api_root.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<StatusNotification> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<StatusNotification>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<StatusNotification>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for StatusNotification - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<StatusNotification>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <StatusNotification as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into StatusNotification - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// String identifying a Supi that shall contain either an IMSI, a network specific identifier, a Global Cable Identifier (GCI) or a Global Line Identifier (GLI) as specified in clause  2.2A of 3GPP TS 23.003. It shall be formatted as follows  - for an IMSI \"imsi-<imsi>\", where <imsi> shall be formatted according to clause 2.2    of 3GPP TS 23.003 that describes an IMSI.  - for a network specific identifier \"nai-<nai>, where <nai> shall be formatted    according to clause 28.7.2 of 3GPP TS 23.003 that describes an NAI.  - for a GCI \"gci-<gci>\", where <gci> shall be formatted according to clause 28.15.2    of 3GPP TS 23.003.  - for a GLI \"gli-<gli>\", where <gli> shall be formatted according to clause 28.16.2 of    3GPP TS 23.003.To enable that the value is used as part of an URI, the string shall    only contain characters allowed according to the \"lower-with-hyphen\" naming convention    defined in 3GPP TS 29.501.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Supi(String);

impl std::convert::From<String> for Supi {
    fn from(x: String) -> Self {
        Supi(x)
    }
}

impl std::string::ToString for Supi {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Supi {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Supi(x.to_string()))
    }
}

impl std::convert::From<Supi> for String {
    fn from(x: Supi) -> Self {
        x.0
    }
}

impl std::ops::Deref for Supi {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Supi {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  table 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SupportedFeatures(String);

impl std::convert::From<String> for SupportedFeatures {
    fn from(x: String) -> Self {
        SupportedFeatures(x)
    }
}

impl std::string::ToString for SupportedFeatures {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for SupportedFeatures {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(SupportedFeatures(x.to_string()))
    }
}

impl std::convert::From<SupportedFeatures> for String {
    fn from(x: SupportedFeatures) -> Self {
        x.0
    }
}

impl std::ops::Deref for SupportedFeatures {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for SupportedFeatures {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// 2 or 3-octet string identifying a tracking area code as specified in clause 9.3.3.10  of 3GPP TS 38.413, in hexadecimal representation. Each character in the string shall  take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character representing the 4 most significant bits of the TAC shall  appear first in the string, and the character representing the 4 least significant bit  of the TAC shall appear last in the string.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Tac(String);

impl std::convert::From<String> for Tac {
    fn from(x: String) -> Self {
        Tac(x)
    }
}

impl std::string::ToString for Tac {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Tac {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Tac(x.to_string()))
    }
}

impl std::convert::From<Tac> for String {
    fn from(x: Tac) -> Self {
        x.0
    }
}

impl std::ops::Deref for Tac {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Tac {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Contains the tracking area identity as described in 3GPP 23.003
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Tai {
    #[serde(rename = "plmnId")]
    pub plmn_id: models::PlmnId,

    /// 2 or 3-octet string identifying a tracking area code as specified in clause 9.3.3.10  of 3GPP TS 38.413, in hexadecimal representation. Each character in the string shall  take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character representing the 4 most significant bits of the TAC shall  appear first in the string, and the character representing the 4 least significant bit  of the TAC shall appear last in the string.
    #[serde(rename = "tac")]
    pub tac: String,

    /// This represents the Network Identifier, which together with a PLMN ID is used to identify an SNPN (see 3GPP TS 23.003 and 3GPP TS 23.501 clause 5.30.2.1).
    #[serde(rename = "nid")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nid: Option<String>,
}

impl Tai {
    #[allow(clippy::new_without_default)]
    pub fn new(plmn_id: models::PlmnId, tac: String) -> Tai {
        Tai {
            plmn_id,
            tac,
            nid: None,
        }
    }
}

/// Converts the Tai value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Tai {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping plmnId in query parameter serialization
            Some("tac".to_string()),
            Some(self.tac.to_string()),
            self.nid
                .as_ref()
                .map(|nid| vec!["nid".to_string(), nid.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Tai value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Tai {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub plmn_id: Vec<models::PlmnId>,
            pub tac: Vec<String>,
            pub nid: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err("Missing value while parsing Tai".to_string())
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "plmnId" => intermediate_rep.plmn_id.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "tac" => intermediate_rep.tac.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nid" => intermediate_rep.nid.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Tai".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Tai {
            plmn_id: intermediate_rep
                .plmn_id
                .into_iter()
                .next()
                .ok_or_else(|| "plmnId missing in Tai".to_string())?,
            tac: intermediate_rep
                .tac
                .into_iter()
                .next()
                .ok_or_else(|| "tac missing in Tai".to_string())?,
            nid: intermediate_rep.nid.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Tai> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Tai>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Tai>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Tai - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Tai> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Tai as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Tai - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Target DNAI Information
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TargetDnaiInfo {
    /// DNAI (Data network access identifier), see clause 5.6.7 of 3GPP TS 23.501.
    #[serde(rename = "targetDnai")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_dnai: Option<String>,

    #[serde(rename = "smfSelectionType")]
    pub smf_selection_type: models::SmfSelectionType,
}

impl TargetDnaiInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(smf_selection_type: models::SmfSelectionType) -> TargetDnaiInfo {
        TargetDnaiInfo {
            target_dnai: None,
            smf_selection_type,
        }
    }
}

/// Converts the TargetDnaiInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TargetDnaiInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.target_dnai.as_ref().map(|target_dnai| {
                vec!["targetDnai".to_string(), target_dnai.to_string()].join(",")
            }),
            // Skipping smfSelectionType in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TargetDnaiInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TargetDnaiInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub target_dnai: Vec<String>,
            pub smf_selection_type: Vec<models::SmfSelectionType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TargetDnaiInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "targetDnai" => intermediate_rep.target_dnai.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "smfSelectionType" => intermediate_rep.smf_selection_type.push(
                        <models::SmfSelectionType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing TargetDnaiInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TargetDnaiInfo {
            target_dnai: intermediate_rep.target_dnai.into_iter().next(),
            smf_selection_type: intermediate_rep
                .smf_selection_type
                .into_iter()
                .next()
                .ok_or_else(|| "smfSelectionType missing in TargetDnaiInfo".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TargetDnaiInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TargetDnaiInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TargetDnaiInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TargetDnaiInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TargetDnaiInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TargetDnaiInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TargetDnaiInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// GTP Tunnel Endpoint Identifier
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Teid(String);

impl std::convert::From<String> for Teid {
    fn from(x: String) -> Self {
        Teid(x)
    }
}

impl std::string::ToString for Teid {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Teid {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Teid(x.to_string()))
    }
}

impl std::convert::From<Teid> for String {
    fn from(x: Teid) -> Self {
        x.0
    }
}

impl std::ops::Deref for Teid {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Teid {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// String with format partial-time or full-time as defined in clause 5.6 of IETF RFC 3339. Examples, 20:15:00, 20:15:00-08:00 (for 8 hours behind UTC).
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TimeOfDay(String);

impl std::convert::From<String> for TimeOfDay {
    fn from(x: String) -> Self {
        TimeOfDay(x)
    }
}

impl std::string::ToString for TimeOfDay {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for TimeOfDay {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(TimeOfDay(x.to_string()))
    }
}

impl std::convert::From<TimeOfDay> for String {
    fn from(x: TimeOfDay) -> Self {
        x.0
    }
}

impl std::ops::Deref for TimeOfDay {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for TimeOfDay {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// String with format \"time-numoffset\" optionally appended by \"daylightSavingTime\", where  - \"time-numoffset\" shall represent the time zone adjusted for daylight saving time and be    encoded as time-numoffset as defined in clause 5.6 of IETF RFC 3339;  - \"daylightSavingTime\" shall represent the adjustment that has been made and shall be    encoded as \"+1\" or \"+2\" for a +1 or +2 hours adjustment.   The example is for 8 hours behind UTC, +1 hour adjustment for Daylight Saving Time.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TimeZone(String);

impl std::convert::From<String> for TimeZone {
    fn from(x: String) -> Self {
        TimeZone(x)
    }
}

impl std::string::ToString for TimeZone {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for TimeZone {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(TimeZone(x.to_string()))
    }
}

impl std::convert::From<TimeZone> for String {
    fn from(x: TimeZone) -> Self {
        x.0
    }
}

impl std::ops::Deref for TimeZone {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for TimeZone {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Contain the TNAP Identifier see clause5.6.2 of 3GPP TS 23.501.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TnapId {
    /// This IE shall be present if the UE is accessing the 5GC via a trusted WLAN access network.When present, it shall contain the SSID of the access point to which the UE is attached, that is received over NGAP,  see IEEE Std 802.11-2012.
    #[serde(rename = "ssId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ss_id: Option<String>,

    /// When present, it shall contain the BSSID of the access point to which the UE is attached, that is received over NGAP, see IEEE Std 802.11-2012.
    #[serde(rename = "bssId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bss_id: Option<String>,

    /// string with format 'bytes' as defined in OpenAPI
    #[serde(rename = "civicAddress")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub civic_address: Option<swagger::ByteArray>,
}

impl TnapId {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TnapId {
        TnapId {
            ss_id: None,
            bss_id: None,
            civic_address: None,
        }
    }
}

/// Converts the TnapId value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TnapId {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.ss_id
                .as_ref()
                .map(|ss_id| vec!["ssId".to_string(), ss_id.to_string()].join(",")),
            self.bss_id
                .as_ref()
                .map(|bss_id| vec!["bssId".to_string(), bss_id.to_string()].join(",")),
            // Skipping civicAddress in query parameter serialization
            // Skipping civicAddress in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TnapId value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TnapId {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ss_id: Vec<String>,
            pub bss_id: Vec<String>,
            pub civic_address: Vec<swagger::ByteArray>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TnapId".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ssId" => intermediate_rep.ss_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "bssId" => intermediate_rep.bss_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "civicAddress" => {
                        return std::result::Result::Err(
                            "Parsing binary data in this style is not supported in TnapId"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing TnapId".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TnapId {
            ss_id: intermediate_rep.ss_id.into_iter().next(),
            bss_id: intermediate_rep.bss_id.into_iter().next(),
            civic_address: intermediate_rep.civic_address.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TnapId> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TnapId>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TnapId>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TnapId - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TnapId> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TnapId as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TnapId - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// This represents the identifier of the TNGF ID as specified in clause 9.3.1.161 of  3GPP TS 38.413  in hexadecimal representation. Each character in the string shall take a value of \"0\" to \"9\", \"a\"  to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character representing the  4 most significant bits of the TNGF ID shall appear first in the string, and the character  representing the 4 least significant bit of the TNGF ID shall appear last in the string.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TngfId(String);

impl std::convert::From<String> for TngfId {
    fn from(x: String) -> Self {
        TngfId(x)
    }
}

impl std::string::ToString for TngfId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for TngfId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(TngfId(x.to_string()))
    }
}

impl std::convert::From<TngfId> for String {
    fn from(x: TngfId) -> Self {
        x.0
    }
}

impl std::ops::Deref for TngfId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for TngfId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Infomation of the TNGF endpoints
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TngfInfo {
    #[serde(rename = "ipv4EndpointAddresses")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv4_endpoint_addresses: Option<Vec<models::Ipv4Addr>>,

    #[serde(rename = "ipv6EndpointAddresses")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_endpoint_addresses: Option<Vec<models::Ipv6Addr>>,

    /// Fully Qualified Domain Name
    #[serde(rename = "endpointFqdn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub endpoint_fqdn: Option<String>,
}

impl TngfInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TngfInfo {
        TngfInfo {
            ipv4_endpoint_addresses: None,
            ipv6_endpoint_addresses: None,
            endpoint_fqdn: None,
        }
    }
}

/// Converts the TngfInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TngfInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.ipv4_endpoint_addresses
                .as_ref()
                .map(|ipv4_endpoint_addresses| {
                    vec![
                        "ipv4EndpointAddresses".to_string(),
                        ipv4_endpoint_addresses
                            .iter()
                            .map(|x| x.to_string())
                            .collect::<Vec<_>>()
                            .join(","),
                    ]
                    .join(",")
                }),
            // Skipping ipv6EndpointAddresses in query parameter serialization
            self.endpoint_fqdn.as_ref().map(|endpoint_fqdn| {
                vec!["endpointFqdn".to_string(), endpoint_fqdn.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TngfInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TngfInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ipv4_endpoint_addresses: Vec<Vec<models::Ipv4Addr>>,
            pub ipv6_endpoint_addresses: Vec<Vec<models::Ipv6Addr>>,
            pub endpoint_fqdn: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TngfInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "ipv4EndpointAddresses" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in TngfInfo"
                                .to_string(),
                        )
                    }
                    "ipv6EndpointAddresses" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in TngfInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "endpointFqdn" => intermediate_rep.endpoint_fqdn.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing TngfInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TngfInfo {
            ipv4_endpoint_addresses: intermediate_rep.ipv4_endpoint_addresses.into_iter().next(),
            ipv6_endpoint_addresses: intermediate_rep.ipv6_endpoint_addresses.into_iter().next(),
            endpoint_fqdn: intermediate_rep.endpoint_fqdn.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TngfInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TngfInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TngfInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TngfInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TngfInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TngfInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TngfInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// contains Trace control and configuration parameters.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TraceData {
    /// Trace Reference (see 3GPP TS 32.422).It shall be encoded as the concatenation of MCC, MNC and Trace ID as follows: 'MCC'<MNC'-'Trace ID'The Trace ID shall be encoded as a 3 octet string in hexadecimal representation. Each character in the Trace ID string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character representing the 4 most significant bits of the Trace ID shall appear first  in the string, and the character representing the 4 least significant bit of the Trace ID shall appear last in the string.
    #[serde(rename = "traceRef")]
    pub trace_ref: String,

    #[serde(rename = "traceDepth")]
    pub trace_depth: models::TraceDepth,

    /// List of NE Types (see 3GPP TS 32.422).It shall be encoded as an octet string in hexadecimal representation. Each character in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character representing the 4 most significant bits shall appear first in the string, and the character representing the 4 least significant bit shall appear last in the string.Octets shall be coded according to 3GPP TS 32.422.
    #[serde(rename = "neTypeList")]
    pub ne_type_list: String,

    /// Triggering events (see 3GPP TS 32.422).It shall be encoded as an octet string in hexadecimal representation. Each character in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character representing the 4 most significant bits shall appear first in the string, and the character representing the 4 least significant bit shall appear last in the string. Octets shall be coded according to 3GPP TS 32.422.
    #[serde(rename = "eventList")]
    pub event_list: String,

    /// String identifying a IPv4 address formatted in the 'dotted decimal' notation as defined in RFC 1166.
    #[serde(rename = "collectionEntityIpv4Addr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub collection_entity_ipv4_addr: Option<String>,

    #[serde(rename = "collectionEntityIpv6Addr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub collection_entity_ipv6_addr: Option<models::Ipv6Addr>,

    /// List of Interfaces (see 3GPP TS 32.422).It shall be encoded as an octet string in hexadecimal representation. Each character in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character representing the 4 most significant bits shall appear first in the string, and the character representing the  4 least significant bit shall appear last in the string. Octets shall be coded according to 3GPP TS 32.422. If this attribute is not present, all the interfaces applicable to the list of NE types indicated in the neTypeList attribute should be traced.
    #[serde(rename = "interfaceList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub interface_list: Option<String>,
}

impl TraceData {
    #[allow(clippy::new_without_default)]
    pub fn new(
        trace_ref: String,
        trace_depth: models::TraceDepth,
        ne_type_list: String,
        event_list: String,
    ) -> TraceData {
        TraceData {
            trace_ref,
            trace_depth,
            ne_type_list,
            event_list,
            collection_entity_ipv4_addr: None,
            collection_entity_ipv6_addr: None,
            interface_list: None,
        }
    }
}

/// Converts the TraceData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TraceData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("traceRef".to_string()),
            Some(self.trace_ref.to_string()),
            // Skipping traceDepth in query parameter serialization
            Some("neTypeList".to_string()),
            Some(self.ne_type_list.to_string()),
            Some("eventList".to_string()),
            Some(self.event_list.to_string()),
            self.collection_entity_ipv4_addr
                .as_ref()
                .map(|collection_entity_ipv4_addr| {
                    vec![
                        "collectionEntityIpv4Addr".to_string(),
                        collection_entity_ipv4_addr.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping collectionEntityIpv6Addr in query parameter serialization
            self.interface_list.as_ref().map(|interface_list| {
                vec!["interfaceList".to_string(), interface_list.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TraceData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TraceData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub trace_ref: Vec<String>,
            pub trace_depth: Vec<models::TraceDepth>,
            pub ne_type_list: Vec<String>,
            pub event_list: Vec<String>,
            pub collection_entity_ipv4_addr: Vec<String>,
            pub collection_entity_ipv6_addr: Vec<models::Ipv6Addr>,
            pub interface_list: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TraceData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "traceRef" => intermediate_rep.trace_ref.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "traceDepth" => intermediate_rep.trace_depth.push(
                        <models::TraceDepth as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "neTypeList" => intermediate_rep.ne_type_list.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "eventList" => intermediate_rep.event_list.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "collectionEntityIpv4Addr" => {
                        intermediate_rep.collection_entity_ipv4_addr.push(
                            <String as std::str::FromStr>::from_str(val)
                                .map_err(|x| x.to_string())?,
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "collectionEntityIpv6Addr" => {
                        intermediate_rep.collection_entity_ipv6_addr.push(
                            <models::Ipv6Addr as std::str::FromStr>::from_str(val)
                                .map_err(|x| x.to_string())?,
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "interfaceList" => intermediate_rep.interface_list.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing TraceData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TraceData {
            trace_ref: intermediate_rep
                .trace_ref
                .into_iter()
                .next()
                .ok_or_else(|| "traceRef missing in TraceData".to_string())?,
            trace_depth: intermediate_rep
                .trace_depth
                .into_iter()
                .next()
                .ok_or_else(|| "traceDepth missing in TraceData".to_string())?,
            ne_type_list: intermediate_rep
                .ne_type_list
                .into_iter()
                .next()
                .ok_or_else(|| "neTypeList missing in TraceData".to_string())?,
            event_list: intermediate_rep
                .event_list
                .into_iter()
                .next()
                .ok_or_else(|| "eventList missing in TraceData".to_string())?,
            collection_entity_ipv4_addr: intermediate_rep
                .collection_entity_ipv4_addr
                .into_iter()
                .next(),
            collection_entity_ipv6_addr: intermediate_rep
                .collection_entity_ipv6_addr
                .into_iter()
                .next(),
            interface_list: intermediate_rep.interface_list.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TraceData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TraceData>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TraceData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TraceData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TraceData> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TraceData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TraceData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// The enumeration TraceDepth defines how detailed information should be recorded in the trace. See 3GPP TS 32.422 for further description of the values. It shall comply with the provisions defined in table 5.6.3.1-1
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TraceDepth {}

impl TraceDepth {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TraceDepth {
        TraceDepth {}
    }
}

/// Converts the TraceDepth value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TraceDepth {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TraceDepth value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TraceDepth {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TraceDepth".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing TraceDepth".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TraceDepth {})
    }
}

// Methods for converting between header::IntoHeaderValue<TraceDepth> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TraceDepth>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TraceDepth>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TraceDepth - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TraceDepth> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TraceDepth as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TraceDepth - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum TraceDepthAnyOf {
    #[serde(rename = "MINIMUM")]
    Minimum,
    #[serde(rename = "MEDIUM")]
    Medium,
    #[serde(rename = "MAXIMUM")]
    Maximum,
    #[serde(rename = "MINIMUM_WO_VENDOR_EXTENSION")]
    MinimumWoVendorExtension,
    #[serde(rename = "MEDIUM_WO_VENDOR_EXTENSION")]
    MediumWoVendorExtension,
    #[serde(rename = "MAXIMUM_WO_VENDOR_EXTENSION")]
    MaximumWoVendorExtension,
}

impl std::fmt::Display for TraceDepthAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            TraceDepthAnyOf::Minimum => write!(f, "MINIMUM"),
            TraceDepthAnyOf::Medium => write!(f, "MEDIUM"),
            TraceDepthAnyOf::Maximum => write!(f, "MAXIMUM"),
            TraceDepthAnyOf::MinimumWoVendorExtension => write!(f, "MINIMUM_WO_VENDOR_EXTENSION"),
            TraceDepthAnyOf::MediumWoVendorExtension => write!(f, "MEDIUM_WO_VENDOR_EXTENSION"),
            TraceDepthAnyOf::MaximumWoVendorExtension => write!(f, "MAXIMUM_WO_VENDOR_EXTENSION"),
        }
    }
}

impl std::str::FromStr for TraceDepthAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "MINIMUM" => std::result::Result::Ok(TraceDepthAnyOf::Minimum),
            "MEDIUM" => std::result::Result::Ok(TraceDepthAnyOf::Medium),
            "MAXIMUM" => std::result::Result::Ok(TraceDepthAnyOf::Maximum),
            "MINIMUM_WO_VENDOR_EXTENSION" => {
                std::result::Result::Ok(TraceDepthAnyOf::MinimumWoVendorExtension)
            }
            "MEDIUM_WO_VENDOR_EXTENSION" => {
                std::result::Result::Ok(TraceDepthAnyOf::MediumWoVendorExtension)
            }
            "MAXIMUM_WO_VENDOR_EXTENSION" => {
                std::result::Result::Ok(TraceDepthAnyOf::MaximumWoVendorExtension)
            }
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Possible values are: - SINGLE_TRANS_UL: Uplink single packet transmission. - SINGLE_TRANS_DL: Downlink single packet transmission. - DUAL_TRANS_UL_FIRST: Dual packet transmission, firstly uplink packet transmission   with subsequent downlink packet transmission. - DUAL_TRANS_DL_FIRST: Dual packet transmission, firstly downlink packet transmission   with subsequent uplink packet transmission.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TrafficProfile {}

impl TrafficProfile {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TrafficProfile {
        TrafficProfile {}
    }
}

/// Converts the TrafficProfile value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TrafficProfile {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TrafficProfile value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TrafficProfile {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TrafficProfile".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing TrafficProfile".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TrafficProfile {})
    }
}

// Methods for converting between header::IntoHeaderValue<TrafficProfile> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TrafficProfile>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TrafficProfile>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TrafficProfile - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TrafficProfile> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TrafficProfile as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TrafficProfile - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum TrafficProfileAnyOf {
    #[serde(rename = "SINGLE_TRANS_UL")]
    SingleTransUl,
    #[serde(rename = "SINGLE_TRANS_DL")]
    SingleTransDl,
    #[serde(rename = "DUAL_TRANS_UL_FIRST")]
    DualTransUlFirst,
    #[serde(rename = "DUAL_TRANS_DL_FIRST")]
    DualTransDlFirst,
    #[serde(rename = "MULTI_TRANS")]
    MultiTrans,
}

impl std::fmt::Display for TrafficProfileAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            TrafficProfileAnyOf::SingleTransUl => write!(f, "SINGLE_TRANS_UL"),
            TrafficProfileAnyOf::SingleTransDl => write!(f, "SINGLE_TRANS_DL"),
            TrafficProfileAnyOf::DualTransUlFirst => write!(f, "DUAL_TRANS_UL_FIRST"),
            TrafficProfileAnyOf::DualTransDlFirst => write!(f, "DUAL_TRANS_DL_FIRST"),
            TrafficProfileAnyOf::MultiTrans => write!(f, "MULTI_TRANS"),
        }
    }
}

impl std::str::FromStr for TrafficProfileAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "SINGLE_TRANS_UL" => std::result::Result::Ok(TrafficProfileAnyOf::SingleTransUl),
            "SINGLE_TRANS_DL" => std::result::Result::Ok(TrafficProfileAnyOf::SingleTransDl),
            "DUAL_TRANS_UL_FIRST" => std::result::Result::Ok(TrafficProfileAnyOf::DualTransUlFirst),
            "DUAL_TRANS_DL_FIRST" => std::result::Result::Ok(TrafficProfileAnyOf::DualTransDlFirst),
            "MULTI_TRANS" => std::result::Result::Ok(TrafficProfileAnyOf::MultiTrans),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Data within Transfer MO Data Request
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TransferMoDataReqData {
    #[serde(rename = "moData")]
    pub mo_data: models::RefToBinaryData,

    #[serde(rename = "moExpDataCounter")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mo_exp_data_counter: Option<models::MoExpDataCounter>,

    #[serde(rename = "ueLocation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_location: Option<models::UserLocation>,
}

impl TransferMoDataReqData {
    #[allow(clippy::new_without_default)]
    pub fn new(mo_data: models::RefToBinaryData) -> TransferMoDataReqData {
        TransferMoDataReqData {
            mo_data,
            mo_exp_data_counter: None,
            ue_location: None,
        }
    }
}

/// Converts the TransferMoDataReqData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TransferMoDataReqData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping moData in query parameter serialization

            // Skipping moExpDataCounter in query parameter serialization

            // Skipping ueLocation in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TransferMoDataReqData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TransferMoDataReqData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub mo_data: Vec<models::RefToBinaryData>,
            pub mo_exp_data_counter: Vec<models::MoExpDataCounter>,
            pub ue_location: Vec<models::UserLocation>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TransferMoDataReqData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "moData" => intermediate_rep.mo_data.push(
                        <models::RefToBinaryData as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "moExpDataCounter" => intermediate_rep.mo_exp_data_counter.push(
                        <models::MoExpDataCounter as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ueLocation" => intermediate_rep.ue_location.push(
                        <models::UserLocation as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing TransferMoDataReqData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TransferMoDataReqData {
            mo_data: intermediate_rep
                .mo_data
                .into_iter()
                .next()
                .ok_or_else(|| "moData missing in TransferMoDataReqData".to_string())?,
            mo_exp_data_counter: intermediate_rep.mo_exp_data_counter.into_iter().next(),
            ue_location: intermediate_rep.ue_location.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TransferMoDataReqData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TransferMoDataReqData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TransferMoDataReqData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TransferMoDataReqData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<TransferMoDataReqData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TransferMoDataReqData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TransferMoDataReqData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TransferMoDataRequest {
    #[serde(rename = "jsonData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub json_data: Option<models::TransferMoDataReqData>,

    #[serde(rename = "binaryMoData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub binary_mo_data: Option<swagger::ByteArray>,
}

impl TransferMoDataRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TransferMoDataRequest {
        TransferMoDataRequest {
            json_data: None,
            binary_mo_data: None,
        }
    }
}

/// Converts the TransferMoDataRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TransferMoDataRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping jsonData in query parameter serialization

            // Skipping binaryMoData in query parameter serialization
            // Skipping binaryMoData in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TransferMoDataRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TransferMoDataRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub json_data: Vec<models::TransferMoDataReqData>,
            pub binary_mo_data: Vec<swagger::ByteArray>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TransferMoDataRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "jsonData" => intermediate_rep.json_data.push(<models::TransferMoDataReqData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "binaryMoData" => return std::result::Result::Err("Parsing binary data in this style is not supported in TransferMoDataRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing TransferMoDataRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TransferMoDataRequest {
            json_data: intermediate_rep.json_data.into_iter().next(),
            binary_mo_data: intermediate_rep.binary_mo_data.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TransferMoDataRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TransferMoDataRequest>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TransferMoDataRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TransferMoDataRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<TransferMoDataRequest>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TransferMoDataRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TransferMoDataRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Transfer MT Data Error Response Additional Information
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TransferMtDataAddInfo {
    /// indicating a time in seconds.
    #[serde(rename = "maxWaitingTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_waiting_time: Option<i32>,
}

impl TransferMtDataAddInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TransferMtDataAddInfo {
        TransferMtDataAddInfo {
            max_waiting_time: None,
        }
    }
}

/// Converts the TransferMtDataAddInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TransferMtDataAddInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> =
            vec![self.max_waiting_time.as_ref().map(|max_waiting_time| {
                vec!["maxWaitingTime".to_string(), max_waiting_time.to_string()].join(",")
            })];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TransferMtDataAddInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TransferMtDataAddInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub max_waiting_time: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TransferMtDataAddInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "maxWaitingTime" => intermediate_rep.max_waiting_time.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing TransferMtDataAddInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TransferMtDataAddInfo {
            max_waiting_time: intermediate_rep.max_waiting_time.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TransferMtDataAddInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TransferMtDataAddInfo>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TransferMtDataAddInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TransferMtDataAddInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<TransferMtDataAddInfo>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TransferMtDataAddInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TransferMtDataAddInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Transfer MT Data Error Response
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TransferMtDataError {
    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub r#type: Option<String>,

    #[serde(rename = "title")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<i32>,

    /// A human-readable explanation specific to this occurrence of the problem.
    #[serde(rename = "detail")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub detail: Option<String>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "instance")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub instance: Option<String>,

    /// A machine-readable application error cause specific to this occurrence of the problem.  This IE should be present and provide application-related error information, if available.
    #[serde(rename = "cause")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cause: Option<String>,

    #[serde(rename = "invalidParams")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub invalid_params: Option<Vec<models::InvalidParam>>,

    /// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  table 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.
    #[serde(rename = "supportedFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_features: Option<String>,

    #[serde(rename = "accessTokenError")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub access_token_error: Option<models::AccessTokenErr>,

    #[serde(rename = "accessTokenRequest")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub access_token_request: Option<models::AccessTokenReq>,

    /// Fully Qualified Domain Name
    #[serde(rename = "nrfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nrf_id: Option<String>,

    #[serde(rename = "remoteError")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remote_error: Option<bool>,

    /// indicating a time in seconds.
    #[serde(rename = "maxWaitingTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_waiting_time: Option<i32>,
}

impl TransferMtDataError {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TransferMtDataError {
        TransferMtDataError {
            r#type: None,
            title: None,
            status: None,
            detail: None,
            instance: None,
            cause: None,
            invalid_params: None,
            supported_features: None,
            access_token_error: None,
            access_token_request: None,
            nrf_id: None,
            remote_error: None,
            max_waiting_time: None,
        }
    }
}

/// Converts the TransferMtDataError value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TransferMtDataError {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.r#type
                .as_ref()
                .map(|r#type| vec!["type".to_string(), r#type.to_string()].join(",")),
            self.title
                .as_ref()
                .map(|title| vec!["title".to_string(), title.to_string()].join(",")),
            self.status
                .as_ref()
                .map(|status| vec!["status".to_string(), status.to_string()].join(",")),
            self.detail
                .as_ref()
                .map(|detail| vec!["detail".to_string(), detail.to_string()].join(",")),
            self.instance
                .as_ref()
                .map(|instance| vec!["instance".to_string(), instance.to_string()].join(",")),
            self.cause
                .as_ref()
                .map(|cause| vec!["cause".to_string(), cause.to_string()].join(",")),
            // Skipping invalidParams in query parameter serialization
            self.supported_features.as_ref().map(|supported_features| {
                vec![
                    "supportedFeatures".to_string(),
                    supported_features.to_string(),
                ]
                .join(",")
            }),
            // Skipping accessTokenError in query parameter serialization

            // Skipping accessTokenRequest in query parameter serialization
            self.nrf_id
                .as_ref()
                .map(|nrf_id| vec!["nrfId".to_string(), nrf_id.to_string()].join(",")),
            self.remote_error.as_ref().map(|remote_error| {
                vec!["remoteError".to_string(), remote_error.to_string()].join(",")
            }),
            self.max_waiting_time.as_ref().map(|max_waiting_time| {
                vec!["maxWaitingTime".to_string(), max_waiting_time.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TransferMtDataError value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TransferMtDataError {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
            pub title: Vec<String>,
            pub status: Vec<i32>,
            pub detail: Vec<String>,
            pub instance: Vec<String>,
            pub cause: Vec<String>,
            pub invalid_params: Vec<Vec<models::InvalidParam>>,
            pub supported_features: Vec<String>,
            pub access_token_error: Vec<models::AccessTokenErr>,
            pub access_token_request: Vec<models::AccessTokenReq>,
            pub nrf_id: Vec<String>,
            pub remote_error: Vec<bool>,
            pub max_waiting_time: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TransferMtDataError".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "title" => intermediate_rep.title.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "detail" => intermediate_rep.detail.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "instance" => intermediate_rep.instance.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "cause" => intermediate_rep.cause.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "invalidParams" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in TransferMtDataError"
                            .to_string(),
                    ),
                    #[allow(clippy::redundant_clone)]
                    "supportedFeatures" => intermediate_rep.supported_features.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "accessTokenError" => intermediate_rep.access_token_error.push(
                        <models::AccessTokenErr as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "accessTokenRequest" => intermediate_rep.access_token_request.push(
                        <models::AccessTokenReq as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nrfId" => intermediate_rep.nrf_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "remoteError" => intermediate_rep.remote_error.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "maxWaitingTime" => intermediate_rep.max_waiting_time.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing TransferMtDataError".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TransferMtDataError {
            r#type: intermediate_rep.r#type.into_iter().next(),
            title: intermediate_rep.title.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            detail: intermediate_rep.detail.into_iter().next(),
            instance: intermediate_rep.instance.into_iter().next(),
            cause: intermediate_rep.cause.into_iter().next(),
            invalid_params: intermediate_rep.invalid_params.into_iter().next(),
            supported_features: intermediate_rep.supported_features.into_iter().next(),
            access_token_error: intermediate_rep.access_token_error.into_iter().next(),
            access_token_request: intermediate_rep.access_token_request.into_iter().next(),
            nrf_id: intermediate_rep.nrf_id.into_iter().next(),
            remote_error: intermediate_rep.remote_error.into_iter().next(),
            max_waiting_time: intermediate_rep.max_waiting_time.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TransferMtDataError> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TransferMtDataError>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TransferMtDataError>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TransferMtDataError - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<TransferMtDataError>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TransferMtDataError as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TransferMtDataError - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TransferMtDataIsmfRequest {
    #[serde(rename = "jsonData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub json_data: Option<models::TransferMtDataReqData>,

    #[serde(rename = "binaryMtData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub binary_mt_data: Option<swagger::ByteArray>,
}

impl TransferMtDataIsmfRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TransferMtDataIsmfRequest {
        TransferMtDataIsmfRequest {
            json_data: None,
            binary_mt_data: None,
        }
    }
}

/// Converts the TransferMtDataIsmfRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TransferMtDataIsmfRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping jsonData in query parameter serialization

            // Skipping binaryMtData in query parameter serialization
            // Skipping binaryMtData in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TransferMtDataIsmfRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TransferMtDataIsmfRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub json_data: Vec<models::TransferMtDataReqData>,
            pub binary_mt_data: Vec<swagger::ByteArray>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TransferMtDataIsmfRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "jsonData" => intermediate_rep.json_data.push(<models::TransferMtDataReqData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "binaryMtData" => return std::result::Result::Err("Parsing binary data in this style is not supported in TransferMtDataIsmfRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing TransferMtDataIsmfRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TransferMtDataIsmfRequest {
            json_data: intermediate_rep.json_data.into_iter().next(),
            binary_mt_data: intermediate_rep.binary_mt_data.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TransferMtDataIsmfRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TransferMtDataIsmfRequest>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TransferMtDataIsmfRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TransferMtDataIsmfRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<TransferMtDataIsmfRequest>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TransferMtDataIsmfRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TransferMtDataIsmfRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Data within Transfer MT Data Request
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TransferMtDataReqData {
    #[serde(rename = "mtData")]
    pub mt_data: models::RefToBinaryData,
}

impl TransferMtDataReqData {
    #[allow(clippy::new_without_default)]
    pub fn new(mt_data: models::RefToBinaryData) -> TransferMtDataReqData {
        TransferMtDataReqData { mt_data }
    }
}

/// Converts the TransferMtDataReqData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TransferMtDataReqData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping mtData in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TransferMtDataReqData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TransferMtDataReqData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub mt_data: Vec<models::RefToBinaryData>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TransferMtDataReqData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "mtData" => intermediate_rep.mt_data.push(
                        <models::RefToBinaryData as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing TransferMtDataReqData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TransferMtDataReqData {
            mt_data: intermediate_rep
                .mt_data
                .into_iter()
                .next()
                .ok_or_else(|| "mtData missing in TransferMtDataReqData".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TransferMtDataReqData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TransferMtDataReqData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TransferMtDataReqData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TransferMtDataReqData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<TransferMtDataReqData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TransferMtDataReqData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TransferMtDataReqData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Possible values are: - UDP: User Datagram Protocol. - TCP: Transmission Control Protocol.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TransportProtocol {}

impl TransportProtocol {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TransportProtocol {
        TransportProtocol {}
    }
}

/// Converts the TransportProtocol value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TransportProtocol {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TransportProtocol value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TransportProtocol {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TransportProtocol".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing TransportProtocol".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TransportProtocol {})
    }
}

// Methods for converting between header::IntoHeaderValue<TransportProtocol> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TransportProtocol>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TransportProtocol>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TransportProtocol - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<TransportProtocol>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TransportProtocol as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TransportProtocol - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum TransportProtocolAnyOf {
    #[serde(rename = "UDP")]
    Udp,
    #[serde(rename = "TCP")]
    Tcp,
}

impl std::fmt::Display for TransportProtocolAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            TransportProtocolAnyOf::Udp => write!(f, "UDP"),
            TransportProtocolAnyOf::Tcp => write!(f, "TCP"),
        }
    }
}

impl std::str::FromStr for TransportProtocolAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "UDP" => std::result::Result::Ok(TransportProtocolAnyOf::Udp),
            "TCP" => std::result::Result::Ok(TransportProtocolAnyOf::Tcp),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Trigger {
    #[serde(rename = "triggerType")]
    pub trigger_type: models::TriggerType,

    #[serde(rename = "triggerCategory")]
    pub trigger_category: models::TriggerCategory,

    /// indicating a time in seconds.
    #[serde(rename = "timeLimit")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub time_limit: Option<i32>,

    /// Integer where the allowed values correspond to the value range of an unsigned 32-bit integer.
    #[serde(rename = "volumeLimit")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub volume_limit: Option<u32>,

    /// Integer where the allowed values correspond to the value range of an unsigned 64-bit integer.
    #[serde(rename = "volumeLimit64")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub volume_limit64: Option<u8>,

    /// Integer where the allowed values correspond to the value range of an unsigned 32-bit integer.
    #[serde(rename = "eventLimit")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub event_limit: Option<u32>,

    /// Integer where the allowed values correspond to the value range of an unsigned 32-bit integer.
    #[serde(rename = "maxNumberOfccc")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_number_ofccc: Option<u32>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "tariffTimeChange")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tariff_time_change: Option<chrono::DateTime<chrono::Utc>>,
}

impl Trigger {
    #[allow(clippy::new_without_default)]
    pub fn new(
        trigger_type: models::TriggerType,
        trigger_category: models::TriggerCategory,
    ) -> Trigger {
        Trigger {
            trigger_type,
            trigger_category,
            time_limit: None,
            volume_limit: None,
            volume_limit64: None,
            event_limit: None,
            max_number_ofccc: None,
            tariff_time_change: None,
        }
    }
}

/// Converts the Trigger value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Trigger {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping triggerType in query parameter serialization

            // Skipping triggerCategory in query parameter serialization
            self.time_limit
                .as_ref()
                .map(|time_limit| vec!["timeLimit".to_string(), time_limit.to_string()].join(",")),
            self.volume_limit.as_ref().map(|volume_limit| {
                vec!["volumeLimit".to_string(), volume_limit.to_string()].join(",")
            }),
            self.volume_limit64.as_ref().map(|volume_limit64| {
                vec!["volumeLimit64".to_string(), volume_limit64.to_string()].join(",")
            }),
            self.event_limit.as_ref().map(|event_limit| {
                vec!["eventLimit".to_string(), event_limit.to_string()].join(",")
            }),
            self.max_number_ofccc.as_ref().map(|max_number_ofccc| {
                vec!["maxNumberOfccc".to_string(), max_number_ofccc.to_string()].join(",")
            }),
            // Skipping tariffTimeChange in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Trigger value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Trigger {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub trigger_type: Vec<models::TriggerType>,
            pub trigger_category: Vec<models::TriggerCategory>,
            pub time_limit: Vec<i32>,
            pub volume_limit: Vec<u32>,
            pub volume_limit64: Vec<u8>,
            pub event_limit: Vec<u32>,
            pub max_number_ofccc: Vec<u32>,
            pub tariff_time_change: Vec<chrono::DateTime<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Trigger".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "triggerType" => intermediate_rep.trigger_type.push(
                        <models::TriggerType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "triggerCategory" => intermediate_rep.trigger_category.push(
                        <models::TriggerCategory as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "timeLimit" => intermediate_rep.time_limit.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "volumeLimit" => intermediate_rep.volume_limit.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "volumeLimit64" => intermediate_rep
                        .volume_limit64
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "eventLimit" => intermediate_rep.event_limit.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "maxNumberOfccc" => intermediate_rep.max_number_ofccc.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "tariffTimeChange" => intermediate_rep.tariff_time_change.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Trigger".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Trigger {
            trigger_type: intermediate_rep
                .trigger_type
                .into_iter()
                .next()
                .ok_or_else(|| "triggerType missing in Trigger".to_string())?,
            trigger_category: intermediate_rep
                .trigger_category
                .into_iter()
                .next()
                .ok_or_else(|| "triggerCategory missing in Trigger".to_string())?,
            time_limit: intermediate_rep.time_limit.into_iter().next(),
            volume_limit: intermediate_rep.volume_limit.into_iter().next(),
            volume_limit64: intermediate_rep.volume_limit64.into_iter().next(),
            event_limit: intermediate_rep.event_limit.into_iter().next(),
            max_number_ofccc: intermediate_rep.max_number_ofccc.into_iter().next(),
            tariff_time_change: intermediate_rep.tariff_time_change.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Trigger> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Trigger>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Trigger>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Trigger - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Trigger> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <Trigger as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into Trigger - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TriggerCategory {}

impl TriggerCategory {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TriggerCategory {
        TriggerCategory {}
    }
}

/// Converts the TriggerCategory value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TriggerCategory {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TriggerCategory value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TriggerCategory {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TriggerCategory".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing TriggerCategory".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TriggerCategory {})
    }
}

// Methods for converting between header::IntoHeaderValue<TriggerCategory> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TriggerCategory>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TriggerCategory>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TriggerCategory - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<TriggerCategory>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TriggerCategory as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TriggerCategory - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum TriggerCategoryAnyOf {
    #[serde(rename = "IMMEDIATE_REPORT")]
    ImmediateReport,
    #[serde(rename = "DEFERRED_REPORT")]
    DeferredReport,
}

impl std::fmt::Display for TriggerCategoryAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            TriggerCategoryAnyOf::ImmediateReport => write!(f, "IMMEDIATE_REPORT"),
            TriggerCategoryAnyOf::DeferredReport => write!(f, "DEFERRED_REPORT"),
        }
    }
}

impl std::str::FromStr for TriggerCategoryAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "IMMEDIATE_REPORT" => std::result::Result::Ok(TriggerCategoryAnyOf::ImmediateReport),
            "DEFERRED_REPORT" => std::result::Result::Ok(TriggerCategoryAnyOf::DeferredReport),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TriggerType {}

impl TriggerType {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TriggerType {
        TriggerType {}
    }
}

/// Converts the TriggerType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TriggerType {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TriggerType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TriggerType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TriggerType".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing TriggerType".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TriggerType {})
    }
}

// Methods for converting between header::IntoHeaderValue<TriggerType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TriggerType>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TriggerType>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TriggerType - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TriggerType> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TriggerType as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TriggerType - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum TriggerTypeAnyOf {
    #[serde(rename = "QUOTA_THRESHOLD")]
    QuotaThreshold,
    #[serde(rename = "QHT")]
    Qht,
    #[serde(rename = "FINAL")]
    Final,
    #[serde(rename = "QUOTA_EXHAUSTED")]
    QuotaExhausted,
    #[serde(rename = "VALIDITY_TIME")]
    ValidityTime,
    #[serde(rename = "OTHER_QUOTA_TYPE")]
    OtherQuotaType,
    #[serde(rename = "FORCED_REAUTHORISATION")]
    ForcedReauthorisation,
    #[serde(rename = "UNUSED_QUOTA_TIMER")]
    UnusedQuotaTimer,
    #[serde(rename = "UNIT_COUNT_INACTIVITY_TIMER")]
    UnitCountInactivityTimer,
    #[serde(rename = "ABNORMAL_RELEASE")]
    AbnormalRelease,
    #[serde(rename = "QOS_CHANGE")]
    QosChange,
    #[serde(rename = "VOLUME_LIMIT")]
    VolumeLimit,
    #[serde(rename = "TIME_LIMIT")]
    TimeLimit,
    #[serde(rename = "EVENT_LIMIT")]
    EventLimit,
    #[serde(rename = "PLMN_CHANGE")]
    PlmnChange,
    #[serde(rename = "USER_LOCATION_CHANGE")]
    UserLocationChange,
    #[serde(rename = "RAT_CHANGE")]
    RatChange,
    #[serde(rename = "SESSION_AMBR_CHANGE")]
    SessionAmbrChange,
    #[serde(rename = "UE_TIMEZONE_CHANGE")]
    UeTimezoneChange,
    #[serde(rename = "TARIFF_TIME_CHANGE")]
    TariffTimeChange,
    #[serde(rename = "MAX_NUMBER_OF_CHANGES_IN_CHARGING_CONDITIONS")]
    MaxNumberOfChangesInChargingConditions,
    #[serde(rename = "MANAGEMENT_INTERVENTION")]
    ManagementIntervention,
    #[serde(rename = "CHANGE_OF_UE_PRESENCE_IN_PRESENCE_REPORTING_AREA")]
    ChangeOfUePresenceInPresenceReportingArea,
    #[serde(rename = "CHANGE_OF_3GPP_PS_DATA_OFF_STATUS")]
    ChangeOf3GppPsDataOffStatus,
    #[serde(rename = "SERVING_NODE_CHANGE")]
    ServingNodeChange,
    #[serde(rename = "REMOVAL_OF_UPF")]
    RemovalOfUpf,
    #[serde(rename = "ADDITION_OF_UPF")]
    AdditionOfUpf,
    #[serde(rename = "INSERTION_OF_ISMF")]
    InsertionOfIsmf,
    #[serde(rename = "REMOVAL_OF_ISMF")]
    RemovalOfIsmf,
    #[serde(rename = "CHANGE_OF_ISMF")]
    ChangeOfIsmf,
    #[serde(rename = "START_OF_SERVICE_DATA_FLOW")]
    StartOfServiceDataFlow,
    #[serde(rename = "ECGI_CHANGE")]
    EcgiChange,
    #[serde(rename = "TAI_CHANGE")]
    TaiChange,
    #[serde(rename = "HANDOVER_CANCEL")]
    HandoverCancel,
    #[serde(rename = "HANDOVER_START")]
    HandoverStart,
    #[serde(rename = "HANDOVER_COMPLETE")]
    HandoverComplete,
    #[serde(rename = "GFBR_GUARANTEED_STATUS_CHANGE")]
    GfbrGuaranteedStatusChange,
    #[serde(rename = "ADDITION_OF_ACCESS")]
    AdditionOfAccess,
    #[serde(rename = "REMOVAL_OF_ACCESS")]
    RemovalOfAccess,
    #[serde(rename = "START_OF_SDF_ADDITIONAL_ACCESS")]
    StartOfSdfAdditionalAccess,
    #[serde(rename = "REDUNDANT_TRANSMISSION_CHANGE")]
    RedundantTransmissionChange,
    #[serde(rename = "CGI_SAI_CHANGE")]
    CgiSaiChange,
    #[serde(rename = "RAI_CHANGE")]
    RaiChange,
}

impl std::fmt::Display for TriggerTypeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            TriggerTypeAnyOf::QuotaThreshold => write!(f, "QUOTA_THRESHOLD"),
            TriggerTypeAnyOf::Qht => write!(f, "QHT"),
            TriggerTypeAnyOf::Final => write!(f, "FINAL"),
            TriggerTypeAnyOf::QuotaExhausted => write!(f, "QUOTA_EXHAUSTED"),
            TriggerTypeAnyOf::ValidityTime => write!(f, "VALIDITY_TIME"),
            TriggerTypeAnyOf::OtherQuotaType => write!(f, "OTHER_QUOTA_TYPE"),
            TriggerTypeAnyOf::ForcedReauthorisation => write!(f, "FORCED_REAUTHORISATION"),
            TriggerTypeAnyOf::UnusedQuotaTimer => write!(f, "UNUSED_QUOTA_TIMER"),
            TriggerTypeAnyOf::UnitCountInactivityTimer => write!(f, "UNIT_COUNT_INACTIVITY_TIMER"),
            TriggerTypeAnyOf::AbnormalRelease => write!(f, "ABNORMAL_RELEASE"),
            TriggerTypeAnyOf::QosChange => write!(f, "QOS_CHANGE"),
            TriggerTypeAnyOf::VolumeLimit => write!(f, "VOLUME_LIMIT"),
            TriggerTypeAnyOf::TimeLimit => write!(f, "TIME_LIMIT"),
            TriggerTypeAnyOf::EventLimit => write!(f, "EVENT_LIMIT"),
            TriggerTypeAnyOf::PlmnChange => write!(f, "PLMN_CHANGE"),
            TriggerTypeAnyOf::UserLocationChange => write!(f, "USER_LOCATION_CHANGE"),
            TriggerTypeAnyOf::RatChange => write!(f, "RAT_CHANGE"),
            TriggerTypeAnyOf::SessionAmbrChange => write!(f, "SESSION_AMBR_CHANGE"),
            TriggerTypeAnyOf::UeTimezoneChange => write!(f, "UE_TIMEZONE_CHANGE"),
            TriggerTypeAnyOf::TariffTimeChange => write!(f, "TARIFF_TIME_CHANGE"),
            TriggerTypeAnyOf::MaxNumberOfChangesInChargingConditions => {
                write!(f, "MAX_NUMBER_OF_CHANGES_IN_CHARGING_CONDITIONS")
            }
            TriggerTypeAnyOf::ManagementIntervention => write!(f, "MANAGEMENT_INTERVENTION"),
            TriggerTypeAnyOf::ChangeOfUePresenceInPresenceReportingArea => {
                write!(f, "CHANGE_OF_UE_PRESENCE_IN_PRESENCE_REPORTING_AREA")
            }
            TriggerTypeAnyOf::ChangeOf3GppPsDataOffStatus => {
                write!(f, "CHANGE_OF_3GPP_PS_DATA_OFF_STATUS")
            }
            TriggerTypeAnyOf::ServingNodeChange => write!(f, "SERVING_NODE_CHANGE"),
            TriggerTypeAnyOf::RemovalOfUpf => write!(f, "REMOVAL_OF_UPF"),
            TriggerTypeAnyOf::AdditionOfUpf => write!(f, "ADDITION_OF_UPF"),
            TriggerTypeAnyOf::InsertionOfIsmf => write!(f, "INSERTION_OF_ISMF"),
            TriggerTypeAnyOf::RemovalOfIsmf => write!(f, "REMOVAL_OF_ISMF"),
            TriggerTypeAnyOf::ChangeOfIsmf => write!(f, "CHANGE_OF_ISMF"),
            TriggerTypeAnyOf::StartOfServiceDataFlow => write!(f, "START_OF_SERVICE_DATA_FLOW"),
            TriggerTypeAnyOf::EcgiChange => write!(f, "ECGI_CHANGE"),
            TriggerTypeAnyOf::TaiChange => write!(f, "TAI_CHANGE"),
            TriggerTypeAnyOf::HandoverCancel => write!(f, "HANDOVER_CANCEL"),
            TriggerTypeAnyOf::HandoverStart => write!(f, "HANDOVER_START"),
            TriggerTypeAnyOf::HandoverComplete => write!(f, "HANDOVER_COMPLETE"),
            TriggerTypeAnyOf::GfbrGuaranteedStatusChange => {
                write!(f, "GFBR_GUARANTEED_STATUS_CHANGE")
            }
            TriggerTypeAnyOf::AdditionOfAccess => write!(f, "ADDITION_OF_ACCESS"),
            TriggerTypeAnyOf::RemovalOfAccess => write!(f, "REMOVAL_OF_ACCESS"),
            TriggerTypeAnyOf::StartOfSdfAdditionalAccess => {
                write!(f, "START_OF_SDF_ADDITIONAL_ACCESS")
            }
            TriggerTypeAnyOf::RedundantTransmissionChange => {
                write!(f, "REDUNDANT_TRANSMISSION_CHANGE")
            }
            TriggerTypeAnyOf::CgiSaiChange => write!(f, "CGI_SAI_CHANGE"),
            TriggerTypeAnyOf::RaiChange => write!(f, "RAI_CHANGE"),
        }
    }
}

impl std::str::FromStr for TriggerTypeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "QUOTA_THRESHOLD" => std::result::Result::Ok(TriggerTypeAnyOf::QuotaThreshold),
            "QHT" => std::result::Result::Ok(TriggerTypeAnyOf::Qht),
            "FINAL" => std::result::Result::Ok(TriggerTypeAnyOf::Final),
            "QUOTA_EXHAUSTED" => std::result::Result::Ok(TriggerTypeAnyOf::QuotaExhausted),
            "VALIDITY_TIME" => std::result::Result::Ok(TriggerTypeAnyOf::ValidityTime),
            "OTHER_QUOTA_TYPE" => std::result::Result::Ok(TriggerTypeAnyOf::OtherQuotaType),
            "FORCED_REAUTHORISATION" => {
                std::result::Result::Ok(TriggerTypeAnyOf::ForcedReauthorisation)
            }
            "UNUSED_QUOTA_TIMER" => std::result::Result::Ok(TriggerTypeAnyOf::UnusedQuotaTimer),
            "UNIT_COUNT_INACTIVITY_TIMER" => {
                std::result::Result::Ok(TriggerTypeAnyOf::UnitCountInactivityTimer)
            }
            "ABNORMAL_RELEASE" => std::result::Result::Ok(TriggerTypeAnyOf::AbnormalRelease),
            "QOS_CHANGE" => std::result::Result::Ok(TriggerTypeAnyOf::QosChange),
            "VOLUME_LIMIT" => std::result::Result::Ok(TriggerTypeAnyOf::VolumeLimit),
            "TIME_LIMIT" => std::result::Result::Ok(TriggerTypeAnyOf::TimeLimit),
            "EVENT_LIMIT" => std::result::Result::Ok(TriggerTypeAnyOf::EventLimit),
            "PLMN_CHANGE" => std::result::Result::Ok(TriggerTypeAnyOf::PlmnChange),
            "USER_LOCATION_CHANGE" => std::result::Result::Ok(TriggerTypeAnyOf::UserLocationChange),
            "RAT_CHANGE" => std::result::Result::Ok(TriggerTypeAnyOf::RatChange),
            "SESSION_AMBR_CHANGE" => std::result::Result::Ok(TriggerTypeAnyOf::SessionAmbrChange),
            "UE_TIMEZONE_CHANGE" => std::result::Result::Ok(TriggerTypeAnyOf::UeTimezoneChange),
            "TARIFF_TIME_CHANGE" => std::result::Result::Ok(TriggerTypeAnyOf::TariffTimeChange),
            "MAX_NUMBER_OF_CHANGES_IN_CHARGING_CONDITIONS" => {
                std::result::Result::Ok(TriggerTypeAnyOf::MaxNumberOfChangesInChargingConditions)
            }
            "MANAGEMENT_INTERVENTION" => {
                std::result::Result::Ok(TriggerTypeAnyOf::ManagementIntervention)
            }
            "CHANGE_OF_UE_PRESENCE_IN_PRESENCE_REPORTING_AREA" => {
                std::result::Result::Ok(TriggerTypeAnyOf::ChangeOfUePresenceInPresenceReportingArea)
            }
            "CHANGE_OF_3GPP_PS_DATA_OFF_STATUS" => {
                std::result::Result::Ok(TriggerTypeAnyOf::ChangeOf3GppPsDataOffStatus)
            }
            "SERVING_NODE_CHANGE" => std::result::Result::Ok(TriggerTypeAnyOf::ServingNodeChange),
            "REMOVAL_OF_UPF" => std::result::Result::Ok(TriggerTypeAnyOf::RemovalOfUpf),
            "ADDITION_OF_UPF" => std::result::Result::Ok(TriggerTypeAnyOf::AdditionOfUpf),
            "INSERTION_OF_ISMF" => std::result::Result::Ok(TriggerTypeAnyOf::InsertionOfIsmf),
            "REMOVAL_OF_ISMF" => std::result::Result::Ok(TriggerTypeAnyOf::RemovalOfIsmf),
            "CHANGE_OF_ISMF" => std::result::Result::Ok(TriggerTypeAnyOf::ChangeOfIsmf),
            "START_OF_SERVICE_DATA_FLOW" => {
                std::result::Result::Ok(TriggerTypeAnyOf::StartOfServiceDataFlow)
            }
            "ECGI_CHANGE" => std::result::Result::Ok(TriggerTypeAnyOf::EcgiChange),
            "TAI_CHANGE" => std::result::Result::Ok(TriggerTypeAnyOf::TaiChange),
            "HANDOVER_CANCEL" => std::result::Result::Ok(TriggerTypeAnyOf::HandoverCancel),
            "HANDOVER_START" => std::result::Result::Ok(TriggerTypeAnyOf::HandoverStart),
            "HANDOVER_COMPLETE" => std::result::Result::Ok(TriggerTypeAnyOf::HandoverComplete),
            "GFBR_GUARANTEED_STATUS_CHANGE" => {
                std::result::Result::Ok(TriggerTypeAnyOf::GfbrGuaranteedStatusChange)
            }
            "ADDITION_OF_ACCESS" => std::result::Result::Ok(TriggerTypeAnyOf::AdditionOfAccess),
            "REMOVAL_OF_ACCESS" => std::result::Result::Ok(TriggerTypeAnyOf::RemovalOfAccess),
            "START_OF_SDF_ADDITIONAL_ACCESS" => {
                std::result::Result::Ok(TriggerTypeAnyOf::StartOfSdfAdditionalAccess)
            }
            "REDUNDANT_TRANSMISSION_CHANGE" => {
                std::result::Result::Ok(TriggerTypeAnyOf::RedundantTransmissionChange)
            }
            "CGI_SAI_CHANGE" => std::result::Result::Ok(TriggerTypeAnyOf::CgiSaiChange),
            "RAI_CHANGE" => std::result::Result::Ok(TriggerTypeAnyOf::RaiChange),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Tunnel Information
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TunnelInfo {
    /// String identifying a IPv4 address formatted in the 'dotted decimal' notation as defined in RFC 1166.
    #[serde(rename = "ipv4Addr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv4_addr: Option<String>,

    #[serde(rename = "ipv6Addr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_addr: Option<models::Ipv6Addr>,

    /// GTP Tunnel Endpoint Identifier
    #[serde(rename = "gtpTeid")]
    pub gtp_teid: String,

    #[serde(rename = "anType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub an_type: Option<models::AccessType>,
}

impl TunnelInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(gtp_teid: String) -> TunnelInfo {
        TunnelInfo {
            ipv4_addr: None,
            ipv6_addr: None,
            gtp_teid,
            an_type: None,
        }
    }
}

/// Converts the TunnelInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TunnelInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.ipv4_addr
                .as_ref()
                .map(|ipv4_addr| vec!["ipv4Addr".to_string(), ipv4_addr.to_string()].join(",")),
            // Skipping ipv6Addr in query parameter serialization
            Some("gtpTeid".to_string()),
            Some(self.gtp_teid.to_string()),
            // Skipping anType in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TunnelInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TunnelInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ipv4_addr: Vec<String>,
            pub ipv6_addr: Vec<models::Ipv6Addr>,
            pub gtp_teid: Vec<String>,
            pub an_type: Vec<models::AccessType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TunnelInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ipv4Addr" => intermediate_rep.ipv4_addr.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ipv6Addr" => intermediate_rep.ipv6_addr.push(
                        <models::Ipv6Addr as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "gtpTeid" => intermediate_rep.gtp_teid.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "anType" => intermediate_rep.an_type.push(
                        <models::AccessType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing TunnelInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TunnelInfo {
            ipv4_addr: intermediate_rep.ipv4_addr.into_iter().next(),
            ipv6_addr: intermediate_rep.ipv6_addr.into_iter().next(),
            gtp_teid: intermediate_rep
                .gtp_teid
                .into_iter()
                .next()
                .ok_or_else(|| "gtpTeid missing in TunnelInfo".to_string())?,
            an_type: intermediate_rep.an_type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TunnelInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TunnelInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TunnelInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TunnelInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TunnelInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TunnelInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TunnelInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contain the TWAP Identifier as defined in clause 4.2.8.5.3 of 3GPP TS 23.501 or the WLAN location information as defined in clause 4.5.7.2.8 of 3GPP TS 23.402.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TwapId {
    /// This IE shall contain the SSID of the access point to which the UE is attached, that is received over NGAP, see IEEE Std 802.11-2012.
    #[serde(rename = "ssId")]
    pub ss_id: String,

    /// When present, it shall contain the BSSID of the access point to which the UE is attached, for trusted WLAN access, see IEEE Std 802.11-2012.
    #[serde(rename = "bssId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bss_id: Option<String>,

    /// string with format 'bytes' as defined in OpenAPI
    #[serde(rename = "civicAddress")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub civic_address: Option<swagger::ByteArray>,
}

impl TwapId {
    #[allow(clippy::new_without_default)]
    pub fn new(ss_id: String) -> TwapId {
        TwapId {
            ss_id,
            bss_id: None,
            civic_address: None,
        }
    }
}

/// Converts the TwapId value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TwapId {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("ssId".to_string()),
            Some(self.ss_id.to_string()),
            self.bss_id
                .as_ref()
                .map(|bss_id| vec!["bssId".to_string(), bss_id.to_string()].join(",")),
            // Skipping civicAddress in query parameter serialization
            // Skipping civicAddress in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TwapId value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TwapId {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ss_id: Vec<String>,
            pub bss_id: Vec<String>,
            pub civic_address: Vec<swagger::ByteArray>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TwapId".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ssId" => intermediate_rep.ss_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "bssId" => intermediate_rep.bss_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "civicAddress" => {
                        return std::result::Result::Err(
                            "Parsing binary data in this style is not supported in TwapId"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing TwapId".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TwapId {
            ss_id: intermediate_rep
                .ss_id
                .into_iter()
                .next()
                .ok_or_else(|| "ssId missing in TwapId".to_string())?,
            bss_id: intermediate_rep.bss_id.into_iter().next(),
            civic_address: intermediate_rep.civic_address.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TwapId> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TwapId>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TwapId>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TwapId - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TwapId> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TwapId as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TwapId - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Addressing information (IP addresses, FQDN) of the TWIF
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TwifInfo {
    #[serde(rename = "ipv4EndpointAddresses")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv4_endpoint_addresses: Option<Vec<models::Ipv4Addr>>,

    #[serde(rename = "ipv6EndpointAddresses")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_endpoint_addresses: Option<Vec<models::Ipv6Addr>>,

    /// Fully Qualified Domain Name
    #[serde(rename = "endpointFqdn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub endpoint_fqdn: Option<String>,
}

impl TwifInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TwifInfo {
        TwifInfo {
            ipv4_endpoint_addresses: None,
            ipv6_endpoint_addresses: None,
            endpoint_fqdn: None,
        }
    }
}

/// Converts the TwifInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TwifInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.ipv4_endpoint_addresses
                .as_ref()
                .map(|ipv4_endpoint_addresses| {
                    vec![
                        "ipv4EndpointAddresses".to_string(),
                        ipv4_endpoint_addresses
                            .iter()
                            .map(|x| x.to_string())
                            .collect::<Vec<_>>()
                            .join(","),
                    ]
                    .join(",")
                }),
            // Skipping ipv6EndpointAddresses in query parameter serialization
            self.endpoint_fqdn.as_ref().map(|endpoint_fqdn| {
                vec!["endpointFqdn".to_string(), endpoint_fqdn.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TwifInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TwifInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ipv4_endpoint_addresses: Vec<Vec<models::Ipv4Addr>>,
            pub ipv6_endpoint_addresses: Vec<Vec<models::Ipv6Addr>>,
            pub endpoint_fqdn: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TwifInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "ipv4EndpointAddresses" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in TwifInfo"
                                .to_string(),
                        )
                    }
                    "ipv6EndpointAddresses" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in TwifInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "endpointFqdn" => intermediate_rep.endpoint_fqdn.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing TwifInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TwifInfo {
            ipv4_endpoint_addresses: intermediate_rep.ipv4_endpoint_addresses.into_iter().next(),
            ipv6_endpoint_addresses: intermediate_rep.ipv6_endpoint_addresses.into_iter().next(),
            endpoint_fqdn: intermediate_rep.endpoint_fqdn.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TwifInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TwifInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TwifInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TwifInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TwifInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TwifInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TwifInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Integer where the allowed values correspond to the value range of an unsigned 16-bit integer.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Uint16(i32);

impl std::convert::From<i32> for Uint16 {
    fn from(x: i32) -> Self {
        Uint16(x)
    }
}

impl std::convert::From<Uint16> for i32 {
    fn from(x: Uint16) -> Self {
        x.0
    }
}

impl std::ops::Deref for Uint16 {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for Uint16 {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// Integer where the allowed values correspond to the value range of an unsigned 32-bit integer.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Uint32(i32);

impl std::convert::From<i32> for Uint32 {
    fn from(x: i32) -> Self {
        Uint32(x)
    }
}

impl std::convert::From<Uint32> for i32 {
    fn from(x: Uint32) -> Self {
        x.0
    }
}

impl std::ops::Deref for Uint32 {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for Uint32 {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// Integer where the allowed values correspond to the value range of an unsigned 64-bit integer.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Uint64(i32);

impl std::convert::From<i32> for Uint64 {
    fn from(x: i32) -> Self {
        Uint64(x)
    }
}

impl std::convert::From<Uint64> for i32 {
    fn from(x: Uint64) -> Self {
        x.0
    }
}

impl std::ops::Deref for Uint64 {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for Uint64 {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// Unsigned Integer, i.e. only value 0 and integers above 0 are permissible.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Uinteger(i32);

impl std::convert::From<i32> for Uinteger {
    fn from(x: i32) -> Self {
        Uinteger(x)
    }
}

impl std::convert::From<Uinteger> for i32 {
    fn from(x: Uinteger) -> Self {
        x.0
    }
}

impl std::ops::Deref for Uinteger {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for Uinteger {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// UL CL or BP Information
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UlclBpInformation {
    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "ulclBpUpfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ulcl_bp_upf_id: Option<uuid::Uuid>,
}

impl UlclBpInformation {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UlclBpInformation {
        UlclBpInformation {
            ulcl_bp_upf_id: None,
        }
    }
}

/// Converts the UlclBpInformation value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UlclBpInformation {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping ulclBpUpfId in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UlclBpInformation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UlclBpInformation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ulcl_bp_upf_id: Vec<uuid::Uuid>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UlclBpInformation".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ulclBpUpfId" => intermediate_rep.ulcl_bp_upf_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UlclBpInformation".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UlclBpInformation {
            ulcl_bp_upf_id: intermediate_rep.ulcl_bp_upf_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UlclBpInformation> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UlclBpInformation>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UlclBpInformation>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UlclBpInformation - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<UlclBpInformation>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UlclBpInformation as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UlclBpInformation - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Indicates the access type of a MA PDU session that is unavailable. Possible values are   - 3GA_UNAVAILABLE   - N3GA_UNAVAILABLE
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UnavailableAccessIndication {}

impl UnavailableAccessIndication {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UnavailableAccessIndication {
        UnavailableAccessIndication {}
    }
}

/// Converts the UnavailableAccessIndication value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UnavailableAccessIndication {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UnavailableAccessIndication value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UnavailableAccessIndication {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UnavailableAccessIndication".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UnavailableAccessIndication".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UnavailableAccessIndication {})
    }
}

// Methods for converting between header::IntoHeaderValue<UnavailableAccessIndication> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UnavailableAccessIndication>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UnavailableAccessIndication>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UnavailableAccessIndication - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<UnavailableAccessIndication>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UnavailableAccessIndication as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UnavailableAccessIndication - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum UnavailableAccessIndicationAnyOf {
    #[serde(rename = "3GA_UNAVAILABLE")]
    Variant3GaUnavailable,
    #[serde(rename = "N3GA_UNAVAILABLE")]
    N3GaUnavailable,
}

impl std::fmt::Display for UnavailableAccessIndicationAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            UnavailableAccessIndicationAnyOf::Variant3GaUnavailable => write!(f, "3GA_UNAVAILABLE"),
            UnavailableAccessIndicationAnyOf::N3GaUnavailable => write!(f, "N3GA_UNAVAILABLE"),
        }
    }
}

impl std::str::FromStr for UnavailableAccessIndicationAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "3GA_UNAVAILABLE" => {
                std::result::Result::Ok(UnavailableAccessIndicationAnyOf::Variant3GaUnavailable)
            }
            "N3GA_UNAVAILABLE" => {
                std::result::Result::Ok(UnavailableAccessIndicationAnyOf::N3GaUnavailable)
            }
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// User Plane Connection State. Possible values are - ACTIVATED - DEACTIVATED - ACTIVATING - SUSPENDED
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpCnxState {}

impl UpCnxState {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpCnxState {
        UpCnxState {}
    }
}

/// Converts the UpCnxState value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpCnxState {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpCnxState value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpCnxState {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UpCnxState".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UpCnxState".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpCnxState {})
    }
}

// Methods for converting between header::IntoHeaderValue<UpCnxState> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpCnxState>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UpCnxState>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UpCnxState - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpCnxState> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UpCnxState as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UpCnxState - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum UpCnxStateAnyOf {
    #[serde(rename = "ACTIVATED")]
    Activated,
    #[serde(rename = "DEACTIVATED")]
    Deactivated,
    #[serde(rename = "ACTIVATING")]
    Activating,
    #[serde(rename = "SUSPENDED")]
    Suspended,
}

impl std::fmt::Display for UpCnxStateAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            UpCnxStateAnyOf::Activated => write!(f, "ACTIVATED"),
            UpCnxStateAnyOf::Deactivated => write!(f, "DEACTIVATED"),
            UpCnxStateAnyOf::Activating => write!(f, "ACTIVATING"),
            UpCnxStateAnyOf::Suspended => write!(f, "SUSPENDED"),
        }
    }
}

impl std::str::FromStr for UpCnxStateAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ACTIVATED" => std::result::Result::Ok(UpCnxStateAnyOf::Activated),
            "DEACTIVATED" => std::result::Result::Ok(UpCnxStateAnyOf::Deactivated),
            "ACTIVATING" => std::result::Result::Ok(UpCnxStateAnyOf::Activating),
            "SUSPENDED" => std::result::Result::Ok(UpCnxStateAnyOf::Suspended),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// indicates whether UP confidentiality protection is required, preferred or not needed for all the traffic on the PDU Session. It shall comply with the provisions defined in table 5.4.3.5-1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpConfidentiality {}

impl UpConfidentiality {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpConfidentiality {
        UpConfidentiality {}
    }
}

/// Converts the UpConfidentiality value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpConfidentiality {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpConfidentiality value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpConfidentiality {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UpConfidentiality".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UpConfidentiality".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpConfidentiality {})
    }
}

// Methods for converting between header::IntoHeaderValue<UpConfidentiality> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpConfidentiality>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UpConfidentiality>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UpConfidentiality - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<UpConfidentiality>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UpConfidentiality as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UpConfidentiality - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// indicates whether UP integrity protection is required, preferred or not needed for all the traffic on the PDU Session. It shall comply with the provisions defined in  table 5.4.3.4-1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpIntegrity {}

impl UpIntegrity {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpIntegrity {
        UpIntegrity {}
    }
}

/// Converts the UpIntegrity value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpIntegrity {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpIntegrity value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpIntegrity {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UpIntegrity".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UpIntegrity".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpIntegrity {})
    }
}

// Methods for converting between header::IntoHeaderValue<UpIntegrity> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpIntegrity>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UpIntegrity>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UpIntegrity - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpIntegrity> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UpIntegrity as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UpIntegrity - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum UpIntegrityAnyOf {
    #[serde(rename = "REQUIRED")]
    Required,
    #[serde(rename = "PREFERRED")]
    Preferred,
    #[serde(rename = "NOT_NEEDED")]
    NotNeeded,
}

impl std::fmt::Display for UpIntegrityAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            UpIntegrityAnyOf::Required => write!(f, "REQUIRED"),
            UpIntegrityAnyOf::Preferred => write!(f, "PREFERRED"),
            UpIntegrityAnyOf::NotNeeded => write!(f, "NOT_NEEDED"),
        }
    }
}

impl std::str::FromStr for UpIntegrityAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "REQUIRED" => std::result::Result::Ok(UpIntegrityAnyOf::Required),
            "PREFERRED" => std::result::Result::Ok(UpIntegrityAnyOf::Preferred),
            "NOT_NEEDED" => std::result::Result::Ok(UpIntegrityAnyOf::NotNeeded),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Contains Userplain security information.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpSecurity {
    #[serde(rename = "upIntegr")]
    pub up_integr: models::UpIntegrity,

    #[serde(rename = "upConfid")]
    pub up_confid: models::UpConfidentiality,
}

impl UpSecurity {
    #[allow(clippy::new_without_default)]
    pub fn new(up_integr: models::UpIntegrity, up_confid: models::UpConfidentiality) -> UpSecurity {
        UpSecurity {
            up_integr,
            up_confid,
        }
    }
}

/// Converts the UpSecurity value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpSecurity {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping upIntegr in query parameter serialization

            // Skipping upConfid in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpSecurity value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpSecurity {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub up_integr: Vec<models::UpIntegrity>,
            pub up_confid: Vec<models::UpConfidentiality>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UpSecurity".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "upIntegr" => intermediate_rep.up_integr.push(
                        <models::UpIntegrity as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "upConfid" => intermediate_rep.up_confid.push(
                        <models::UpConfidentiality as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UpSecurity".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpSecurity {
            up_integr: intermediate_rep
                .up_integr
                .into_iter()
                .next()
                .ok_or_else(|| "upIntegr missing in UpSecurity".to_string())?,
            up_confid: intermediate_rep
                .up_confid
                .into_iter()
                .next()
                .ok_or_else(|| "upConfid missing in UpSecurity".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpSecurity> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpSecurity>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UpSecurity>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UpSecurity - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpSecurity> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UpSecurity as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UpSecurity - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// User Plane Security Information
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpSecurityInfo {
    #[serde(rename = "upSecurity")]
    pub up_security: models::UpSecurity,

    #[serde(rename = "maxIntegrityProtectedDataRateUl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_integrity_protected_data_rate_ul: Option<models::MaxIntegrityProtectedDataRate>,

    #[serde(rename = "maxIntegrityProtectedDataRateDl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_integrity_protected_data_rate_dl: Option<models::MaxIntegrityProtectedDataRate>,

    #[serde(rename = "securityResult")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_result: Option<models::SecurityResult>,
}

impl UpSecurityInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(up_security: models::UpSecurity) -> UpSecurityInfo {
        UpSecurityInfo {
            up_security,
            max_integrity_protected_data_rate_ul: None,
            max_integrity_protected_data_rate_dl: None,
            security_result: None,
        }
    }
}

/// Converts the UpSecurityInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpSecurityInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping upSecurity in query parameter serialization

            // Skipping maxIntegrityProtectedDataRateUl in query parameter serialization

            // Skipping maxIntegrityProtectedDataRateDl in query parameter serialization

            // Skipping securityResult in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpSecurityInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpSecurityInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub up_security: Vec<models::UpSecurity>,
            pub max_integrity_protected_data_rate_ul: Vec<models::MaxIntegrityProtectedDataRate>,
            pub max_integrity_protected_data_rate_dl: Vec<models::MaxIntegrityProtectedDataRate>,
            pub security_result: Vec<models::SecurityResult>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UpSecurityInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "upSecurity" => intermediate_rep.up_security.push(
                        <models::UpSecurity as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "maxIntegrityProtectedDataRateUl" => {
                        intermediate_rep.max_integrity_protected_data_rate_ul.push(
                            <models::MaxIntegrityProtectedDataRate as std::str::FromStr>::from_str(
                                val,
                            )
                            .map_err(|x| x.to_string())?,
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "maxIntegrityProtectedDataRateDl" => {
                        intermediate_rep.max_integrity_protected_data_rate_dl.push(
                            <models::MaxIntegrityProtectedDataRate as std::str::FromStr>::from_str(
                                val,
                            )
                            .map_err(|x| x.to_string())?,
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "securityResult" => intermediate_rep.security_result.push(
                        <models::SecurityResult as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UpSecurityInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpSecurityInfo {
            up_security: intermediate_rep
                .up_security
                .into_iter()
                .next()
                .ok_or_else(|| "upSecurity missing in UpSecurityInfo".to_string())?,
            max_integrity_protected_data_rate_ul: intermediate_rep
                .max_integrity_protected_data_rate_ul
                .into_iter()
                .next(),
            max_integrity_protected_data_rate_dl: intermediate_rep
                .max_integrity_protected_data_rate_dl
                .into_iter()
                .next(),
            security_result: intermediate_rep.security_result.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpSecurityInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpSecurityInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UpSecurityInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UpSecurityInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpSecurityInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UpSecurityInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UpSecurityInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdatePduSession200Response {
    #[serde(rename = "jsonData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub json_data: Option<models::HsmfUpdatedData>,

    #[serde(rename = "binaryDataN1SmInfoToUe")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub binary_data_n1_sm_info_to_ue: Option<swagger::ByteArray>,

    #[serde(rename = "binaryDataN4Information")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub binary_data_n4_information: Option<swagger::ByteArray>,

    #[serde(rename = "binaryDataN4InformationExt1")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub binary_data_n4_information_ext1: Option<swagger::ByteArray>,

    #[serde(rename = "binaryDataN4InformationExt2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub binary_data_n4_information_ext2: Option<swagger::ByteArray>,
}

impl UpdatePduSession200Response {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdatePduSession200Response {
        UpdatePduSession200Response {
            json_data: None,
            binary_data_n1_sm_info_to_ue: None,
            binary_data_n4_information: None,
            binary_data_n4_information_ext1: None,
            binary_data_n4_information_ext2: None,
        }
    }
}

/// Converts the UpdatePduSession200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdatePduSession200Response {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping jsonData in query parameter serialization

            // Skipping binaryDataN1SmInfoToUe in query parameter serialization
            // Skipping binaryDataN1SmInfoToUe in query parameter serialization

            // Skipping binaryDataN4Information in query parameter serialization
            // Skipping binaryDataN4Information in query parameter serialization

            // Skipping binaryDataN4InformationExt1 in query parameter serialization
            // Skipping binaryDataN4InformationExt1 in query parameter serialization

            // Skipping binaryDataN4InformationExt2 in query parameter serialization
            // Skipping binaryDataN4InformationExt2 in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdatePduSession200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdatePduSession200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub json_data: Vec<models::HsmfUpdatedData>,
            pub binary_data_n1_sm_info_to_ue: Vec<swagger::ByteArray>,
            pub binary_data_n4_information: Vec<swagger::ByteArray>,
            pub binary_data_n4_information_ext1: Vec<swagger::ByteArray>,
            pub binary_data_n4_information_ext2: Vec<swagger::ByteArray>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UpdatePduSession200Response".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "jsonData" => intermediate_rep.json_data.push(<models::HsmfUpdatedData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "binaryDataN1SmInfoToUe" => return std::result::Result::Err("Parsing binary data in this style is not supported in UpdatePduSession200Response".to_string()),
                    "binaryDataN4Information" => return std::result::Result::Err("Parsing binary data in this style is not supported in UpdatePduSession200Response".to_string()),
                    "binaryDataN4InformationExt1" => return std::result::Result::Err("Parsing binary data in this style is not supported in UpdatePduSession200Response".to_string()),
                    "binaryDataN4InformationExt2" => return std::result::Result::Err("Parsing binary data in this style is not supported in UpdatePduSession200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdatePduSession200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdatePduSession200Response {
            json_data: intermediate_rep.json_data.into_iter().next(),
            binary_data_n1_sm_info_to_ue: intermediate_rep
                .binary_data_n1_sm_info_to_ue
                .into_iter()
                .next(),
            binary_data_n4_information: intermediate_rep
                .binary_data_n4_information
                .into_iter()
                .next(),
            binary_data_n4_information_ext1: intermediate_rep
                .binary_data_n4_information_ext1
                .into_iter()
                .next(),
            binary_data_n4_information_ext2: intermediate_rep
                .binary_data_n4_information_ext2
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdatePduSession200Response> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdatePduSession200Response>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UpdatePduSession200Response>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UpdatePduSession200Response - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<UpdatePduSession200Response>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UpdatePduSession200Response as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UpdatePduSession200Response - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdatePduSession400Response {
    #[serde(rename = "jsonData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub json_data: Option<models::HsmfUpdateError>,

    #[serde(rename = "binaryDataN1SmInfoToUe")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub binary_data_n1_sm_info_to_ue: Option<swagger::ByteArray>,
}

impl UpdatePduSession400Response {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdatePduSession400Response {
        UpdatePduSession400Response {
            json_data: None,
            binary_data_n1_sm_info_to_ue: None,
        }
    }
}

/// Converts the UpdatePduSession400Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdatePduSession400Response {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping jsonData in query parameter serialization

            // Skipping binaryDataN1SmInfoToUe in query parameter serialization
            // Skipping binaryDataN1SmInfoToUe in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdatePduSession400Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdatePduSession400Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub json_data: Vec<models::HsmfUpdateError>,
            pub binary_data_n1_sm_info_to_ue: Vec<swagger::ByteArray>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UpdatePduSession400Response".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "jsonData" => intermediate_rep.json_data.push(<models::HsmfUpdateError as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "binaryDataN1SmInfoToUe" => return std::result::Result::Err("Parsing binary data in this style is not supported in UpdatePduSession400Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdatePduSession400Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdatePduSession400Response {
            json_data: intermediate_rep.json_data.into_iter().next(),
            binary_data_n1_sm_info_to_ue: intermediate_rep
                .binary_data_n1_sm_info_to_ue
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdatePduSession400Response> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdatePduSession400Response>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UpdatePduSession400Response>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UpdatePduSession400Response - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<UpdatePduSession400Response>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UpdatePduSession400Response as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UpdatePduSession400Response - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdatePduSessionRequest {
    #[serde(rename = "jsonData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub json_data: Option<models::HsmfUpdateData>,

    #[serde(rename = "binaryDataN1SmInfoFromUe")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub binary_data_n1_sm_info_from_ue: Option<swagger::ByteArray>,

    #[serde(rename = "binaryDataUnknownN1SmInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub binary_data_unknown_n1_sm_info: Option<swagger::ByteArray>,

    #[serde(rename = "binaryDataN4Information")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub binary_data_n4_information: Option<swagger::ByteArray>,

    #[serde(rename = "binaryDataN4InformationExt1")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub binary_data_n4_information_ext1: Option<swagger::ByteArray>,

    #[serde(rename = "binaryDataN4InformationExt2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub binary_data_n4_information_ext2: Option<swagger::ByteArray>,
}

impl UpdatePduSessionRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdatePduSessionRequest {
        UpdatePduSessionRequest {
            json_data: None,
            binary_data_n1_sm_info_from_ue: None,
            binary_data_unknown_n1_sm_info: None,
            binary_data_n4_information: None,
            binary_data_n4_information_ext1: None,
            binary_data_n4_information_ext2: None,
        }
    }
}

/// Converts the UpdatePduSessionRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdatePduSessionRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping jsonData in query parameter serialization

            // Skipping binaryDataN1SmInfoFromUe in query parameter serialization
            // Skipping binaryDataN1SmInfoFromUe in query parameter serialization

            // Skipping binaryDataUnknownN1SmInfo in query parameter serialization
            // Skipping binaryDataUnknownN1SmInfo in query parameter serialization

            // Skipping binaryDataN4Information in query parameter serialization
            // Skipping binaryDataN4Information in query parameter serialization

            // Skipping binaryDataN4InformationExt1 in query parameter serialization
            // Skipping binaryDataN4InformationExt1 in query parameter serialization

            // Skipping binaryDataN4InformationExt2 in query parameter serialization
            // Skipping binaryDataN4InformationExt2 in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdatePduSessionRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdatePduSessionRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub json_data: Vec<models::HsmfUpdateData>,
            pub binary_data_n1_sm_info_from_ue: Vec<swagger::ByteArray>,
            pub binary_data_unknown_n1_sm_info: Vec<swagger::ByteArray>,
            pub binary_data_n4_information: Vec<swagger::ByteArray>,
            pub binary_data_n4_information_ext1: Vec<swagger::ByteArray>,
            pub binary_data_n4_information_ext2: Vec<swagger::ByteArray>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UpdatePduSessionRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "jsonData" => intermediate_rep.json_data.push(<models::HsmfUpdateData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "binaryDataN1SmInfoFromUe" => return std::result::Result::Err("Parsing binary data in this style is not supported in UpdatePduSessionRequest".to_string()),
                    "binaryDataUnknownN1SmInfo" => return std::result::Result::Err("Parsing binary data in this style is not supported in UpdatePduSessionRequest".to_string()),
                    "binaryDataN4Information" => return std::result::Result::Err("Parsing binary data in this style is not supported in UpdatePduSessionRequest".to_string()),
                    "binaryDataN4InformationExt1" => return std::result::Result::Err("Parsing binary data in this style is not supported in UpdatePduSessionRequest".to_string()),
                    "binaryDataN4InformationExt2" => return std::result::Result::Err("Parsing binary data in this style is not supported in UpdatePduSessionRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdatePduSessionRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdatePduSessionRequest {
            json_data: intermediate_rep.json_data.into_iter().next(),
            binary_data_n1_sm_info_from_ue: intermediate_rep
                .binary_data_n1_sm_info_from_ue
                .into_iter()
                .next(),
            binary_data_unknown_n1_sm_info: intermediate_rep
                .binary_data_unknown_n1_sm_info
                .into_iter()
                .next(),
            binary_data_n4_information: intermediate_rep
                .binary_data_n4_information
                .into_iter()
                .next(),
            binary_data_n4_information_ext1: intermediate_rep
                .binary_data_n4_information_ext1
                .into_iter()
                .next(),
            binary_data_n4_information_ext2: intermediate_rep
                .binary_data_n4_information_ext2
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdatePduSessionRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdatePduSessionRequest>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UpdatePduSessionRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UpdatePduSessionRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<UpdatePduSessionRequest>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UpdatePduSessionRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UpdatePduSessionRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateSmContext200Response {
    #[serde(rename = "jsonData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub json_data: Option<models::SmContextUpdatedData>,

    #[serde(rename = "binaryDataN1SmMessage")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub binary_data_n1_sm_message: Option<swagger::ByteArray>,

    #[serde(rename = "binaryDataN2SmInformation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub binary_data_n2_sm_information: Option<swagger::ByteArray>,
}

impl UpdateSmContext200Response {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateSmContext200Response {
        UpdateSmContext200Response {
            json_data: None,
            binary_data_n1_sm_message: None,
            binary_data_n2_sm_information: None,
        }
    }
}

/// Converts the UpdateSmContext200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateSmContext200Response {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping jsonData in query parameter serialization

            // Skipping binaryDataN1SmMessage in query parameter serialization
            // Skipping binaryDataN1SmMessage in query parameter serialization

            // Skipping binaryDataN2SmInformation in query parameter serialization
            // Skipping binaryDataN2SmInformation in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateSmContext200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateSmContext200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub json_data: Vec<models::SmContextUpdatedData>,
            pub binary_data_n1_sm_message: Vec<swagger::ByteArray>,
            pub binary_data_n2_sm_information: Vec<swagger::ByteArray>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UpdateSmContext200Response".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "jsonData" => intermediate_rep.json_data.push(<models::SmContextUpdatedData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "binaryDataN1SmMessage" => return std::result::Result::Err("Parsing binary data in this style is not supported in UpdateSmContext200Response".to_string()),
                    "binaryDataN2SmInformation" => return std::result::Result::Err("Parsing binary data in this style is not supported in UpdateSmContext200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateSmContext200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateSmContext200Response {
            json_data: intermediate_rep.json_data.into_iter().next(),
            binary_data_n1_sm_message: intermediate_rep
                .binary_data_n1_sm_message
                .into_iter()
                .next(),
            binary_data_n2_sm_information: intermediate_rep
                .binary_data_n2_sm_information
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateSmContext200Response> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateSmContext200Response>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UpdateSmContext200Response>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UpdateSmContext200Response - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<UpdateSmContext200Response>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UpdateSmContext200Response as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UpdateSmContext200Response - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateSmContext400Response {
    #[serde(rename = "jsonData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub json_data: Option<models::SmContextUpdateError>,

    #[serde(rename = "binaryDataN1SmMessage")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub binary_data_n1_sm_message: Option<swagger::ByteArray>,

    #[serde(rename = "binaryDataN2SmInformation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub binary_data_n2_sm_information: Option<swagger::ByteArray>,
}

impl UpdateSmContext400Response {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateSmContext400Response {
        UpdateSmContext400Response {
            json_data: None,
            binary_data_n1_sm_message: None,
            binary_data_n2_sm_information: None,
        }
    }
}

/// Converts the UpdateSmContext400Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateSmContext400Response {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping jsonData in query parameter serialization

            // Skipping binaryDataN1SmMessage in query parameter serialization
            // Skipping binaryDataN1SmMessage in query parameter serialization

            // Skipping binaryDataN2SmInformation in query parameter serialization
            // Skipping binaryDataN2SmInformation in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateSmContext400Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateSmContext400Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub json_data: Vec<models::SmContextUpdateError>,
            pub binary_data_n1_sm_message: Vec<swagger::ByteArray>,
            pub binary_data_n2_sm_information: Vec<swagger::ByteArray>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UpdateSmContext400Response".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "jsonData" => intermediate_rep.json_data.push(<models::SmContextUpdateError as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "binaryDataN1SmMessage" => return std::result::Result::Err("Parsing binary data in this style is not supported in UpdateSmContext400Response".to_string()),
                    "binaryDataN2SmInformation" => return std::result::Result::Err("Parsing binary data in this style is not supported in UpdateSmContext400Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateSmContext400Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateSmContext400Response {
            json_data: intermediate_rep.json_data.into_iter().next(),
            binary_data_n1_sm_message: intermediate_rep
                .binary_data_n1_sm_message
                .into_iter()
                .next(),
            binary_data_n2_sm_information: intermediate_rep
                .binary_data_n2_sm_information
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateSmContext400Response> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateSmContext400Response>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UpdateSmContext400Response>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UpdateSmContext400Response - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<UpdateSmContext400Response>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UpdateSmContext400Response as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UpdateSmContext400Response - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateSmContextRequest {
    #[serde(rename = "jsonData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub json_data: Option<models::SmContextUpdateData>,

    #[serde(rename = "binaryDataN1SmMessage")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub binary_data_n1_sm_message: Option<swagger::ByteArray>,

    #[serde(rename = "binaryDataN2SmInformation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub binary_data_n2_sm_information: Option<swagger::ByteArray>,

    #[serde(rename = "binaryDataN2SmInformationExt1")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub binary_data_n2_sm_information_ext1: Option<swagger::ByteArray>,
}

impl UpdateSmContextRequest {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpdateSmContextRequest {
        UpdateSmContextRequest {
            json_data: None,
            binary_data_n1_sm_message: None,
            binary_data_n2_sm_information: None,
            binary_data_n2_sm_information_ext1: None,
        }
    }
}

/// Converts the UpdateSmContextRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpdateSmContextRequest {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping jsonData in query parameter serialization

            // Skipping binaryDataN1SmMessage in query parameter serialization
            // Skipping binaryDataN1SmMessage in query parameter serialization

            // Skipping binaryDataN2SmInformation in query parameter serialization
            // Skipping binaryDataN2SmInformation in query parameter serialization

            // Skipping binaryDataN2SmInformationExt1 in query parameter serialization
            // Skipping binaryDataN2SmInformationExt1 in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateSmContextRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateSmContextRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub json_data: Vec<models::SmContextUpdateData>,
            pub binary_data_n1_sm_message: Vec<swagger::ByteArray>,
            pub binary_data_n2_sm_information: Vec<swagger::ByteArray>,
            pub binary_data_n2_sm_information_ext1: Vec<swagger::ByteArray>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UpdateSmContextRequest".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "jsonData" => intermediate_rep.json_data.push(<models::SmContextUpdateData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "binaryDataN1SmMessage" => return std::result::Result::Err("Parsing binary data in this style is not supported in UpdateSmContextRequest".to_string()),
                    "binaryDataN2SmInformation" => return std::result::Result::Err("Parsing binary data in this style is not supported in UpdateSmContextRequest".to_string()),
                    "binaryDataN2SmInformationExt1" => return std::result::Result::Err("Parsing binary data in this style is not supported in UpdateSmContextRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateSmContextRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateSmContextRequest {
            json_data: intermediate_rep.json_data.into_iter().next(),
            binary_data_n1_sm_message: intermediate_rep
                .binary_data_n1_sm_message
                .into_iter()
                .next(),
            binary_data_n2_sm_information: intermediate_rep
                .binary_data_n2_sm_information
                .into_iter()
                .next(),
            binary_data_n2_sm_information_ext1: intermediate_rep
                .binary_data_n2_sm_information_ext1
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateSmContextRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateSmContextRequest>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UpdateSmContextRequest>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UpdateSmContextRequest - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<UpdateSmContextRequest>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UpdateSmContextRequest as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UpdateSmContextRequest - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// String providing an URI formatted according to RFC 3986.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Uri(String);

impl std::convert::From<String> for Uri {
    fn from(x: String) -> Self {
        Uri(x)
    }
}

impl std::string::ToString for Uri {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Uri {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Uri(x.to_string()))
    }
}

impl std::convert::From<Uri> for String {
    fn from(x: Uri) -> Self {
        x.0
    }
}

impl std::ops::Deref for Uri {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Uri {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// At least one of eutraLocation, nrLocation and n3gaLocation shall be present. Several of them may be present.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UserLocation {
    #[serde(rename = "eutraLocation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub eutra_location: Option<models::EutraLocation>,

    #[serde(rename = "nrLocation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nr_location: Option<models::NrLocation>,

    #[serde(rename = "n3gaLocation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n3ga_location: Option<models::N3gaLocation>,

    #[serde(rename = "utraLocation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub utra_location: Option<models::UtraLocation>,

    #[serde(rename = "geraLocation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gera_location: Option<models::GeraLocation>,
}

impl UserLocation {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UserLocation {
        UserLocation {
            eutra_location: None,
            nr_location: None,
            n3ga_location: None,
            utra_location: None,
            gera_location: None,
        }
    }
}

/// Converts the UserLocation value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UserLocation {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping eutraLocation in query parameter serialization

            // Skipping nrLocation in query parameter serialization

            // Skipping n3gaLocation in query parameter serialization

            // Skipping utraLocation in query parameter serialization

            // Skipping geraLocation in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UserLocation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UserLocation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub eutra_location: Vec<models::EutraLocation>,
            pub nr_location: Vec<models::NrLocation>,
            pub n3ga_location: Vec<models::N3gaLocation>,
            pub utra_location: Vec<models::UtraLocation>,
            pub gera_location: Vec<models::GeraLocation>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UserLocation".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "eutraLocation" => intermediate_rep.eutra_location.push(
                        <models::EutraLocation as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nrLocation" => intermediate_rep.nr_location.push(
                        <models::NrLocation as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n3gaLocation" => intermediate_rep.n3ga_location.push(
                        <models::N3gaLocation as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "utraLocation" => intermediate_rep.utra_location.push(
                        <models::UtraLocation as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "geraLocation" => intermediate_rep.gera_location.push(
                        <models::GeraLocation as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UserLocation".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UserLocation {
            eutra_location: intermediate_rep.eutra_location.into_iter().next(),
            nr_location: intermediate_rep.nr_location.into_iter().next(),
            n3ga_location: intermediate_rep.n3ga_location.into_iter().next(),
            utra_location: intermediate_rep.utra_location.into_iter().next(),
            gera_location: intermediate_rep.gera_location.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UserLocation> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UserLocation>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UserLocation>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UserLocation - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UserLocation> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UserLocation as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UserLocation - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Exactly one of cgi, sai or lai shall be present.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UtraLocation {
    #[serde(rename = "cgi")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cgi: Option<models::CellGlobalId>,

    #[serde(rename = "sai")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sai: Option<models::ServiceAreaId>,

    #[serde(rename = "lai")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lai: Option<models::LocationAreaId>,

    #[serde(rename = "rai")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rai: Option<models::RoutingAreaId>,

    /// The value represents the elapsed time in minutes since the last network contact of the mobile station.  Value \"0\" indicates that the location information was obtained after a successful paging procedure for  Active Location Retrieval when the UE is in idle mode  or after a successful location reporting procedure  the UE is in connected mode. Any other value than \"0\" indicates that the location information is the last known one.  See 3GPP TS 29.002 clause 17.7.8.
    #[serde(rename = "ageOfLocationInformation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub age_of_location_information: Option<u16>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "ueLocationTimestamp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_location_timestamp: Option<chrono::DateTime<chrono::Utc>>,

    /// Refer to geographical Information.See 3GPP TS 23.032 clause 7.3.2. Only the description of an ellipsoid point with uncertainty circle is allowed to be used.
    #[serde(rename = "geographicalInformation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub geographical_information: Option<String>,

    /// Refers to Calling Geodetic Location. See ITU-T Recommendation Q.763 (1999) clause 3.88.2. Only the description of an ellipsoid point with uncertainty circle is allowed to be used.
    #[serde(rename = "geodeticInformation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub geodetic_information: Option<String>,
}

impl UtraLocation {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UtraLocation {
        UtraLocation {
            cgi: None,
            sai: None,
            lai: None,
            rai: None,
            age_of_location_information: None,
            ue_location_timestamp: None,
            geographical_information: None,
            geodetic_information: None,
        }
    }
}

/// Converts the UtraLocation value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UtraLocation {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping cgi in query parameter serialization

            // Skipping sai in query parameter serialization

            // Skipping lai in query parameter serialization

            // Skipping rai in query parameter serialization
            self.age_of_location_information
                .as_ref()
                .map(|age_of_location_information| {
                    vec![
                        "ageOfLocationInformation".to_string(),
                        age_of_location_information.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping ueLocationTimestamp in query parameter serialization
            self.geographical_information
                .as_ref()
                .map(|geographical_information| {
                    vec![
                        "geographicalInformation".to_string(),
                        geographical_information.to_string(),
                    ]
                    .join(",")
                }),
            self.geodetic_information
                .as_ref()
                .map(|geodetic_information| {
                    vec![
                        "geodeticInformation".to_string(),
                        geodetic_information.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UtraLocation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UtraLocation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cgi: Vec<models::CellGlobalId>,
            pub sai: Vec<models::ServiceAreaId>,
            pub lai: Vec<models::LocationAreaId>,
            pub rai: Vec<models::RoutingAreaId>,
            pub age_of_location_information: Vec<u16>,
            pub ue_location_timestamp: Vec<chrono::DateTime<chrono::Utc>>,
            pub geographical_information: Vec<String>,
            pub geodetic_information: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UtraLocation".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "cgi" => intermediate_rep.cgi.push(
                        <models::CellGlobalId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "sai" => intermediate_rep.sai.push(
                        <models::ServiceAreaId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "lai" => intermediate_rep.lai.push(
                        <models::LocationAreaId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "rai" => intermediate_rep.rai.push(
                        <models::RoutingAreaId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ageOfLocationInformation" => {
                        intermediate_rep.age_of_location_information.push(
                            <u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "ueLocationTimestamp" => intermediate_rep.ue_location_timestamp.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "geographicalInformation" => intermediate_rep.geographical_information.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "geodeticInformation" => intermediate_rep.geodetic_information.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UtraLocation".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UtraLocation {
            cgi: intermediate_rep.cgi.into_iter().next(),
            sai: intermediate_rep.sai.into_iter().next(),
            lai: intermediate_rep.lai.into_iter().next(),
            rai: intermediate_rep.rai.into_iter().next(),
            age_of_location_information: intermediate_rep
                .age_of_location_information
                .into_iter()
                .next(),
            ue_location_timestamp: intermediate_rep.ue_location_timestamp.into_iter().next(),
            geographical_information: intermediate_rep.geographical_information.into_iter().next(),
            geodetic_information: intermediate_rep.geodetic_information.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UtraLocation> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UtraLocation>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UtraLocation>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UtraLocation - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UtraLocation> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UtraLocation as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UtraLocation - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains Usage data information.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VolumeTimedReport {
    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "startTimeStamp")]
    pub start_time_stamp: chrono::DateTime<chrono::Utc>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "endTimeStamp")]
    pub end_time_stamp: chrono::DateTime<chrono::Utc>,

    /// string with format 'int64' as defined in OpenAPI.
    #[serde(rename = "downlinkVolume")]
    pub downlink_volume: i64,

    /// string with format 'int64' as defined in OpenAPI.
    #[serde(rename = "uplinkVolume")]
    pub uplink_volume: i64,
}

impl VolumeTimedReport {
    #[allow(clippy::new_without_default)]
    pub fn new(
        start_time_stamp: chrono::DateTime<chrono::Utc>,
        end_time_stamp: chrono::DateTime<chrono::Utc>,
        downlink_volume: i64,
        uplink_volume: i64,
    ) -> VolumeTimedReport {
        VolumeTimedReport {
            start_time_stamp,
            end_time_stamp,
            downlink_volume,
            uplink_volume,
        }
    }
}

/// Converts the VolumeTimedReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for VolumeTimedReport {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping startTimeStamp in query parameter serialization

            // Skipping endTimeStamp in query parameter serialization
            Some("downlinkVolume".to_string()),
            Some(self.downlink_volume.to_string()),
            Some("uplinkVolume".to_string()),
            Some(self.uplink_volume.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VolumeTimedReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VolumeTimedReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub start_time_stamp: Vec<chrono::DateTime<chrono::Utc>>,
            pub end_time_stamp: Vec<chrono::DateTime<chrono::Utc>>,
            pub downlink_volume: Vec<i64>,
            pub uplink_volume: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing VolumeTimedReport".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "startTimeStamp" => intermediate_rep.start_time_stamp.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "endTimeStamp" => intermediate_rep.end_time_stamp.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "downlinkVolume" => intermediate_rep.downlink_volume.push(
                        <i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "uplinkVolume" => intermediate_rep.uplink_volume.push(
                        <i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing VolumeTimedReport".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VolumeTimedReport {
            start_time_stamp: intermediate_rep
                .start_time_stamp
                .into_iter()
                .next()
                .ok_or_else(|| "startTimeStamp missing in VolumeTimedReport".to_string())?,
            end_time_stamp: intermediate_rep
                .end_time_stamp
                .into_iter()
                .next()
                .ok_or_else(|| "endTimeStamp missing in VolumeTimedReport".to_string())?,
            downlink_volume: intermediate_rep
                .downlink_volume
                .into_iter()
                .next()
                .ok_or_else(|| "downlinkVolume missing in VolumeTimedReport".to_string())?,
            uplink_volume: intermediate_rep
                .uplink_volume
                .into_iter()
                .next()
                .ok_or_else(|| "uplinkVolume missing in VolumeTimedReport".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VolumeTimedReport> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<VolumeTimedReport>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<VolumeTimedReport>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for VolumeTimedReport - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<VolumeTimedReport>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <VolumeTimedReport as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into VolumeTimedReport - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// VPLMN QoS
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VplmnQos {
    /// Unsigned integer representing a 5G QoS Identifier (see clause 5.7.2.1 of 3GPP TS 23.501, within the range 0 to 255.
    #[serde(rename = "5qi")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub param_5qi: Option<u8>,

    #[serde(rename = "arp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub arp: Option<models::Arp>,

    #[serde(rename = "sessionAmbr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub session_ambr: Option<models::Ambr>,

    /// String representing a bit rate; the prefixes follow the standard symbols from The International System of Units, and represent x1000 multipliers, with the exception that prefix \"K\" is used to represent the standard symbol \"k\".
    #[serde(rename = "maxFbrDl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_fbr_dl: Option<String>,

    /// String representing a bit rate; the prefixes follow the standard symbols from The International System of Units, and represent x1000 multipliers, with the exception that prefix \"K\" is used to represent the standard symbol \"k\".
    #[serde(rename = "maxFbrUl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_fbr_ul: Option<String>,

    /// String representing a bit rate; the prefixes follow the standard symbols from The International System of Units, and represent x1000 multipliers, with the exception that prefix \"K\" is used to represent the standard symbol \"k\".
    #[serde(rename = "guaFbrDl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gua_fbr_dl: Option<String>,

    /// String representing a bit rate; the prefixes follow the standard symbols from The International System of Units, and represent x1000 multipliers, with the exception that prefix \"K\" is used to represent the standard symbol \"k\".
    #[serde(rename = "guaFbrUl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gua_fbr_ul: Option<String>,
}

impl VplmnQos {
    #[allow(clippy::new_without_default)]
    pub fn new() -> VplmnQos {
        VplmnQos {
            param_5qi: None,
            arp: None,
            session_ambr: None,
            max_fbr_dl: None,
            max_fbr_ul: None,
            gua_fbr_dl: None,
            gua_fbr_ul: None,
        }
    }
}

/// Converts the VplmnQos value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for VplmnQos {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.param_5qi
                .as_ref()
                .map(|param_5qi| vec!["5qi".to_string(), param_5qi.to_string()].join(",")),
            // Skipping arp in query parameter serialization

            // Skipping sessionAmbr in query parameter serialization
            self.max_fbr_dl
                .as_ref()
                .map(|max_fbr_dl| vec!["maxFbrDl".to_string(), max_fbr_dl.to_string()].join(",")),
            self.max_fbr_ul
                .as_ref()
                .map(|max_fbr_ul| vec!["maxFbrUl".to_string(), max_fbr_ul.to_string()].join(",")),
            self.gua_fbr_dl
                .as_ref()
                .map(|gua_fbr_dl| vec!["guaFbrDl".to_string(), gua_fbr_dl.to_string()].join(",")),
            self.gua_fbr_ul
                .as_ref()
                .map(|gua_fbr_ul| vec!["guaFbrUl".to_string(), gua_fbr_ul.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VplmnQos value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VplmnQos {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub param_5qi: Vec<u8>,
            pub arp: Vec<models::Arp>,
            pub session_ambr: Vec<models::Ambr>,
            pub max_fbr_dl: Vec<String>,
            pub max_fbr_ul: Vec<String>,
            pub gua_fbr_dl: Vec<String>,
            pub gua_fbr_ul: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing VplmnQos".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "5qi" => intermediate_rep
                        .param_5qi
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "arp" => intermediate_rep.arp.push(
                        <models::Arp as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "sessionAmbr" => intermediate_rep.session_ambr.push(
                        <models::Ambr as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "maxFbrDl" => intermediate_rep.max_fbr_dl.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "maxFbrUl" => intermediate_rep.max_fbr_ul.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "guaFbrDl" => intermediate_rep.gua_fbr_dl.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "guaFbrUl" => intermediate_rep.gua_fbr_ul.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing VplmnQos".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VplmnQos {
            param_5qi: intermediate_rep.param_5qi.into_iter().next(),
            arp: intermediate_rep.arp.into_iter().next(),
            session_ambr: intermediate_rep.session_ambr.into_iter().next(),
            max_fbr_dl: intermediate_rep.max_fbr_dl.into_iter().next(),
            max_fbr_ul: intermediate_rep.max_fbr_ul.into_iter().next(),
            gua_fbr_dl: intermediate_rep.gua_fbr_dl.into_iter().next(),
            gua_fbr_ul: intermediate_rep.gua_fbr_ul.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VplmnQos> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<VplmnQos>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<VplmnQos>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for VplmnQos - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<VplmnQos> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <VplmnQos as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into VplmnQos - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Data within Update Request towards V-SMF, or from SMF to I-SMF
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VsmfUpdateData {
    #[serde(rename = "requestIndication")]
    pub request_indication: models::RequestIndication,

    #[serde(rename = "sessionAmbr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub session_ambr: Option<models::Ambr>,

    #[serde(rename = "qosFlowsAddModRequestList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub qos_flows_add_mod_request_list: Option<Vec<models::QosFlowAddModifyRequestItem>>,

    #[serde(rename = "qosFlowsRelRequestList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub qos_flows_rel_request_list: Option<Vec<models::QosFlowReleaseRequestItem>>,

    #[serde(rename = "epsBearerInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub eps_bearer_info: Option<Vec<models::EpsBearerInfo>>,

    #[serde(rename = "assignEbiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assign_ebi_list: Option<Vec<models::Arp>>,

    #[serde(rename = "revokeEbiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub revoke_ebi_list: Option<Vec<models::EpsBearerId>>,

    #[serde(rename = "modifiedEbiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub modified_ebi_list: Option<Vec<models::EbiArpMapping>>,

    /// Procedure Transaction Identifier
    #[serde(rename = "pti")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pti: Option<u8>,

    #[serde(rename = "n1SmInfoToUe")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n1_sm_info_to_ue: Option<models::RefToBinaryData>,

    #[serde(rename = "alwaysOnGranted")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub always_on_granted: Option<bool>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "hsmfPduSessionUri")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hsmf_pdu_session_uri: Option<String>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "newSmfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub new_smf_id: Option<uuid::Uuid>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "newSmfPduSessionUri")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub new_smf_pdu_session_uri: Option<String>,

    /// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  table 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.
    #[serde(rename = "supportedFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_features: Option<String>,

    #[serde(rename = "cause")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cause: Option<models::Cause>,

    #[serde(rename = "n1smCause")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n1sm_cause: Option<String>,

    /// indicating a time in seconds.
    #[serde(rename = "backOffTimer")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub back_off_timer: Option<i32>,

    #[serde(rename = "maReleaseInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ma_release_ind: Option<models::MaReleaseIndication>,

    #[serde(rename = "maAcceptedInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ma_accepted_ind: Option<bool>,

    #[serde(rename = "additionalCnTunnelInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_cn_tunnel_info: Option<models::TunnelInfo>,

    #[serde(rename = "dnaiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dnai_list: Option<Vec<models::Dnai>>,

    #[serde(rename = "n4Info")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n4_info: Option<models::N4Information>,

    #[serde(rename = "n4InfoExt1")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n4_info_ext1: Option<models::N4Information>,

    #[serde(rename = "n4InfoExt2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n4_info_ext2: Option<models::N4Information>,

    #[serde(rename = "n4InfoExt3")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n4_info_ext3: Option<models::N4Information>,

    #[serde(rename = "smallDataRateControlEnabled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub small_data_rate_control_enabled: Option<bool>,

    #[serde(rename = "qosMonitoringInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub qos_monitoring_info: Option<models::QosMonitoringInfo>,

    #[serde(rename = "epsPdnCnxInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub eps_pdn_cnx_info: Option<models::EpsPdnCnxInfo>,

    #[serde(rename = "n9DataForwardingInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n9_data_forwarding_ind: Option<bool>,

    /// indicating a time in seconds.
    #[serde(rename = "n9InactivityTimer")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n9_inactivity_timer: Option<i32>,
}

impl VsmfUpdateData {
    #[allow(clippy::new_without_default)]
    pub fn new(request_indication: models::RequestIndication) -> VsmfUpdateData {
        VsmfUpdateData {
            request_indication,
            session_ambr: None,
            qos_flows_add_mod_request_list: None,
            qos_flows_rel_request_list: None,
            eps_bearer_info: None,
            assign_ebi_list: None,
            revoke_ebi_list: None,
            modified_ebi_list: None,
            pti: None,
            n1_sm_info_to_ue: None,
            always_on_granted: Some(false),
            hsmf_pdu_session_uri: None,
            new_smf_id: None,
            new_smf_pdu_session_uri: None,
            supported_features: None,
            cause: None,
            n1sm_cause: None,
            back_off_timer: None,
            ma_release_ind: None,
            ma_accepted_ind: Some(false),
            additional_cn_tunnel_info: None,
            dnai_list: None,
            n4_info: None,
            n4_info_ext1: None,
            n4_info_ext2: None,
            n4_info_ext3: None,
            small_data_rate_control_enabled: None,
            qos_monitoring_info: None,
            eps_pdn_cnx_info: None,
            n9_data_forwarding_ind: Some(false),
            n9_inactivity_timer: None,
        }
    }
}

/// Converts the VsmfUpdateData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for VsmfUpdateData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping requestIndication in query parameter serialization

            // Skipping sessionAmbr in query parameter serialization

            // Skipping qosFlowsAddModRequestList in query parameter serialization

            // Skipping qosFlowsRelRequestList in query parameter serialization

            // Skipping epsBearerInfo in query parameter serialization

            // Skipping assignEbiList in query parameter serialization
            self.revoke_ebi_list.as_ref().map(|revoke_ebi_list| {
                vec![
                    "revokeEbiList".to_string(),
                    revoke_ebi_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping modifiedEbiList in query parameter serialization
            self.pti
                .as_ref()
                .map(|pti| vec!["pti".to_string(), pti.to_string()].join(",")),
            // Skipping n1SmInfoToUe in query parameter serialization
            self.always_on_granted.as_ref().map(|always_on_granted| {
                vec!["alwaysOnGranted".to_string(), always_on_granted.to_string()].join(",")
            }),
            self.hsmf_pdu_session_uri
                .as_ref()
                .map(|hsmf_pdu_session_uri| {
                    vec![
                        "hsmfPduSessionUri".to_string(),
                        hsmf_pdu_session_uri.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping newSmfId in query parameter serialization
            self.new_smf_pdu_session_uri
                .as_ref()
                .map(|new_smf_pdu_session_uri| {
                    vec![
                        "newSmfPduSessionUri".to_string(),
                        new_smf_pdu_session_uri.to_string(),
                    ]
                    .join(",")
                }),
            self.supported_features.as_ref().map(|supported_features| {
                vec![
                    "supportedFeatures".to_string(),
                    supported_features.to_string(),
                ]
                .join(",")
            }),
            // Skipping cause in query parameter serialization
            self.n1sm_cause
                .as_ref()
                .map(|n1sm_cause| vec!["n1smCause".to_string(), n1sm_cause.to_string()].join(",")),
            self.back_off_timer.as_ref().map(|back_off_timer| {
                vec!["backOffTimer".to_string(), back_off_timer.to_string()].join(",")
            }),
            // Skipping maReleaseInd in query parameter serialization
            self.ma_accepted_ind.as_ref().map(|ma_accepted_ind| {
                vec!["maAcceptedInd".to_string(), ma_accepted_ind.to_string()].join(",")
            }),
            // Skipping additionalCnTunnelInfo in query parameter serialization
            self.dnai_list.as_ref().map(|dnai_list| {
                vec![
                    "dnaiList".to_string(),
                    dnai_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping n4Info in query parameter serialization

            // Skipping n4InfoExt1 in query parameter serialization

            // Skipping n4InfoExt2 in query parameter serialization

            // Skipping n4InfoExt3 in query parameter serialization
            self.small_data_rate_control_enabled
                .as_ref()
                .map(|small_data_rate_control_enabled| {
                    vec![
                        "smallDataRateControlEnabled".to_string(),
                        small_data_rate_control_enabled.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping qosMonitoringInfo in query parameter serialization

            // Skipping epsPdnCnxInfo in query parameter serialization
            self.n9_data_forwarding_ind
                .as_ref()
                .map(|n9_data_forwarding_ind| {
                    vec![
                        "n9DataForwardingInd".to_string(),
                        n9_data_forwarding_ind.to_string(),
                    ]
                    .join(",")
                }),
            self.n9_inactivity_timer
                .as_ref()
                .map(|n9_inactivity_timer| {
                    vec![
                        "n9InactivityTimer".to_string(),
                        n9_inactivity_timer.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VsmfUpdateData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VsmfUpdateData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub request_indication: Vec<models::RequestIndication>,
            pub session_ambr: Vec<models::Ambr>,
            pub qos_flows_add_mod_request_list: Vec<Vec<models::QosFlowAddModifyRequestItem>>,
            pub qos_flows_rel_request_list: Vec<Vec<models::QosFlowReleaseRequestItem>>,
            pub eps_bearer_info: Vec<Vec<models::EpsBearerInfo>>,
            pub assign_ebi_list: Vec<Vec<models::Arp>>,
            pub revoke_ebi_list: Vec<Vec<models::EpsBearerId>>,
            pub modified_ebi_list: Vec<Vec<models::EbiArpMapping>>,
            pub pti: Vec<u8>,
            pub n1_sm_info_to_ue: Vec<models::RefToBinaryData>,
            pub always_on_granted: Vec<bool>,
            pub hsmf_pdu_session_uri: Vec<String>,
            pub new_smf_id: Vec<uuid::Uuid>,
            pub new_smf_pdu_session_uri: Vec<String>,
            pub supported_features: Vec<String>,
            pub cause: Vec<models::Cause>,
            pub n1sm_cause: Vec<String>,
            pub back_off_timer: Vec<i32>,
            pub ma_release_ind: Vec<models::MaReleaseIndication>,
            pub ma_accepted_ind: Vec<bool>,
            pub additional_cn_tunnel_info: Vec<models::TunnelInfo>,
            pub dnai_list: Vec<Vec<models::Dnai>>,
            pub n4_info: Vec<models::N4Information>,
            pub n4_info_ext1: Vec<models::N4Information>,
            pub n4_info_ext2: Vec<models::N4Information>,
            pub n4_info_ext3: Vec<models::N4Information>,
            pub small_data_rate_control_enabled: Vec<bool>,
            pub qos_monitoring_info: Vec<models::QosMonitoringInfo>,
            pub eps_pdn_cnx_info: Vec<models::EpsPdnCnxInfo>,
            pub n9_data_forwarding_ind: Vec<bool>,
            pub n9_inactivity_timer: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing VsmfUpdateData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "requestIndication" => intermediate_rep.request_indication.push(
                        <models::RequestIndication as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "sessionAmbr" => intermediate_rep.session_ambr.push(
                        <models::Ambr as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "qosFlowsAddModRequestList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in VsmfUpdateData"
                                .to_string(),
                        )
                    }
                    "qosFlowsRelRequestList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in VsmfUpdateData"
                                .to_string(),
                        )
                    }
                    "epsBearerInfo" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in VsmfUpdateData"
                                .to_string(),
                        )
                    }
                    "assignEbiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in VsmfUpdateData"
                                .to_string(),
                        )
                    }
                    "revokeEbiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in VsmfUpdateData"
                                .to_string(),
                        )
                    }
                    "modifiedEbiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in VsmfUpdateData"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "pti" => intermediate_rep
                        .pti
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "n1SmInfoToUe" => intermediate_rep.n1_sm_info_to_ue.push(
                        <models::RefToBinaryData as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "alwaysOnGranted" => intermediate_rep.always_on_granted.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "hsmfPduSessionUri" => intermediate_rep.hsmf_pdu_session_uri.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "newSmfId" => intermediate_rep.new_smf_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "newSmfPduSessionUri" => intermediate_rep.new_smf_pdu_session_uri.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "supportedFeatures" => intermediate_rep.supported_features.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "cause" => intermediate_rep.cause.push(
                        <models::Cause as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n1smCause" => intermediate_rep.n1sm_cause.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "backOffTimer" => intermediate_rep.back_off_timer.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "maReleaseInd" => intermediate_rep.ma_release_ind.push(
                        <models::MaReleaseIndication as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "maAcceptedInd" => intermediate_rep.ma_accepted_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "additionalCnTunnelInfo" => intermediate_rep.additional_cn_tunnel_info.push(
                        <models::TunnelInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "dnaiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in VsmfUpdateData"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "n4Info" => intermediate_rep.n4_info.push(
                        <models::N4Information as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n4InfoExt1" => intermediate_rep.n4_info_ext1.push(
                        <models::N4Information as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n4InfoExt2" => intermediate_rep.n4_info_ext2.push(
                        <models::N4Information as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n4InfoExt3" => intermediate_rep.n4_info_ext3.push(
                        <models::N4Information as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "smallDataRateControlEnabled" => {
                        intermediate_rep.small_data_rate_control_enabled.push(
                            <bool as std::str::FromStr>::from_str(val)
                                .map_err(|x| x.to_string())?,
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "qosMonitoringInfo" => intermediate_rep.qos_monitoring_info.push(
                        <models::QosMonitoringInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "epsPdnCnxInfo" => intermediate_rep.eps_pdn_cnx_info.push(
                        <models::EpsPdnCnxInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n9DataForwardingInd" => intermediate_rep.n9_data_forwarding_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n9InactivityTimer" => intermediate_rep.n9_inactivity_timer.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing VsmfUpdateData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VsmfUpdateData {
            request_indication: intermediate_rep
                .request_indication
                .into_iter()
                .next()
                .ok_or_else(|| "requestIndication missing in VsmfUpdateData".to_string())?,
            session_ambr: intermediate_rep.session_ambr.into_iter().next(),
            qos_flows_add_mod_request_list: intermediate_rep
                .qos_flows_add_mod_request_list
                .into_iter()
                .next(),
            qos_flows_rel_request_list: intermediate_rep
                .qos_flows_rel_request_list
                .into_iter()
                .next(),
            eps_bearer_info: intermediate_rep.eps_bearer_info.into_iter().next(),
            assign_ebi_list: intermediate_rep.assign_ebi_list.into_iter().next(),
            revoke_ebi_list: intermediate_rep.revoke_ebi_list.into_iter().next(),
            modified_ebi_list: intermediate_rep.modified_ebi_list.into_iter().next(),
            pti: intermediate_rep.pti.into_iter().next(),
            n1_sm_info_to_ue: intermediate_rep.n1_sm_info_to_ue.into_iter().next(),
            always_on_granted: intermediate_rep.always_on_granted.into_iter().next(),
            hsmf_pdu_session_uri: intermediate_rep.hsmf_pdu_session_uri.into_iter().next(),
            new_smf_id: intermediate_rep.new_smf_id.into_iter().next(),
            new_smf_pdu_session_uri: intermediate_rep.new_smf_pdu_session_uri.into_iter().next(),
            supported_features: intermediate_rep.supported_features.into_iter().next(),
            cause: intermediate_rep.cause.into_iter().next(),
            n1sm_cause: intermediate_rep.n1sm_cause.into_iter().next(),
            back_off_timer: intermediate_rep.back_off_timer.into_iter().next(),
            ma_release_ind: intermediate_rep.ma_release_ind.into_iter().next(),
            ma_accepted_ind: intermediate_rep.ma_accepted_ind.into_iter().next(),
            additional_cn_tunnel_info: intermediate_rep
                .additional_cn_tunnel_info
                .into_iter()
                .next(),
            dnai_list: intermediate_rep.dnai_list.into_iter().next(),
            n4_info: intermediate_rep.n4_info.into_iter().next(),
            n4_info_ext1: intermediate_rep.n4_info_ext1.into_iter().next(),
            n4_info_ext2: intermediate_rep.n4_info_ext2.into_iter().next(),
            n4_info_ext3: intermediate_rep.n4_info_ext3.into_iter().next(),
            small_data_rate_control_enabled: intermediate_rep
                .small_data_rate_control_enabled
                .into_iter()
                .next(),
            qos_monitoring_info: intermediate_rep.qos_monitoring_info.into_iter().next(),
            eps_pdn_cnx_info: intermediate_rep.eps_pdn_cnx_info.into_iter().next(),
            n9_data_forwarding_ind: intermediate_rep.n9_data_forwarding_ind.into_iter().next(),
            n9_inactivity_timer: intermediate_rep.n9_inactivity_timer.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VsmfUpdateData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<VsmfUpdateData>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<VsmfUpdateData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for VsmfUpdateData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<VsmfUpdateData> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <VsmfUpdateData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into VsmfUpdateData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Error within Update Response from V-SMF, or from I-SMF to SMF
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VsmfUpdateError {
    #[serde(rename = "error")]
    pub error: models::ExtProblemDetails,

    /// Procedure Transaction Identifier
    #[serde(rename = "pti")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pti: Option<u8>,

    #[serde(rename = "n1smCause")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n1sm_cause: Option<String>,

    #[serde(rename = "n1SmInfoFromUe")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n1_sm_info_from_ue: Option<models::RefToBinaryData>,

    #[serde(rename = "unknownN1SmInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unknown_n1_sm_info: Option<models::RefToBinaryData>,

    #[serde(rename = "failedToAssignEbiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub failed_to_assign_ebi_list: Option<Vec<models::Arp>>,

    #[serde(rename = "ngApCause")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ng_ap_cause: Option<models::NgApCause>,

    /// Unsigned Integer, i.e. only value 0 and integers above 0 are permissible.
    #[serde(rename = "5gMmCauseValue")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub param_5g_mm_cause_value: Option<u32>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "recoveryTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recovery_time: Option<chrono::DateTime<chrono::Utc>>,

    #[serde(rename = "n4Info")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n4_info: Option<models::N4Information>,

    #[serde(rename = "n4InfoExt1")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n4_info_ext1: Option<models::N4Information>,

    #[serde(rename = "n4InfoExt2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n4_info_ext2: Option<models::N4Information>,

    #[serde(rename = "n4InfoExt3")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n4_info_ext3: Option<models::N4Information>,
}

impl VsmfUpdateError {
    #[allow(clippy::new_without_default)]
    pub fn new(error: models::ExtProblemDetails) -> VsmfUpdateError {
        VsmfUpdateError {
            error,
            pti: None,
            n1sm_cause: None,
            n1_sm_info_from_ue: None,
            unknown_n1_sm_info: None,
            failed_to_assign_ebi_list: None,
            ng_ap_cause: None,
            param_5g_mm_cause_value: None,
            recovery_time: None,
            n4_info: None,
            n4_info_ext1: None,
            n4_info_ext2: None,
            n4_info_ext3: None,
        }
    }
}

/// Converts the VsmfUpdateError value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for VsmfUpdateError {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping error in query parameter serialization
            self.pti
                .as_ref()
                .map(|pti| vec!["pti".to_string(), pti.to_string()].join(",")),
            self.n1sm_cause
                .as_ref()
                .map(|n1sm_cause| vec!["n1smCause".to_string(), n1sm_cause.to_string()].join(",")),
            // Skipping n1SmInfoFromUe in query parameter serialization

            // Skipping unknownN1SmInfo in query parameter serialization

            // Skipping failedToAssignEbiList in query parameter serialization

            // Skipping ngApCause in query parameter serialization
            self.param_5g_mm_cause_value
                .as_ref()
                .map(|param_5g_mm_cause_value| {
                    vec![
                        "5gMmCauseValue".to_string(),
                        param_5g_mm_cause_value.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping recoveryTime in query parameter serialization

            // Skipping n4Info in query parameter serialization

            // Skipping n4InfoExt1 in query parameter serialization

            // Skipping n4InfoExt2 in query parameter serialization

            // Skipping n4InfoExt3 in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VsmfUpdateError value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VsmfUpdateError {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub error: Vec<models::ExtProblemDetails>,
            pub pti: Vec<u8>,
            pub n1sm_cause: Vec<String>,
            pub n1_sm_info_from_ue: Vec<models::RefToBinaryData>,
            pub unknown_n1_sm_info: Vec<models::RefToBinaryData>,
            pub failed_to_assign_ebi_list: Vec<Vec<models::Arp>>,
            pub ng_ap_cause: Vec<models::NgApCause>,
            pub param_5g_mm_cause_value: Vec<u32>,
            pub recovery_time: Vec<chrono::DateTime<chrono::Utc>>,
            pub n4_info: Vec<models::N4Information>,
            pub n4_info_ext1: Vec<models::N4Information>,
            pub n4_info_ext2: Vec<models::N4Information>,
            pub n4_info_ext3: Vec<models::N4Information>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing VsmfUpdateError".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "error" => intermediate_rep.error.push(
                        <models::ExtProblemDetails as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "pti" => intermediate_rep
                        .pti
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "n1smCause" => intermediate_rep.n1sm_cause.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n1SmInfoFromUe" => intermediate_rep.n1_sm_info_from_ue.push(
                        <models::RefToBinaryData as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "unknownN1SmInfo" => intermediate_rep.unknown_n1_sm_info.push(
                        <models::RefToBinaryData as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "failedToAssignEbiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in VsmfUpdateError"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "ngApCause" => intermediate_rep.ng_ap_cause.push(
                        <models::NgApCause as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "5gMmCauseValue" => intermediate_rep.param_5g_mm_cause_value.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "recoveryTime" => intermediate_rep.recovery_time.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n4Info" => intermediate_rep.n4_info.push(
                        <models::N4Information as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n4InfoExt1" => intermediate_rep.n4_info_ext1.push(
                        <models::N4Information as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n4InfoExt2" => intermediate_rep.n4_info_ext2.push(
                        <models::N4Information as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n4InfoExt3" => intermediate_rep.n4_info_ext3.push(
                        <models::N4Information as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing VsmfUpdateError".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VsmfUpdateError {
            error: intermediate_rep
                .error
                .into_iter()
                .next()
                .ok_or_else(|| "error missing in VsmfUpdateError".to_string())?,
            pti: intermediate_rep.pti.into_iter().next(),
            n1sm_cause: intermediate_rep.n1sm_cause.into_iter().next(),
            n1_sm_info_from_ue: intermediate_rep.n1_sm_info_from_ue.into_iter().next(),
            unknown_n1_sm_info: intermediate_rep.unknown_n1_sm_info.into_iter().next(),
            failed_to_assign_ebi_list: intermediate_rep
                .failed_to_assign_ebi_list
                .into_iter()
                .next(),
            ng_ap_cause: intermediate_rep.ng_ap_cause.into_iter().next(),
            param_5g_mm_cause_value: intermediate_rep.param_5g_mm_cause_value.into_iter().next(),
            recovery_time: intermediate_rep.recovery_time.into_iter().next(),
            n4_info: intermediate_rep.n4_info.into_iter().next(),
            n4_info_ext1: intermediate_rep.n4_info_ext1.into_iter().next(),
            n4_info_ext2: intermediate_rep.n4_info_ext2.into_iter().next(),
            n4_info_ext3: intermediate_rep.n4_info_ext3.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VsmfUpdateError> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<VsmfUpdateError>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<VsmfUpdateError>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for VsmfUpdateError - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<VsmfUpdateError>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <VsmfUpdateError as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into VsmfUpdateError - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Data within Update Response from V-SMF, or from I-SMF to SMF
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VsmfUpdatedData {
    #[serde(rename = "qosFlowsAddModList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub qos_flows_add_mod_list: Option<Vec<models::QosFlowItem>>,

    #[serde(rename = "qosFlowsRelList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub qos_flows_rel_list: Option<Vec<models::QosFlowItem>>,

    #[serde(rename = "qosFlowsFailedtoAddModList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub qos_flows_failedto_add_mod_list: Option<Vec<models::QosFlowItem>>,

    #[serde(rename = "qosFlowsFailedtoRelList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub qos_flows_failedto_rel_list: Option<Vec<models::QosFlowItem>>,

    #[serde(rename = "n1SmInfoFromUe")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n1_sm_info_from_ue: Option<models::RefToBinaryData>,

    #[serde(rename = "unknownN1SmInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unknown_n1_sm_info: Option<models::RefToBinaryData>,

    #[serde(rename = "ueLocation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_location: Option<models::UserLocation>,

    /// String with format \"time-numoffset\" optionally appended by \"daylightSavingTime\", where  - \"time-numoffset\" shall represent the time zone adjusted for daylight saving time and be    encoded as time-numoffset as defined in clause 5.6 of IETF RFC 3339;  - \"daylightSavingTime\" shall represent the adjustment that has been made and shall be    encoded as \"+1\" or \"+2\" for a +1 or +2 hours adjustment.   The example is for 8 hours behind UTC, +1 hour adjustment for Daylight Saving Time.
    #[serde(rename = "ueTimeZone")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_time_zone: Option<String>,

    #[serde(rename = "addUeLocation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub add_ue_location: Option<models::UserLocation>,

    #[serde(rename = "assignedEbiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assigned_ebi_list: Option<Vec<models::EbiArpMapping>>,

    #[serde(rename = "failedToAssignEbiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub failed_to_assign_ebi_list: Option<Vec<models::Arp>>,

    #[serde(rename = "releasedEbiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub released_ebi_list: Option<Vec<models::EpsBearerId>>,

    #[serde(rename = "secondaryRatUsageReport")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub secondary_rat_usage_report: Option<Vec<models::SecondaryRatUsageReport>>,

    #[serde(rename = "secondaryRatUsageInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub secondary_rat_usage_info: Option<Vec<models::SecondaryRatUsageInfo>>,

    #[serde(rename = "n4Info")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n4_info: Option<models::N4Information>,

    #[serde(rename = "n4InfoExt1")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n4_info_ext1: Option<models::N4Information>,

    #[serde(rename = "n4InfoExt2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n4_info_ext2: Option<models::N4Information>,

    #[serde(rename = "n4InfoExt3")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n4_info_ext3: Option<models::N4Information>,
}

impl VsmfUpdatedData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> VsmfUpdatedData {
        VsmfUpdatedData {
            qos_flows_add_mod_list: None,
            qos_flows_rel_list: None,
            qos_flows_failedto_add_mod_list: None,
            qos_flows_failedto_rel_list: None,
            n1_sm_info_from_ue: None,
            unknown_n1_sm_info: None,
            ue_location: None,
            ue_time_zone: None,
            add_ue_location: None,
            assigned_ebi_list: None,
            failed_to_assign_ebi_list: None,
            released_ebi_list: None,
            secondary_rat_usage_report: None,
            secondary_rat_usage_info: None,
            n4_info: None,
            n4_info_ext1: None,
            n4_info_ext2: None,
            n4_info_ext3: None,
        }
    }
}

/// Converts the VsmfUpdatedData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for VsmfUpdatedData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping qosFlowsAddModList in query parameter serialization

            // Skipping qosFlowsRelList in query parameter serialization

            // Skipping qosFlowsFailedtoAddModList in query parameter serialization

            // Skipping qosFlowsFailedtoRelList in query parameter serialization

            // Skipping n1SmInfoFromUe in query parameter serialization

            // Skipping unknownN1SmInfo in query parameter serialization

            // Skipping ueLocation in query parameter serialization
            self.ue_time_zone.as_ref().map(|ue_time_zone| {
                vec!["ueTimeZone".to_string(), ue_time_zone.to_string()].join(",")
            }),
            // Skipping addUeLocation in query parameter serialization

            // Skipping assignedEbiList in query parameter serialization

            // Skipping failedToAssignEbiList in query parameter serialization
            self.released_ebi_list.as_ref().map(|released_ebi_list| {
                vec![
                    "releasedEbiList".to_string(),
                    released_ebi_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping secondaryRatUsageReport in query parameter serialization

            // Skipping secondaryRatUsageInfo in query parameter serialization

            // Skipping n4Info in query parameter serialization

            // Skipping n4InfoExt1 in query parameter serialization

            // Skipping n4InfoExt2 in query parameter serialization

            // Skipping n4InfoExt3 in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VsmfUpdatedData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VsmfUpdatedData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub qos_flows_add_mod_list: Vec<Vec<models::QosFlowItem>>,
            pub qos_flows_rel_list: Vec<Vec<models::QosFlowItem>>,
            pub qos_flows_failedto_add_mod_list: Vec<Vec<models::QosFlowItem>>,
            pub qos_flows_failedto_rel_list: Vec<Vec<models::QosFlowItem>>,
            pub n1_sm_info_from_ue: Vec<models::RefToBinaryData>,
            pub unknown_n1_sm_info: Vec<models::RefToBinaryData>,
            pub ue_location: Vec<models::UserLocation>,
            pub ue_time_zone: Vec<String>,
            pub add_ue_location: Vec<models::UserLocation>,
            pub assigned_ebi_list: Vec<Vec<models::EbiArpMapping>>,
            pub failed_to_assign_ebi_list: Vec<Vec<models::Arp>>,
            pub released_ebi_list: Vec<Vec<models::EpsBearerId>>,
            pub secondary_rat_usage_report: Vec<Vec<models::SecondaryRatUsageReport>>,
            pub secondary_rat_usage_info: Vec<Vec<models::SecondaryRatUsageInfo>>,
            pub n4_info: Vec<models::N4Information>,
            pub n4_info_ext1: Vec<models::N4Information>,
            pub n4_info_ext2: Vec<models::N4Information>,
            pub n4_info_ext3: Vec<models::N4Information>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing VsmfUpdatedData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "qosFlowsAddModList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in VsmfUpdatedData"
                                .to_string(),
                        )
                    }
                    "qosFlowsRelList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in VsmfUpdatedData"
                                .to_string(),
                        )
                    }
                    "qosFlowsFailedtoAddModList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in VsmfUpdatedData"
                                .to_string(),
                        )
                    }
                    "qosFlowsFailedtoRelList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in VsmfUpdatedData"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "n1SmInfoFromUe" => intermediate_rep.n1_sm_info_from_ue.push(
                        <models::RefToBinaryData as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "unknownN1SmInfo" => intermediate_rep.unknown_n1_sm_info.push(
                        <models::RefToBinaryData as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ueLocation" => intermediate_rep.ue_location.push(
                        <models::UserLocation as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ueTimeZone" => intermediate_rep.ue_time_zone.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "addUeLocation" => intermediate_rep.add_ue_location.push(
                        <models::UserLocation as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "assignedEbiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in VsmfUpdatedData"
                                .to_string(),
                        )
                    }
                    "failedToAssignEbiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in VsmfUpdatedData"
                                .to_string(),
                        )
                    }
                    "releasedEbiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in VsmfUpdatedData"
                                .to_string(),
                        )
                    }
                    "secondaryRatUsageReport" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in VsmfUpdatedData"
                                .to_string(),
                        )
                    }
                    "secondaryRatUsageInfo" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in VsmfUpdatedData"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "n4Info" => intermediate_rep.n4_info.push(
                        <models::N4Information as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n4InfoExt1" => intermediate_rep.n4_info_ext1.push(
                        <models::N4Information as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n4InfoExt2" => intermediate_rep.n4_info_ext2.push(
                        <models::N4Information as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n4InfoExt3" => intermediate_rep.n4_info_ext3.push(
                        <models::N4Information as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing VsmfUpdatedData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VsmfUpdatedData {
            qos_flows_add_mod_list: intermediate_rep.qos_flows_add_mod_list.into_iter().next(),
            qos_flows_rel_list: intermediate_rep.qos_flows_rel_list.into_iter().next(),
            qos_flows_failedto_add_mod_list: intermediate_rep
                .qos_flows_failedto_add_mod_list
                .into_iter()
                .next(),
            qos_flows_failedto_rel_list: intermediate_rep
                .qos_flows_failedto_rel_list
                .into_iter()
                .next(),
            n1_sm_info_from_ue: intermediate_rep.n1_sm_info_from_ue.into_iter().next(),
            unknown_n1_sm_info: intermediate_rep.unknown_n1_sm_info.into_iter().next(),
            ue_location: intermediate_rep.ue_location.into_iter().next(),
            ue_time_zone: intermediate_rep.ue_time_zone.into_iter().next(),
            add_ue_location: intermediate_rep.add_ue_location.into_iter().next(),
            assigned_ebi_list: intermediate_rep.assigned_ebi_list.into_iter().next(),
            failed_to_assign_ebi_list: intermediate_rep
                .failed_to_assign_ebi_list
                .into_iter()
                .next(),
            released_ebi_list: intermediate_rep.released_ebi_list.into_iter().next(),
            secondary_rat_usage_report: intermediate_rep
                .secondary_rat_usage_report
                .into_iter()
                .next(),
            secondary_rat_usage_info: intermediate_rep.secondary_rat_usage_info.into_iter().next(),
            n4_info: intermediate_rep.n4_info.into_iter().next(),
            n4_info_ext1: intermediate_rep.n4_info_ext1.into_iter().next(),
            n4_info_ext2: intermediate_rep.n4_info_ext2.into_iter().next(),
            n4_info_ext3: intermediate_rep.n4_info_ext3.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VsmfUpdatedData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<VsmfUpdatedData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<VsmfUpdatedData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for VsmfUpdatedData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<VsmfUpdatedData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <VsmfUpdatedData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into VsmfUpdatedData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// This represents the identifier of the W-AGF ID as specified in clause 9.3.1.162 of  3GPP TS 38.413 in hexadecimal representation. Each character in the string shall take a value  of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant  character representing the 4 most significant bits of the W-AGF ID shall appear first in the  string, and the character representing the 4 least significant bit of the W-AGF ID shall  appear last in the string.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct WAgfId(String);

impl std::convert::From<String> for WAgfId {
    fn from(x: String) -> Self {
        WAgfId(x)
    }
}

impl std::string::ToString for WAgfId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for WAgfId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(WAgfId(x.to_string()))
    }
}

impl std::convert::From<WAgfId> for String {
    fn from(x: WAgfId) -> Self {
        x.0
    }
}

impl std::ops::Deref for WAgfId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for WAgfId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Information of the W-AGF end-points
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct WAgfInfo {
    #[serde(rename = "ipv4EndpointAddresses")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv4_endpoint_addresses: Option<Vec<models::Ipv4Addr>>,

    #[serde(rename = "ipv6EndpointAddresses")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_endpoint_addresses: Option<Vec<models::Ipv6Addr>>,

    /// Fully Qualified Domain Name
    #[serde(rename = "endpointFqdn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub endpoint_fqdn: Option<String>,
}

impl WAgfInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> WAgfInfo {
        WAgfInfo {
            ipv4_endpoint_addresses: None,
            ipv6_endpoint_addresses: None,
            endpoint_fqdn: None,
        }
    }
}

/// Converts the WAgfInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for WAgfInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.ipv4_endpoint_addresses
                .as_ref()
                .map(|ipv4_endpoint_addresses| {
                    vec![
                        "ipv4EndpointAddresses".to_string(),
                        ipv4_endpoint_addresses
                            .iter()
                            .map(|x| x.to_string())
                            .collect::<Vec<_>>()
                            .join(","),
                    ]
                    .join(",")
                }),
            // Skipping ipv6EndpointAddresses in query parameter serialization
            self.endpoint_fqdn.as_ref().map(|endpoint_fqdn| {
                vec!["endpointFqdn".to_string(), endpoint_fqdn.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a WAgfInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for WAgfInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ipv4_endpoint_addresses: Vec<Vec<models::Ipv4Addr>>,
            pub ipv6_endpoint_addresses: Vec<Vec<models::Ipv6Addr>>,
            pub endpoint_fqdn: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing WAgfInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "ipv4EndpointAddresses" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in WAgfInfo"
                                .to_string(),
                        )
                    }
                    "ipv6EndpointAddresses" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in WAgfInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "endpointFqdn" => intermediate_rep.endpoint_fqdn.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing WAgfInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(WAgfInfo {
            ipv4_endpoint_addresses: intermediate_rep.ipv4_endpoint_addresses.into_iter().next(),
            ipv6_endpoint_addresses: intermediate_rep.ipv6_endpoint_addresses.into_iter().next(),
            endpoint_fqdn: intermediate_rep.endpoint_fqdn.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<WAgfInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<WAgfInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<WAgfInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for WAgfInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<WAgfInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <WAgfInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into WAgfInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}
