#![allow(unused_qualifications)]

use std::str::FromStr;

#[cfg(any(feature = "client", feature = "server"))]
use crate::header;
use crate::models;

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AccessAndMobilitySubscriptionData {
    /// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  tableÂ 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.
    #[serde(rename = "supportedFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_features: Option<String>,

    #[serde(rename = "gpsis")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gpsis: Option<Vec<models::Gpsi>>,

    /// Identifier of a group of NFs.
    #[serde(rename = "hssGroupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hss_group_id: Option<String>,

    #[serde(rename = "internalGroupIds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub internal_group_ids: Option<Vec<models::GroupId>>,

    /// A map(list of key-value pairs) where GroupId serves as key of SharedDataId
    #[serde(rename = "sharedVnGroupDataIds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shared_vn_group_data_ids: Option<std::collections::HashMap<String, models::SharedDataId>>,

    #[serde(rename = "subscribedUeAmbr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscribed_ue_ambr: Option<models::AmbrRm>,

    #[serde(rename = "nssai")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nssai: Option<swagger::Nullable<models::Nssai>>,

    #[serde(rename = "ratRestrictions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rat_restrictions: Option<Vec<models::RatType>>,

    #[serde(rename = "forbiddenAreas")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub forbidden_areas: Option<Vec<models::Area>>,

    #[serde(rename = "serviceAreaRestriction")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_area_restriction: Option<models::ServiceAreaRestriction>,

    #[serde(rename = "coreNetworkTypeRestrictions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub core_network_type_restrictions: Option<Vec<models::CoreNetworkType>>,

    /// Unsigned integer representing the 'Subscriber Profile ID for RAT/Frequency Priority'  as specified in 3GPP TS 36.413 with the OpenAPI 'nullable: true' property.
    #[serde(rename = "rfspIndex")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rfsp_index: Option<swagger::Nullable<u16>>,

    /// indicating a time in seconds with OpenAPI defined 'nullable: true' property.
    #[serde(rename = "subsRegTimer")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subs_reg_timer: Option<swagger::Nullable<i32>>,

    #[serde(rename = "ueUsageType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_usage_type: Option<i32>,

    #[serde(rename = "mpsPriority")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mps_priority: Option<bool>,

    #[serde(rename = "mcsPriority")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mcs_priority: Option<bool>,

    /// indicating a time in seconds with OpenAPI defined 'nullable: true' property.
    #[serde(rename = "activeTime")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub active_time: Option<swagger::Nullable<i32>>,

    #[serde(rename = "sorInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sor_info: Option<models::SorInfo>,

    #[serde(rename = "sorInfoExpectInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sor_info_expect_ind: Option<bool>,

    #[serde(rename = "sorafRetrieval")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub soraf_retrieval: Option<bool>,

    #[serde(rename = "sorUpdateIndicatorList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sor_update_indicator_list: Option<Vec<models::SorUpdateIndicator>>,

    #[serde(rename = "upuInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub upu_info: Option<models::UpuInfo>,

    #[serde(rename = "routingIndicator")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub routing_indicator: Option<String>,

    #[serde(rename = "micoAllowed")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mico_allowed: Option<bool>,

    #[serde(rename = "sharedAmDataIds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shared_am_data_ids: Option<Vec<models::SharedDataId>>,

    #[serde(rename = "odbPacketServices")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub odb_packet_services: Option<models::OdbPacketServices>,

    #[serde(rename = "subscribedDnnList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscribed_dnn_list:
        Option<Vec<models::AccessAndMobilitySubscriptionDataSubscribedDnnListInner>>,

    /// indicating a time in seconds.
    #[serde(rename = "serviceGapTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_gap_time: Option<i32>,

    #[serde(rename = "mdtUserConsent")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mdt_user_consent: Option<models::MdtUserConsent>,

    #[serde(rename = "mdtConfiguration")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mdt_configuration: Option<models::MdtConfiguration>,

    #[serde(rename = "traceData")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trace_data: Option<swagger::Nullable<models::TraceData>>,

    #[serde(rename = "cagData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cag_data: Option<models::CagData>,

    /// String representing the STN-SR as defined in clause 18.6 of 3GPP TS 23.003.
    #[serde(rename = "stnSr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stn_sr: Option<String>,

    /// String representing the C-MSISDN as defined in clause 18.7 of 3GPP TS 23.003.
    #[serde(rename = "cMsisdn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub c_msisdn: Option<String>,

    #[serde(rename = "nbIoTUePriority")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nb_io_tue_priority: Option<u8>,

    #[serde(rename = "nssaiInclusionAllowed")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nssai_inclusion_allowed: Option<bool>,

    /// string with format 'bytes' as defined in OpenAPI
    #[serde(rename = "rgWirelineCharacteristics")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rg_wireline_characteristics: Option<swagger::ByteArray>,

    #[serde(rename = "ecRestrictionDataWb")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ec_restriction_data_wb: Option<models::EcRestrictionDataWb>,

    #[serde(rename = "ecRestrictionDataNb")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ec_restriction_data_nb: Option<bool>,

    #[serde(rename = "expectedUeBehaviourList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expected_ue_behaviour_list: Option<models::ExpectedUeBehaviourData>,

    #[serde(rename = "primaryRatRestrictions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub primary_rat_restrictions: Option<Vec<models::RatType>>,

    #[serde(rename = "secondaryRatRestrictions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub secondary_rat_restrictions: Option<Vec<models::RatType>>,

    #[serde(rename = "edrxParametersList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub edrx_parameters_list: Option<Vec<models::EdrxParameters>>,

    #[serde(rename = "ptwParametersList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ptw_parameters_list: Option<Vec<models::PtwParameters>>,

    #[serde(rename = "iabOperationAllowed")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub iab_operation_allowed: Option<bool>,

    /// A map (list of key-value pairs where PlmnId serves as key) of PlmnRestriction
    #[serde(rename = "adjacentPlmnRestrictions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub adjacent_plmn_restrictions:
        Option<std::collections::HashMap<String, models::PlmnRestriction>>,

    #[serde(rename = "wirelineForbiddenAreas")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub wireline_forbidden_areas: Option<Vec<models::WirelineArea>>,

    #[serde(rename = "wirelineServiceAreaRestriction")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub wireline_service_area_restriction: Option<models::WirelineServiceAreaRestriction>,

    #[serde(rename = "pcfSelectionAssistanceInfos")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pcf_selection_assistance_infos: Option<Vec<models::PcfSelectionAssistanceInfo>>,

    #[serde(rename = "aerialUeSubInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aerial_ue_sub_info: Option<models::AerialUeSubscriptionInfo>,

    #[serde(rename = "roamingRestrictions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub roaming_restrictions: Option<models::RoamingRestrictions>,

    #[serde(rename = "remoteProvInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remote_prov_ind: Option<bool>,
}

impl AccessAndMobilitySubscriptionData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AccessAndMobilitySubscriptionData {
        AccessAndMobilitySubscriptionData {
            supported_features: None,
            gpsis: None,
            hss_group_id: None,
            internal_group_ids: None,
            shared_vn_group_data_ids: None,
            subscribed_ue_ambr: None,
            nssai: None,
            rat_restrictions: None,
            forbidden_areas: None,
            service_area_restriction: None,
            core_network_type_restrictions: None,
            rfsp_index: None,
            subs_reg_timer: None,
            ue_usage_type: None,
            mps_priority: None,
            mcs_priority: None,
            active_time: None,
            sor_info: None,
            sor_info_expect_ind: None,
            soraf_retrieval: Some(false),
            sor_update_indicator_list: None,
            upu_info: None,
            routing_indicator: None,
            mico_allowed: None,
            shared_am_data_ids: None,
            odb_packet_services: None,
            subscribed_dnn_list: None,
            service_gap_time: None,
            mdt_user_consent: None,
            mdt_configuration: None,
            trace_data: None,
            cag_data: None,
            stn_sr: None,
            c_msisdn: None,
            nb_io_tue_priority: None,
            nssai_inclusion_allowed: Some(false),
            rg_wireline_characteristics: None,
            ec_restriction_data_wb: None,
            ec_restriction_data_nb: Some(false),
            expected_ue_behaviour_list: None,
            primary_rat_restrictions: None,
            secondary_rat_restrictions: None,
            edrx_parameters_list: None,
            ptw_parameters_list: None,
            iab_operation_allowed: Some(false),
            adjacent_plmn_restrictions: None,
            wireline_forbidden_areas: None,
            wireline_service_area_restriction: None,
            pcf_selection_assistance_infos: None,
            aerial_ue_sub_info: None,
            roaming_restrictions: None,
            remote_prov_ind: Some(false),
        }
    }
}

/// Converts the AccessAndMobilitySubscriptionData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AccessAndMobilitySubscriptionData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.supported_features.as_ref().map(|supported_features| {
                vec![
                    "supportedFeatures".to_string(),
                    supported_features.to_string(),
                ]
                .join(",")
            }),
            self.gpsis.as_ref().map(|gpsis| {
                vec![
                    "gpsis".to_string(),
                    gpsis
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.hss_group_id.as_ref().map(|hss_group_id| {
                vec!["hssGroupId".to_string(), hss_group_id.to_string()].join(",")
            }),
            self.internal_group_ids.as_ref().map(|internal_group_ids| {
                vec![
                    "internalGroupIds".to_string(),
                    internal_group_ids
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping sharedVnGroupDataIds in query parameter serialization

            // Skipping subscribedUeAmbr in query parameter serialization

            // Skipping nssai in query parameter serialization

            // Skipping ratRestrictions in query parameter serialization

            // Skipping forbiddenAreas in query parameter serialization

            // Skipping serviceAreaRestriction in query parameter serialization

            // Skipping coreNetworkTypeRestrictions in query parameter serialization
            self.rfsp_index.as_ref().map(|rfsp_index| {
                vec![
                    "rfspIndex".to_string(),
                    rfsp_index
                        .as_ref()
                        .map_or("null".to_string(), |x| x.to_string()),
                ]
                .join(",")
            }),
            self.subs_reg_timer.as_ref().map(|subs_reg_timer| {
                vec![
                    "subsRegTimer".to_string(),
                    subs_reg_timer
                        .as_ref()
                        .map_or("null".to_string(), |x| x.to_string()),
                ]
                .join(",")
            }),
            self.ue_usage_type.as_ref().map(|ue_usage_type| {
                vec!["ueUsageType".to_string(), ue_usage_type.to_string()].join(",")
            }),
            self.mps_priority.as_ref().map(|mps_priority| {
                vec!["mpsPriority".to_string(), mps_priority.to_string()].join(",")
            }),
            self.mcs_priority.as_ref().map(|mcs_priority| {
                vec!["mcsPriority".to_string(), mcs_priority.to_string()].join(",")
            }),
            self.active_time.as_ref().map(|active_time| {
                vec![
                    "activeTime".to_string(),
                    active_time
                        .as_ref()
                        .map_or("null".to_string(), |x| x.to_string()),
                ]
                .join(",")
            }),
            // Skipping sorInfo in query parameter serialization
            self.sor_info_expect_ind
                .as_ref()
                .map(|sor_info_expect_ind| {
                    vec![
                        "sorInfoExpectInd".to_string(),
                        sor_info_expect_ind.to_string(),
                    ]
                    .join(",")
                }),
            self.soraf_retrieval.as_ref().map(|soraf_retrieval| {
                vec!["sorafRetrieval".to_string(), soraf_retrieval.to_string()].join(",")
            }),
            // Skipping sorUpdateIndicatorList in query parameter serialization

            // Skipping upuInfo in query parameter serialization
            self.routing_indicator.as_ref().map(|routing_indicator| {
                vec![
                    "routingIndicator".to_string(),
                    routing_indicator.to_string(),
                ]
                .join(",")
            }),
            self.mico_allowed.as_ref().map(|mico_allowed| {
                vec!["micoAllowed".to_string(), mico_allowed.to_string()].join(",")
            }),
            self.shared_am_data_ids.as_ref().map(|shared_am_data_ids| {
                vec![
                    "sharedAmDataIds".to_string(),
                    shared_am_data_ids
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping odbPacketServices in query parameter serialization

            // Skipping subscribedDnnList in query parameter serialization
            self.service_gap_time.as_ref().map(|service_gap_time| {
                vec!["serviceGapTime".to_string(), service_gap_time.to_string()].join(",")
            }),
            // Skipping mdtUserConsent in query parameter serialization

            // Skipping mdtConfiguration in query parameter serialization

            // Skipping traceData in query parameter serialization

            // Skipping cagData in query parameter serialization
            self.stn_sr
                .as_ref()
                .map(|stn_sr| vec!["stnSr".to_string(), stn_sr.to_string()].join(",")),
            self.c_msisdn
                .as_ref()
                .map(|c_msisdn| vec!["cMsisdn".to_string(), c_msisdn.to_string()].join(",")),
            self.nb_io_tue_priority.as_ref().map(|nb_io_tue_priority| {
                vec![
                    "nbIoTUePriority".to_string(),
                    nb_io_tue_priority.to_string(),
                ]
                .join(",")
            }),
            self.nssai_inclusion_allowed
                .as_ref()
                .map(|nssai_inclusion_allowed| {
                    vec![
                        "nssaiInclusionAllowed".to_string(),
                        nssai_inclusion_allowed.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping rgWirelineCharacteristics in query parameter serialization
            // Skipping rgWirelineCharacteristics in query parameter serialization

            // Skipping ecRestrictionDataWb in query parameter serialization
            self.ec_restriction_data_nb
                .as_ref()
                .map(|ec_restriction_data_nb| {
                    vec![
                        "ecRestrictionDataNb".to_string(),
                        ec_restriction_data_nb.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping expectedUeBehaviourList in query parameter serialization

            // Skipping primaryRatRestrictions in query parameter serialization

            // Skipping secondaryRatRestrictions in query parameter serialization

            // Skipping edrxParametersList in query parameter serialization

            // Skipping ptwParametersList in query parameter serialization
            self.iab_operation_allowed
                .as_ref()
                .map(|iab_operation_allowed| {
                    vec![
                        "iabOperationAllowed".to_string(),
                        iab_operation_allowed.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping adjacentPlmnRestrictions in query parameter serialization
            // Skipping adjacentPlmnRestrictions in query parameter serialization

            // Skipping wirelineForbiddenAreas in query parameter serialization

            // Skipping wirelineServiceAreaRestriction in query parameter serialization

            // Skipping pcfSelectionAssistanceInfos in query parameter serialization

            // Skipping aerialUeSubInfo in query parameter serialization

            // Skipping roamingRestrictions in query parameter serialization
            self.remote_prov_ind.as_ref().map(|remote_prov_ind| {
                vec!["remoteProvInd".to_string(), remote_prov_ind.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AccessAndMobilitySubscriptionData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AccessAndMobilitySubscriptionData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub supported_features: Vec<String>,
            pub gpsis: Vec<Vec<models::Gpsi>>,
            pub hss_group_id: Vec<String>,
            pub internal_group_ids: Vec<Vec<models::GroupId>>,
            pub shared_vn_group_data_ids:
                Vec<std::collections::HashMap<String, models::SharedDataId>>,
            pub subscribed_ue_ambr: Vec<models::AmbrRm>,
            pub nssai: Vec<models::Nssai>,
            pub rat_restrictions: Vec<Vec<models::RatType>>,
            pub forbidden_areas: Vec<Vec<models::Area>>,
            pub service_area_restriction: Vec<models::ServiceAreaRestriction>,
            pub core_network_type_restrictions: Vec<Vec<models::CoreNetworkType>>,
            pub rfsp_index: Vec<u16>,
            pub subs_reg_timer: Vec<i32>,
            pub ue_usage_type: Vec<i32>,
            pub mps_priority: Vec<bool>,
            pub mcs_priority: Vec<bool>,
            pub active_time: Vec<i32>,
            pub sor_info: Vec<models::SorInfo>,
            pub sor_info_expect_ind: Vec<bool>,
            pub soraf_retrieval: Vec<bool>,
            pub sor_update_indicator_list: Vec<Vec<models::SorUpdateIndicator>>,
            pub upu_info: Vec<models::UpuInfo>,
            pub routing_indicator: Vec<String>,
            pub mico_allowed: Vec<bool>,
            pub shared_am_data_ids: Vec<Vec<models::SharedDataId>>,
            pub odb_packet_services: Vec<models::OdbPacketServices>,
            pub subscribed_dnn_list:
                Vec<Vec<models::AccessAndMobilitySubscriptionDataSubscribedDnnListInner>>,
            pub service_gap_time: Vec<i32>,
            pub mdt_user_consent: Vec<models::MdtUserConsent>,
            pub mdt_configuration: Vec<models::MdtConfiguration>,
            pub trace_data: Vec<models::TraceData>,
            pub cag_data: Vec<models::CagData>,
            pub stn_sr: Vec<String>,
            pub c_msisdn: Vec<String>,
            pub nb_io_tue_priority: Vec<u8>,
            pub nssai_inclusion_allowed: Vec<bool>,
            pub rg_wireline_characteristics: Vec<swagger::ByteArray>,
            pub ec_restriction_data_wb: Vec<models::EcRestrictionDataWb>,
            pub ec_restriction_data_nb: Vec<bool>,
            pub expected_ue_behaviour_list: Vec<models::ExpectedUeBehaviourData>,
            pub primary_rat_restrictions: Vec<Vec<models::RatType>>,
            pub secondary_rat_restrictions: Vec<Vec<models::RatType>>,
            pub edrx_parameters_list: Vec<Vec<models::EdrxParameters>>,
            pub ptw_parameters_list: Vec<Vec<models::PtwParameters>>,
            pub iab_operation_allowed: Vec<bool>,
            pub adjacent_plmn_restrictions:
                Vec<std::collections::HashMap<String, models::PlmnRestriction>>,
            pub wireline_forbidden_areas: Vec<Vec<models::WirelineArea>>,
            pub wireline_service_area_restriction: Vec<models::WirelineServiceAreaRestriction>,
            pub pcf_selection_assistance_infos: Vec<Vec<models::PcfSelectionAssistanceInfo>>,
            pub aerial_ue_sub_info: Vec<models::AerialUeSubscriptionInfo>,
            pub roaming_restrictions: Vec<models::RoamingRestrictions>,
            pub remote_prov_ind: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AccessAndMobilitySubscriptionData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "supportedFeatures" => intermediate_rep.supported_features.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "gpsis" => return std::result::Result::Err("Parsing a container in this style is not supported in AccessAndMobilitySubscriptionData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "hssGroupId" => intermediate_rep.hss_group_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "internalGroupIds" => return std::result::Result::Err("Parsing a container in this style is not supported in AccessAndMobilitySubscriptionData".to_string()),
                    "sharedVnGroupDataIds" => return std::result::Result::Err("Parsing a container in this style is not supported in AccessAndMobilitySubscriptionData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "subscribedUeAmbr" => intermediate_rep.subscribed_ue_ambr.push(<models::AmbrRm as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "nssai" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AccessAndMobilitySubscriptionData".to_string()),
                    "ratRestrictions" => return std::result::Result::Err("Parsing a container in this style is not supported in AccessAndMobilitySubscriptionData".to_string()),
                    "forbiddenAreas" => return std::result::Result::Err("Parsing a container in this style is not supported in AccessAndMobilitySubscriptionData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "serviceAreaRestriction" => intermediate_rep.service_area_restriction.push(<models::ServiceAreaRestriction as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "coreNetworkTypeRestrictions" => return std::result::Result::Err("Parsing a container in this style is not supported in AccessAndMobilitySubscriptionData".to_string()),
                    "rfspIndex" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AccessAndMobilitySubscriptionData".to_string()),
                    "subsRegTimer" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AccessAndMobilitySubscriptionData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "ueUsageType" => intermediate_rep.ue_usage_type.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "mpsPriority" => intermediate_rep.mps_priority.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "mcsPriority" => intermediate_rep.mcs_priority.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "activeTime" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AccessAndMobilitySubscriptionData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "sorInfo" => intermediate_rep.sor_info.push(<models::SorInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sorInfoExpectInd" => intermediate_rep.sor_info_expect_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sorafRetrieval" => intermediate_rep.soraf_retrieval.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "sorUpdateIndicatorList" => return std::result::Result::Err("Parsing a container in this style is not supported in AccessAndMobilitySubscriptionData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "upuInfo" => intermediate_rep.upu_info.push(<models::UpuInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "routingIndicator" => intermediate_rep.routing_indicator.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "micoAllowed" => intermediate_rep.mico_allowed.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "sharedAmDataIds" => return std::result::Result::Err("Parsing a container in this style is not supported in AccessAndMobilitySubscriptionData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "odbPacketServices" => intermediate_rep.odb_packet_services.push(<models::OdbPacketServices as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "subscribedDnnList" => return std::result::Result::Err("Parsing a container in this style is not supported in AccessAndMobilitySubscriptionData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "serviceGapTime" => intermediate_rep.service_gap_time.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "mdtUserConsent" => intermediate_rep.mdt_user_consent.push(<models::MdtUserConsent as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "mdtConfiguration" => intermediate_rep.mdt_configuration.push(<models::MdtConfiguration as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "traceData" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AccessAndMobilitySubscriptionData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "cagData" => intermediate_rep.cag_data.push(<models::CagData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "stnSr" => intermediate_rep.stn_sr.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cMsisdn" => intermediate_rep.c_msisdn.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "nbIoTUePriority" => intermediate_rep.nb_io_tue_priority.push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "nssaiInclusionAllowed" => intermediate_rep.nssai_inclusion_allowed.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "rgWirelineCharacteristics" => return std::result::Result::Err("Parsing binary data in this style is not supported in AccessAndMobilitySubscriptionData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "ecRestrictionDataWb" => intermediate_rep.ec_restriction_data_wb.push(<models::EcRestrictionDataWb as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ecRestrictionDataNb" => intermediate_rep.ec_restriction_data_nb.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "expectedUeBehaviourList" => intermediate_rep.expected_ue_behaviour_list.push(<models::ExpectedUeBehaviourData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "primaryRatRestrictions" => return std::result::Result::Err("Parsing a container in this style is not supported in AccessAndMobilitySubscriptionData".to_string()),
                    "secondaryRatRestrictions" => return std::result::Result::Err("Parsing a container in this style is not supported in AccessAndMobilitySubscriptionData".to_string()),
                    "edrxParametersList" => return std::result::Result::Err("Parsing a container in this style is not supported in AccessAndMobilitySubscriptionData".to_string()),
                    "ptwParametersList" => return std::result::Result::Err("Parsing a container in this style is not supported in AccessAndMobilitySubscriptionData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "iabOperationAllowed" => intermediate_rep.iab_operation_allowed.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "adjacentPlmnRestrictions" => return std::result::Result::Err("Parsing a container in this style is not supported in AccessAndMobilitySubscriptionData".to_string()),
                    "wirelineForbiddenAreas" => return std::result::Result::Err("Parsing a container in this style is not supported in AccessAndMobilitySubscriptionData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "wirelineServiceAreaRestriction" => intermediate_rep.wireline_service_area_restriction.push(<models::WirelineServiceAreaRestriction as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "pcfSelectionAssistanceInfos" => return std::result::Result::Err("Parsing a container in this style is not supported in AccessAndMobilitySubscriptionData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "aerialUeSubInfo" => intermediate_rep.aerial_ue_sub_info.push(<models::AerialUeSubscriptionInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "roamingRestrictions" => intermediate_rep.roaming_restrictions.push(<models::RoamingRestrictions as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "remoteProvInd" => intermediate_rep.remote_prov_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AccessAndMobilitySubscriptionData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AccessAndMobilitySubscriptionData {
            supported_features: intermediate_rep.supported_features.into_iter().next(),
            gpsis: intermediate_rep.gpsis.into_iter().next(),
            hss_group_id: intermediate_rep.hss_group_id.into_iter().next(),
            internal_group_ids: intermediate_rep.internal_group_ids.into_iter().next(),
            shared_vn_group_data_ids: intermediate_rep.shared_vn_group_data_ids.into_iter().next(),
            subscribed_ue_ambr: intermediate_rep.subscribed_ue_ambr.into_iter().next(),
            nssai: std::result::Result::Err(
                "Nullable types not supported in AccessAndMobilitySubscriptionData".to_string(),
            )?,
            rat_restrictions: intermediate_rep.rat_restrictions.into_iter().next(),
            forbidden_areas: intermediate_rep.forbidden_areas.into_iter().next(),
            service_area_restriction: intermediate_rep.service_area_restriction.into_iter().next(),
            core_network_type_restrictions: intermediate_rep
                .core_network_type_restrictions
                .into_iter()
                .next(),
            rfsp_index: std::result::Result::Err(
                "Nullable types not supported in AccessAndMobilitySubscriptionData".to_string(),
            )?,
            subs_reg_timer: std::result::Result::Err(
                "Nullable types not supported in AccessAndMobilitySubscriptionData".to_string(),
            )?,
            ue_usage_type: intermediate_rep.ue_usage_type.into_iter().next(),
            mps_priority: intermediate_rep.mps_priority.into_iter().next(),
            mcs_priority: intermediate_rep.mcs_priority.into_iter().next(),
            active_time: std::result::Result::Err(
                "Nullable types not supported in AccessAndMobilitySubscriptionData".to_string(),
            )?,
            sor_info: intermediate_rep.sor_info.into_iter().next(),
            sor_info_expect_ind: intermediate_rep.sor_info_expect_ind.into_iter().next(),
            soraf_retrieval: intermediate_rep.soraf_retrieval.into_iter().next(),
            sor_update_indicator_list: intermediate_rep
                .sor_update_indicator_list
                .into_iter()
                .next(),
            upu_info: intermediate_rep.upu_info.into_iter().next(),
            routing_indicator: intermediate_rep.routing_indicator.into_iter().next(),
            mico_allowed: intermediate_rep.mico_allowed.into_iter().next(),
            shared_am_data_ids: intermediate_rep.shared_am_data_ids.into_iter().next(),
            odb_packet_services: intermediate_rep.odb_packet_services.into_iter().next(),
            subscribed_dnn_list: intermediate_rep.subscribed_dnn_list.into_iter().next(),
            service_gap_time: intermediate_rep.service_gap_time.into_iter().next(),
            mdt_user_consent: intermediate_rep.mdt_user_consent.into_iter().next(),
            mdt_configuration: intermediate_rep.mdt_configuration.into_iter().next(),
            trace_data: std::result::Result::Err(
                "Nullable types not supported in AccessAndMobilitySubscriptionData".to_string(),
            )?,
            cag_data: intermediate_rep.cag_data.into_iter().next(),
            stn_sr: intermediate_rep.stn_sr.into_iter().next(),
            c_msisdn: intermediate_rep.c_msisdn.into_iter().next(),
            nb_io_tue_priority: intermediate_rep.nb_io_tue_priority.into_iter().next(),
            nssai_inclusion_allowed: intermediate_rep.nssai_inclusion_allowed.into_iter().next(),
            rg_wireline_characteristics: intermediate_rep
                .rg_wireline_characteristics
                .into_iter()
                .next(),
            ec_restriction_data_wb: intermediate_rep.ec_restriction_data_wb.into_iter().next(),
            ec_restriction_data_nb: intermediate_rep.ec_restriction_data_nb.into_iter().next(),
            expected_ue_behaviour_list: intermediate_rep
                .expected_ue_behaviour_list
                .into_iter()
                .next(),
            primary_rat_restrictions: intermediate_rep.primary_rat_restrictions.into_iter().next(),
            secondary_rat_restrictions: intermediate_rep
                .secondary_rat_restrictions
                .into_iter()
                .next(),
            edrx_parameters_list: intermediate_rep.edrx_parameters_list.into_iter().next(),
            ptw_parameters_list: intermediate_rep.ptw_parameters_list.into_iter().next(),
            iab_operation_allowed: intermediate_rep.iab_operation_allowed.into_iter().next(),
            adjacent_plmn_restrictions: intermediate_rep
                .adjacent_plmn_restrictions
                .into_iter()
                .next(),
            wireline_forbidden_areas: intermediate_rep.wireline_forbidden_areas.into_iter().next(),
            wireline_service_area_restriction: intermediate_rep
                .wireline_service_area_restriction
                .into_iter()
                .next(),
            pcf_selection_assistance_infos: intermediate_rep
                .pcf_selection_assistance_infos
                .into_iter()
                .next(),
            aerial_ue_sub_info: intermediate_rep.aerial_ue_sub_info.into_iter().next(),
            roaming_restrictions: intermediate_rep.roaming_restrictions.into_iter().next(),
            remote_prov_ind: intermediate_rep.remote_prov_ind.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AccessAndMobilitySubscriptionData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AccessAndMobilitySubscriptionData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AccessAndMobilitySubscriptionData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AccessAndMobilitySubscriptionData - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<AccessAndMobilitySubscriptionData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AccessAndMobilitySubscriptionData as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AccessAndMobilitySubscriptionData - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AccessAndMobilitySubscriptionDataSubscribedDnnListInner {}

impl AccessAndMobilitySubscriptionDataSubscribedDnnListInner {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AccessAndMobilitySubscriptionDataSubscribedDnnListInner {
        AccessAndMobilitySubscriptionDataSubscribedDnnListInner {}
    }
}

/// Converts the AccessAndMobilitySubscriptionDataSubscribedDnnListInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AccessAndMobilitySubscriptionDataSubscribedDnnListInner {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AccessAndMobilitySubscriptionDataSubscribedDnnListInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AccessAndMobilitySubscriptionDataSubscribedDnnListInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AccessAndMobilitySubscriptionDataSubscribedDnnListInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => return std::result::Result::Err("Unexpected key while parsing AccessAndMobilitySubscriptionDataSubscribedDnnListInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AccessAndMobilitySubscriptionDataSubscribedDnnListInner {})
    }
}

// Methods for converting between header::IntoHeaderValue<AccessAndMobilitySubscriptionDataSubscribedDnnListInner> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl
    std::convert::TryFrom<
        header::IntoHeaderValue<AccessAndMobilitySubscriptionDataSubscribedDnnListInner>,
    > for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AccessAndMobilitySubscriptionDataSubscribedDnnListInner>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AccessAndMobilitySubscriptionDataSubscribedDnnListInner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<AccessAndMobilitySubscriptionDataSubscribedDnnListInner>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AccessAndMobilitySubscriptionDataSubscribedDnnListInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AccessAndMobilitySubscriptionDataSubscribedDnnListInner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

/// Represents the access technology
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AccessTech {}

impl AccessTech {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AccessTech {
        AccessTech {}
    }
}

/// Converts the AccessTech value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AccessTech {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AccessTech value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AccessTech {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AccessTech".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AccessTech".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AccessTech {})
    }
}

// Methods for converting between header::IntoHeaderValue<AccessTech> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AccessTech>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AccessTech>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AccessTech - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AccessTech> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AccessTech as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AccessTech - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum AccessTechAnyOf {
    #[serde(rename = "NR")]
    Nr,
    #[serde(rename = "EUTRAN_IN_WBS1_MODE_AND_NBS1_MODE")]
    EutranInWbs1ModeAndNbs1Mode,
    #[serde(rename = "EUTRAN_IN_NBS1_MODE_ONLY")]
    EutranInNbs1ModeOnly,
    #[serde(rename = "EUTRAN_IN_WBS1_MODE_ONLY")]
    EutranInWbs1ModeOnly,
    #[serde(rename = "UTRAN")]
    Utran,
    #[serde(rename = "GSM_AND_ECGSM_IoT")]
    GsmAndEcgsmIoT,
    #[serde(rename = "GSM_WITHOUT_ECGSM_IoT")]
    GsmWithoutEcgsmIoT,
    #[serde(rename = "ECGSM_IoT_ONLY")]
    EcgsmIoTOnly,
    #[serde(rename = "CDMA_1xRTT")]
    Cdma1xRtt,
    #[serde(rename = "CDMA_HRPD")]
    CdmaHrpd,
    #[serde(rename = "GSM_COMPACT")]
    GsmCompact,
}

impl std::fmt::Display for AccessTechAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            AccessTechAnyOf::Nr => write!(f, "NR"),
            AccessTechAnyOf::EutranInWbs1ModeAndNbs1Mode => {
                write!(f, "EUTRAN_IN_WBS1_MODE_AND_NBS1_MODE")
            }
            AccessTechAnyOf::EutranInNbs1ModeOnly => write!(f, "EUTRAN_IN_NBS1_MODE_ONLY"),
            AccessTechAnyOf::EutranInWbs1ModeOnly => write!(f, "EUTRAN_IN_WBS1_MODE_ONLY"),
            AccessTechAnyOf::Utran => write!(f, "UTRAN"),
            AccessTechAnyOf::GsmAndEcgsmIoT => write!(f, "GSM_AND_ECGSM_IoT"),
            AccessTechAnyOf::GsmWithoutEcgsmIoT => write!(f, "GSM_WITHOUT_ECGSM_IoT"),
            AccessTechAnyOf::EcgsmIoTOnly => write!(f, "ECGSM_IoT_ONLY"),
            AccessTechAnyOf::Cdma1xRtt => write!(f, "CDMA_1xRTT"),
            AccessTechAnyOf::CdmaHrpd => write!(f, "CDMA_HRPD"),
            AccessTechAnyOf::GsmCompact => write!(f, "GSM_COMPACT"),
        }
    }
}

impl std::str::FromStr for AccessTechAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "NR" => std::result::Result::Ok(AccessTechAnyOf::Nr),
            "EUTRAN_IN_WBS1_MODE_AND_NBS1_MODE" => {
                std::result::Result::Ok(AccessTechAnyOf::EutranInWbs1ModeAndNbs1Mode)
            }
            "EUTRAN_IN_NBS1_MODE_ONLY" => {
                std::result::Result::Ok(AccessTechAnyOf::EutranInNbs1ModeOnly)
            }
            "EUTRAN_IN_WBS1_MODE_ONLY" => {
                std::result::Result::Ok(AccessTechAnyOf::EutranInWbs1ModeOnly)
            }
            "UTRAN" => std::result::Result::Ok(AccessTechAnyOf::Utran),
            "GSM_AND_ECGSM_IoT" => std::result::Result::Ok(AccessTechAnyOf::GsmAndEcgsmIoT),
            "GSM_WITHOUT_ECGSM_IoT" => std::result::Result::Ok(AccessTechAnyOf::GsmWithoutEcgsmIoT),
            "ECGSM_IoT_ONLY" => std::result::Result::Ok(AccessTechAnyOf::EcgsmIoTOnly),
            "CDMA_1xRTT" => std::result::Result::Ok(AccessTechAnyOf::Cdma1xRtt),
            "CDMA_HRPD" => std::result::Result::Ok(AccessTechAnyOf::CdmaHrpd),
            "GSM_COMPACT" => std::result::Result::Ok(AccessTechAnyOf::GsmCompact),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Error returned in the access token response message
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AccessTokenErr {
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "error")]
    pub error: String,

    #[serde(rename = "error_description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_description: Option<String>,

    #[serde(rename = "error_uri")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_uri: Option<String>,
}

impl AccessTokenErr {
    #[allow(clippy::new_without_default)]
    pub fn new(error: String) -> AccessTokenErr {
        AccessTokenErr {
            error,
            error_description: None,
            error_uri: None,
        }
    }
}

/// Converts the AccessTokenErr value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AccessTokenErr {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("error".to_string()),
            Some(self.error.to_string()),
            self.error_description.as_ref().map(|error_description| {
                vec![
                    "error_description".to_string(),
                    error_description.to_string(),
                ]
                .join(",")
            }),
            self.error_uri
                .as_ref()
                .map(|error_uri| vec!["error_uri".to_string(), error_uri.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AccessTokenErr value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AccessTokenErr {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub error: Vec<String>,
            pub error_description: Vec<String>,
            pub error_uri: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AccessTokenErr".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "error" => intermediate_rep.error.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "error_description" => intermediate_rep.error_description.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "error_uri" => intermediate_rep.error_uri.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AccessTokenErr".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AccessTokenErr {
            error: intermediate_rep
                .error
                .into_iter()
                .next()
                .ok_or_else(|| "error missing in AccessTokenErr".to_string())?,
            error_description: intermediate_rep.error_description.into_iter().next(),
            error_uri: intermediate_rep.error_uri.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AccessTokenErr> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AccessTokenErr>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AccessTokenErr>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AccessTokenErr - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AccessTokenErr> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AccessTokenErr as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AccessTokenErr - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains information related to the access token request
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AccessTokenReq {
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "grant_type")]
    pub grant_type: String,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "nfInstanceId")]
    pub nf_instance_id: uuid::Uuid,

    #[serde(rename = "nfType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nf_type: Option<models::NfType>,

    #[serde(rename = "targetNfType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_nf_type: Option<models::NfType>,

    #[serde(rename = "scope")]
    pub scope: String,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "targetNfInstanceId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_nf_instance_id: Option<uuid::Uuid>,

    #[serde(rename = "requesterPlmn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requester_plmn: Option<models::PlmnId>,

    #[serde(rename = "requesterPlmnList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requester_plmn_list: Option<Vec<models::PlmnId>>,

    #[serde(rename = "requesterSnssaiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requester_snssai_list: Option<Vec<models::Snssai>>,

    /// Fully Qualified Domain Name
    #[serde(rename = "requesterFqdn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requester_fqdn: Option<String>,

    #[serde(rename = "requesterSnpnList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requester_snpn_list: Option<Vec<models::PlmnIdNid>>,

    #[serde(rename = "targetPlmn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_plmn: Option<models::PlmnId>,

    #[serde(rename = "targetSnpn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_snpn: Option<models::PlmnIdNid>,

    #[serde(rename = "targetSnssaiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_snssai_list: Option<Vec<models::Snssai>>,

    #[serde(rename = "targetNsiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_nsi_list: Option<Vec<String>>,

    /// NF Set Identifier (see clause 28.12 of 3GPP TS 23.003), formatted as the following string \"set<Set ID>.<nftype>set.5gc.mnc<MNC>.mcc<MCC>\", or  \"set<SetID>.<NFType>set.5gc.nid<NID>.mnc<MNC>.mcc<MCC>\" with  <MCC> encoded as defined in clause 5.4.2 (\"Mcc\" data type definition)  <MNC> encoding the Mobile Network Code part of the PLMN, comprising 3 digits.    If there are only 2 significant digits in the MNC, one \"0\" digit shall be inserted    at the left side to fill the 3 digits coding of MNC.  Pattern: '^[0-9]{3}$' <NFType> encoded as a value defined in Table 6.1.6.3.3-1 of 3GPP TS 29.510 but    with lower case characters <Set ID> encoded as a string of characters consisting of    alphabetic characters (A-Z and a-z), digits (0-9) and/or the hyphen (-) and that    shall end with either an alphabetic character or a digit.
    #[serde(rename = "targetNfSetId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_nf_set_id: Option<String>,

    /// NF Service Set Identifier (see clause 28.12 of 3GPP TS 23.003) formatted as the following  string \"set<Set ID>.sn<Service Name>.nfi<NF Instance ID>.5gc.mnc<MNC>.mcc<MCC>\", or  \"set<SetID>.sn<ServiceName>.nfi<NFInstanceID>.5gc.nid<NID>.mnc<MNC>.mcc<MCC>\" with  <MCC> encoded as defined in clause 5.4.2 (\"Mcc\" data type definition)   <MNC> encoding the Mobile Network Code part of the PLMN, comprising 3 digits.    If there are only 2 significant digits in the MNC, one \"0\" digit shall be inserted    at the left side to fill the 3 digits coding of MNC.  Pattern: '^[0-9]{3}$' <NID> encoded as defined in clauseÂ 5.4.2 (\"Nid\" data type definition)  <NFInstanceId> encoded as defined in clause 5.3.2  <ServiceName> encoded as defined in 3GPP TS 29.510  <Set ID> encoded as a string of characters consisting of alphabetic    characters (A-Z and a-z), digits (0-9) and/or the hyphen (-) and that shall end    with either an alphabetic character or a digit.
    #[serde(rename = "targetNfServiceSetId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_nf_service_set_id: Option<String>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "hnrfAccessTokenUri")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hnrf_access_token_uri: Option<String>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "sourceNfInstanceId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source_nf_instance_id: Option<uuid::Uuid>,
}

impl AccessTokenReq {
    #[allow(clippy::new_without_default)]
    pub fn new(grant_type: String, nf_instance_id: uuid::Uuid, scope: String) -> AccessTokenReq {
        AccessTokenReq {
            grant_type,
            nf_instance_id,
            nf_type: None,
            target_nf_type: None,
            scope,
            target_nf_instance_id: None,
            requester_plmn: None,
            requester_plmn_list: None,
            requester_snssai_list: None,
            requester_fqdn: None,
            requester_snpn_list: None,
            target_plmn: None,
            target_snpn: None,
            target_snssai_list: None,
            target_nsi_list: None,
            target_nf_set_id: None,
            target_nf_service_set_id: None,
            hnrf_access_token_uri: None,
            source_nf_instance_id: None,
        }
    }
}

/// Converts the AccessTokenReq value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AccessTokenReq {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("grant_type".to_string()),
            Some(self.grant_type.to_string()),
            // Skipping nfInstanceId in query parameter serialization

            // Skipping nfType in query parameter serialization

            // Skipping targetNfType in query parameter serialization
            Some("scope".to_string()),
            Some(self.scope.to_string()),
            // Skipping targetNfInstanceId in query parameter serialization

            // Skipping requesterPlmn in query parameter serialization

            // Skipping requesterPlmnList in query parameter serialization

            // Skipping requesterSnssaiList in query parameter serialization
            self.requester_fqdn.as_ref().map(|requester_fqdn| {
                vec!["requesterFqdn".to_string(), requester_fqdn.to_string()].join(",")
            }),
            // Skipping requesterSnpnList in query parameter serialization

            // Skipping targetPlmn in query parameter serialization

            // Skipping targetSnpn in query parameter serialization

            // Skipping targetSnssaiList in query parameter serialization
            self.target_nsi_list.as_ref().map(|target_nsi_list| {
                vec![
                    "targetNsiList".to_string(),
                    target_nsi_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.target_nf_set_id.as_ref().map(|target_nf_set_id| {
                vec!["targetNfSetId".to_string(), target_nf_set_id.to_string()].join(",")
            }),
            self.target_nf_service_set_id
                .as_ref()
                .map(|target_nf_service_set_id| {
                    vec![
                        "targetNfServiceSetId".to_string(),
                        target_nf_service_set_id.to_string(),
                    ]
                    .join(",")
                }),
            self.hnrf_access_token_uri
                .as_ref()
                .map(|hnrf_access_token_uri| {
                    vec![
                        "hnrfAccessTokenUri".to_string(),
                        hnrf_access_token_uri.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping sourceNfInstanceId in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AccessTokenReq value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AccessTokenReq {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub grant_type: Vec<String>,
            pub nf_instance_id: Vec<uuid::Uuid>,
            pub nf_type: Vec<models::NfType>,
            pub target_nf_type: Vec<models::NfType>,
            pub scope: Vec<String>,
            pub target_nf_instance_id: Vec<uuid::Uuid>,
            pub requester_plmn: Vec<models::PlmnId>,
            pub requester_plmn_list: Vec<Vec<models::PlmnId>>,
            pub requester_snssai_list: Vec<Vec<models::Snssai>>,
            pub requester_fqdn: Vec<String>,
            pub requester_snpn_list: Vec<Vec<models::PlmnIdNid>>,
            pub target_plmn: Vec<models::PlmnId>,
            pub target_snpn: Vec<models::PlmnIdNid>,
            pub target_snssai_list: Vec<Vec<models::Snssai>>,
            pub target_nsi_list: Vec<Vec<String>>,
            pub target_nf_set_id: Vec<String>,
            pub target_nf_service_set_id: Vec<String>,
            pub hnrf_access_token_uri: Vec<String>,
            pub source_nf_instance_id: Vec<uuid::Uuid>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AccessTokenReq".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "grant_type" => intermediate_rep.grant_type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nfInstanceId" => intermediate_rep.nf_instance_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nfType" => intermediate_rep.nf_type.push(
                        <models::NfType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "targetNfType" => intermediate_rep.target_nf_type.push(
                        <models::NfType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "scope" => intermediate_rep.scope.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "targetNfInstanceId" => intermediate_rep.target_nf_instance_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "requesterPlmn" => intermediate_rep.requester_plmn.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "requesterPlmnList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AccessTokenReq"
                                .to_string(),
                        )
                    }
                    "requesterSnssaiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AccessTokenReq"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "requesterFqdn" => intermediate_rep.requester_fqdn.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "requesterSnpnList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AccessTokenReq"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "targetPlmn" => intermediate_rep.target_plmn.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "targetSnpn" => intermediate_rep.target_snpn.push(
                        <models::PlmnIdNid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "targetSnssaiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AccessTokenReq"
                                .to_string(),
                        )
                    }
                    "targetNsiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AccessTokenReq"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "targetNfSetId" => intermediate_rep.target_nf_set_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "targetNfServiceSetId" => intermediate_rep.target_nf_service_set_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "hnrfAccessTokenUri" => intermediate_rep.hnrf_access_token_uri.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "sourceNfInstanceId" => intermediate_rep.source_nf_instance_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AccessTokenReq".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AccessTokenReq {
            grant_type: intermediate_rep
                .grant_type
                .into_iter()
                .next()
                .ok_or_else(|| "grant_type missing in AccessTokenReq".to_string())?,
            nf_instance_id: intermediate_rep
                .nf_instance_id
                .into_iter()
                .next()
                .ok_or_else(|| "nfInstanceId missing in AccessTokenReq".to_string())?,
            nf_type: intermediate_rep.nf_type.into_iter().next(),
            target_nf_type: intermediate_rep.target_nf_type.into_iter().next(),
            scope: intermediate_rep
                .scope
                .into_iter()
                .next()
                .ok_or_else(|| "scope missing in AccessTokenReq".to_string())?,
            target_nf_instance_id: intermediate_rep.target_nf_instance_id.into_iter().next(),
            requester_plmn: intermediate_rep.requester_plmn.into_iter().next(),
            requester_plmn_list: intermediate_rep.requester_plmn_list.into_iter().next(),
            requester_snssai_list: intermediate_rep.requester_snssai_list.into_iter().next(),
            requester_fqdn: intermediate_rep.requester_fqdn.into_iter().next(),
            requester_snpn_list: intermediate_rep.requester_snpn_list.into_iter().next(),
            target_plmn: intermediate_rep.target_plmn.into_iter().next(),
            target_snpn: intermediate_rep.target_snpn.into_iter().next(),
            target_snssai_list: intermediate_rep.target_snssai_list.into_iter().next(),
            target_nsi_list: intermediate_rep.target_nsi_list.into_iter().next(),
            target_nf_set_id: intermediate_rep.target_nf_set_id.into_iter().next(),
            target_nf_service_set_id: intermediate_rep.target_nf_service_set_id.into_iter().next(),
            hnrf_access_token_uri: intermediate_rep.hnrf_access_token_uri.into_iter().next(),
            source_nf_instance_id: intermediate_rep.source_nf_instance_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AccessTokenReq> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AccessTokenReq>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AccessTokenReq>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AccessTokenReq - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AccessTokenReq> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AccessTokenReq as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AccessTokenReq - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Indicates whether the access is  via 3GPP or via non-3GPP.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum AccessType {
    #[serde(rename = "3GPP_ACCESS")]
    Variant3GppAccess,
    #[serde(rename = "NON_3GPP_ACCESS")]
    Non3GppAccess,
}

impl std::fmt::Display for AccessType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            AccessType::Variant3GppAccess => write!(f, "3GPP_ACCESS"),
            AccessType::Non3GppAccess => write!(f, "NON_3GPP_ACCESS"),
        }
    }
}

impl std::str::FromStr for AccessType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "3GPP_ACCESS" => std::result::Result::Ok(AccessType::Variant3GppAccess),
            "NON_3GPP_ACCESS" => std::result::Result::Ok(AccessType::Non3GppAccess),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Contains indication whether the acknowledgement from UE is needed.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AckInd(bool);

impl std::convert::From<bool> for AckInd {
    fn from(x: bool) -> Self {
        AckInd(x)
    }
}

impl std::convert::From<AckInd> for bool {
    fn from(x: AckInd) -> Self {
        x.0
    }
}

impl std::ops::Deref for AckInd {
    type Target = bool;
    fn deref(&self) -> &bool {
        &self.0
    }
}

impl std::ops::DerefMut for AckInd {
    fn deref_mut(&mut self) -> &mut bool {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AcknowledgeInfo {
    /// MAC value for protecting SOR procedure (SoR-MAC-IAUSF and SoR-XMAC-IUE).
    #[serde(rename = "sorMacIue")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sor_mac_iue: Option<String>,

    /// MAC value for protecting UPU procedure (UPU-MAC-IAUSF and UPU-MAC-IUE).
    #[serde(rename = "upuMacIue")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub upu_mac_iue: Option<String>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "provisioningTime")]
    pub provisioning_time: chrono::DateTime<chrono::Utc>,

    /// string with format 'bytes' as defined in OpenAPI
    #[serde(rename = "sorTransparentContainer")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sor_transparent_container: Option<swagger::ByteArray>,

    #[serde(rename = "ueNotReachable")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_not_reachable: Option<bool>,

    /// string with format 'bytes' as defined in OpenAPI
    #[serde(rename = "upuTransparentContainer")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub upu_transparent_container: Option<swagger::ByteArray>,
}

impl AcknowledgeInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(provisioning_time: chrono::DateTime<chrono::Utc>) -> AcknowledgeInfo {
        AcknowledgeInfo {
            sor_mac_iue: None,
            upu_mac_iue: None,
            provisioning_time,
            sor_transparent_container: None,
            ue_not_reachable: Some(false),
            upu_transparent_container: None,
        }
    }
}

/// Converts the AcknowledgeInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AcknowledgeInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.sor_mac_iue.as_ref().map(|sor_mac_iue| {
                vec!["sorMacIue".to_string(), sor_mac_iue.to_string()].join(",")
            }),
            self.upu_mac_iue.as_ref().map(|upu_mac_iue| {
                vec!["upuMacIue".to_string(), upu_mac_iue.to_string()].join(",")
            }),
            // Skipping provisioningTime in query parameter serialization

            // Skipping sorTransparentContainer in query parameter serialization
            // Skipping sorTransparentContainer in query parameter serialization
            self.ue_not_reachable.as_ref().map(|ue_not_reachable| {
                vec!["ueNotReachable".to_string(), ue_not_reachable.to_string()].join(",")
            }),
            // Skipping upuTransparentContainer in query parameter serialization
            // Skipping upuTransparentContainer in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AcknowledgeInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AcknowledgeInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub sor_mac_iue: Vec<String>,
            pub upu_mac_iue: Vec<String>,
            pub provisioning_time: Vec<chrono::DateTime<chrono::Utc>>,
            pub sor_transparent_container: Vec<swagger::ByteArray>,
            pub ue_not_reachable: Vec<bool>,
            pub upu_transparent_container: Vec<swagger::ByteArray>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AcknowledgeInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "sorMacIue" => intermediate_rep.sor_mac_iue.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "upuMacIue" => intermediate_rep.upu_mac_iue.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "provisioningTime" => intermediate_rep.provisioning_time.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "sorTransparentContainer" => {
                        return std::result::Result::Err(
                            "Parsing binary data in this style is not supported in AcknowledgeInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "ueNotReachable" => intermediate_rep.ue_not_reachable.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "upuTransparentContainer" => {
                        return std::result::Result::Err(
                            "Parsing binary data in this style is not supported in AcknowledgeInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AcknowledgeInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AcknowledgeInfo {
            sor_mac_iue: intermediate_rep.sor_mac_iue.into_iter().next(),
            upu_mac_iue: intermediate_rep.upu_mac_iue.into_iter().next(),
            provisioning_time: intermediate_rep
                .provisioning_time
                .into_iter()
                .next()
                .ok_or_else(|| "provisioningTime missing in AcknowledgeInfo".to_string())?,
            sor_transparent_container: intermediate_rep
                .sor_transparent_container
                .into_iter()
                .next(),
            ue_not_reachable: intermediate_rep.ue_not_reachable.into_iter().next(),
            upu_transparent_container: intermediate_rep
                .upu_transparent_container
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AcknowledgeInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AcknowledgeInfo>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AcknowledgeInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AcknowledgeInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<AcknowledgeInfo>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AcknowledgeInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AcknowledgeInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// The ACS information for the 5G-RG is defined in BBFÂ TR-069Â [42] or in BBFÂ TR-369
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AcsInfo {
    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "acsUrl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub acs_url: Option<String>,

    /// String identifying a IPv4 address formatted in the 'dotted decimal' notation as defined in RFC 1166.
    #[serde(rename = "acsIpv4Addr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub acs_ipv4_addr: Option<String>,

    #[serde(rename = "acsIpv6Addr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub acs_ipv6_addr: Option<models::Ipv6Addr>,
}

impl AcsInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AcsInfo {
        AcsInfo {
            acs_url: None,
            acs_ipv4_addr: None,
            acs_ipv6_addr: None,
        }
    }
}

/// Converts the AcsInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AcsInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.acs_url
                .as_ref()
                .map(|acs_url| vec!["acsUrl".to_string(), acs_url.to_string()].join(",")),
            self.acs_ipv4_addr.as_ref().map(|acs_ipv4_addr| {
                vec!["acsIpv4Addr".to_string(), acs_ipv4_addr.to_string()].join(",")
            }),
            // Skipping acsIpv6Addr in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AcsInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AcsInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub acs_url: Vec<String>,
            pub acs_ipv4_addr: Vec<String>,
            pub acs_ipv6_addr: Vec<models::Ipv6Addr>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AcsInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "acsUrl" => intermediate_rep.acs_url.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "acsIpv4Addr" => intermediate_rep.acs_ipv4_addr.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "acsIpv6Addr" => intermediate_rep.acs_ipv6_addr.push(
                        <models::Ipv6Addr as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AcsInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AcsInfo {
            acs_url: intermediate_rep.acs_url.into_iter().next(),
            acs_ipv4_addr: intermediate_rep.acs_ipv4_addr.into_iter().next(),
            acs_ipv6_addr: intermediate_rep.acs_ipv6_addr.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AcsInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AcsInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AcsInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AcsInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AcsInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AcsInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AcsInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdditionalSnssaiData {
    #[serde(rename = "requiredAuthnAuthz")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub required_authn_authz: Option<bool>,

    #[serde(rename = "subscribedUeSliceMbr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscribed_ue_slice_mbr: Option<models::SliceMbrRm>,

    #[serde(rename = "subscribedNsSrgList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscribed_ns_srg_list: Option<Vec<models::NsSrg>>,
}

impl AdditionalSnssaiData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AdditionalSnssaiData {
        AdditionalSnssaiData {
            required_authn_authz: None,
            subscribed_ue_slice_mbr: None,
            subscribed_ns_srg_list: None,
        }
    }
}

/// Converts the AdditionalSnssaiData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AdditionalSnssaiData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.required_authn_authz
                .as_ref()
                .map(|required_authn_authz| {
                    vec![
                        "requiredAuthnAuthz".to_string(),
                        required_authn_authz.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping subscribedUeSliceMbr in query parameter serialization
            self.subscribed_ns_srg_list
                .as_ref()
                .map(|subscribed_ns_srg_list| {
                    vec![
                        "subscribedNsSrgList".to_string(),
                        subscribed_ns_srg_list
                            .iter()
                            .map(|x| x.to_string())
                            .collect::<Vec<_>>()
                            .join(","),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdditionalSnssaiData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdditionalSnssaiData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub required_authn_authz: Vec<bool>,
            pub subscribed_ue_slice_mbr: Vec<models::SliceMbrRm>,
            pub subscribed_ns_srg_list: Vec<Vec<models::NsSrg>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AdditionalSnssaiData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "requiredAuthnAuthz" => intermediate_rep.required_authn_authz.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "subscribedUeSliceMbr" => intermediate_rep.subscribed_ue_slice_mbr.push(<models::SliceMbrRm as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "subscribedNsSrgList" => return std::result::Result::Err("Parsing a container in this style is not supported in AdditionalSnssaiData".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdditionalSnssaiData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdditionalSnssaiData {
            required_authn_authz: intermediate_rep.required_authn_authz.into_iter().next(),
            subscribed_ue_slice_mbr: intermediate_rep.subscribed_ue_slice_mbr.into_iter().next(),
            subscribed_ns_srg_list: intermediate_rep.subscribed_ns_srg_list.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdditionalSnssaiData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AdditionalSnssaiData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AdditionalSnssaiData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AdditionalSnssaiData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<AdditionalSnssaiData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AdditionalSnssaiData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AdditionalSnssaiData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Indicates the Aerial service for the UE is allowed or not allowed, possible values are - AERIAL_UE_ALLOWED: Aerial service for the UE is allowed. - AERIAL_UE_NOT_ALLOWED: Aerial service for the UE is not allowed.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AerialUeIndication {}

impl AerialUeIndication {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AerialUeIndication {
        AerialUeIndication {}
    }
}

/// Converts the AerialUeIndication value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AerialUeIndication {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AerialUeIndication value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AerialUeIndication {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AerialUeIndication".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AerialUeIndication".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AerialUeIndication {})
    }
}

// Methods for converting between header::IntoHeaderValue<AerialUeIndication> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AerialUeIndication>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AerialUeIndication>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AerialUeIndication - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<AerialUeIndication>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AerialUeIndication as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AerialUeIndication - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum AerialUeIndicationAnyOf {
    #[serde(rename = "AERIAL_UE_ALLOWED")]
    Allowed,
    #[serde(rename = "AERIAL_UE_NOT_ALLOWED")]
    NotAllowed,
}

impl std::fmt::Display for AerialUeIndicationAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            AerialUeIndicationAnyOf::Allowed => write!(f, "AERIAL_UE_ALLOWED"),
            AerialUeIndicationAnyOf::NotAllowed => write!(f, "AERIAL_UE_NOT_ALLOWED"),
        }
    }
}

impl std::str::FromStr for AerialUeIndicationAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "AERIAL_UE_ALLOWED" => std::result::Result::Ok(AerialUeIndicationAnyOf::Allowed),
            "AERIAL_UE_NOT_ALLOWED" => std::result::Result::Ok(AerialUeIndicationAnyOf::NotAllowed),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Contains the Aerial UE Subscription Information, it at least contains the Aerial UE Indication.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AerialUeSubscriptionInfo {
    #[serde(rename = "aerialUeInd")]
    pub aerial_ue_ind: models::AerialUeIndication,

    /// String identifying a Gpsi shall contain either an External Id or an MSISDN.  It shall be formatted as follows -External Identifier= \"extid-'extid', where 'extid'  shall be formatted according to clause 19.7.2 of 3GPP TS 23.003 that describes an  External Identifier.
    #[serde(rename = "3gppUavId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub param_3gpp_uav_id: Option<String>,
}

impl AerialUeSubscriptionInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(aerial_ue_ind: models::AerialUeIndication) -> AerialUeSubscriptionInfo {
        AerialUeSubscriptionInfo {
            aerial_ue_ind,
            param_3gpp_uav_id: None,
        }
    }
}

/// Converts the AerialUeSubscriptionInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AerialUeSubscriptionInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping aerialUeInd in query parameter serialization
            self.param_3gpp_uav_id.as_ref().map(|param_3gpp_uav_id| {
                vec!["3gppUavId".to_string(), param_3gpp_uav_id.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AerialUeSubscriptionInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AerialUeSubscriptionInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub aerial_ue_ind: Vec<models::AerialUeIndication>,
            pub param_3gpp_uav_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AerialUeSubscriptionInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "aerialUeInd" => intermediate_rep.aerial_ue_ind.push(
                        <models::AerialUeIndication as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "3gppUavId" => intermediate_rep.param_3gpp_uav_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AerialUeSubscriptionInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AerialUeSubscriptionInfo {
            aerial_ue_ind: intermediate_rep
                .aerial_ue_ind
                .into_iter()
                .next()
                .ok_or_else(|| "aerialUeInd missing in AerialUeSubscriptionInfo".to_string())?,
            param_3gpp_uav_id: intermediate_rep.param_3gpp_uav_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AerialUeSubscriptionInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AerialUeSubscriptionInfo>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AerialUeSubscriptionInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AerialUeSubscriptionInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<AerialUeSubscriptionInfo>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AerialUeSubscriptionInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AerialUeSubscriptionInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AfExternal {
    #[serde(rename = "afId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub af_id: Option<String>,

    #[serde(rename = "allowedGeographicArea")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allowed_geographic_area: Option<Vec<models::GeographicArea>>,

    #[serde(rename = "privacyCheckRelatedAction")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub privacy_check_related_action: Option<models::PrivacyCheckRelatedAction>,

    #[serde(rename = "validTimePeriod")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub valid_time_period: Option<models::ValidTimePeriod>,
}

impl AfExternal {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AfExternal {
        AfExternal {
            af_id: None,
            allowed_geographic_area: None,
            privacy_check_related_action: None,
            valid_time_period: None,
        }
    }
}

/// Converts the AfExternal value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AfExternal {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.af_id
                .as_ref()
                .map(|af_id| vec!["afId".to_string(), af_id.to_string()].join(",")),
            // Skipping allowedGeographicArea in query parameter serialization

            // Skipping privacyCheckRelatedAction in query parameter serialization

            // Skipping validTimePeriod in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AfExternal value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AfExternal {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub af_id: Vec<String>,
            pub allowed_geographic_area: Vec<Vec<models::GeographicArea>>,
            pub privacy_check_related_action: Vec<models::PrivacyCheckRelatedAction>,
            pub valid_time_period: Vec<models::ValidTimePeriod>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AfExternal".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "afId" => intermediate_rep.af_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "allowedGeographicArea" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AfExternal"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "privacyCheckRelatedAction" => {
                        intermediate_rep.privacy_check_related_action.push(
                            <models::PrivacyCheckRelatedAction as std::str::FromStr>::from_str(val)
                                .map_err(|x| x.to_string())?,
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "validTimePeriod" => intermediate_rep.valid_time_period.push(
                        <models::ValidTimePeriod as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AfExternal".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AfExternal {
            af_id: intermediate_rep.af_id.into_iter().next(),
            allowed_geographic_area: intermediate_rep.allowed_geographic_area.into_iter().next(),
            privacy_check_related_action: intermediate_rep
                .privacy_check_related_action
                .into_iter()
                .next(),
            valid_time_period: intermediate_rep.valid_time_period.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AfExternal> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AfExternal>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AfExternal>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AfExternal - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AfExternal> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AfExternal as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AfExternal - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AfId(String);

impl std::convert::From<String> for AfId {
    fn from(x: String) -> Self {
        AfId(x)
    }
}

impl std::string::ToString for AfId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for AfId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(AfId(x.to_string()))
    }
}

impl std::convert::From<AfId> for String {
    fn from(x: AfId) -> Self {
        x.0
    }
}

impl std::ops::Deref for AfId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for AfId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Indicates value of altitude.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Altitude(f64);

impl std::convert::From<f64> for Altitude {
    fn from(x: f64) -> Self {
        Altitude(x)
    }
}

impl std::convert::From<Altitude> for f64 {
    fn from(x: Altitude) -> Self {
        x.0
    }
}

impl std::ops::Deref for Altitude {
    type Target = f64;
    fn deref(&self) -> &f64 {
        &self.0
    }
}

impl std::ops::DerefMut for Altitude {
    fn deref_mut(&mut self) -> &mut f64 {
        &mut self.0
    }
}

/// Contains the maximum aggregated uplink and downlink bit rates.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Ambr {
    /// String representing a bit rate; the prefixes follow the standard symbols from The International System of Units, and represent x1000 multipliers, with the exception that prefix \"K\" is used to represent the standard symbol \"k\".
    #[serde(rename = "uplink")]
    pub uplink: String,

    /// String representing a bit rate; the prefixes follow the standard symbols from The International System of Units, and represent x1000 multipliers, with the exception that prefix \"K\" is used to represent the standard symbol \"k\".
    #[serde(rename = "downlink")]
    pub downlink: String,
}

impl Ambr {
    #[allow(clippy::new_without_default)]
    pub fn new(uplink: String, downlink: String) -> Ambr {
        Ambr { uplink, downlink }
    }
}

/// Converts the Ambr value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Ambr {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("uplink".to_string()),
            Some(self.uplink.to_string()),
            Some("downlink".to_string()),
            Some(self.downlink.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Ambr value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Ambr {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub uplink: Vec<String>,
            pub downlink: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err("Missing value while parsing Ambr".to_string())
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "uplink" => intermediate_rep.uplink.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "downlink" => intermediate_rep.downlink.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Ambr".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Ambr {
            uplink: intermediate_rep
                .uplink
                .into_iter()
                .next()
                .ok_or_else(|| "uplink missing in Ambr".to_string())?,
            downlink: intermediate_rep
                .downlink
                .into_iter()
                .next()
                .ok_or_else(|| "downlink missing in Ambr".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Ambr> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Ambr>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Ambr>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Ambr - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Ambr> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Ambr as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Ambr - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// This data type is defined in the same way as the 'Ambr' data type, but with the OpenAPI 'nullable: true' property.\"
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AmbrRm {
    /// String representing a bit rate; the prefixes follow the standard symbols from The International System of Units, and represent x1000 multipliers, with the exception that prefix \"K\" is used to represent the standard symbol \"k\".
    #[serde(rename = "uplink")]
    pub uplink: String,

    /// String representing a bit rate; the prefixes follow the standard symbols from The International System of Units, and represent x1000 multipliers, with the exception that prefix \"K\" is used to represent the standard symbol \"k\".
    #[serde(rename = "downlink")]
    pub downlink: String,
}

impl AmbrRm {
    #[allow(clippy::new_without_default)]
    pub fn new(uplink: String, downlink: String) -> AmbrRm {
        AmbrRm { uplink, downlink }
    }
}

/// Converts the AmbrRm value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AmbrRm {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("uplink".to_string()),
            Some(self.uplink.to_string()),
            Some("downlink".to_string()),
            Some(self.downlink.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AmbrRm value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AmbrRm {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub uplink: Vec<String>,
            pub downlink: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AmbrRm".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "uplink" => intermediate_rep.uplink.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "downlink" => intermediate_rep.downlink.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AmbrRm".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AmbrRm {
            uplink: intermediate_rep
                .uplink
                .into_iter()
                .next()
                .ok_or_else(|| "uplink missing in AmbrRm".to_string())?,
            downlink: intermediate_rep
                .downlink
                .into_iter()
                .next()
                .ok_or_else(|| "downlink missing in AmbrRm".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AmbrRm> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AmbrRm>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AmbrRm>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AmbrRm - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AmbrRm> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AmbrRm as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AmbrRm - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// String identifying the AMF ID composed of AMF Region ID (8 bits), AMF Set ID (10 bits) and AMF  Pointer (6 bits) as specified in clause 2.10.1 of 3GPP TS 23.003. It is encoded as a string of  6 hexadecimal characters (i.e., 24 bits).
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AmfId(String);

impl std::convert::From<String> for AmfId {
    fn from(x: String) -> Self {
        AmfId(x)
    }
}

impl std::string::ToString for AmfId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for AmfId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(AmfId(x.to_string()))
    }
}

impl std::convert::From<AmfId> for String {
    fn from(x: AmfId) -> Self {
        x.0
    }
}

impl std::ops::Deref for AmfId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for AmfId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AmfInfo {
    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "amfInstanceId")]
    pub amf_instance_id: uuid::Uuid,

    #[serde(rename = "guami")]
    pub guami: models::Guami,

    #[serde(rename = "accessType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub access_type: Option<models::AccessType>,
}

impl AmfInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(amf_instance_id: uuid::Uuid, guami: models::Guami) -> AmfInfo {
        AmfInfo {
            amf_instance_id,
            guami,
            access_type: None,
        }
    }
}

/// Converts the AmfInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AmfInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping amfInstanceId in query parameter serialization

            // Skipping guami in query parameter serialization

            // Skipping accessType in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AmfInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AmfInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub amf_instance_id: Vec<uuid::Uuid>,
            pub guami: Vec<models::Guami>,
            pub access_type: Vec<models::AccessType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AmfInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "amfInstanceId" => intermediate_rep.amf_instance_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "guami" => intermediate_rep.guami.push(
                        <models::Guami as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "accessType" => intermediate_rep.access_type.push(
                        <models::AccessType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AmfInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AmfInfo {
            amf_instance_id: intermediate_rep
                .amf_instance_id
                .into_iter()
                .next()
                .ok_or_else(|| "amfInstanceId missing in AmfInfo".to_string())?,
            guami: intermediate_rep
                .guami
                .into_iter()
                .next()
                .ok_or_else(|| "guami missing in AmfInfo".to_string())?,
            access_type: intermediate_rep.access_type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AmfInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AmfInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AmfInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AmfInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AmfInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AmfInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AmfInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Indicates value of angle.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Angle(i32);

impl std::convert::From<i32> for Angle {
    fn from(x: i32) -> Self {
        Angle(x)
    }
}

impl std::convert::From<Angle> for i32 {
    fn from(x: Angle) -> Self {
        x.0
    }
}

impl std::ops::Deref for Angle {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for Angle {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AppDescriptor {
    /// Represents the Operating System of the served UE.
    #[serde(rename = "osId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub os_id: Option<uuid::Uuid>,

    #[serde(rename = "appId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub app_id: Option<String>,
}

impl AppDescriptor {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AppDescriptor {
        AppDescriptor {
            os_id: None,
            app_id: None,
        }
    }
}

/// Converts the AppDescriptor value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AppDescriptor {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping osId in query parameter serialization
            self.app_id
                .as_ref()
                .map(|app_id| vec!["appId".to_string(), app_id.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AppDescriptor value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AppDescriptor {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub os_id: Vec<uuid::Uuid>,
            pub app_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AppDescriptor".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "osId" => intermediate_rep.os_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "appId" => intermediate_rep.app_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AppDescriptor".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AppDescriptor {
            os_id: intermediate_rep.os_id.into_iter().next(),
            app_id: intermediate_rep.app_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AppDescriptor> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AppDescriptor>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AppDescriptor>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AppDescriptor - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AppDescriptor> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AppDescriptor as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AppDescriptor - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AppPortId {
    /// Integer where the allowed values correspond to the value range of an unsigned 16-bit integer.
    #[serde(rename = "destinationPort")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub destination_port: Option<u16>,

    /// Integer where the allowed values correspond to the value range of an unsigned 16-bit integer.
    #[serde(rename = "originatorPort")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub originator_port: Option<u16>,
}

impl AppPortId {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AppPortId {
        AppPortId {
            destination_port: None,
            originator_port: None,
        }
    }
}

/// Converts the AppPortId value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AppPortId {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.destination_port.as_ref().map(|destination_port| {
                vec!["destinationPort".to_string(), destination_port.to_string()].join(",")
            }),
            self.originator_port.as_ref().map(|originator_port| {
                vec!["originatorPort".to_string(), originator_port.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AppPortId value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AppPortId {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub destination_port: Vec<u16>,
            pub originator_port: Vec<u16>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AppPortId".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "destinationPort" => intermediate_rep.destination_port.push(
                        <u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "originatorPort" => intermediate_rep.originator_port.push(
                        <u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AppPortId".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AppPortId {
            destination_port: intermediate_rep.destination_port.into_iter().next(),
            originator_port: intermediate_rep.originator_port.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AppPortId> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AppPortId>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AppPortId>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AppPortId - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AppPortId> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AppPortId as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AppPortId - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Provides area information.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Area {
    #[serde(rename = "tacs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tacs: Option<Vec<models::Tac>>,

    /// Values are operator specific.
    #[serde(rename = "areaCode")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub area_code: Option<String>,
}

impl Area {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Area {
        Area {
            tacs: None,
            area_code: None,
        }
    }
}

/// Converts the Area value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Area {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.tacs.as_ref().map(|tacs| {
                vec![
                    "tacs".to_string(),
                    tacs.iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.area_code
                .as_ref()
                .map(|area_code| vec!["areaCode".to_string(), area_code.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Area value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Area {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub tacs: Vec<Vec<models::Tac>>,
            pub area_code: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err("Missing value while parsing Area".to_string())
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "tacs" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Area"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "areaCode" => intermediate_rep.area_code.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Area".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Area {
            tacs: intermediate_rep.tacs.into_iter().next(),
            area_code: intermediate_rep.area_code.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Area> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Area>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Area>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Area - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Area> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Area as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Area - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Values are operator specific.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AreaCode(String);

impl std::convert::From<String> for AreaCode {
    fn from(x: String) -> Self {
        AreaCode(x)
    }
}

impl std::string::ToString for AreaCode {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for AreaCode {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(AreaCode(x.to_string()))
    }
}

impl std::convert::From<AreaCode> for String {
    fn from(x: AreaCode) -> Self {
        x.0
    }
}

impl std::ops::Deref for AreaCode {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for AreaCode {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Contain the area based on Cells or Tracking Areas.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AreaScope {
    #[serde(rename = "eutraCellIdList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub eutra_cell_id_list: Option<Vec<models::EutraCellId>>,

    #[serde(rename = "nrCellIdList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nr_cell_id_list: Option<Vec<models::NrCellId>>,

    #[serde(rename = "tacList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tac_list: Option<Vec<models::Tac>>,

    /// A map (list of key-value pairs) where PlmnId converted to a string serves as key
    #[serde(rename = "tacInfoPerPlmn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tac_info_per_plmn: Option<std::collections::HashMap<String, models::TacInfo>>,
}

impl AreaScope {
    #[allow(clippy::new_without_default)]
    pub fn new() -> AreaScope {
        AreaScope {
            eutra_cell_id_list: None,
            nr_cell_id_list: None,
            tac_list: None,
            tac_info_per_plmn: None,
        }
    }
}

/// Converts the AreaScope value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AreaScope {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.eutra_cell_id_list.as_ref().map(|eutra_cell_id_list| {
                vec![
                    "eutraCellIdList".to_string(),
                    eutra_cell_id_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.nr_cell_id_list.as_ref().map(|nr_cell_id_list| {
                vec![
                    "nrCellIdList".to_string(),
                    nr_cell_id_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.tac_list.as_ref().map(|tac_list| {
                vec![
                    "tacList".to_string(),
                    tac_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping tacInfoPerPlmn in query parameter serialization
            // Skipping tacInfoPerPlmn in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AreaScope value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AreaScope {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub eutra_cell_id_list: Vec<Vec<models::EutraCellId>>,
            pub nr_cell_id_list: Vec<Vec<models::NrCellId>>,
            pub tac_list: Vec<Vec<models::Tac>>,
            pub tac_info_per_plmn: Vec<std::collections::HashMap<String, models::TacInfo>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing AreaScope".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "eutraCellIdList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AreaScope"
                                .to_string(),
                        )
                    }
                    "nrCellIdList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AreaScope"
                                .to_string(),
                        )
                    }
                    "tacList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AreaScope"
                                .to_string(),
                        )
                    }
                    "tacInfoPerPlmn" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in AreaScope"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing AreaScope".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AreaScope {
            eutra_cell_id_list: intermediate_rep.eutra_cell_id_list.into_iter().next(),
            nr_cell_id_list: intermediate_rep.nr_cell_id_list.into_iter().next(),
            tac_list: intermediate_rep.tac_list.into_iter().next(),
            tac_info_per_plmn: intermediate_rep.tac_info_per_plmn.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AreaScope> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AreaScope>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<AreaScope>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for AreaScope - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AreaScope> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <AreaScope as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into AreaScope - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Integer value indicating the ARFCN applicable for a downlink, uplink or bi-directional (TDD) NR global frequency raster, as definition of \"ARFCN-ValueNR\" IE in clause 6.3.2 of 3GPP TS 38.331.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ArfcnValueNr(i32);

impl std::convert::From<i32> for ArfcnValueNr {
    fn from(x: i32) -> Self {
        ArfcnValueNr(x)
    }
}

impl std::convert::From<ArfcnValueNr> for i32 {
    fn from(x: ArfcnValueNr) -> Self {
        x.0
    }
}

impl std::ops::Deref for ArfcnValueNr {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for ArfcnValueNr {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// Contains Allocation and Retention Priority information.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Arp {
    /// nullable true shall not be used for this attribute. Unsigned integer indicating the ARP Priority Level (see clause 5.7.2.2 of 3GPP TS 23.501, within the range 1 to 15.Values are ordered in decreasing order of priority, i.e. with 1 as the highest priority and 15 as the lowest priority.
    #[serde(rename = "priorityLevel")]
    pub priority_level: swagger::Nullable<u8>,

    #[serde(rename = "preemptCap")]
    pub preempt_cap: models::PreemptionCapability,

    #[serde(rename = "preemptVuln")]
    pub preempt_vuln: models::PreemptionVulnerability,
}

impl Arp {
    #[allow(clippy::new_without_default)]
    pub fn new(
        priority_level: swagger::Nullable<u8>,
        preempt_cap: models::PreemptionCapability,
        preempt_vuln: models::PreemptionVulnerability,
    ) -> Arp {
        Arp {
            priority_level,
            preempt_cap,
            preempt_vuln,
        }
    }
}

/// Converts the Arp value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Arp {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("priorityLevel".to_string()),
            Some(
                self.priority_level
                    .as_ref()
                    .map_or("null".to_string(), |x| x.to_string()),
            ),
            // Skipping preemptCap in query parameter serialization

            // Skipping preemptVuln in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Arp value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Arp {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub priority_level: Vec<u8>,
            pub preempt_cap: Vec<models::PreemptionCapability>,
            pub preempt_vuln: Vec<models::PreemptionVulnerability>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err("Missing value while parsing Arp".to_string())
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "priorityLevel" => {
                        return std::result::Result::Err(
                            "Parsing a nullable type in this style is not supported in Arp"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "preemptCap" => intermediate_rep.preempt_cap.push(
                        <models::PreemptionCapability as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "preemptVuln" => intermediate_rep.preempt_vuln.push(
                        <models::PreemptionVulnerability as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Arp".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Arp {
            priority_level: std::result::Result::Err(
                "Nullable types not supported in Arp".to_string(),
            )?,
            preempt_cap: intermediate_rep
                .preempt_cap
                .into_iter()
                .next()
                .ok_or_else(|| "preemptCap missing in Arp".to_string())?,
            preempt_vuln: intermediate_rep
                .preempt_vuln
                .into_iter()
                .next()
                .ok_or_else(|| "preemptVuln missing in Arp".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Arp> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Arp>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Arp>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Arp - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Arp> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Arp as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Arp - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// nullable true shall not be used for this attribute. Unsigned integer indicating the ARP Priority Level (see clause 5.7.2.2 of 3GPP TS 23.501, within the range 1 to 15.Values are ordered in decreasing order of priority, i.e. with 1 as the highest priority and 15 as the lowest priority.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ArpPriorityLevel(i32);

impl std::convert::From<i32> for ArpPriorityLevel {
    fn from(x: i32) -> Self {
        ArpPriorityLevel(x)
    }
}

impl std::convert::From<ArpPriorityLevel> for i32 {
    fn from(x: ArpPriorityLevel) -> Self {
        x.0
    }
}

impl std::ops::Deref for ArpPriorityLevel {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for ArpPriorityLevel {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// Parameters \"replaceableInd\" and \"rechargeableInd\" are only included if the value of Parameter \"batteryInd\" is true.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BatteryIndication {
    /// This IE shall indicate whether the UE is battery powered or not. true: the UE is battery powered; false or absent: the UE is not battery powered
    #[serde(rename = "batteryInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub battery_ind: Option<bool>,

    /// This IE shall indicate whether the battery of the UE is replaceable or not. true: the battery of the UE is replaceable; false or absent: the battery of the UE is not replaceable.
    #[serde(rename = "replaceableInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaceable_ind: Option<bool>,

    /// This IE shall indicate whether the battery of the UE is rechargeable or not. true: the battery of UE is rechargeable; false or absent: the battery of the UE is not rechargeable.
    #[serde(rename = "rechargeableInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rechargeable_ind: Option<bool>,
}

impl BatteryIndication {
    #[allow(clippy::new_without_default)]
    pub fn new() -> BatteryIndication {
        BatteryIndication {
            battery_ind: None,
            replaceable_ind: None,
            rechargeable_ind: None,
        }
    }
}

/// Converts the BatteryIndication value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for BatteryIndication {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.battery_ind.as_ref().map(|battery_ind| {
                vec!["batteryInd".to_string(), battery_ind.to_string()].join(",")
            }),
            self.replaceable_ind.as_ref().map(|replaceable_ind| {
                vec!["replaceableInd".to_string(), replaceable_ind.to_string()].join(",")
            }),
            self.rechargeable_ind.as_ref().map(|rechargeable_ind| {
                vec!["rechargeableInd".to_string(), rechargeable_ind.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BatteryIndication value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BatteryIndication {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub battery_ind: Vec<bool>,
            pub replaceable_ind: Vec<bool>,
            pub rechargeable_ind: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing BatteryIndication".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "batteryInd" => intermediate_rep.battery_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "replaceableInd" => intermediate_rep.replaceable_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "rechargeableInd" => intermediate_rep.rechargeable_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing BatteryIndication".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BatteryIndication {
            battery_ind: intermediate_rep.battery_ind.into_iter().next(),
            replaceable_ind: intermediate_rep.replaceable_ind.into_iter().next(),
            rechargeable_ind: intermediate_rep.rechargeable_ind.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BatteryIndication> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<BatteryIndication>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<BatteryIndication>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for BatteryIndication - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<BatteryIndication>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <BatteryIndication as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into BatteryIndication - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// string with format 'binary' as defined in OpenAPI.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Binary(swagger::ByteArray);

impl std::convert::From<swagger::ByteArray> for Binary {
    fn from(x: swagger::ByteArray) -> Self {
        Binary(x)
    }
}

impl std::convert::From<Binary> for swagger::ByteArray {
    fn from(x: Binary) -> Self {
        x.0
    }
}

impl std::ops::Deref for Binary {
    type Target = swagger::ByteArray;
    fn deref(&self) -> &swagger::ByteArray {
        &self.0
    }
}

impl std::ops::DerefMut for Binary {
    fn deref_mut(&mut self) -> &mut swagger::ByteArray {
        &mut self.0
    }
}

/// String representing a bit rate; the prefixes follow the standard symbols from The International System of Units, and represent x1000 multipliers, with the exception that prefix \"K\" is used to represent the standard symbol \"k\".
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BitRate(String);

impl std::convert::From<String> for BitRate {
    fn from(x: String) -> Self {
        BitRate(x)
    }
}

impl std::string::ToString for BitRate {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for BitRate {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(BitRate(x.to_string()))
    }
}

impl std::convert::From<BitRate> for String {
    fn from(x: BitRate) -> Self {
        x.0
    }
}

impl std::ops::Deref for BitRate {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for BitRate {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// string with format 'bytes' as defined in OpenAPI
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Bytes(swagger::ByteArray);

impl std::convert::From<swagger::ByteArray> for Bytes {
    fn from(x: swagger::ByteArray) -> Self {
        Bytes(x)
    }
}

impl std::convert::From<Bytes> for swagger::ByteArray {
    fn from(x: Bytes) -> Self {
        x.0
    }
}

impl std::ops::Deref for Bytes {
    type Target = swagger::ByteArray;
    fn deref(&self) -> &swagger::ByteArray {
        &self.0
    }
}

impl std::ops::DerefMut for Bytes {
    fn deref_mut(&mut self) -> &mut swagger::ByteArray {
        &mut self.0
    }
}

/// String representing the C-MSISDN as defined in clause 18.7 of 3GPP TS 23.003.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CMsisdn(String);

impl std::convert::From<String> for CMsisdn {
    fn from(x: String) -> Self {
        CMsisdn(x)
    }
}

impl std::string::ToString for CMsisdn {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for CMsisdn {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(CMsisdn(x.to_string()))
    }
}

impl std::convert::From<CMsisdn> for String {
    fn from(x: CMsisdn) -> Self {
        x.0
    }
}

impl std::ops::Deref for CMsisdn {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for CMsisdn {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CagData {
    /// A map (list of key-value pairs where PlmnId serves as key) of CagInfo
    #[serde(rename = "cagInfos")]
    pub cag_infos: std::collections::HashMap<String, models::CagInfo>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "provisioningTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provisioning_time: Option<chrono::DateTime<chrono::Utc>>,
}

impl CagData {
    #[allow(clippy::new_without_default)]
    pub fn new(cag_infos: std::collections::HashMap<String, models::CagInfo>) -> CagData {
        CagData {
            cag_infos,
            provisioning_time: None,
        }
    }
}

/// Converts the CagData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CagData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping cagInfos in query parameter serialization
            // Skipping cagInfos in query parameter serialization

            // Skipping provisioningTime in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CagData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CagData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cag_infos: Vec<std::collections::HashMap<String, models::CagInfo>>,
            pub provisioning_time: Vec<chrono::DateTime<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing CagData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "cagInfos" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in CagData"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "provisioningTime" => intermediate_rep.provisioning_time.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing CagData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CagData {
            cag_infos: intermediate_rep
                .cag_infos
                .into_iter()
                .next()
                .ok_or_else(|| "cagInfos missing in CagData".to_string())?,
            provisioning_time: intermediate_rep.provisioning_time.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CagData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CagData>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<CagData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for CagData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CagData> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <CagData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into CagData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// String containing a Closed Access Group Identifier.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CagId(String);

impl std::convert::From<String> for CagId {
    fn from(x: String) -> Self {
        CagId(x)
    }
}

impl std::string::ToString for CagId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for CagId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(CagId(x.to_string()))
    }
}

impl std::convert::From<CagId> for String {
    fn from(x: CagId) -> Self {
        x.0
    }
}

impl std::ops::Deref for CagId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for CagId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CagInfo {
    #[serde(rename = "allowedCagList")]
    pub allowed_cag_list: Vec<models::CagId>,

    #[serde(rename = "cagOnlyIndicator")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cag_only_indicator: Option<bool>,
}

impl CagInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(allowed_cag_list: Vec<models::CagId>) -> CagInfo {
        CagInfo {
            allowed_cag_list,
            cag_only_indicator: None,
        }
    }
}

/// Converts the CagInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CagInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("allowedCagList".to_string()),
            Some(
                self.allowed_cag_list
                    .iter()
                    .map(|x| x.to_string())
                    .collect::<Vec<_>>()
                    .join(","),
            ),
            self.cag_only_indicator.as_ref().map(|cag_only_indicator| {
                vec![
                    "cagOnlyIndicator".to_string(),
                    cag_only_indicator.to_string(),
                ]
                .join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CagInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CagInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub allowed_cag_list: Vec<Vec<models::CagId>>,
            pub cag_only_indicator: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing CagInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "allowedCagList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in CagInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "cagOnlyIndicator" => intermediate_rep.cag_only_indicator.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing CagInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CagInfo {
            allowed_cag_list: intermediate_rep
                .allowed_cag_list
                .into_iter()
                .next()
                .ok_or_else(|| "allowedCagList missing in CagInfo".to_string())?,
            cag_only_indicator: intermediate_rep.cag_only_indicator.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CagInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CagInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<CagInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for CagInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CagInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <CagInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into CagInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// It contains data which need to be changed.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChangeItem {
    #[serde(rename = "op")]
    pub op: models::ChangeType,

    /// contains a JSON pointer value (as defined in IETF RFC 6901) that references a target  location within the resource on which the change has been applied.
    #[serde(rename = "path")]
    pub path: String,

    /// indicates the path of the source JSON element (according to JSON Pointer syntax)  being moved or copied to the location indicated by the \"path\" attribute. It shall  be present if the \"op\" attribute is of value \"MOVE\".
    #[serde(rename = "from")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub from: Option<String>,

    #[serde(rename = "origValue")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub orig_value: Option<serde_json::Value>,

    #[serde(rename = "newValue")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub new_value: Option<serde_json::Value>,
}

impl ChangeItem {
    #[allow(clippy::new_without_default)]
    pub fn new(op: models::ChangeType, path: String) -> ChangeItem {
        ChangeItem {
            op,
            path,
            from: None,
            orig_value: None,
            new_value: None,
        }
    }
}

/// Converts the ChangeItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ChangeItem {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping op in query parameter serialization
            Some("path".to_string()),
            Some(self.path.to_string()),
            self.from
                .as_ref()
                .map(|from| vec!["from".to_string(), from.to_string()].join(",")),
            // Skipping origValue in query parameter serialization

            // Skipping newValue in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChangeItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChangeItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub op: Vec<models::ChangeType>,
            pub path: Vec<String>,
            pub from: Vec<String>,
            pub orig_value: Vec<serde_json::Value>,
            pub new_value: Vec<serde_json::Value>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ChangeItem".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "op" => intermediate_rep.op.push(
                        <models::ChangeType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "path" => intermediate_rep.path.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "from" => intermediate_rep.from.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "origValue" => intermediate_rep.orig_value.push(
                        <serde_json::Value as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "newValue" => intermediate_rep.new_value.push(
                        <serde_json::Value as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ChangeItem".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChangeItem {
            op: intermediate_rep
                .op
                .into_iter()
                .next()
                .ok_or_else(|| "op missing in ChangeItem".to_string())?,
            path: intermediate_rep
                .path
                .into_iter()
                .next()
                .ok_or_else(|| "path missing in ChangeItem".to_string())?,
            from: intermediate_rep.from.into_iter().next(),
            orig_value: intermediate_rep.orig_value.into_iter().next(),
            new_value: intermediate_rep.new_value.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChangeItem> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ChangeItem>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ChangeItem>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ChangeItem - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ChangeItem> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ChangeItem as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ChangeItem - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Indicates the type of change to be performed.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChangeType {}

impl ChangeType {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ChangeType {
        ChangeType {}
    }
}

/// Converts the ChangeType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ChangeType {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChangeType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChangeType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ChangeType".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ChangeType".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChangeType {})
    }
}

// Methods for converting between header::IntoHeaderValue<ChangeType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ChangeType>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ChangeType>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ChangeType - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ChangeType> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ChangeType as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ChangeType - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ChangeTypeAnyOf {
    #[serde(rename = "ADD")]
    Add,
    #[serde(rename = "MOVE")]
    Move,
    #[serde(rename = "REMOVE")]
    Remove,
    #[serde(rename = "REPLACE")]
    Replace,
}

impl std::fmt::Display for ChangeTypeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ChangeTypeAnyOf::Add => write!(f, "ADD"),
            ChangeTypeAnyOf::Move => write!(f, "MOVE"),
            ChangeTypeAnyOf::Remove => write!(f, "REMOVE"),
            ChangeTypeAnyOf::Replace => write!(f, "REPLACE"),
        }
    }
}

impl std::str::FromStr for ChangeTypeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ADD" => std::result::Result::Ok(ChangeTypeAnyOf::Add),
            "MOVE" => std::result::Result::Ok(ChangeTypeAnyOf::Move),
            "REMOVE" => std::result::Result::Ok(ChangeTypeAnyOf::Remove),
            "REPLACE" => std::result::Result::Ok(ChangeTypeAnyOf::Replace),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Indicates a Civic address.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CivicAddress {
    #[serde(rename = "country")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub country: Option<String>,

    #[serde(rename = "A1")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub a1: Option<String>,

    #[serde(rename = "A2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub a2: Option<String>,

    #[serde(rename = "A3")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub a3: Option<String>,

    #[serde(rename = "A4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub a4: Option<String>,

    #[serde(rename = "A5")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub a5: Option<String>,

    #[serde(rename = "A6")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub a6: Option<String>,

    #[serde(rename = "PRD")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prd: Option<String>,

    #[serde(rename = "POD")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pod: Option<String>,

    #[serde(rename = "STS")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sts: Option<String>,

    #[serde(rename = "HNO")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hno: Option<String>,

    #[serde(rename = "HNS")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hns: Option<String>,

    #[serde(rename = "LMK")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lmk: Option<String>,

    #[serde(rename = "LOC")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub loc: Option<String>,

    #[serde(rename = "NAM")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nam: Option<String>,

    #[serde(rename = "PC")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pc: Option<String>,

    #[serde(rename = "BLD")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bld: Option<String>,

    #[serde(rename = "UNIT")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unit: Option<String>,

    #[serde(rename = "FLR")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub flr: Option<String>,

    #[serde(rename = "ROOM")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub room: Option<String>,

    #[serde(rename = "PLC")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub plc: Option<String>,

    #[serde(rename = "PCN")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pcn: Option<String>,

    #[serde(rename = "POBOX")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pobox: Option<String>,

    #[serde(rename = "ADDCODE")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub addcode: Option<String>,

    #[serde(rename = "SEAT")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub seat: Option<String>,

    #[serde(rename = "RD")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rd: Option<String>,

    #[serde(rename = "RDSEC")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rdsec: Option<String>,

    #[serde(rename = "RDBR")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rdbr: Option<String>,

    #[serde(rename = "RDSUBBR")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rdsubbr: Option<String>,

    #[serde(rename = "PRM")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prm: Option<String>,

    #[serde(rename = "POM")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pom: Option<String>,

    #[serde(rename = "usageRules")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub usage_rules: Option<String>,

    #[serde(rename = "method")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub method: Option<String>,

    #[serde(rename = "providedBy")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provided_by: Option<String>,
}

impl CivicAddress {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CivicAddress {
        CivicAddress {
            country: None,
            a1: None,
            a2: None,
            a3: None,
            a4: None,
            a5: None,
            a6: None,
            prd: None,
            pod: None,
            sts: None,
            hno: None,
            hns: None,
            lmk: None,
            loc: None,
            nam: None,
            pc: None,
            bld: None,
            unit: None,
            flr: None,
            room: None,
            plc: None,
            pcn: None,
            pobox: None,
            addcode: None,
            seat: None,
            rd: None,
            rdsec: None,
            rdbr: None,
            rdsubbr: None,
            prm: None,
            pom: None,
            usage_rules: None,
            method: None,
            provided_by: None,
        }
    }
}

/// Converts the CivicAddress value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CivicAddress {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.country
                .as_ref()
                .map(|country| vec!["country".to_string(), country.to_string()].join(",")),
            self.a1
                .as_ref()
                .map(|a1| vec!["A1".to_string(), a1.to_string()].join(",")),
            self.a2
                .as_ref()
                .map(|a2| vec!["A2".to_string(), a2.to_string()].join(",")),
            self.a3
                .as_ref()
                .map(|a3| vec!["A3".to_string(), a3.to_string()].join(",")),
            self.a4
                .as_ref()
                .map(|a4| vec!["A4".to_string(), a4.to_string()].join(",")),
            self.a5
                .as_ref()
                .map(|a5| vec!["A5".to_string(), a5.to_string()].join(",")),
            self.a6
                .as_ref()
                .map(|a6| vec!["A6".to_string(), a6.to_string()].join(",")),
            self.prd
                .as_ref()
                .map(|prd| vec!["PRD".to_string(), prd.to_string()].join(",")),
            self.pod
                .as_ref()
                .map(|pod| vec!["POD".to_string(), pod.to_string()].join(",")),
            self.sts
                .as_ref()
                .map(|sts| vec!["STS".to_string(), sts.to_string()].join(",")),
            self.hno
                .as_ref()
                .map(|hno| vec!["HNO".to_string(), hno.to_string()].join(",")),
            self.hns
                .as_ref()
                .map(|hns| vec!["HNS".to_string(), hns.to_string()].join(",")),
            self.lmk
                .as_ref()
                .map(|lmk| vec!["LMK".to_string(), lmk.to_string()].join(",")),
            self.loc
                .as_ref()
                .map(|loc| vec!["LOC".to_string(), loc.to_string()].join(",")),
            self.nam
                .as_ref()
                .map(|nam| vec!["NAM".to_string(), nam.to_string()].join(",")),
            self.pc
                .as_ref()
                .map(|pc| vec!["PC".to_string(), pc.to_string()].join(",")),
            self.bld
                .as_ref()
                .map(|bld| vec!["BLD".to_string(), bld.to_string()].join(",")),
            self.unit
                .as_ref()
                .map(|unit| vec!["UNIT".to_string(), unit.to_string()].join(",")),
            self.flr
                .as_ref()
                .map(|flr| vec!["FLR".to_string(), flr.to_string()].join(",")),
            self.room
                .as_ref()
                .map(|room| vec!["ROOM".to_string(), room.to_string()].join(",")),
            self.plc
                .as_ref()
                .map(|plc| vec!["PLC".to_string(), plc.to_string()].join(",")),
            self.pcn
                .as_ref()
                .map(|pcn| vec!["PCN".to_string(), pcn.to_string()].join(",")),
            self.pobox
                .as_ref()
                .map(|pobox| vec!["POBOX".to_string(), pobox.to_string()].join(",")),
            self.addcode
                .as_ref()
                .map(|addcode| vec!["ADDCODE".to_string(), addcode.to_string()].join(",")),
            self.seat
                .as_ref()
                .map(|seat| vec!["SEAT".to_string(), seat.to_string()].join(",")),
            self.rd
                .as_ref()
                .map(|rd| vec!["RD".to_string(), rd.to_string()].join(",")),
            self.rdsec
                .as_ref()
                .map(|rdsec| vec!["RDSEC".to_string(), rdsec.to_string()].join(",")),
            self.rdbr
                .as_ref()
                .map(|rdbr| vec!["RDBR".to_string(), rdbr.to_string()].join(",")),
            self.rdsubbr
                .as_ref()
                .map(|rdsubbr| vec!["RDSUBBR".to_string(), rdsubbr.to_string()].join(",")),
            self.prm
                .as_ref()
                .map(|prm| vec!["PRM".to_string(), prm.to_string()].join(",")),
            self.pom
                .as_ref()
                .map(|pom| vec!["POM".to_string(), pom.to_string()].join(",")),
            self.usage_rules.as_ref().map(|usage_rules| {
                vec!["usageRules".to_string(), usage_rules.to_string()].join(",")
            }),
            self.method
                .as_ref()
                .map(|method| vec!["method".to_string(), method.to_string()].join(",")),
            self.provided_by.as_ref().map(|provided_by| {
                vec!["providedBy".to_string(), provided_by.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CivicAddress value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CivicAddress {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub country: Vec<String>,
            pub a1: Vec<String>,
            pub a2: Vec<String>,
            pub a3: Vec<String>,
            pub a4: Vec<String>,
            pub a5: Vec<String>,
            pub a6: Vec<String>,
            pub prd: Vec<String>,
            pub pod: Vec<String>,
            pub sts: Vec<String>,
            pub hno: Vec<String>,
            pub hns: Vec<String>,
            pub lmk: Vec<String>,
            pub loc: Vec<String>,
            pub nam: Vec<String>,
            pub pc: Vec<String>,
            pub bld: Vec<String>,
            pub unit: Vec<String>,
            pub flr: Vec<String>,
            pub room: Vec<String>,
            pub plc: Vec<String>,
            pub pcn: Vec<String>,
            pub pobox: Vec<String>,
            pub addcode: Vec<String>,
            pub seat: Vec<String>,
            pub rd: Vec<String>,
            pub rdsec: Vec<String>,
            pub rdbr: Vec<String>,
            pub rdsubbr: Vec<String>,
            pub prm: Vec<String>,
            pub pom: Vec<String>,
            pub usage_rules: Vec<String>,
            pub method: Vec<String>,
            pub provided_by: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing CivicAddress".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "country" => intermediate_rep.country.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "A1" => intermediate_rep.a1.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "A2" => intermediate_rep.a2.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "A3" => intermediate_rep.a3.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "A4" => intermediate_rep.a4.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "A5" => intermediate_rep.a5.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "A6" => intermediate_rep.a6.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "PRD" => intermediate_rep.prd.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "POD" => intermediate_rep.pod.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "STS" => intermediate_rep.sts.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "HNO" => intermediate_rep.hno.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "HNS" => intermediate_rep.hns.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "LMK" => intermediate_rep.lmk.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "LOC" => intermediate_rep.loc.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "NAM" => intermediate_rep.nam.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "PC" => intermediate_rep.pc.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "BLD" => intermediate_rep.bld.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "UNIT" => intermediate_rep.unit.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "FLR" => intermediate_rep.flr.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ROOM" => intermediate_rep.room.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "PLC" => intermediate_rep.plc.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "PCN" => intermediate_rep.pcn.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "POBOX" => intermediate_rep.pobox.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ADDCODE" => intermediate_rep.addcode.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "SEAT" => intermediate_rep.seat.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "RD" => intermediate_rep.rd.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "RDSEC" => intermediate_rep.rdsec.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "RDBR" => intermediate_rep.rdbr.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "RDSUBBR" => intermediate_rep.rdsubbr.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "PRM" => intermediate_rep.prm.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "POM" => intermediate_rep.pom.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "usageRules" => intermediate_rep.usage_rules.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "method" => intermediate_rep.method.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "providedBy" => intermediate_rep.provided_by.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing CivicAddress".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CivicAddress {
            country: intermediate_rep.country.into_iter().next(),
            a1: intermediate_rep.a1.into_iter().next(),
            a2: intermediate_rep.a2.into_iter().next(),
            a3: intermediate_rep.a3.into_iter().next(),
            a4: intermediate_rep.a4.into_iter().next(),
            a5: intermediate_rep.a5.into_iter().next(),
            a6: intermediate_rep.a6.into_iter().next(),
            prd: intermediate_rep.prd.into_iter().next(),
            pod: intermediate_rep.pod.into_iter().next(),
            sts: intermediate_rep.sts.into_iter().next(),
            hno: intermediate_rep.hno.into_iter().next(),
            hns: intermediate_rep.hns.into_iter().next(),
            lmk: intermediate_rep.lmk.into_iter().next(),
            loc: intermediate_rep.loc.into_iter().next(),
            nam: intermediate_rep.nam.into_iter().next(),
            pc: intermediate_rep.pc.into_iter().next(),
            bld: intermediate_rep.bld.into_iter().next(),
            unit: intermediate_rep.unit.into_iter().next(),
            flr: intermediate_rep.flr.into_iter().next(),
            room: intermediate_rep.room.into_iter().next(),
            plc: intermediate_rep.plc.into_iter().next(),
            pcn: intermediate_rep.pcn.into_iter().next(),
            pobox: intermediate_rep.pobox.into_iter().next(),
            addcode: intermediate_rep.addcode.into_iter().next(),
            seat: intermediate_rep.seat.into_iter().next(),
            rd: intermediate_rep.rd.into_iter().next(),
            rdsec: intermediate_rep.rdsec.into_iter().next(),
            rdbr: intermediate_rep.rdbr.into_iter().next(),
            rdsubbr: intermediate_rep.rdsubbr.into_iter().next(),
            prm: intermediate_rep.prm.into_iter().next(),
            pom: intermediate_rep.pom.into_iter().next(),
            usage_rules: intermediate_rep.usage_rules.into_iter().next(),
            method: intermediate_rep.method.into_iter().next(),
            provided_by: intermediate_rep.provided_by.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CivicAddress> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CivicAddress>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<CivicAddress>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for CivicAddress - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CivicAddress> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <CivicAddress as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into CivicAddress - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CodeWord(String);

impl std::convert::From<String> for CodeWord {
    fn from(x: String) -> Self {
        CodeWord(x)
    }
}

impl std::string::ToString for CodeWord {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for CodeWord {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(CodeWord(x.to_string()))
    }
}

impl std::convert::From<CodeWord> for String {
    fn from(x: CodeWord) -> Self {
        x.0
    }
}

impl std::ops::Deref for CodeWord {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for CodeWord {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CodeWordInd {}

impl CodeWordInd {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CodeWordInd {
        CodeWordInd {}
    }
}

/// Converts the CodeWordInd value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CodeWordInd {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CodeWordInd value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CodeWordInd {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing CodeWordInd".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing CodeWordInd".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CodeWordInd {})
    }
}

// Methods for converting between header::IntoHeaderValue<CodeWordInd> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CodeWordInd>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<CodeWordInd>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for CodeWordInd - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CodeWordInd> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <CodeWordInd as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into CodeWordInd - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum CodeWordIndAnyOf {
    #[serde(rename = "CODEWORD_CHECK_IN_UE")]
    Ue,
    #[serde(rename = "CODEWORD_CHECK_IN_GMLC")]
    Gmlc,
}

impl std::fmt::Display for CodeWordIndAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            CodeWordIndAnyOf::Ue => write!(f, "CODEWORD_CHECK_IN_UE"),
            CodeWordIndAnyOf::Gmlc => write!(f, "CODEWORD_CHECK_IN_GMLC"),
        }
    }
}

impl std::str::FromStr for CodeWordIndAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "CODEWORD_CHECK_IN_UE" => std::result::Result::Ok(CodeWordIndAnyOf::Ue),
            "CODEWORD_CHECK_IN_GMLC" => std::result::Result::Ok(CodeWordIndAnyOf::Gmlc),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// The enumeration CollectionPeriodRmmLteMdt defines Collection period for RRM measurements LTE for MDT in the trace. See 3GPP TS 32.422 for further description of the values. It shall comply with the provisions defined in table 5.6.3.15-1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CollectionPeriodRmmLteMdt {}

impl CollectionPeriodRmmLteMdt {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CollectionPeriodRmmLteMdt {
        CollectionPeriodRmmLteMdt {}
    }
}

/// Converts the CollectionPeriodRmmLteMdt value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CollectionPeriodRmmLteMdt {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CollectionPeriodRmmLteMdt value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CollectionPeriodRmmLteMdt {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing CollectionPeriodRmmLteMdt".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing CollectionPeriodRmmLteMdt".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CollectionPeriodRmmLteMdt {})
    }
}

// Methods for converting between header::IntoHeaderValue<CollectionPeriodRmmLteMdt> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CollectionPeriodRmmLteMdt>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<CollectionPeriodRmmLteMdt>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for CollectionPeriodRmmLteMdt - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<CollectionPeriodRmmLteMdt>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <CollectionPeriodRmmLteMdt as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into CollectionPeriodRmmLteMdt - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum CollectionPeriodRmmLteMdtAnyOf {
    #[serde(rename = "1024")]
    Variant1024,
    #[serde(rename = "1280")]
    Variant1280,
    #[serde(rename = "2048")]
    Variant2048,
    #[serde(rename = "2560")]
    Variant2560,
    #[serde(rename = "5120")]
    Variant5120,
    #[serde(rename = "10240")]
    Variant10240,
    #[serde(rename = "60000")]
    Variant60000,
}

impl std::fmt::Display for CollectionPeriodRmmLteMdtAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            CollectionPeriodRmmLteMdtAnyOf::Variant1024 => write!(f, "1024"),
            CollectionPeriodRmmLteMdtAnyOf::Variant1280 => write!(f, "1280"),
            CollectionPeriodRmmLteMdtAnyOf::Variant2048 => write!(f, "2048"),
            CollectionPeriodRmmLteMdtAnyOf::Variant2560 => write!(f, "2560"),
            CollectionPeriodRmmLteMdtAnyOf::Variant5120 => write!(f, "5120"),
            CollectionPeriodRmmLteMdtAnyOf::Variant10240 => write!(f, "10240"),
            CollectionPeriodRmmLteMdtAnyOf::Variant60000 => write!(f, "60000"),
        }
    }
}

impl std::str::FromStr for CollectionPeriodRmmLteMdtAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "1024" => std::result::Result::Ok(CollectionPeriodRmmLteMdtAnyOf::Variant1024),
            "1280" => std::result::Result::Ok(CollectionPeriodRmmLteMdtAnyOf::Variant1280),
            "2048" => std::result::Result::Ok(CollectionPeriodRmmLteMdtAnyOf::Variant2048),
            "2560" => std::result::Result::Ok(CollectionPeriodRmmLteMdtAnyOf::Variant2560),
            "5120" => std::result::Result::Ok(CollectionPeriodRmmLteMdtAnyOf::Variant5120),
            "10240" => std::result::Result::Ok(CollectionPeriodRmmLteMdtAnyOf::Variant10240),
            "60000" => std::result::Result::Ok(CollectionPeriodRmmLteMdtAnyOf::Variant60000),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// The enumeration CollectionPeriodRmmNrMdt defines Collection period for RRM measurements NR for MDT in the trace. See 3GPP TS 32.422 for further description of the values. It shall comply with the provisions defined in table 5.6.3.19-1
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CollectionPeriodRmmNrMdt {}

impl CollectionPeriodRmmNrMdt {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CollectionPeriodRmmNrMdt {
        CollectionPeriodRmmNrMdt {}
    }
}

/// Converts the CollectionPeriodRmmNrMdt value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CollectionPeriodRmmNrMdt {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CollectionPeriodRmmNrMdt value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CollectionPeriodRmmNrMdt {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing CollectionPeriodRmmNrMdt".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing CollectionPeriodRmmNrMdt".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CollectionPeriodRmmNrMdt {})
    }
}

// Methods for converting between header::IntoHeaderValue<CollectionPeriodRmmNrMdt> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CollectionPeriodRmmNrMdt>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<CollectionPeriodRmmNrMdt>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for CollectionPeriodRmmNrMdt - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<CollectionPeriodRmmNrMdt>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <CollectionPeriodRmmNrMdt as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into CollectionPeriodRmmNrMdt - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum CollectionPeriodRmmNrMdtAnyOf {
    #[serde(rename = "1024")]
    Variant1024,
    #[serde(rename = "2048")]
    Variant2048,
    #[serde(rename = "5120")]
    Variant5120,
    #[serde(rename = "10240")]
    Variant10240,
    #[serde(rename = "60000")]
    Variant60000,
}

impl std::fmt::Display for CollectionPeriodRmmNrMdtAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            CollectionPeriodRmmNrMdtAnyOf::Variant1024 => write!(f, "1024"),
            CollectionPeriodRmmNrMdtAnyOf::Variant2048 => write!(f, "2048"),
            CollectionPeriodRmmNrMdtAnyOf::Variant5120 => write!(f, "5120"),
            CollectionPeriodRmmNrMdtAnyOf::Variant10240 => write!(f, "10240"),
            CollectionPeriodRmmNrMdtAnyOf::Variant60000 => write!(f, "60000"),
        }
    }
}

impl std::str::FromStr for CollectionPeriodRmmNrMdtAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "1024" => std::result::Result::Ok(CollectionPeriodRmmNrMdtAnyOf::Variant1024),
            "2048" => std::result::Result::Ok(CollectionPeriodRmmNrMdtAnyOf::Variant2048),
            "5120" => std::result::Result::Ok(CollectionPeriodRmmNrMdtAnyOf::Variant5120),
            "10240" => std::result::Result::Ok(CollectionPeriodRmmNrMdtAnyOf::Variant10240),
            "60000" => std::result::Result::Ok(CollectionPeriodRmmNrMdtAnyOf::Variant60000),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Indicates value of confidence.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Confidence(i32);

impl std::convert::From<i32> for Confidence {
    fn from(x: i32) -> Self {
        Confidence(x)
    }
}

impl std::convert::From<Confidence> for i32 {
    fn from(x: Confidence) -> Self {
        x.0
    }
}

impl std::ops::Deref for Confidence {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for Confidence {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContextInfo {
    #[serde(rename = "origHeaders")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub orig_headers: Option<Vec<String>>,

    #[serde(rename = "requestHeaders")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub request_headers: Option<Vec<String>>,
}

impl ContextInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ContextInfo {
        ContextInfo {
            orig_headers: None,
            request_headers: None,
        }
    }
}

/// Converts the ContextInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ContextInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.orig_headers.as_ref().map(|orig_headers| {
                vec![
                    "origHeaders".to_string(),
                    orig_headers
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.request_headers.as_ref().map(|request_headers| {
                vec![
                    "requestHeaders".to_string(),
                    request_headers
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContextInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContextInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub orig_headers: Vec<Vec<String>>,
            pub request_headers: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ContextInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "origHeaders" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in ContextInfo"
                                .to_string(),
                        )
                    }
                    "requestHeaders" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in ContextInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ContextInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContextInfo {
            orig_headers: intermediate_rep.orig_headers.into_iter().next(),
            request_headers: intermediate_rep.request_headers.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContextInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ContextInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ContextInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ContextInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ContextInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ContextInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ContextInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// It contains the Core Network type 5GC or EPC.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CoreNetworkType {}

impl CoreNetworkType {
    #[allow(clippy::new_without_default)]
    pub fn new() -> CoreNetworkType {
        CoreNetworkType {}
    }
}

/// Converts the CoreNetworkType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CoreNetworkType {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CoreNetworkType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CoreNetworkType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing CoreNetworkType".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing CoreNetworkType".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CoreNetworkType {})
    }
}

// Methods for converting between header::IntoHeaderValue<CoreNetworkType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CoreNetworkType>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<CoreNetworkType>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for CoreNetworkType - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<CoreNetworkType>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <CoreNetworkType as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into CoreNetworkType - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum CoreNetworkTypeAnyOf {
    #[serde(rename = "5GC")]
    Variant5Gc,
    #[serde(rename = "EPC")]
    Epc,
}

impl std::fmt::Display for CoreNetworkTypeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            CoreNetworkTypeAnyOf::Variant5Gc => write!(f, "5GC"),
            CoreNetworkTypeAnyOf::Epc => write!(f, "EPC"),
        }
    }
}

impl std::str::FromStr for CoreNetworkTypeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "5GC" => std::result::Result::Ok(CoreNetworkTypeAnyOf::Variant5Gc),
            "EPC" => std::result::Result::Ok(CoreNetworkTypeAnyOf::Epc),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// CounterSoR.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CounterSor(String);

impl std::convert::From<String> for CounterSor {
    fn from(x: String) -> Self {
        CounterSor(x)
    }
}

impl std::string::ToString for CounterSor {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for CounterSor {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(CounterSor(x.to_string()))
    }
}

impl std::convert::From<CounterSor> for String {
    fn from(x: CounterSor) -> Self {
        x.0
    }
}

impl std::ops::Deref for CounterSor {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for CounterSor {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// CounterUPU.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CounterUpu(String);

impl std::convert::From<String> for CounterUpu {
    fn from(x: String) -> Self {
        CounterUpu(x)
    }
}

impl std::string::ToString for CounterUpu {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for CounterUpu {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(CounterUpu(x.to_string()))
    }
}

impl std::convert::From<CounterUpu> for String {
    fn from(x: CounterUpu) -> Self {
        x.0
    }
}

impl std::ops::Deref for CounterUpu {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for CounterUpu {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DataSetName {}

impl DataSetName {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DataSetName {
        DataSetName {}
    }
}

/// Converts the DataSetName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DataSetName {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DataSetName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DataSetName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing DataSetName".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing DataSetName".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DataSetName {})
    }
}

// Methods for converting between header::IntoHeaderValue<DataSetName> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DataSetName>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<DataSetName>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for DataSetName - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DataSetName> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <DataSetName as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into DataSetName - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum DataSetNameAnyOf {
    #[serde(rename = "AM")]
    Am,
    #[serde(rename = "SMF_SEL")]
    SmfSel,
    #[serde(rename = "UEC_SMF")]
    UecSmf,
    #[serde(rename = "UEC_SMSF")]
    UecSmsf,
    #[serde(rename = "SMS_SUB")]
    SmsSub,
    #[serde(rename = "SM")]
    Sm,
    #[serde(rename = "TRACE")]
    Trace,
    #[serde(rename = "SMS_MNG")]
    SmsMng,
    #[serde(rename = "LCS_PRIVACY")]
    LcsPrivacy,
    #[serde(rename = "LCS_MO")]
    LcsMo,
    #[serde(rename = "UEC_AMF")]
    UecAmf,
    #[serde(rename = "V2X")]
    V2X,
    #[serde(rename = "LCS_BCA")]
    LcsBca,
    #[serde(rename = "PROSE")]
    Prose,
    #[serde(rename = "UC")]
    Uc,
    #[serde(rename = "MBS")]
    Mbs,
}

impl std::fmt::Display for DataSetNameAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            DataSetNameAnyOf::Am => write!(f, "AM"),
            DataSetNameAnyOf::SmfSel => write!(f, "SMF_SEL"),
            DataSetNameAnyOf::UecSmf => write!(f, "UEC_SMF"),
            DataSetNameAnyOf::UecSmsf => write!(f, "UEC_SMSF"),
            DataSetNameAnyOf::SmsSub => write!(f, "SMS_SUB"),
            DataSetNameAnyOf::Sm => write!(f, "SM"),
            DataSetNameAnyOf::Trace => write!(f, "TRACE"),
            DataSetNameAnyOf::SmsMng => write!(f, "SMS_MNG"),
            DataSetNameAnyOf::LcsPrivacy => write!(f, "LCS_PRIVACY"),
            DataSetNameAnyOf::LcsMo => write!(f, "LCS_MO"),
            DataSetNameAnyOf::UecAmf => write!(f, "UEC_AMF"),
            DataSetNameAnyOf::V2X => write!(f, "V2X"),
            DataSetNameAnyOf::LcsBca => write!(f, "LCS_BCA"),
            DataSetNameAnyOf::Prose => write!(f, "PROSE"),
            DataSetNameAnyOf::Uc => write!(f, "UC"),
            DataSetNameAnyOf::Mbs => write!(f, "MBS"),
        }
    }
}

impl std::str::FromStr for DataSetNameAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "AM" => std::result::Result::Ok(DataSetNameAnyOf::Am),
            "SMF_SEL" => std::result::Result::Ok(DataSetNameAnyOf::SmfSel),
            "UEC_SMF" => std::result::Result::Ok(DataSetNameAnyOf::UecSmf),
            "UEC_SMSF" => std::result::Result::Ok(DataSetNameAnyOf::UecSmsf),
            "SMS_SUB" => std::result::Result::Ok(DataSetNameAnyOf::SmsSub),
            "SM" => std::result::Result::Ok(DataSetNameAnyOf::Sm),
            "TRACE" => std::result::Result::Ok(DataSetNameAnyOf::Trace),
            "SMS_MNG" => std::result::Result::Ok(DataSetNameAnyOf::SmsMng),
            "LCS_PRIVACY" => std::result::Result::Ok(DataSetNameAnyOf::LcsPrivacy),
            "LCS_MO" => std::result::Result::Ok(DataSetNameAnyOf::LcsMo),
            "UEC_AMF" => std::result::Result::Ok(DataSetNameAnyOf::UecAmf),
            "V2X" => std::result::Result::Ok(DataSetNameAnyOf::V2X),
            "LCS_BCA" => std::result::Result::Ok(DataSetNameAnyOf::LcsBca),
            "PROSE" => std::result::Result::Ok(DataSetNameAnyOf::Prose),
            "UC" => std::result::Result::Ok(DataSetNameAnyOf::Uc),
            "MBS" => std::result::Result::Ok(DataSetNameAnyOf::Mbs),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// string with format 'date-time' as defined in OpenAPI.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DateTime(chrono::DateTime<chrono::Utc>);

impl std::convert::From<chrono::DateTime<chrono::Utc>> for DateTime {
    fn from(x: chrono::DateTime<chrono::Utc>) -> Self {
        DateTime(x)
    }
}

impl std::convert::From<DateTime> for chrono::DateTime<chrono::Utc> {
    fn from(x: DateTime) -> Self {
        x.0
    }
}

impl std::ops::Deref for DateTime {
    type Target = chrono::DateTime<chrono::Utc>;
    fn deref(&self) -> &chrono::DateTime<chrono::Utc> {
        &self.0
    }
}

impl std::ops::DerefMut for DateTime {
    fn deref_mut(&mut self) -> &mut chrono::DateTime<chrono::Utc> {
        &mut self.0
    }
}

/// integer between and including 1 and 7 denoting a weekday. 1 shall indicate Monday, and the subsequent weekdays  shall be indicated with the next higher numbers. 7 shall indicate Sunday.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DayOfWeek(i32);

impl std::convert::From<i32> for DayOfWeek {
    fn from(x: i32) -> Self {
        DayOfWeek(x)
    }
}

impl std::convert::From<DayOfWeek> for i32 {
    fn from(x: DayOfWeek) -> Self {
        x.0
    }
}

impl std::ops::Deref for DayOfWeek {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for DayOfWeek {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DefaultUnrelatedClass {
    #[serde(rename = "allowedGeographicArea")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allowed_geographic_area: Option<Vec<models::GeographicArea>>,

    #[serde(rename = "privacyCheckRelatedAction")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub privacy_check_related_action: Option<models::PrivacyCheckRelatedAction>,

    #[serde(rename = "codeWordInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub code_word_ind: Option<models::CodeWordInd>,

    #[serde(rename = "validTimePeriod")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub valid_time_period: Option<models::ValidTimePeriod>,

    #[serde(rename = "codeWordList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub code_word_list: Option<Vec<models::CodeWord>>,
}

impl DefaultUnrelatedClass {
    #[allow(clippy::new_without_default)]
    pub fn new() -> DefaultUnrelatedClass {
        DefaultUnrelatedClass {
            allowed_geographic_area: None,
            privacy_check_related_action: None,
            code_word_ind: None,
            valid_time_period: None,
            code_word_list: None,
        }
    }
}

/// Converts the DefaultUnrelatedClass value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DefaultUnrelatedClass {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping allowedGeographicArea in query parameter serialization

            // Skipping privacyCheckRelatedAction in query parameter serialization

            // Skipping codeWordInd in query parameter serialization

            // Skipping validTimePeriod in query parameter serialization
            self.code_word_list.as_ref().map(|code_word_list| {
                vec![
                    "codeWordList".to_string(),
                    code_word_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DefaultUnrelatedClass value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DefaultUnrelatedClass {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub allowed_geographic_area: Vec<Vec<models::GeographicArea>>,
            pub privacy_check_related_action: Vec<models::PrivacyCheckRelatedAction>,
            pub code_word_ind: Vec<models::CodeWordInd>,
            pub valid_time_period: Vec<models::ValidTimePeriod>,
            pub code_word_list: Vec<Vec<models::CodeWord>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing DefaultUnrelatedClass".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "allowedGeographicArea" => return std::result::Result::Err("Parsing a container in this style is not supported in DefaultUnrelatedClass".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "privacyCheckRelatedAction" => intermediate_rep.privacy_check_related_action.push(<models::PrivacyCheckRelatedAction as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "codeWordInd" => intermediate_rep.code_word_ind.push(<models::CodeWordInd as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "validTimePeriod" => intermediate_rep.valid_time_period.push(<models::ValidTimePeriod as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "codeWordList" => return std::result::Result::Err("Parsing a container in this style is not supported in DefaultUnrelatedClass".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing DefaultUnrelatedClass".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DefaultUnrelatedClass {
            allowed_geographic_area: intermediate_rep.allowed_geographic_area.into_iter().next(),
            privacy_check_related_action: intermediate_rep
                .privacy_check_related_action
                .into_iter()
                .next(),
            code_word_ind: intermediate_rep.code_word_ind.into_iter().next(),
            valid_time_period: intermediate_rep.valid_time_period.into_iter().next(),
            code_word_list: intermediate_rep.code_word_list.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DefaultUnrelatedClass> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DefaultUnrelatedClass>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<DefaultUnrelatedClass>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for DefaultUnrelatedClass - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<DefaultUnrelatedClass>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <DefaultUnrelatedClass as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into DefaultUnrelatedClass - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// String representing a Data Network as defined in clause 9A of 3GPP TS 23.003;  it shall contain either a DNN Network Identifier, or a full DNN with both the Network  Identifier and Operator Identifier, as specified in 3GPP TS 23.003 clause 9.1.1 and 9.1.2. It shall be coded as string in which the labels are separated by dots  (e.g. \"Label1.Label2.Label3\").
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Dnn(String);

impl std::convert::From<String> for Dnn {
    fn from(x: String) -> Self {
        Dnn(x)
    }
}

impl std::string::ToString for Dnn {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Dnn {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Dnn(x.to_string()))
    }
}

impl std::convert::From<Dnn> for String {
    fn from(x: Dnn) -> Self {
        x.0
    }
}

impl std::ops::Deref for Dnn {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Dnn {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DnnConfiguration {
    #[serde(rename = "pduSessionTypes")]
    pub pdu_session_types: models::PduSessionTypes,

    #[serde(rename = "sscModes")]
    pub ssc_modes: models::SscModes,

    #[serde(rename = "iwkEpsInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub iwk_eps_ind: Option<bool>,

    #[serde(rename = "5gQosProfile")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub param_5g_qos_profile: Option<models::SubscribedDefaultQos>,

    #[serde(rename = "sessionAmbr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub session_ambr: Option<models::Ambr>,

    #[serde(rename = "3gppChargingCharacteristics")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub param_3gpp_charging_characteristics: Option<String>,

    #[serde(rename = "staticIpAddress")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub static_ip_address: Option<Vec<models::IpAddress>>,

    #[serde(rename = "upSecurity")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub up_security: Option<models::UpSecurity>,

    #[serde(rename = "pduSessionContinuityInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pdu_session_continuity_ind: Option<models::PduSessionContinuityInd>,

    /// Identity of the NEF
    #[serde(rename = "niddNefId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nidd_nef_id: Option<String>,

    #[serde(rename = "niddInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nidd_info: Option<models::NiddInformation>,

    #[serde(rename = "redundantSessionAllowed")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub redundant_session_allowed: Option<bool>,

    #[serde(rename = "acsInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub acs_info: Option<models::AcsInfo>,

    #[serde(rename = "ipv4FrameRouteList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv4_frame_route_list: Option<Vec<models::FrameRouteInfo>>,

    #[serde(rename = "ipv6FrameRouteList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_frame_route_list: Option<Vec<models::FrameRouteInfo>>,

    #[serde(rename = "atsssAllowed")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub atsss_allowed: Option<bool>,

    #[serde(rename = "secondaryAuth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub secondary_auth: Option<bool>,

    #[serde(rename = "uavSecondaryAuth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub uav_secondary_auth: Option<bool>,

    #[serde(rename = "dnAaaIpAddressAllocation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dn_aaa_ip_address_allocation: Option<bool>,

    #[serde(rename = "dnAaaAddress")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dn_aaa_address: Option<models::IpAddress>,

    #[serde(rename = "additionalDnAaaAddresses")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_dn_aaa_addresses: Option<Vec<models::IpAddress>>,

    /// Fully Qualified Domain Name
    #[serde(rename = "dnAaaFqdn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dn_aaa_fqdn: Option<String>,

    #[serde(rename = "iptvAccCtrlInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub iptv_acc_ctrl_info: Option<String>,

    #[serde(rename = "ipv4Index")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv4_index: Option<models::IpIndex>,

    #[serde(rename = "ipv6Index")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_index: Option<models::IpIndex>,

    #[serde(rename = "ecsAddrConfigInfo")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ecs_addr_config_info: Option<swagger::Nullable<models::EcsAddrConfigInfo>>,

    #[serde(rename = "additionalEcsAddrConfigInfos")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_ecs_addr_config_infos: Option<Vec<models::EcsAddrConfigInfo>>,

    #[serde(rename = "sharedEcsAddrConfigInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shared_ecs_addr_config_info: Option<String>,

    #[serde(rename = "additionalSharedEcsAddrConfigInfoIds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_shared_ecs_addr_config_info_ids: Option<Vec<models::SharedDataId>>,

    #[serde(rename = "easDiscoveryAuthorized")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub eas_discovery_authorized: Option<bool>,

    #[serde(rename = "onboardingInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub onboarding_ind: Option<bool>,

    #[serde(rename = "aerialUeInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aerial_ue_ind: Option<models::AerialUeIndication>,

    #[serde(rename = "subscribedMaxIpv6PrefixSize")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscribed_max_ipv6_prefix_size: Option<i32>,
}

impl DnnConfiguration {
    #[allow(clippy::new_without_default)]
    pub fn new(
        pdu_session_types: models::PduSessionTypes,
        ssc_modes: models::SscModes,
    ) -> DnnConfiguration {
        DnnConfiguration {
            pdu_session_types,
            ssc_modes,
            iwk_eps_ind: None,
            param_5g_qos_profile: None,
            session_ambr: None,
            param_3gpp_charging_characteristics: None,
            static_ip_address: None,
            up_security: None,
            pdu_session_continuity_ind: None,
            nidd_nef_id: None,
            nidd_info: None,
            redundant_session_allowed: None,
            acs_info: None,
            ipv4_frame_route_list: None,
            ipv6_frame_route_list: None,
            atsss_allowed: Some(false),
            secondary_auth: None,
            uav_secondary_auth: Some(false),
            dn_aaa_ip_address_allocation: None,
            dn_aaa_address: None,
            additional_dn_aaa_addresses: None,
            dn_aaa_fqdn: None,
            iptv_acc_ctrl_info: None,
            ipv4_index: None,
            ipv6_index: None,
            ecs_addr_config_info: None,
            additional_ecs_addr_config_infos: None,
            shared_ecs_addr_config_info: None,
            additional_shared_ecs_addr_config_info_ids: None,
            eas_discovery_authorized: Some(false),
            onboarding_ind: Some(false),
            aerial_ue_ind: None,
            subscribed_max_ipv6_prefix_size: None,
        }
    }
}

/// Converts the DnnConfiguration value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DnnConfiguration {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping pduSessionTypes in query parameter serialization

            // Skipping sscModes in query parameter serialization
            self.iwk_eps_ind.as_ref().map(|iwk_eps_ind| {
                vec!["iwkEpsInd".to_string(), iwk_eps_ind.to_string()].join(",")
            }),
            // Skipping 5gQosProfile in query parameter serialization

            // Skipping sessionAmbr in query parameter serialization
            self.param_3gpp_charging_characteristics.as_ref().map(
                |param_3gpp_charging_characteristics| {
                    vec![
                        "3gppChargingCharacteristics".to_string(),
                        param_3gpp_charging_characteristics.to_string(),
                    ]
                    .join(",")
                },
            ),
            // Skipping staticIpAddress in query parameter serialization

            // Skipping upSecurity in query parameter serialization

            // Skipping pduSessionContinuityInd in query parameter serialization
            self.nidd_nef_id.as_ref().map(|nidd_nef_id| {
                vec!["niddNefId".to_string(), nidd_nef_id.to_string()].join(",")
            }),
            // Skipping niddInfo in query parameter serialization
            self.redundant_session_allowed
                .as_ref()
                .map(|redundant_session_allowed| {
                    vec![
                        "redundantSessionAllowed".to_string(),
                        redundant_session_allowed.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping acsInfo in query parameter serialization

            // Skipping ipv4FrameRouteList in query parameter serialization

            // Skipping ipv6FrameRouteList in query parameter serialization
            self.atsss_allowed.as_ref().map(|atsss_allowed| {
                vec!["atsssAllowed".to_string(), atsss_allowed.to_string()].join(",")
            }),
            self.secondary_auth.as_ref().map(|secondary_auth| {
                vec!["secondaryAuth".to_string(), secondary_auth.to_string()].join(",")
            }),
            self.uav_secondary_auth.as_ref().map(|uav_secondary_auth| {
                vec![
                    "uavSecondaryAuth".to_string(),
                    uav_secondary_auth.to_string(),
                ]
                .join(",")
            }),
            self.dn_aaa_ip_address_allocation
                .as_ref()
                .map(|dn_aaa_ip_address_allocation| {
                    vec![
                        "dnAaaIpAddressAllocation".to_string(),
                        dn_aaa_ip_address_allocation.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping dnAaaAddress in query parameter serialization

            // Skipping additionalDnAaaAddresses in query parameter serialization
            self.dn_aaa_fqdn.as_ref().map(|dn_aaa_fqdn| {
                vec!["dnAaaFqdn".to_string(), dn_aaa_fqdn.to_string()].join(",")
            }),
            self.iptv_acc_ctrl_info.as_ref().map(|iptv_acc_ctrl_info| {
                vec![
                    "iptvAccCtrlInfo".to_string(),
                    iptv_acc_ctrl_info.to_string(),
                ]
                .join(",")
            }),
            // Skipping ipv4Index in query parameter serialization

            // Skipping ipv6Index in query parameter serialization

            // Skipping ecsAddrConfigInfo in query parameter serialization

            // Skipping additionalEcsAddrConfigInfos in query parameter serialization
            self.shared_ecs_addr_config_info
                .as_ref()
                .map(|shared_ecs_addr_config_info| {
                    vec![
                        "sharedEcsAddrConfigInfo".to_string(),
                        shared_ecs_addr_config_info.to_string(),
                    ]
                    .join(",")
                }),
            self.additional_shared_ecs_addr_config_info_ids
                .as_ref()
                .map(|additional_shared_ecs_addr_config_info_ids| {
                    vec![
                        "additionalSharedEcsAddrConfigInfoIds".to_string(),
                        additional_shared_ecs_addr_config_info_ids
                            .iter()
                            .map(|x| x.to_string())
                            .collect::<Vec<_>>()
                            .join(","),
                    ]
                    .join(",")
                }),
            self.eas_discovery_authorized
                .as_ref()
                .map(|eas_discovery_authorized| {
                    vec![
                        "easDiscoveryAuthorized".to_string(),
                        eas_discovery_authorized.to_string(),
                    ]
                    .join(",")
                }),
            self.onboarding_ind.as_ref().map(|onboarding_ind| {
                vec!["onboardingInd".to_string(), onboarding_ind.to_string()].join(",")
            }),
            // Skipping aerialUeInd in query parameter serialization
            self.subscribed_max_ipv6_prefix_size
                .as_ref()
                .map(|subscribed_max_ipv6_prefix_size| {
                    vec![
                        "subscribedMaxIpv6PrefixSize".to_string(),
                        subscribed_max_ipv6_prefix_size.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DnnConfiguration value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DnnConfiguration {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub pdu_session_types: Vec<models::PduSessionTypes>,
            pub ssc_modes: Vec<models::SscModes>,
            pub iwk_eps_ind: Vec<bool>,
            pub param_5g_qos_profile: Vec<models::SubscribedDefaultQos>,
            pub session_ambr: Vec<models::Ambr>,
            pub param_3gpp_charging_characteristics: Vec<String>,
            pub static_ip_address: Vec<Vec<models::IpAddress>>,
            pub up_security: Vec<models::UpSecurity>,
            pub pdu_session_continuity_ind: Vec<models::PduSessionContinuityInd>,
            pub nidd_nef_id: Vec<String>,
            pub nidd_info: Vec<models::NiddInformation>,
            pub redundant_session_allowed: Vec<bool>,
            pub acs_info: Vec<models::AcsInfo>,
            pub ipv4_frame_route_list: Vec<Vec<models::FrameRouteInfo>>,
            pub ipv6_frame_route_list: Vec<Vec<models::FrameRouteInfo>>,
            pub atsss_allowed: Vec<bool>,
            pub secondary_auth: Vec<bool>,
            pub uav_secondary_auth: Vec<bool>,
            pub dn_aaa_ip_address_allocation: Vec<bool>,
            pub dn_aaa_address: Vec<models::IpAddress>,
            pub additional_dn_aaa_addresses: Vec<Vec<models::IpAddress>>,
            pub dn_aaa_fqdn: Vec<String>,
            pub iptv_acc_ctrl_info: Vec<String>,
            pub ipv4_index: Vec<models::IpIndex>,
            pub ipv6_index: Vec<models::IpIndex>,
            pub ecs_addr_config_info: Vec<models::EcsAddrConfigInfo>,
            pub additional_ecs_addr_config_infos: Vec<Vec<models::EcsAddrConfigInfo>>,
            pub shared_ecs_addr_config_info: Vec<String>,
            pub additional_shared_ecs_addr_config_info_ids: Vec<Vec<models::SharedDataId>>,
            pub eas_discovery_authorized: Vec<bool>,
            pub onboarding_ind: Vec<bool>,
            pub aerial_ue_ind: Vec<models::AerialUeIndication>,
            pub subscribed_max_ipv6_prefix_size: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing DnnConfiguration".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "pduSessionTypes" => intermediate_rep.pdu_session_types.push(<models::PduSessionTypes as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sscModes" => intermediate_rep.ssc_modes.push(<models::SscModes as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "iwkEpsInd" => intermediate_rep.iwk_eps_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "5gQosProfile" => intermediate_rep.param_5g_qos_profile.push(<models::SubscribedDefaultQos as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sessionAmbr" => intermediate_rep.session_ambr.push(<models::Ambr as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "3gppChargingCharacteristics" => intermediate_rep.param_3gpp_charging_characteristics.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "staticIpAddress" => return std::result::Result::Err("Parsing a container in this style is not supported in DnnConfiguration".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "upSecurity" => intermediate_rep.up_security.push(<models::UpSecurity as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pduSessionContinuityInd" => intermediate_rep.pdu_session_continuity_ind.push(<models::PduSessionContinuityInd as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "niddNefId" => intermediate_rep.nidd_nef_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "niddInfo" => intermediate_rep.nidd_info.push(<models::NiddInformation as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "redundantSessionAllowed" => intermediate_rep.redundant_session_allowed.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "acsInfo" => intermediate_rep.acs_info.push(<models::AcsInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "ipv4FrameRouteList" => return std::result::Result::Err("Parsing a container in this style is not supported in DnnConfiguration".to_string()),
                    "ipv6FrameRouteList" => return std::result::Result::Err("Parsing a container in this style is not supported in DnnConfiguration".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "atsssAllowed" => intermediate_rep.atsss_allowed.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "secondaryAuth" => intermediate_rep.secondary_auth.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "uavSecondaryAuth" => intermediate_rep.uav_secondary_auth.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dnAaaIpAddressAllocation" => intermediate_rep.dn_aaa_ip_address_allocation.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dnAaaAddress" => intermediate_rep.dn_aaa_address.push(<models::IpAddress as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "additionalDnAaaAddresses" => return std::result::Result::Err("Parsing a container in this style is not supported in DnnConfiguration".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "dnAaaFqdn" => intermediate_rep.dn_aaa_fqdn.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "iptvAccCtrlInfo" => intermediate_rep.iptv_acc_ctrl_info.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ipv4Index" => intermediate_rep.ipv4_index.push(<models::IpIndex as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ipv6Index" => intermediate_rep.ipv6_index.push(<models::IpIndex as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "ecsAddrConfigInfo" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in DnnConfiguration".to_string()),
                    "additionalEcsAddrConfigInfos" => return std::result::Result::Err("Parsing a container in this style is not supported in DnnConfiguration".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "sharedEcsAddrConfigInfo" => intermediate_rep.shared_ecs_addr_config_info.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "additionalSharedEcsAddrConfigInfoIds" => return std::result::Result::Err("Parsing a container in this style is not supported in DnnConfiguration".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "easDiscoveryAuthorized" => intermediate_rep.eas_discovery_authorized.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "onboardingInd" => intermediate_rep.onboarding_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "aerialUeInd" => intermediate_rep.aerial_ue_ind.push(<models::AerialUeIndication as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "subscribedMaxIpv6PrefixSize" => intermediate_rep.subscribed_max_ipv6_prefix_size.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DnnConfiguration".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DnnConfiguration {
            pdu_session_types: intermediate_rep
                .pdu_session_types
                .into_iter()
                .next()
                .ok_or_else(|| "pduSessionTypes missing in DnnConfiguration".to_string())?,
            ssc_modes: intermediate_rep
                .ssc_modes
                .into_iter()
                .next()
                .ok_or_else(|| "sscModes missing in DnnConfiguration".to_string())?,
            iwk_eps_ind: intermediate_rep.iwk_eps_ind.into_iter().next(),
            param_5g_qos_profile: intermediate_rep.param_5g_qos_profile.into_iter().next(),
            session_ambr: intermediate_rep.session_ambr.into_iter().next(),
            param_3gpp_charging_characteristics: intermediate_rep
                .param_3gpp_charging_characteristics
                .into_iter()
                .next(),
            static_ip_address: intermediate_rep.static_ip_address.into_iter().next(),
            up_security: intermediate_rep.up_security.into_iter().next(),
            pdu_session_continuity_ind: intermediate_rep
                .pdu_session_continuity_ind
                .into_iter()
                .next(),
            nidd_nef_id: intermediate_rep.nidd_nef_id.into_iter().next(),
            nidd_info: intermediate_rep.nidd_info.into_iter().next(),
            redundant_session_allowed: intermediate_rep
                .redundant_session_allowed
                .into_iter()
                .next(),
            acs_info: intermediate_rep.acs_info.into_iter().next(),
            ipv4_frame_route_list: intermediate_rep.ipv4_frame_route_list.into_iter().next(),
            ipv6_frame_route_list: intermediate_rep.ipv6_frame_route_list.into_iter().next(),
            atsss_allowed: intermediate_rep.atsss_allowed.into_iter().next(),
            secondary_auth: intermediate_rep.secondary_auth.into_iter().next(),
            uav_secondary_auth: intermediate_rep.uav_secondary_auth.into_iter().next(),
            dn_aaa_ip_address_allocation: intermediate_rep
                .dn_aaa_ip_address_allocation
                .into_iter()
                .next(),
            dn_aaa_address: intermediate_rep.dn_aaa_address.into_iter().next(),
            additional_dn_aaa_addresses: intermediate_rep
                .additional_dn_aaa_addresses
                .into_iter()
                .next(),
            dn_aaa_fqdn: intermediate_rep.dn_aaa_fqdn.into_iter().next(),
            iptv_acc_ctrl_info: intermediate_rep.iptv_acc_ctrl_info.into_iter().next(),
            ipv4_index: intermediate_rep.ipv4_index.into_iter().next(),
            ipv6_index: intermediate_rep.ipv6_index.into_iter().next(),
            ecs_addr_config_info: std::result::Result::Err(
                "Nullable types not supported in DnnConfiguration".to_string(),
            )?,
            additional_ecs_addr_config_infos: intermediate_rep
                .additional_ecs_addr_config_infos
                .into_iter()
                .next(),
            shared_ecs_addr_config_info: intermediate_rep
                .shared_ecs_addr_config_info
                .into_iter()
                .next(),
            additional_shared_ecs_addr_config_info_ids: intermediate_rep
                .additional_shared_ecs_addr_config_info_ids
                .into_iter()
                .next(),
            eas_discovery_authorized: intermediate_rep.eas_discovery_authorized.into_iter().next(),
            onboarding_ind: intermediate_rep.onboarding_ind.into_iter().next(),
            aerial_ue_ind: intermediate_rep.aerial_ue_ind.into_iter().next(),
            subscribed_max_ipv6_prefix_size: intermediate_rep
                .subscribed_max_ipv6_prefix_size
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DnnConfiguration> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DnnConfiguration>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<DnnConfiguration>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for DnnConfiguration - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<DnnConfiguration>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <DnnConfiguration as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into DnnConfiguration - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DnnIndicator(bool);

impl std::convert::From<bool> for DnnIndicator {
    fn from(x: bool) -> Self {
        DnnIndicator(x)
    }
}

impl std::convert::From<DnnIndicator> for bool {
    fn from(x: DnnIndicator) -> Self {
        x.0
    }
}

impl std::ops::Deref for DnnIndicator {
    type Target = bool;
    fn deref(&self) -> &bool {
        &self.0
    }
}

impl std::ops::DerefMut for DnnIndicator {
    fn deref_mut(&mut self) -> &mut bool {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DnnInfo {
    #[serde(rename = "dnn")]
    pub dnn: models::AccessAndMobilitySubscriptionDataSubscribedDnnListInner,

    #[serde(rename = "defaultDnnIndicator")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_dnn_indicator: Option<bool>,

    #[serde(rename = "lboRoamingAllowed")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lbo_roaming_allowed: Option<bool>,

    #[serde(rename = "iwkEpsInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub iwk_eps_ind: Option<bool>,

    #[serde(rename = "dnnBarred")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dnn_barred: Option<bool>,

    #[serde(rename = "invokeNefInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub invoke_nef_ind: Option<bool>,

    #[serde(rename = "smfList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub smf_list: Option<Vec<models::NfInstanceId>>,

    #[serde(rename = "sameSmfInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub same_smf_ind: Option<bool>,
}

impl DnnInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(dnn: models::AccessAndMobilitySubscriptionDataSubscribedDnnListInner) -> DnnInfo {
        DnnInfo {
            dnn,
            default_dnn_indicator: None,
            lbo_roaming_allowed: None,
            iwk_eps_ind: None,
            dnn_barred: None,
            invoke_nef_ind: None,
            smf_list: None,
            same_smf_ind: None,
        }
    }
}

/// Converts the DnnInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for DnnInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping dnn in query parameter serialization
            self.default_dnn_indicator
                .as_ref()
                .map(|default_dnn_indicator| {
                    vec![
                        "defaultDnnIndicator".to_string(),
                        default_dnn_indicator.to_string(),
                    ]
                    .join(",")
                }),
            self.lbo_roaming_allowed
                .as_ref()
                .map(|lbo_roaming_allowed| {
                    vec![
                        "lboRoamingAllowed".to_string(),
                        lbo_roaming_allowed.to_string(),
                    ]
                    .join(",")
                }),
            self.iwk_eps_ind.as_ref().map(|iwk_eps_ind| {
                vec!["iwkEpsInd".to_string(), iwk_eps_ind.to_string()].join(",")
            }),
            self.dnn_barred
                .as_ref()
                .map(|dnn_barred| vec!["dnnBarred".to_string(), dnn_barred.to_string()].join(",")),
            self.invoke_nef_ind.as_ref().map(|invoke_nef_ind| {
                vec!["invokeNefInd".to_string(), invoke_nef_ind.to_string()].join(",")
            }),
            // Skipping smfList in query parameter serialization
            self.same_smf_ind.as_ref().map(|same_smf_ind| {
                vec!["sameSmfInd".to_string(), same_smf_ind.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DnnInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DnnInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub dnn: Vec<models::AccessAndMobilitySubscriptionDataSubscribedDnnListInner>,
            pub default_dnn_indicator: Vec<bool>,
            pub lbo_roaming_allowed: Vec<bool>,
            pub iwk_eps_ind: Vec<bool>,
            pub dnn_barred: Vec<bool>,
            pub invoke_nef_ind: Vec<bool>,
            pub smf_list: Vec<Vec<models::NfInstanceId>>,
            pub same_smf_ind: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing DnnInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "dnn" => intermediate_rep.dnn.push(<models::AccessAndMobilitySubscriptionDataSubscribedDnnListInner as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "defaultDnnIndicator" => intermediate_rep.default_dnn_indicator.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lboRoamingAllowed" => intermediate_rep.lbo_roaming_allowed.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "iwkEpsInd" => intermediate_rep.iwk_eps_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dnnBarred" => intermediate_rep.dnn_barred.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "invokeNefInd" => intermediate_rep.invoke_nef_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "smfList" => return std::result::Result::Err("Parsing a container in this style is not supported in DnnInfo".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "sameSmfInd" => intermediate_rep.same_smf_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DnnInfo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DnnInfo {
            dnn: intermediate_rep
                .dnn
                .into_iter()
                .next()
                .ok_or_else(|| "dnn missing in DnnInfo".to_string())?,
            default_dnn_indicator: intermediate_rep.default_dnn_indicator.into_iter().next(),
            lbo_roaming_allowed: intermediate_rep.lbo_roaming_allowed.into_iter().next(),
            iwk_eps_ind: intermediate_rep.iwk_eps_ind.into_iter().next(),
            dnn_barred: intermediate_rep.dnn_barred.into_iter().next(),
            invoke_nef_ind: intermediate_rep.invoke_nef_ind.into_iter().next(),
            smf_list: intermediate_rep.smf_list.into_iter().next(),
            same_smf_ind: intermediate_rep.same_smf_ind.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DnnInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<DnnInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<DnnInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for DnnInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<DnnInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <DnnInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into DnnInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// indicating a time in seconds.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DurationSec(i32);

impl std::convert::From<i32> for DurationSec {
    fn from(x: i32) -> Self {
        DurationSec(x)
    }
}

impl std::convert::From<DurationSec> for i32 {
    fn from(x: DurationSec) -> Self {
        x.0
    }
}

impl std::ops::Deref for DurationSec {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for DurationSec {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// indicating a time in seconds with OpenAPI defined 'nullable: true' property.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DurationSecRm(i32);

impl std::convert::From<i32> for DurationSecRm {
    fn from(x: i32) -> Self {
        DurationSecRm(x)
    }
}

impl std::convert::From<DurationSecRm> for i32 {
    fn from(x: DurationSecRm) -> Self {
        x.0
    }
}

impl std::ops::Deref for DurationSecRm {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for DurationSecRm {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EcRestrictionDataWb {
    #[serde(rename = "ecModeARestricted")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ec_mode_a_restricted: Option<bool>,

    #[serde(rename = "ecModeBRestricted")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ec_mode_b_restricted: Option<bool>,
}

impl EcRestrictionDataWb {
    #[allow(clippy::new_without_default)]
    pub fn new() -> EcRestrictionDataWb {
        EcRestrictionDataWb {
            ec_mode_a_restricted: None,
            ec_mode_b_restricted: None,
        }
    }
}

/// Converts the EcRestrictionDataWb value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EcRestrictionDataWb {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.ec_mode_a_restricted
                .as_ref()
                .map(|ec_mode_a_restricted| {
                    vec![
                        "ecModeARestricted".to_string(),
                        ec_mode_a_restricted.to_string(),
                    ]
                    .join(",")
                }),
            self.ec_mode_b_restricted
                .as_ref()
                .map(|ec_mode_b_restricted| {
                    vec![
                        "ecModeBRestricted".to_string(),
                        ec_mode_b_restricted.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EcRestrictionDataWb value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EcRestrictionDataWb {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ec_mode_a_restricted: Vec<bool>,
            pub ec_mode_b_restricted: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing EcRestrictionDataWb".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ecModeARestricted" => intermediate_rep.ec_mode_a_restricted.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ecModeBRestricted" => intermediate_rep.ec_mode_b_restricted.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing EcRestrictionDataWb".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EcRestrictionDataWb {
            ec_mode_a_restricted: intermediate_rep.ec_mode_a_restricted.into_iter().next(),
            ec_mode_b_restricted: intermediate_rep.ec_mode_b_restricted.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EcRestrictionDataWb> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<EcRestrictionDataWb>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<EcRestrictionDataWb>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for EcRestrictionDataWb - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<EcRestrictionDataWb>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <EcRestrictionDataWb as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into EcRestrictionDataWb - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains the ECGI (E-UTRAN Cell Global Identity), as described in 3GPP 23.003
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Ecgi {
    #[serde(rename = "plmnId")]
    pub plmn_id: models::PlmnId,

    /// 28-bit string identifying an E-UTRA Cell Id as specified in clause 9.3.1.9 of  3GPP TS 38.413, in hexadecimal representation. Each character in the string shall take a  value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most  significant character representing the 4 most significant bits of the Cell Id shall appear  first in the string, and the character representing the 4 least significant bit of the  Cell Id shall appear last in the string.
    #[serde(rename = "eutraCellId")]
    pub eutra_cell_id: String,

    /// This represents the Network Identifier, which together with a PLMN ID is used to identify an SNPN (see 3GPP TS 23.003 and 3GPP TS 23.501 clause 5.30.2.1).
    #[serde(rename = "nid")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nid: Option<String>,
}

impl Ecgi {
    #[allow(clippy::new_without_default)]
    pub fn new(plmn_id: models::PlmnId, eutra_cell_id: String) -> Ecgi {
        Ecgi {
            plmn_id,
            eutra_cell_id,
            nid: None,
        }
    }
}

/// Converts the Ecgi value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Ecgi {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping plmnId in query parameter serialization
            Some("eutraCellId".to_string()),
            Some(self.eutra_cell_id.to_string()),
            self.nid
                .as_ref()
                .map(|nid| vec!["nid".to_string(), nid.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Ecgi value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Ecgi {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub plmn_id: Vec<models::PlmnId>,
            pub eutra_cell_id: Vec<String>,
            pub nid: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err("Missing value while parsing Ecgi".to_string())
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "plmnId" => intermediate_rep.plmn_id.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "eutraCellId" => intermediate_rep.eutra_cell_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nid" => intermediate_rep.nid.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Ecgi".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Ecgi {
            plmn_id: intermediate_rep
                .plmn_id
                .into_iter()
                .next()
                .ok_or_else(|| "plmnId missing in Ecgi".to_string())?,
            eutra_cell_id: intermediate_rep
                .eutra_cell_id
                .into_iter()
                .next()
                .ok_or_else(|| "eutraCellId missing in Ecgi".to_string())?,
            nid: intermediate_rep.nid.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Ecgi> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Ecgi>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Ecgi>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Ecgi - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Ecgi> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Ecgi as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Ecgi - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EcsAddrConfigInfo {
    #[serde(rename = "ecsServerAddr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ecs_server_addr: Option<models::EcsServerAddr>,

    #[serde(rename = "spatialValidityCond")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub spatial_validity_cond: Option<models::SpatialValidityCond>,
}

impl EcsAddrConfigInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> EcsAddrConfigInfo {
        EcsAddrConfigInfo {
            ecs_server_addr: None,
            spatial_validity_cond: None,
        }
    }
}

/// Converts the EcsAddrConfigInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EcsAddrConfigInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping ecsServerAddr in query parameter serialization

            // Skipping spatialValidityCond in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EcsAddrConfigInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EcsAddrConfigInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ecs_server_addr: Vec<models::EcsServerAddr>,
            pub spatial_validity_cond: Vec<models::SpatialValidityCond>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing EcsAddrConfigInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ecsServerAddr" => intermediate_rep.ecs_server_addr.push(
                        <models::EcsServerAddr as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "spatialValidityCond" => intermediate_rep.spatial_validity_cond.push(
                        <models::SpatialValidityCond as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing EcsAddrConfigInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EcsAddrConfigInfo {
            ecs_server_addr: intermediate_rep.ecs_server_addr.into_iter().next(),
            spatial_validity_cond: intermediate_rep.spatial_validity_cond.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EcsAddrConfigInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<EcsAddrConfigInfo>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<EcsAddrConfigInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for EcsAddrConfigInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<EcsAddrConfigInfo>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <EcsAddrConfigInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into EcsAddrConfigInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains the Edge Configuration Server Address Configuration Information as defined in clause 5.2.3.6.1 of 3GPP TS 23.502.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EcsServerAddr {
    #[serde(rename = "ecsFqdnList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ecs_fqdn_list: Option<Vec<models::Fqdn>>,

    #[serde(rename = "ecsIpAddressList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ecs_ip_address_list: Option<Vec<models::IpAddr>>,

    #[serde(rename = "ecsUriList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ecs_uri_list: Option<Vec<models::Uri>>,

    #[serde(rename = "ecsProviderId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ecs_provider_id: Option<String>,
}

impl EcsServerAddr {
    #[allow(clippy::new_without_default)]
    pub fn new() -> EcsServerAddr {
        EcsServerAddr {
            ecs_fqdn_list: None,
            ecs_ip_address_list: None,
            ecs_uri_list: None,
            ecs_provider_id: None,
        }
    }
}

/// Converts the EcsServerAddr value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EcsServerAddr {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.ecs_fqdn_list.as_ref().map(|ecs_fqdn_list| {
                vec![
                    "ecsFqdnList".to_string(),
                    ecs_fqdn_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping ecsIpAddressList in query parameter serialization
            self.ecs_uri_list.as_ref().map(|ecs_uri_list| {
                vec![
                    "ecsUriList".to_string(),
                    ecs_uri_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.ecs_provider_id.as_ref().map(|ecs_provider_id| {
                vec!["ecsProviderId".to_string(), ecs_provider_id.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EcsServerAddr value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EcsServerAddr {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ecs_fqdn_list: Vec<Vec<models::Fqdn>>,
            pub ecs_ip_address_list: Vec<Vec<models::IpAddr>>,
            pub ecs_uri_list: Vec<Vec<models::Uri>>,
            pub ecs_provider_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing EcsServerAddr".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "ecsFqdnList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in EcsServerAddr"
                                .to_string(),
                        )
                    }
                    "ecsIpAddressList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in EcsServerAddr"
                                .to_string(),
                        )
                    }
                    "ecsUriList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in EcsServerAddr"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "ecsProviderId" => intermediate_rep.ecs_provider_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing EcsServerAddr".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EcsServerAddr {
            ecs_fqdn_list: intermediate_rep.ecs_fqdn_list.into_iter().next(),
            ecs_ip_address_list: intermediate_rep.ecs_ip_address_list.into_iter().next(),
            ecs_uri_list: intermediate_rep.ecs_uri_list.into_iter().next(),
            ecs_provider_id: intermediate_rep.ecs_provider_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EcsServerAddr> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<EcsServerAddr>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<EcsServerAddr>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for EcsServerAddr - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<EcsServerAddr> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <EcsServerAddr as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into EcsServerAddr - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EdrxParameters {
    #[serde(rename = "ratType")]
    pub rat_type: models::RatType,

    #[serde(rename = "edrxValue")]
    pub edrx_value: String,
}

impl EdrxParameters {
    #[allow(clippy::new_without_default)]
    pub fn new(rat_type: models::RatType, edrx_value: String) -> EdrxParameters {
        EdrxParameters {
            rat_type,
            edrx_value,
        }
    }
}

/// Converts the EdrxParameters value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EdrxParameters {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping ratType in query parameter serialization
            Some("edrxValue".to_string()),
            Some(self.edrx_value.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EdrxParameters value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EdrxParameters {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub rat_type: Vec<models::RatType>,
            pub edrx_value: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing EdrxParameters".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ratType" => intermediate_rep.rat_type.push(
                        <models::RatType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "edrxValue" => intermediate_rep.edrx_value.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing EdrxParameters".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EdrxParameters {
            rat_type: intermediate_rep
                .rat_type
                .into_iter()
                .next()
                .ok_or_else(|| "ratType missing in EdrxParameters".to_string())?,
            edrx_value: intermediate_rep
                .edrx_value
                .into_iter()
                .next()
                .ok_or_else(|| "edrxValue missing in EdrxParameters".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EdrxParameters> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<EdrxParameters>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<EdrxParameters>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for EdrxParameters - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<EdrxParameters> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <EdrxParameters as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into EdrxParameters - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Ellipsoid Arc.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EllipsoidArc {
    #[serde(rename = "shape")]
    pub shape: models::SupportedGadShapes,

    #[serde(rename = "point")]
    pub point: models::GeographicalCoordinates,

    /// Indicates value of the inner radius.
    #[serde(rename = "innerRadius")]
    pub inner_radius: u32,

    /// Indicates value of uncertainty.
    #[serde(rename = "uncertaintyRadius")]
    pub uncertainty_radius: f32,

    /// Indicates value of angle.
    #[serde(rename = "offsetAngle")]
    pub offset_angle: u16,

    /// Indicates value of angle.
    #[serde(rename = "includedAngle")]
    pub included_angle: u16,

    /// Indicates value of confidence.
    #[serde(rename = "confidence")]
    pub confidence: u8,
}

impl EllipsoidArc {
    #[allow(clippy::new_without_default)]
    pub fn new(
        shape: models::SupportedGadShapes,
        point: models::GeographicalCoordinates,
        inner_radius: u32,
        uncertainty_radius: f32,
        offset_angle: u16,
        included_angle: u16,
        confidence: u8,
    ) -> EllipsoidArc {
        EllipsoidArc {
            shape,
            point,
            inner_radius,
            uncertainty_radius,
            offset_angle,
            included_angle,
            confidence,
        }
    }
}

/// Converts the EllipsoidArc value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EllipsoidArc {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping shape in query parameter serialization

            // Skipping point in query parameter serialization
            Some("innerRadius".to_string()),
            Some(self.inner_radius.to_string()),
            Some("uncertaintyRadius".to_string()),
            Some(self.uncertainty_radius.to_string()),
            Some("offsetAngle".to_string()),
            Some(self.offset_angle.to_string()),
            Some("includedAngle".to_string()),
            Some(self.included_angle.to_string()),
            Some("confidence".to_string()),
            Some(self.confidence.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EllipsoidArc value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EllipsoidArc {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub shape: Vec<models::SupportedGadShapes>,
            pub point: Vec<models::GeographicalCoordinates>,
            pub inner_radius: Vec<u32>,
            pub uncertainty_radius: Vec<f32>,
            pub offset_angle: Vec<u16>,
            pub included_angle: Vec<u16>,
            pub confidence: Vec<u8>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing EllipsoidArc".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "shape" => intermediate_rep.shape.push(
                        <models::SupportedGadShapes as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "point" => intermediate_rep.point.push(
                        <models::GeographicalCoordinates as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "innerRadius" => intermediate_rep.inner_radius.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "uncertaintyRadius" => intermediate_rep.uncertainty_radius.push(
                        <f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "offsetAngle" => intermediate_rep.offset_angle.push(
                        <u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "includedAngle" => intermediate_rep.included_angle.push(
                        <u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "confidence" => intermediate_rep
                        .confidence
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing EllipsoidArc".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EllipsoidArc {
            shape: intermediate_rep
                .shape
                .into_iter()
                .next()
                .ok_or_else(|| "shape missing in EllipsoidArc".to_string())?,
            point: intermediate_rep
                .point
                .into_iter()
                .next()
                .ok_or_else(|| "point missing in EllipsoidArc".to_string())?,
            inner_radius: intermediate_rep
                .inner_radius
                .into_iter()
                .next()
                .ok_or_else(|| "innerRadius missing in EllipsoidArc".to_string())?,
            uncertainty_radius: intermediate_rep
                .uncertainty_radius
                .into_iter()
                .next()
                .ok_or_else(|| "uncertaintyRadius missing in EllipsoidArc".to_string())?,
            offset_angle: intermediate_rep
                .offset_angle
                .into_iter()
                .next()
                .ok_or_else(|| "offsetAngle missing in EllipsoidArc".to_string())?,
            included_angle: intermediate_rep
                .included_angle
                .into_iter()
                .next()
                .ok_or_else(|| "includedAngle missing in EllipsoidArc".to_string())?,
            confidence: intermediate_rep
                .confidence
                .into_iter()
                .next()
                .ok_or_else(|| "confidence missing in EllipsoidArc".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EllipsoidArc> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<EllipsoidArc>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<EllipsoidArc>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for EllipsoidArc - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<EllipsoidArc> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <EllipsoidArc as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into EllipsoidArc - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EllipsoidArcAllOf {
    #[serde(rename = "point")]
    pub point: models::GeographicalCoordinates,

    /// Indicates value of the inner radius.
    #[serde(rename = "innerRadius")]
    pub inner_radius: u32,

    /// Indicates value of uncertainty.
    #[serde(rename = "uncertaintyRadius")]
    pub uncertainty_radius: f32,

    /// Indicates value of angle.
    #[serde(rename = "offsetAngle")]
    pub offset_angle: u16,

    /// Indicates value of angle.
    #[serde(rename = "includedAngle")]
    pub included_angle: u16,

    /// Indicates value of confidence.
    #[serde(rename = "confidence")]
    pub confidence: u8,
}

impl EllipsoidArcAllOf {
    #[allow(clippy::new_without_default)]
    pub fn new(
        point: models::GeographicalCoordinates,
        inner_radius: u32,
        uncertainty_radius: f32,
        offset_angle: u16,
        included_angle: u16,
        confidence: u8,
    ) -> EllipsoidArcAllOf {
        EllipsoidArcAllOf {
            point,
            inner_radius,
            uncertainty_radius,
            offset_angle,
            included_angle,
            confidence,
        }
    }
}

/// Converts the EllipsoidArcAllOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EllipsoidArcAllOf {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping point in query parameter serialization
            Some("innerRadius".to_string()),
            Some(self.inner_radius.to_string()),
            Some("uncertaintyRadius".to_string()),
            Some(self.uncertainty_radius.to_string()),
            Some("offsetAngle".to_string()),
            Some(self.offset_angle.to_string()),
            Some("includedAngle".to_string()),
            Some(self.included_angle.to_string()),
            Some("confidence".to_string()),
            Some(self.confidence.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EllipsoidArcAllOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EllipsoidArcAllOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub point: Vec<models::GeographicalCoordinates>,
            pub inner_radius: Vec<u32>,
            pub uncertainty_radius: Vec<f32>,
            pub offset_angle: Vec<u16>,
            pub included_angle: Vec<u16>,
            pub confidence: Vec<u8>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing EllipsoidArcAllOf".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "point" => intermediate_rep.point.push(
                        <models::GeographicalCoordinates as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "innerRadius" => intermediate_rep.inner_radius.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "uncertaintyRadius" => intermediate_rep.uncertainty_radius.push(
                        <f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "offsetAngle" => intermediate_rep.offset_angle.push(
                        <u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "includedAngle" => intermediate_rep.included_angle.push(
                        <u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "confidence" => intermediate_rep
                        .confidence
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing EllipsoidArcAllOf".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EllipsoidArcAllOf {
            point: intermediate_rep
                .point
                .into_iter()
                .next()
                .ok_or_else(|| "point missing in EllipsoidArcAllOf".to_string())?,
            inner_radius: intermediate_rep
                .inner_radius
                .into_iter()
                .next()
                .ok_or_else(|| "innerRadius missing in EllipsoidArcAllOf".to_string())?,
            uncertainty_radius: intermediate_rep
                .uncertainty_radius
                .into_iter()
                .next()
                .ok_or_else(|| "uncertaintyRadius missing in EllipsoidArcAllOf".to_string())?,
            offset_angle: intermediate_rep
                .offset_angle
                .into_iter()
                .next()
                .ok_or_else(|| "offsetAngle missing in EllipsoidArcAllOf".to_string())?,
            included_angle: intermediate_rep
                .included_angle
                .into_iter()
                .next()
                .ok_or_else(|| "includedAngle missing in EllipsoidArcAllOf".to_string())?,
            confidence: intermediate_rep
                .confidence
                .into_iter()
                .next()
                .ok_or_else(|| "confidence missing in EllipsoidArcAllOf".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EllipsoidArcAllOf> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<EllipsoidArcAllOf>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<EllipsoidArcAllOf>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for EllipsoidArcAllOf - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<EllipsoidArcAllOf>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <EllipsoidArcAllOf as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into EllipsoidArcAllOf - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EmergencyInfo {
    /// Fully Qualified Domain Name
    #[serde(rename = "pgwFqdn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pgw_fqdn: Option<String>,

    #[serde(rename = "pgwIpAddress")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pgw_ip_address: Option<models::IpAddress>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "smfInstanceId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub smf_instance_id: Option<uuid::Uuid>,

    #[serde(rename = "epdgInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub epdg_ind: Option<bool>,

    #[serde(rename = "plmnId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub plmn_id: Option<models::PlmnId>,
}

impl EmergencyInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> EmergencyInfo {
        EmergencyInfo {
            pgw_fqdn: None,
            pgw_ip_address: None,
            smf_instance_id: None,
            epdg_ind: Some(false),
            plmn_id: None,
        }
    }
}

/// Converts the EmergencyInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EmergencyInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.pgw_fqdn
                .as_ref()
                .map(|pgw_fqdn| vec!["pgwFqdn".to_string(), pgw_fqdn.to_string()].join(",")),
            // Skipping pgwIpAddress in query parameter serialization

            // Skipping smfInstanceId in query parameter serialization
            self.epdg_ind
                .as_ref()
                .map(|epdg_ind| vec!["epdgInd".to_string(), epdg_ind.to_string()].join(",")),
            // Skipping plmnId in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EmergencyInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EmergencyInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub pgw_fqdn: Vec<String>,
            pub pgw_ip_address: Vec<models::IpAddress>,
            pub smf_instance_id: Vec<uuid::Uuid>,
            pub epdg_ind: Vec<bool>,
            pub plmn_id: Vec<models::PlmnId>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing EmergencyInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "pgwFqdn" => intermediate_rep.pgw_fqdn.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "pgwIpAddress" => intermediate_rep.pgw_ip_address.push(
                        <models::IpAddress as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "smfInstanceId" => intermediate_rep.smf_instance_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "epdgInd" => intermediate_rep.epdg_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "plmnId" => intermediate_rep.plmn_id.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing EmergencyInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EmergencyInfo {
            pgw_fqdn: intermediate_rep.pgw_fqdn.into_iter().next(),
            pgw_ip_address: intermediate_rep.pgw_ip_address.into_iter().next(),
            smf_instance_id: intermediate_rep.smf_instance_id.into_iter().next(),
            epdg_ind: intermediate_rep.epdg_ind.into_iter().next(),
            plmn_id: intermediate_rep.plmn_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EmergencyInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<EmergencyInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<EmergencyInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for EmergencyInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<EmergencyInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <EmergencyInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into EmergencyInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// This represents the identifier of the eNB ID as specified in clause 9.2.1.37 of  3GPP TS 36.413. The string shall be formatted with the following pattern  '^('MacroeNB-[A-Fa-f0-9]{5}|LMacroeNB-[A-Fa-f0-9]{6}|SMacroeNB-[A-Fa-f0-9]{5} |HomeeNB-[A-Fa-f0-9]{7})$'. The value of the eNB ID shall be encoded in hexadecimal representation. Each character in the  string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits.  The padding 0 shall be added to make multiple nibbles, so the most significant character  representing the padding 0 if required together with the 4 most significant bits of the eNB ID  shall appear first in the string, and the character representing the 4 least significant bit  of the eNB ID (to form a nibble) shall appear last in the string.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EnbId(String);

impl std::convert::From<String> for EnbId {
    fn from(x: String) -> Self {
        EnbId(x)
    }
}

impl std::string::ToString for EnbId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for EnbId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(EnbId(x.to_string()))
    }
}

impl std::convert::From<EnbId> for String {
    fn from(x: EnbId) -> Self {
        x.0
    }
}

impl std::ops::Deref for EnbId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for EnbId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EnhancedCoverageRestrictionData {
    #[serde(rename = "plmnEcInfoList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub plmn_ec_info_list: Option<Vec<models::PlmnEcInfo>>,
}

impl EnhancedCoverageRestrictionData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> EnhancedCoverageRestrictionData {
        EnhancedCoverageRestrictionData {
            plmn_ec_info_list: None,
        }
    }
}

/// Converts the EnhancedCoverageRestrictionData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EnhancedCoverageRestrictionData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping plmnEcInfoList in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EnhancedCoverageRestrictionData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EnhancedCoverageRestrictionData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub plmn_ec_info_list: Vec<Vec<models::PlmnEcInfo>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing EnhancedCoverageRestrictionData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "plmnEcInfoList" => return std::result::Result::Err("Parsing a container in this style is not supported in EnhancedCoverageRestrictionData".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing EnhancedCoverageRestrictionData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EnhancedCoverageRestrictionData {
            plmn_ec_info_list: intermediate_rep.plmn_ec_info_list.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EnhancedCoverageRestrictionData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<EnhancedCoverageRestrictionData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<EnhancedCoverageRestrictionData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for EnhancedCoverageRestrictionData - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<EnhancedCoverageRestrictionData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EnhancedCoverageRestrictionData as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into EnhancedCoverageRestrictionData - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EpsInterworkingInfo {
    /// A map (list of key-value pairs where Dnn serves as key) of EpsIwkPgws
    #[serde(rename = "epsIwkPgws")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub eps_iwk_pgws: Option<std::collections::HashMap<String, models::EpsIwkPgw>>,
}

impl EpsInterworkingInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> EpsInterworkingInfo {
        EpsInterworkingInfo { eps_iwk_pgws: None }
    }
}

/// Converts the EpsInterworkingInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EpsInterworkingInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping epsIwkPgws in query parameter serialization
            // Skipping epsIwkPgws in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EpsInterworkingInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EpsInterworkingInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub eps_iwk_pgws: Vec<std::collections::HashMap<String, models::EpsIwkPgw>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing EpsInterworkingInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "epsIwkPgws" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in EpsInterworkingInfo"
                            .to_string(),
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing EpsInterworkingInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EpsInterworkingInfo {
            eps_iwk_pgws: intermediate_rep.eps_iwk_pgws.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EpsInterworkingInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<EpsInterworkingInfo>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<EpsInterworkingInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for EpsInterworkingInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<EpsInterworkingInfo>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <EpsInterworkingInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into EpsInterworkingInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EpsIwkPgw {
    /// Fully Qualified Domain Name
    #[serde(rename = "pgwFqdn")]
    pub pgw_fqdn: String,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "smfInstanceId")]
    pub smf_instance_id: uuid::Uuid,

    #[serde(rename = "plmnId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub plmn_id: Option<models::PlmnId>,
}

impl EpsIwkPgw {
    #[allow(clippy::new_without_default)]
    pub fn new(pgw_fqdn: String, smf_instance_id: uuid::Uuid) -> EpsIwkPgw {
        EpsIwkPgw {
            pgw_fqdn,
            smf_instance_id,
            plmn_id: None,
        }
    }
}

/// Converts the EpsIwkPgw value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EpsIwkPgw {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("pgwFqdn".to_string()),
            Some(self.pgw_fqdn.to_string()),
            // Skipping smfInstanceId in query parameter serialization

            // Skipping plmnId in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EpsIwkPgw value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EpsIwkPgw {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub pgw_fqdn: Vec<String>,
            pub smf_instance_id: Vec<uuid::Uuid>,
            pub plmn_id: Vec<models::PlmnId>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing EpsIwkPgw".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "pgwFqdn" => intermediate_rep.pgw_fqdn.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "smfInstanceId" => intermediate_rep.smf_instance_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "plmnId" => intermediate_rep.plmn_id.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing EpsIwkPgw".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EpsIwkPgw {
            pgw_fqdn: intermediate_rep
                .pgw_fqdn
                .into_iter()
                .next()
                .ok_or_else(|| "pgwFqdn missing in EpsIwkPgw".to_string())?,
            smf_instance_id: intermediate_rep
                .smf_instance_id
                .into_iter()
                .next()
                .ok_or_else(|| "smfInstanceId missing in EpsIwkPgw".to_string())?,
            plmn_id: intermediate_rep.plmn_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EpsIwkPgw> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<EpsIwkPgw>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<EpsIwkPgw>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for EpsIwkPgw - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<EpsIwkPgw> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <EpsIwkPgw as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into EpsIwkPgw - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// 28-bit string identifying an E-UTRA Cell Id as specified in clause 9.3.1.9 of  3GPP TS 38.413, in hexadecimal representation. Each character in the string shall take a  value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most  significant character representing the 4 most significant bits of the Cell Id shall appear  first in the string, and the character representing the 4 least significant bit of the  Cell Id shall appear last in the string.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EutraCellId(String);

impl std::convert::From<String> for EutraCellId {
    fn from(x: String) -> Self {
        EutraCellId(x)
    }
}

impl std::string::ToString for EutraCellId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for EutraCellId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(EutraCellId(x.to_string()))
    }
}

impl std::convert::From<EutraCellId> for String {
    fn from(x: EutraCellId) -> Self {
        x.0
    }
}

impl std::ops::Deref for EutraCellId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for EutraCellId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// The enumeration EventForMdt defines events triggered measurement for logged MDT in the trace. See 3GPP TS 32.422 for further description of the values. It shall comply with the provisions defined in table 5.6.3.11-1
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EventForMdt {}

impl EventForMdt {
    #[allow(clippy::new_without_default)]
    pub fn new() -> EventForMdt {
        EventForMdt {}
    }
}

/// Converts the EventForMdt value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for EventForMdt {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EventForMdt value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EventForMdt {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing EventForMdt".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing EventForMdt".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EventForMdt {})
    }
}

// Methods for converting between header::IntoHeaderValue<EventForMdt> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<EventForMdt>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<EventForMdt>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for EventForMdt - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<EventForMdt> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <EventForMdt as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into EventForMdt - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum EventForMdtAnyOf {
    #[serde(rename = "OUT_OF_COVERAG")]
    OutOfCoverag,
    #[serde(rename = "A2_EVENT")]
    A2Event,
}

impl std::fmt::Display for EventForMdtAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            EventForMdtAnyOf::OutOfCoverag => write!(f, "OUT_OF_COVERAG"),
            EventForMdtAnyOf::A2Event => write!(f, "A2_EVENT"),
        }
    }
}

impl std::str::FromStr for EventForMdtAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "OUT_OF_COVERAG" => std::result::Result::Ok(EventForMdtAnyOf::OutOfCoverag),
            "A2_EVENT" => std::result::Result::Ok(EventForMdtAnyOf::A2Event),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ExpectedUeBehaviourData {
    #[serde(rename = "stationaryIndication")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stationary_indication: Option<models::StationaryIndication>,

    /// indicating a time in seconds.
    #[serde(rename = "communicationDurationTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub communication_duration_time: Option<i32>,

    /// indicating a time in seconds.
    #[serde(rename = "periodicTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub periodic_time: Option<i32>,

    #[serde(rename = "scheduledCommunicationTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scheduled_communication_time: Option<models::ScheduledCommunicationTime>,

    #[serde(rename = "scheduledCommunicationType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scheduled_communication_type: Option<models::ScheduledCommunicationType>,

    /// Identifies the UE's expected geographical movement. The attribute is only applicable in 5G.
    #[serde(rename = "expectedUmts")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expected_umts: Option<Vec<models::LocationArea>>,

    #[serde(rename = "trafficProfile")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub traffic_profile: Option<models::TrafficProfile>,

    #[serde(rename = "batteryIndication")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub battery_indication: Option<models::BatteryIndication>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "validityTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub validity_time: Option<chrono::DateTime<chrono::Utc>>,
}

impl ExpectedUeBehaviourData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ExpectedUeBehaviourData {
        ExpectedUeBehaviourData {
            stationary_indication: None,
            communication_duration_time: None,
            periodic_time: None,
            scheduled_communication_time: None,
            scheduled_communication_type: None,
            expected_umts: None,
            traffic_profile: None,
            battery_indication: None,
            validity_time: None,
        }
    }
}

/// Converts the ExpectedUeBehaviourData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ExpectedUeBehaviourData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping stationaryIndication in query parameter serialization
            self.communication_duration_time
                .as_ref()
                .map(|communication_duration_time| {
                    vec![
                        "communicationDurationTime".to_string(),
                        communication_duration_time.to_string(),
                    ]
                    .join(",")
                }),
            self.periodic_time.as_ref().map(|periodic_time| {
                vec!["periodicTime".to_string(), periodic_time.to_string()].join(",")
            }),
            // Skipping scheduledCommunicationTime in query parameter serialization

            // Skipping scheduledCommunicationType in query parameter serialization

            // Skipping expectedUmts in query parameter serialization

            // Skipping trafficProfile in query parameter serialization

            // Skipping batteryIndication in query parameter serialization

            // Skipping validityTime in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ExpectedUeBehaviourData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ExpectedUeBehaviourData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub stationary_indication: Vec<models::StationaryIndication>,
            pub communication_duration_time: Vec<i32>,
            pub periodic_time: Vec<i32>,
            pub scheduled_communication_time: Vec<models::ScheduledCommunicationTime>,
            pub scheduled_communication_type: Vec<models::ScheduledCommunicationType>,
            pub expected_umts: Vec<Vec<models::LocationArea>>,
            pub traffic_profile: Vec<models::TrafficProfile>,
            pub battery_indication: Vec<models::BatteryIndication>,
            pub validity_time: Vec<chrono::DateTime<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ExpectedUeBehaviourData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "stationaryIndication" => intermediate_rep.stationary_indication.push(<models::StationaryIndication as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "communicationDurationTime" => intermediate_rep.communication_duration_time.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "periodicTime" => intermediate_rep.periodic_time.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "scheduledCommunicationTime" => intermediate_rep.scheduled_communication_time.push(<models::ScheduledCommunicationTime as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "scheduledCommunicationType" => intermediate_rep.scheduled_communication_type.push(<models::ScheduledCommunicationType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "expectedUmts" => return std::result::Result::Err("Parsing a container in this style is not supported in ExpectedUeBehaviourData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "trafficProfile" => intermediate_rep.traffic_profile.push(<models::TrafficProfile as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "batteryIndication" => intermediate_rep.battery_indication.push(<models::BatteryIndication as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "validityTime" => intermediate_rep.validity_time.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ExpectedUeBehaviourData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ExpectedUeBehaviourData {
            stationary_indication: intermediate_rep.stationary_indication.into_iter().next(),
            communication_duration_time: intermediate_rep
                .communication_duration_time
                .into_iter()
                .next(),
            periodic_time: intermediate_rep.periodic_time.into_iter().next(),
            scheduled_communication_time: intermediate_rep
                .scheduled_communication_time
                .into_iter()
                .next(),
            scheduled_communication_type: intermediate_rep
                .scheduled_communication_type
                .into_iter()
                .next(),
            expected_umts: intermediate_rep.expected_umts.into_iter().next(),
            traffic_profile: intermediate_rep.traffic_profile.into_iter().next(),
            battery_indication: intermediate_rep.battery_indication.into_iter().next(),
            validity_time: intermediate_rep.validity_time.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ExpectedUeBehaviourData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ExpectedUeBehaviourData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ExpectedUeBehaviourData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ExpectedUeBehaviourData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ExpectedUeBehaviourData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ExpectedUeBehaviourData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ExpectedUeBehaviourData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ExtGroupId(String);

impl std::convert::From<String> for ExtGroupId {
    fn from(x: String) -> Self {
        ExtGroupId(x)
    }
}

impl std::string::ToString for ExtGroupId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for ExtGroupId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(ExtGroupId(x.to_string()))
    }
}

impl std::convert::From<ExtGroupId> for String {
    fn from(x: ExtGroupId) -> Self {
        x.0
    }
}

impl std::ops::Deref for ExtGroupId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for ExtGroupId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Contains identifiers of shared Session Management Subscription Data and optionally individual Session Management Subscription Data.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ExtendedSmSubsData {
    #[serde(rename = "sharedSmSubsDataIds")]
    pub shared_sm_subs_data_ids: Vec<models::SharedDataId>,

    #[serde(rename = "individualSmSubsData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub individual_sm_subs_data: Option<Vec<models::SessionManagementSubscriptionData>>,
}

impl ExtendedSmSubsData {
    #[allow(clippy::new_without_default)]
    pub fn new(shared_sm_subs_data_ids: Vec<models::SharedDataId>) -> ExtendedSmSubsData {
        ExtendedSmSubsData {
            shared_sm_subs_data_ids,
            individual_sm_subs_data: None,
        }
    }
}

/// Converts the ExtendedSmSubsData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ExtendedSmSubsData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("sharedSmSubsDataIds".to_string()),
            Some(
                self.shared_sm_subs_data_ids
                    .iter()
                    .map(|x| x.to_string())
                    .collect::<Vec<_>>()
                    .join(","),
            ),
            // Skipping individualSmSubsData in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ExtendedSmSubsData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ExtendedSmSubsData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub shared_sm_subs_data_ids: Vec<Vec<models::SharedDataId>>,
            pub individual_sm_subs_data: Vec<Vec<models::SessionManagementSubscriptionData>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ExtendedSmSubsData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "sharedSmSubsDataIds" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in ExtendedSmSubsData"
                            .to_string(),
                    ),
                    "individualSmSubsData" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in ExtendedSmSubsData"
                            .to_string(),
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ExtendedSmSubsData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ExtendedSmSubsData {
            shared_sm_subs_data_ids: intermediate_rep
                .shared_sm_subs_data_ids
                .into_iter()
                .next()
                .ok_or_else(|| "sharedSmSubsDataIds missing in ExtendedSmSubsData".to_string())?,
            individual_sm_subs_data: intermediate_rep.individual_sm_subs_data.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ExtendedSmSubsData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ExtendedSmSubsData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ExtendedSmSubsData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ExtendedSmSubsData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ExtendedSmSubsData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ExtendedSmSubsData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ExtendedSmSubsData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// String identifying External Group Identifier that identifies a group made up of one or more  subscriptions associated to a group of IMSIs, as specified in clause 19.7.3 of 3GPP TS 23.003.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ExternalGroupId(String);

impl std::convert::From<String> for ExternalGroupId {
    fn from(x: String) -> Self {
        ExternalGroupId(x)
    }
}

impl std::string::ToString for ExternalGroupId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for ExternalGroupId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(ExternalGroupId(x.to_string()))
    }
}

impl std::convert::From<ExternalGroupId> for String {
    fn from(x: ExternalGroupId) -> Self {
        x.0
    }
}

impl std::ops::Deref for ExternalGroupId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for ExternalGroupId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ExternalUnrelatedClass {
    #[serde(rename = "lcsClientExternals")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lcs_client_externals: Option<Vec<models::LcsClientExternal>>,

    #[serde(rename = "afExternals")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub af_externals: Option<Vec<models::AfExternal>>,

    #[serde(rename = "lcsClientGroupExternals")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lcs_client_group_externals: Option<Vec<models::LcsClientGroupExternal>>,
}

impl ExternalUnrelatedClass {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ExternalUnrelatedClass {
        ExternalUnrelatedClass {
            lcs_client_externals: None,
            af_externals: None,
            lcs_client_group_externals: None,
        }
    }
}

/// Converts the ExternalUnrelatedClass value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ExternalUnrelatedClass {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping lcsClientExternals in query parameter serialization

            // Skipping afExternals in query parameter serialization

            // Skipping lcsClientGroupExternals in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ExternalUnrelatedClass value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ExternalUnrelatedClass {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub lcs_client_externals: Vec<Vec<models::LcsClientExternal>>,
            pub af_externals: Vec<Vec<models::AfExternal>>,
            pub lcs_client_group_externals: Vec<Vec<models::LcsClientGroupExternal>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ExternalUnrelatedClass".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "lcsClientExternals" => return std::result::Result::Err("Parsing a container in this style is not supported in ExternalUnrelatedClass".to_string()),
                    "afExternals" => return std::result::Result::Err("Parsing a container in this style is not supported in ExternalUnrelatedClass".to_string()),
                    "lcsClientGroupExternals" => return std::result::Result::Err("Parsing a container in this style is not supported in ExternalUnrelatedClass".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ExternalUnrelatedClass".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ExternalUnrelatedClass {
            lcs_client_externals: intermediate_rep.lcs_client_externals.into_iter().next(),
            af_externals: intermediate_rep.af_externals.into_iter().next(),
            lcs_client_group_externals: intermediate_rep
                .lcs_client_group_externals
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ExternalUnrelatedClass> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ExternalUnrelatedClass>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ExternalUnrelatedClass>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ExternalUnrelatedClass - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ExternalUnrelatedClass>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ExternalUnrelatedClass as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ExternalUnrelatedClass - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// string with format 'float' as defined in OpenAPI.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Float(f32);

impl std::convert::From<f32> for Float {
    fn from(x: f32) -> Self {
        Float(x)
    }
}

impl std::convert::From<Float> for f32 {
    fn from(x: Float) -> Self {
        x.0
    }
}

impl std::ops::Deref for Float {
    type Target = f32;
    fn deref(&self) -> &f32 {
        &self.0
    }
}

impl std::ops::DerefMut for Float {
    fn deref_mut(&mut self) -> &mut f32 {
        &mut self.0
    }
}

/// Fully Qualified Domain Name
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Fqdn(String);

impl std::convert::From<String> for Fqdn {
    fn from(x: String) -> Self {
        Fqdn(x)
    }
}

impl std::string::ToString for Fqdn {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Fqdn {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Fqdn(x.to_string()))
    }
}

impl std::convert::From<Fqdn> for String {
    fn from(x: Fqdn) -> Self {
        x.0
    }
}

impl std::ops::Deref for Fqdn {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Fqdn {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FrameRouteInfo {
    /// \"String identifying a IPv4 address mask formatted in the 'dotted decimal' notation as defined in RFC 1166.\"
    #[serde(rename = "ipv4Mask")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv4_mask: Option<String>,

    #[serde(rename = "ipv6Prefix")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_prefix: Option<models::Ipv6Prefix>,
}

impl FrameRouteInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> FrameRouteInfo {
        FrameRouteInfo {
            ipv4_mask: None,
            ipv6_prefix: None,
        }
    }
}

/// Converts the FrameRouteInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FrameRouteInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.ipv4_mask
                .as_ref()
                .map(|ipv4_mask| vec!["ipv4Mask".to_string(), ipv4_mask.to_string()].join(",")),
            // Skipping ipv6Prefix in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FrameRouteInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FrameRouteInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ipv4_mask: Vec<String>,
            pub ipv6_prefix: Vec<models::Ipv6Prefix>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing FrameRouteInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ipv4Mask" => intermediate_rep.ipv4_mask.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ipv6Prefix" => intermediate_rep.ipv6_prefix.push(
                        <models::Ipv6Prefix as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing FrameRouteInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FrameRouteInfo {
            ipv4_mask: intermediate_rep.ipv4_mask.into_iter().next(),
            ipv6_prefix: intermediate_rep.ipv6_prefix.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FrameRouteInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FrameRouteInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<FrameRouteInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for FrameRouteInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FrameRouteInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <FrameRouteInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into FrameRouteInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Common base type for GAD shapes.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GadShape {
    #[serde(rename = "shape")]
    pub shape: models::SupportedGadShapes,
}

impl GadShape {
    #[allow(clippy::new_without_default)]
    pub fn new(shape: models::SupportedGadShapes) -> GadShape {
        GadShape { shape }
    }
}

/// Converts the GadShape value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GadShape {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping shape in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GadShape value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GadShape {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub shape: Vec<models::SupportedGadShapes>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GadShape".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "shape" => intermediate_rep.shape.push(
                        <models::SupportedGadShapes as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GadShape".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GadShape {
            shape: intermediate_rep
                .shape
                .into_iter()
                .next()
                .ok_or_else(|| "shape missing in GadShape".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GadShape> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GadShape>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GadShape>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GadShape - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GadShape> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GadShape as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GadShape - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// List of geographic area or list of civic address info
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GeoServiceArea {
    #[serde(rename = "geographicAreaList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub geographic_area_list: Option<Vec<models::GeographicArea>>,

    #[serde(rename = "civicAddressList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub civic_address_list: Option<Vec<models::CivicAddress>>,
}

impl GeoServiceArea {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GeoServiceArea {
        GeoServiceArea {
            geographic_area_list: None,
            civic_address_list: None,
        }
    }
}

/// Converts the GeoServiceArea value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GeoServiceArea {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping geographicAreaList in query parameter serialization

            // Skipping civicAddressList in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GeoServiceArea value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GeoServiceArea {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub geographic_area_list: Vec<Vec<models::GeographicArea>>,
            pub civic_address_list: Vec<Vec<models::CivicAddress>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GeoServiceArea".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "geographicAreaList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in GeoServiceArea"
                                .to_string(),
                        )
                    }
                    "civicAddressList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in GeoServiceArea"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GeoServiceArea".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GeoServiceArea {
            geographic_area_list: intermediate_rep.geographic_area_list.into_iter().next(),
            civic_address_list: intermediate_rep.civic_address_list.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GeoServiceArea> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GeoServiceArea>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GeoServiceArea>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GeoServiceArea - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GeoServiceArea> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GeoServiceArea as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GeoServiceArea - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Geographic area specified by different shape.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GeographicArea {
    #[serde(rename = "shape")]
    pub shape: models::SupportedGadShapes,

    #[serde(rename = "point")]
    pub point: models::GeographicalCoordinates,

    /// Indicates value of uncertainty.
    #[serde(rename = "uncertainty")]
    pub uncertainty: f32,

    #[serde(rename = "uncertaintyEllipse")]
    pub uncertainty_ellipse: models::UncertaintyEllipse,

    /// Indicates value of confidence.
    #[serde(rename = "confidence")]
    pub confidence: u8,

    /// List of points.
    #[serde(rename = "pointList")]
    pub point_list: Vec<models::GeographicalCoordinates>,

    /// Indicates value of altitude.
    #[serde(rename = "altitude")]
    pub altitude: f64,

    /// Indicates value of uncertainty.
    #[serde(rename = "uncertaintyAltitude")]
    pub uncertainty_altitude: f32,

    /// Indicates value of the inner radius.
    #[serde(rename = "innerRadius")]
    pub inner_radius: u32,

    /// Indicates value of uncertainty.
    #[serde(rename = "uncertaintyRadius")]
    pub uncertainty_radius: f32,

    /// Indicates value of angle.
    #[serde(rename = "offsetAngle")]
    pub offset_angle: u16,

    /// Indicates value of angle.
    #[serde(rename = "includedAngle")]
    pub included_angle: u16,
}

impl GeographicArea {
    #[allow(clippy::new_without_default)]
    pub fn new(
        shape: models::SupportedGadShapes,
        point: models::GeographicalCoordinates,
        uncertainty: f32,
        uncertainty_ellipse: models::UncertaintyEllipse,
        confidence: u8,
        point_list: Vec<models::GeographicalCoordinates>,
        altitude: f64,
        uncertainty_altitude: f32,
        inner_radius: u32,
        uncertainty_radius: f32,
        offset_angle: u16,
        included_angle: u16,
    ) -> GeographicArea {
        GeographicArea {
            shape,
            point,
            uncertainty,
            uncertainty_ellipse,
            confidence,
            point_list,
            altitude,
            uncertainty_altitude,
            inner_radius,
            uncertainty_radius,
            offset_angle,
            included_angle,
        }
    }
}

/// Converts the GeographicArea value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GeographicArea {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping shape in query parameter serialization

            // Skipping point in query parameter serialization
            Some("uncertainty".to_string()),
            Some(self.uncertainty.to_string()),
            // Skipping uncertaintyEllipse in query parameter serialization
            Some("confidence".to_string()),
            Some(self.confidence.to_string()),
            // Skipping pointList in query parameter serialization
            Some("altitude".to_string()),
            Some(self.altitude.to_string()),
            Some("uncertaintyAltitude".to_string()),
            Some(self.uncertainty_altitude.to_string()),
            Some("innerRadius".to_string()),
            Some(self.inner_radius.to_string()),
            Some("uncertaintyRadius".to_string()),
            Some(self.uncertainty_radius.to_string()),
            Some("offsetAngle".to_string()),
            Some(self.offset_angle.to_string()),
            Some("includedAngle".to_string()),
            Some(self.included_angle.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GeographicArea value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GeographicArea {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub shape: Vec<models::SupportedGadShapes>,
            pub point: Vec<models::GeographicalCoordinates>,
            pub uncertainty: Vec<f32>,
            pub uncertainty_ellipse: Vec<models::UncertaintyEllipse>,
            pub confidence: Vec<u8>,
            pub point_list: Vec<Vec<models::GeographicalCoordinates>>,
            pub altitude: Vec<f64>,
            pub uncertainty_altitude: Vec<f32>,
            pub inner_radius: Vec<u32>,
            pub uncertainty_radius: Vec<f32>,
            pub offset_angle: Vec<u16>,
            pub included_angle: Vec<u16>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GeographicArea".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "shape" => intermediate_rep.shape.push(
                        <models::SupportedGadShapes as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "point" => intermediate_rep.point.push(
                        <models::GeographicalCoordinates as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "uncertainty" => intermediate_rep.uncertainty.push(
                        <f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "uncertaintyEllipse" => intermediate_rep.uncertainty_ellipse.push(
                        <models::UncertaintyEllipse as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "confidence" => intermediate_rep
                        .confidence
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "pointList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in GeographicArea"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "altitude" => intermediate_rep.altitude.push(
                        <f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "uncertaintyAltitude" => intermediate_rep.uncertainty_altitude.push(
                        <f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "innerRadius" => intermediate_rep.inner_radius.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "uncertaintyRadius" => intermediate_rep.uncertainty_radius.push(
                        <f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "offsetAngle" => intermediate_rep.offset_angle.push(
                        <u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "includedAngle" => intermediate_rep.included_angle.push(
                        <u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GeographicArea".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GeographicArea {
            shape: intermediate_rep
                .shape
                .into_iter()
                .next()
                .ok_or_else(|| "shape missing in GeographicArea".to_string())?,
            point: intermediate_rep
                .point
                .into_iter()
                .next()
                .ok_or_else(|| "point missing in GeographicArea".to_string())?,
            uncertainty: intermediate_rep
                .uncertainty
                .into_iter()
                .next()
                .ok_or_else(|| "uncertainty missing in GeographicArea".to_string())?,
            uncertainty_ellipse: intermediate_rep
                .uncertainty_ellipse
                .into_iter()
                .next()
                .ok_or_else(|| "uncertaintyEllipse missing in GeographicArea".to_string())?,
            confidence: intermediate_rep
                .confidence
                .into_iter()
                .next()
                .ok_or_else(|| "confidence missing in GeographicArea".to_string())?,
            point_list: intermediate_rep
                .point_list
                .into_iter()
                .next()
                .ok_or_else(|| "pointList missing in GeographicArea".to_string())?,
            altitude: intermediate_rep
                .altitude
                .into_iter()
                .next()
                .ok_or_else(|| "altitude missing in GeographicArea".to_string())?,
            uncertainty_altitude: intermediate_rep
                .uncertainty_altitude
                .into_iter()
                .next()
                .ok_or_else(|| "uncertaintyAltitude missing in GeographicArea".to_string())?,
            inner_radius: intermediate_rep
                .inner_radius
                .into_iter()
                .next()
                .ok_or_else(|| "innerRadius missing in GeographicArea".to_string())?,
            uncertainty_radius: intermediate_rep
                .uncertainty_radius
                .into_iter()
                .next()
                .ok_or_else(|| "uncertaintyRadius missing in GeographicArea".to_string())?,
            offset_angle: intermediate_rep
                .offset_angle
                .into_iter()
                .next()
                .ok_or_else(|| "offsetAngle missing in GeographicArea".to_string())?,
            included_angle: intermediate_rep
                .included_angle
                .into_iter()
                .next()
                .ok_or_else(|| "includedAngle missing in GeographicArea".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GeographicArea> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GeographicArea>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GeographicArea>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GeographicArea - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GeographicArea> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GeographicArea as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GeographicArea - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Geographical coordinates.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GeographicalCoordinates {
    #[serde(rename = "lon")]
    pub lon: f64,

    #[serde(rename = "lat")]
    pub lat: f64,
}

impl GeographicalCoordinates {
    #[allow(clippy::new_without_default)]
    pub fn new(lon: f64, lat: f64) -> GeographicalCoordinates {
        GeographicalCoordinates { lon, lat }
    }
}

/// Converts the GeographicalCoordinates value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GeographicalCoordinates {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("lon".to_string()),
            Some(self.lon.to_string()),
            Some("lat".to_string()),
            Some(self.lat.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GeographicalCoordinates value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GeographicalCoordinates {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub lon: Vec<f64>,
            pub lat: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GeographicalCoordinates".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "lon" => intermediate_rep.lon.push(
                        <f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "lat" => intermediate_rep.lat.push(
                        <f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GeographicalCoordinates".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GeographicalCoordinates {
            lon: intermediate_rep
                .lon
                .into_iter()
                .next()
                .ok_or_else(|| "lon missing in GeographicalCoordinates".to_string())?,
            lat: intermediate_rep
                .lat
                .into_iter()
                .next()
                .ok_or_else(|| "lat missing in GeographicalCoordinates".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GeographicalCoordinates> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GeographicalCoordinates>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GeographicalCoordinates>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GeographicalCoordinates - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<GeographicalCoordinates>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GeographicalCoordinates as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GeographicalCoordinates - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// string with format 'bytes' as defined in OpenAPI
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Gli {}

impl Gli {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Gli {
        Gli {}
    }
}

/// Converts the Gli value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Gli {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Gli value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Gli {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err("Missing value while parsing Gli".to_string())
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Gli".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Gli {})
    }
}

// Methods for converting between header::IntoHeaderValue<Gli> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Gli>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Gli>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Gli - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Gli> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Gli as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Gli - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// One of the six attributes n3IwfId, gNbIdm, ngeNbId, wagfId, tngfId, eNbId shall be present.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GlobalRanNodeId {
    #[serde(rename = "plmnId")]
    pub plmn_id: models::PlmnId,

    /// This represents the identifier of the N3IWF ID as specified in clause 9.3.1.57 of  3GPP TS 38.413 in hexadecimal representation. Each character in the string shall take a value  of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant  character representing the 4 most significant bits of the N3IWF ID shall appear first in the  string, and the character representing the 4 least significant bit of the N3IWF ID shall  appear last in the string.
    #[serde(rename = "n3IwfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub n3_iwf_id: Option<String>,

    #[serde(rename = "gNbId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub g_nb_id: Option<models::GnbId>,

    /// This represents the identifier of the ng-eNB ID as specified in clause 9.3.1.8 of  3GPP TS 38.413. The value of the ng-eNB ID shall be encoded in hexadecimal representation.  Each character in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and  shall represent 4 bits. The padding 0 shall be added to make multiple nibbles, so the most  significant character representing the padding 0 if required together with the 4 most  significant bits of the ng-eNB ID shall appear first in the string, and the character  representing the 4 least significant bit of the ng-eNB ID (to form a nibble) shall appear last  in the string.
    #[serde(rename = "ngeNbId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nge_nb_id: Option<String>,

    /// This represents the identifier of the W-AGF ID as specified in clause 9.3.1.162 of  3GPP TS 38.413 in hexadecimal representation. Each character in the string shall take a value  of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant  character representing the 4 most significant bits of the W-AGF ID shall appear first in the  string, and the character representing the 4 least significant bit of the W-AGF ID shall  appear last in the string.
    #[serde(rename = "wagfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub wagf_id: Option<String>,

    /// This represents the identifier of the TNGF ID as specified in clause 9.3.1.161 of  3GPP TS 38.413  in hexadecimal representation. Each character in the string shall take a value of \"0\" to \"9\", \"a\"  to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character representing the  4 most significant bits of the TNGF ID shall appear first in the string, and the character  representing the 4 least significant bit of the TNGF ID shall appear last in the string.
    #[serde(rename = "tngfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tngf_id: Option<String>,

    /// This represents the Network Identifier, which together with a PLMN ID is used to identify an SNPN (see 3GPP TS 23.003 and 3GPP TS 23.501 clause 5.30.2.1).
    #[serde(rename = "nid")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nid: Option<String>,

    /// This represents the identifier of the eNB ID as specified in clause 9.2.1.37 of  3GPP TS 36.413. The string shall be formatted with the following pattern  '^('MacroeNB-[A-Fa-f0-9]{5}|LMacroeNB-[A-Fa-f0-9]{6}|SMacroeNB-[A-Fa-f0-9]{5} |HomeeNB-[A-Fa-f0-9]{7})$'. The value of the eNB ID shall be encoded in hexadecimal representation. Each character in the  string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits.  The padding 0 shall be added to make multiple nibbles, so the most significant character  representing the padding 0 if required together with the 4 most significant bits of the eNB ID  shall appear first in the string, and the character representing the 4 least significant bit  of the eNB ID (to form a nibble) shall appear last in the string.
    #[serde(rename = "eNbId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub e_nb_id: Option<String>,
}

impl GlobalRanNodeId {
    #[allow(clippy::new_without_default)]
    pub fn new(plmn_id: models::PlmnId) -> GlobalRanNodeId {
        GlobalRanNodeId {
            plmn_id,
            n3_iwf_id: None,
            g_nb_id: None,
            nge_nb_id: None,
            wagf_id: None,
            tngf_id: None,
            nid: None,
            e_nb_id: None,
        }
    }
}

/// Converts the GlobalRanNodeId value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GlobalRanNodeId {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping plmnId in query parameter serialization
            self.n3_iwf_id
                .as_ref()
                .map(|n3_iwf_id| vec!["n3IwfId".to_string(), n3_iwf_id.to_string()].join(",")),
            // Skipping gNbId in query parameter serialization
            self.nge_nb_id
                .as_ref()
                .map(|nge_nb_id| vec!["ngeNbId".to_string(), nge_nb_id.to_string()].join(",")),
            self.wagf_id
                .as_ref()
                .map(|wagf_id| vec!["wagfId".to_string(), wagf_id.to_string()].join(",")),
            self.tngf_id
                .as_ref()
                .map(|tngf_id| vec!["tngfId".to_string(), tngf_id.to_string()].join(",")),
            self.nid
                .as_ref()
                .map(|nid| vec!["nid".to_string(), nid.to_string()].join(",")),
            self.e_nb_id
                .as_ref()
                .map(|e_nb_id| vec!["eNbId".to_string(), e_nb_id.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GlobalRanNodeId value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GlobalRanNodeId {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub plmn_id: Vec<models::PlmnId>,
            pub n3_iwf_id: Vec<String>,
            pub g_nb_id: Vec<models::GnbId>,
            pub nge_nb_id: Vec<String>,
            pub wagf_id: Vec<String>,
            pub tngf_id: Vec<String>,
            pub nid: Vec<String>,
            pub e_nb_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GlobalRanNodeId".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "plmnId" => intermediate_rep.plmn_id.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "n3IwfId" => intermediate_rep.n3_iwf_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "gNbId" => intermediate_rep.g_nb_id.push(
                        <models::GnbId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ngeNbId" => intermediate_rep.nge_nb_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "wagfId" => intermediate_rep.wagf_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "tngfId" => intermediate_rep.tngf_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nid" => intermediate_rep.nid.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "eNbId" => intermediate_rep.e_nb_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GlobalRanNodeId".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GlobalRanNodeId {
            plmn_id: intermediate_rep
                .plmn_id
                .into_iter()
                .next()
                .ok_or_else(|| "plmnId missing in GlobalRanNodeId".to_string())?,
            n3_iwf_id: intermediate_rep.n3_iwf_id.into_iter().next(),
            g_nb_id: intermediate_rep.g_nb_id.into_iter().next(),
            nge_nb_id: intermediate_rep.nge_nb_id.into_iter().next(),
            wagf_id: intermediate_rep.wagf_id.into_iter().next(),
            tngf_id: intermediate_rep.tngf_id.into_iter().next(),
            nid: intermediate_rep.nid.into_iter().next(),
            e_nb_id: intermediate_rep.e_nb_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GlobalRanNodeId> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GlobalRanNodeId>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GlobalRanNodeId>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GlobalRanNodeId - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<GlobalRanNodeId>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GlobalRanNodeId as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GlobalRanNodeId - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Provides the G-NB identifier.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GnbId {
    /// Unsigned integer representing the bit length of the gNB ID as defined in clause 9.3.1.6 of 3GPP TS 38.413 [11], within the range 22 to 32.
    #[serde(rename = "bitLength")]
    pub bit_length: u8,

    /// This represents the identifier of the gNB. The value of the gNB ID shall be encoded in hexadecimal representation. Each character in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The padding 0 shall be added to make multiple nibbles,  the most significant character representing the padding 0 if required together with the 4 most significant bits of the gNB ID shall appear first in the string, and the character representing the 4 least significant bit of the gNB ID shall appear last in the string.
    #[serde(rename = "gNBValue")]
    pub g_nb_value: String,
}

impl GnbId {
    #[allow(clippy::new_without_default)]
    pub fn new(bit_length: u8, g_nb_value: String) -> GnbId {
        GnbId {
            bit_length,
            g_nb_value,
        }
    }
}

/// Converts the GnbId value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GnbId {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("bitLength".to_string()),
            Some(self.bit_length.to_string()),
            Some("gNBValue".to_string()),
            Some(self.g_nb_value.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GnbId value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GnbId {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub bit_length: Vec<u8>,
            pub g_nb_value: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GnbId".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "bitLength" => intermediate_rep
                        .bit_length
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "gNBValue" => intermediate_rep.g_nb_value.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GnbId".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GnbId {
            bit_length: intermediate_rep
                .bit_length
                .into_iter()
                .next()
                .ok_or_else(|| "bitLength missing in GnbId".to_string())?,
            g_nb_value: intermediate_rep
                .g_nb_value
                .into_iter()
                .next()
                .ok_or_else(|| "gNBValue missing in GnbId".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GnbId> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GnbId>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GnbId>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GnbId - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GnbId> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <GnbId as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into GnbId - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// String identifying a Gpsi shall contain either an External Id or an MSISDN.  It shall be formatted as follows -External Identifier= \"extid-'extid', where 'extid'  shall be formatted according to clause 19.7.2 of 3GPP TS 23.003 that describes an  External Identifier.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Gpsi(String);

impl std::convert::From<String> for Gpsi {
    fn from(x: String) -> Self {
        Gpsi(x)
    }
}

impl std::string::ToString for Gpsi {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Gpsi {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Gpsi(x.to_string()))
    }
}

impl std::convert::From<Gpsi> for String {
    fn from(x: Gpsi) -> Self {
        x.0
    }
}

impl std::ops::Deref for Gpsi {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Gpsi {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Type of GPSI (MSISDN or External-ID)
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GpsiType {}

impl GpsiType {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GpsiType {
        GpsiType {}
    }
}

/// Converts the GpsiType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GpsiType {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GpsiType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GpsiType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GpsiType".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GpsiType".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GpsiType {})
    }
}

// Methods for converting between header::IntoHeaderValue<GpsiType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GpsiType>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GpsiType>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GpsiType - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GpsiType> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GpsiType as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GpsiType - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum GpsiTypeAnyOf {
    #[serde(rename = "MSISDN")]
    Msisdn,
    #[serde(rename = "EXT_ID")]
    ExtId,
    #[serde(rename = "EXT_GROUP_ID")]
    ExtGroupId,
}

impl std::fmt::Display for GpsiTypeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            GpsiTypeAnyOf::Msisdn => write!(f, "MSISDN"),
            GpsiTypeAnyOf::ExtId => write!(f, "EXT_ID"),
            GpsiTypeAnyOf::ExtGroupId => write!(f, "EXT_GROUP_ID"),
        }
    }
}

impl std::str::FromStr for GpsiTypeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "MSISDN" => std::result::Result::Ok(GpsiTypeAnyOf::Msisdn),
            "EXT_ID" => std::result::Result::Ok(GpsiTypeAnyOf::ExtId),
            "EXT_GROUP_ID" => std::result::Result::Ok(GpsiTypeAnyOf::ExtGroupId),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// String identifying a group of devices network internal globally unique ID which identifies a set of IMSIs, as specified in clause 19.9 of 3GPP TS 23.003.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GroupId(String);

impl std::convert::From<String> for GroupId {
    fn from(x: String) -> Self {
        GroupId(x)
    }
}

impl std::string::ToString for GroupId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for GroupId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(GroupId(x.to_string()))
    }
}

impl std::convert::From<GroupId> for String {
    fn from(x: GroupId) -> Self {
        x.0
    }
}

impl std::ops::Deref for GroupId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for GroupId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GroupIdentifiers {
    #[serde(rename = "extGroupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ext_group_id: Option<String>,

    /// String identifying a group of devices network internal globally unique ID which identifies a set of IMSIs, as specified in clause 19.9 of 3GPP TS 23.003.
    #[serde(rename = "intGroupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub int_group_id: Option<String>,

    #[serde(rename = "ueIdList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_id_list: Option<Vec<models::UeId>>,
}

impl GroupIdentifiers {
    #[allow(clippy::new_without_default)]
    pub fn new() -> GroupIdentifiers {
        GroupIdentifiers {
            ext_group_id: None,
            int_group_id: None,
            ue_id_list: None,
        }
    }
}

/// Converts the GroupIdentifiers value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GroupIdentifiers {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.ext_group_id.as_ref().map(|ext_group_id| {
                vec!["extGroupId".to_string(), ext_group_id.to_string()].join(",")
            }),
            self.int_group_id.as_ref().map(|int_group_id| {
                vec!["intGroupId".to_string(), int_group_id.to_string()].join(",")
            }),
            // Skipping ueIdList in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GroupIdentifiers value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GroupIdentifiers {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ext_group_id: Vec<String>,
            pub int_group_id: Vec<String>,
            pub ue_id_list: Vec<Vec<models::UeId>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing GroupIdentifiers".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "extGroupId" => intermediate_rep.ext_group_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "intGroupId" => intermediate_rep.int_group_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "ueIdList" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in GroupIdentifiers"
                            .to_string(),
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing GroupIdentifiers".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GroupIdentifiers {
            ext_group_id: intermediate_rep.ext_group_id.into_iter().next(),
            int_group_id: intermediate_rep.int_group_id.into_iter().next(),
            ue_id_list: intermediate_rep.ue_id_list.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GroupIdentifiers> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GroupIdentifiers>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<GroupIdentifiers>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for GroupIdentifiers - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<GroupIdentifiers>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <GroupIdentifiers as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into GroupIdentifiers - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Globally Unique AMF Identifier constructed out of PLMN, Network and AMF identity.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Guami {
    #[serde(rename = "plmnId")]
    pub plmn_id: models::PlmnIdNid,

    /// String identifying the AMF ID composed of AMF Region ID (8 bits), AMF Set ID (10 bits) and AMF  Pointer (6 bits) as specified in clause 2.10.1 of 3GPP TS 23.003. It is encoded as a string of  6 hexadecimal characters (i.e., 24 bits).
    #[serde(rename = "amfId")]
    pub amf_id: String,
}

impl Guami {
    #[allow(clippy::new_without_default)]
    pub fn new(plmn_id: models::PlmnIdNid, amf_id: String) -> Guami {
        Guami { plmn_id, amf_id }
    }
}

/// Converts the Guami value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Guami {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping plmnId in query parameter serialization
            Some("amfId".to_string()),
            Some(self.amf_id.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Guami value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Guami {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub plmn_id: Vec<models::PlmnIdNid>,
            pub amf_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Guami".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "plmnId" => intermediate_rep.plmn_id.push(
                        <models::PlmnIdNid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "amfId" => intermediate_rep.amf_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Guami".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Guami {
            plmn_id: intermediate_rep
                .plmn_id
                .into_iter()
                .next()
                .ok_or_else(|| "plmnId missing in Guami".to_string())?,
            amf_id: intermediate_rep
                .amf_id
                .into_iter()
                .next()
                .ok_or_else(|| "amfId missing in Guami".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Guami> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Guami>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Guami>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Guami - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Guami> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Guami as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Guami - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// This IE represents the identifier of the HFC node Id as specified in CableLabs WR-TR-5WWC-ARCH. It is provisioned by the wireline operator as part of wireline operations and may contain up to six characters.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct HfcNid(String);

impl std::convert::From<String> for HfcNid {
    fn from(x: String) -> Self {
        HfcNid(x)
    }
}

impl std::string::ToString for HfcNid {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for HfcNid {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(HfcNid(x.to_string()))
    }
}

impl std::convert::From<HfcNid> for String {
    fn from(x: HfcNid) -> Self {
        x.0
    }
}

impl std::ops::Deref for HfcNid {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for HfcNid {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IdTranslationResult {
    /// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  tableÂ 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.
    #[serde(rename = "supportedFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_features: Option<String>,

    /// String identifying a Supi that shall contain either an IMSI, a network specific identifier, a Global Cable Identifier (GCI) or a Global Line Identifier (GLI) as specified in clause  2.2A of 3GPP TS 23.003. It shall be formatted as follows  - for an IMSI \"imsi-<imsi>\", where <imsi> shall be formatted according to clause 2.2    of 3GPP TS 23.003 that describes an IMSI.  - for a network specific identifier \"nai-<nai>, where <nai> shall be formatted    according to clause 28.7.2 of 3GPP TS 23.003 that describes an NAI.  - for a GCI \"gci-<gci>\", where <gci> shall be formatted according to clause 28.15.2    of 3GPP TS 23.003.  - for a GLI \"gli-<gli>\", where <gli> shall be formatted according to clause 28.16.2 of    3GPP TS 23.003.To enable that the value is used as part of an URI, the string shall    only contain characters allowed according to the \"lower-with-hyphen\" naming convention    defined in 3GPP TS 29.501.
    #[serde(rename = "supi")]
    pub supi: String,

    /// String identifying a Gpsi shall contain either an External Id or an MSISDN.  It shall be formatted as follows -External Identifier= \"extid-'extid', where 'extid'  shall be formatted according to clause 19.7.2 of 3GPP TS 23.003 that describes an  External Identifier.
    #[serde(rename = "gpsi")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gpsi: Option<String>,

    #[serde(rename = "additionalSupis")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_supis: Option<Vec<models::Supi>>,

    #[serde(rename = "additionalGpsis")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_gpsis: Option<Vec<models::Gpsi>>,
}

impl IdTranslationResult {
    #[allow(clippy::new_without_default)]
    pub fn new(supi: String) -> IdTranslationResult {
        IdTranslationResult {
            supported_features: None,
            supi,
            gpsi: None,
            additional_supis: None,
            additional_gpsis: None,
        }
    }
}

/// Converts the IdTranslationResult value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for IdTranslationResult {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.supported_features.as_ref().map(|supported_features| {
                vec![
                    "supportedFeatures".to_string(),
                    supported_features.to_string(),
                ]
                .join(",")
            }),
            Some("supi".to_string()),
            Some(self.supi.to_string()),
            self.gpsi
                .as_ref()
                .map(|gpsi| vec!["gpsi".to_string(), gpsi.to_string()].join(",")),
            self.additional_supis.as_ref().map(|additional_supis| {
                vec![
                    "additionalSupis".to_string(),
                    additional_supis
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.additional_gpsis.as_ref().map(|additional_gpsis| {
                vec![
                    "additionalGpsis".to_string(),
                    additional_gpsis
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IdTranslationResult value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IdTranslationResult {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub supported_features: Vec<String>,
            pub supi: Vec<String>,
            pub gpsi: Vec<String>,
            pub additional_supis: Vec<Vec<models::Supi>>,
            pub additional_gpsis: Vec<Vec<models::Gpsi>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing IdTranslationResult".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "supportedFeatures" => intermediate_rep.supported_features.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "supi" => intermediate_rep.supi.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "gpsi" => intermediate_rep.gpsi.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "additionalSupis" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in IdTranslationResult"
                            .to_string(),
                    ),
                    "additionalGpsis" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in IdTranslationResult"
                            .to_string(),
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing IdTranslationResult".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IdTranslationResult {
            supported_features: intermediate_rep.supported_features.into_iter().next(),
            supi: intermediate_rep
                .supi
                .into_iter()
                .next()
                .ok_or_else(|| "supi missing in IdTranslationResult".to_string())?,
            gpsi: intermediate_rep.gpsi.into_iter().next(),
            additional_supis: intermediate_rep.additional_supis.into_iter().next(),
            additional_gpsis: intermediate_rep.additional_gpsis.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IdTranslationResult> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<IdTranslationResult>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<IdTranslationResult>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for IdTranslationResult - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<IdTranslationResult>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <IdTranslationResult as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into IdTranslationResult - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ImmediateReport {
    #[serde(rename = "amData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub am_data: Option<models::AccessAndMobilitySubscriptionData>,

    #[serde(rename = "smfSelData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub smf_sel_data: Option<models::SmfSelectionSubscriptionData>,

    #[serde(rename = "uecAmfData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub uec_amf_data: Option<models::UeContextInAmfData>,

    #[serde(rename = "uecSmfData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub uec_smf_data: Option<models::UeContextInSmfData>,

    #[serde(rename = "uecSmsfData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub uec_smsf_data: Option<models::UeContextInSmsfData>,

    #[serde(rename = "smsSubsData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sms_subs_data: Option<models::SmsSubscriptionData>,

    #[serde(rename = "smData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sm_data: Option<models::SmSubsData>,

    #[serde(rename = "traceData")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trace_data: Option<swagger::Nullable<models::TraceData>>,

    #[serde(rename = "smsMngData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sms_mng_data: Option<models::SmsManagementSubscriptionData>,

    #[serde(rename = "lcsPrivacyData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lcs_privacy_data: Option<models::LcsPrivacyData>,

    #[serde(rename = "lcsMoData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lcs_mo_data: Option<models::LcsMoData>,

    #[serde(rename = "v2xData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub v2x_data: Option<models::V2xSubscriptionData>,

    #[serde(rename = "lcsBroadcastAssistanceTypesData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lcs_broadcast_assistance_types_data: Option<models::LcsBroadcastAssistanceTypesData>,

    #[serde(rename = "proseData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prose_data: Option<models::ProseSubscriptionData>,

    #[serde(rename = "mbsData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mbs_data: Option<models::MbsSubscriptionData>,

    #[serde(rename = "ucData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub uc_data: Option<models::UcSubscriptionData>,
}

impl ImmediateReport {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ImmediateReport {
        ImmediateReport {
            am_data: None,
            smf_sel_data: None,
            uec_amf_data: None,
            uec_smf_data: None,
            uec_smsf_data: None,
            sms_subs_data: None,
            sm_data: None,
            trace_data: None,
            sms_mng_data: None,
            lcs_privacy_data: None,
            lcs_mo_data: None,
            v2x_data: None,
            lcs_broadcast_assistance_types_data: None,
            prose_data: None,
            mbs_data: None,
            uc_data: None,
        }
    }
}

/// Converts the ImmediateReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ImmediateReport {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping amData in query parameter serialization

            // Skipping smfSelData in query parameter serialization

            // Skipping uecAmfData in query parameter serialization

            // Skipping uecSmfData in query parameter serialization

            // Skipping uecSmsfData in query parameter serialization

            // Skipping smsSubsData in query parameter serialization

            // Skipping smData in query parameter serialization

            // Skipping traceData in query parameter serialization

            // Skipping smsMngData in query parameter serialization

            // Skipping lcsPrivacyData in query parameter serialization

            // Skipping lcsMoData in query parameter serialization

            // Skipping v2xData in query parameter serialization

            // Skipping lcsBroadcastAssistanceTypesData in query parameter serialization

            // Skipping proseData in query parameter serialization

            // Skipping mbsData in query parameter serialization

            // Skipping ucData in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ImmediateReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ImmediateReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub am_data: Vec<models::AccessAndMobilitySubscriptionData>,
            pub smf_sel_data: Vec<models::SmfSelectionSubscriptionData>,
            pub uec_amf_data: Vec<models::UeContextInAmfData>,
            pub uec_smf_data: Vec<models::UeContextInSmfData>,
            pub uec_smsf_data: Vec<models::UeContextInSmsfData>,
            pub sms_subs_data: Vec<models::SmsSubscriptionData>,
            pub sm_data: Vec<models::SmSubsData>,
            pub trace_data: Vec<models::TraceData>,
            pub sms_mng_data: Vec<models::SmsManagementSubscriptionData>,
            pub lcs_privacy_data: Vec<models::LcsPrivacyData>,
            pub lcs_mo_data: Vec<models::LcsMoData>,
            pub v2x_data: Vec<models::V2xSubscriptionData>,
            pub lcs_broadcast_assistance_types_data: Vec<models::LcsBroadcastAssistanceTypesData>,
            pub prose_data: Vec<models::ProseSubscriptionData>,
            pub mbs_data: Vec<models::MbsSubscriptionData>,
            pub uc_data: Vec<models::UcSubscriptionData>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ImmediateReport".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "amData" => intermediate_rep.am_data.push(<models::AccessAndMobilitySubscriptionData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "smfSelData" => intermediate_rep.smf_sel_data.push(<models::SmfSelectionSubscriptionData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "uecAmfData" => intermediate_rep.uec_amf_data.push(<models::UeContextInAmfData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "uecSmfData" => intermediate_rep.uec_smf_data.push(<models::UeContextInSmfData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "uecSmsfData" => intermediate_rep.uec_smsf_data.push(<models::UeContextInSmsfData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "smsSubsData" => intermediate_rep.sms_subs_data.push(<models::SmsSubscriptionData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "smData" => intermediate_rep.sm_data.push(<models::SmSubsData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "traceData" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ImmediateReport".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "smsMngData" => intermediate_rep.sms_mng_data.push(<models::SmsManagementSubscriptionData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lcsPrivacyData" => intermediate_rep.lcs_privacy_data.push(<models::LcsPrivacyData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lcsMoData" => intermediate_rep.lcs_mo_data.push(<models::LcsMoData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "v2xData" => intermediate_rep.v2x_data.push(<models::V2xSubscriptionData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lcsBroadcastAssistanceTypesData" => intermediate_rep.lcs_broadcast_assistance_types_data.push(<models::LcsBroadcastAssistanceTypesData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "proseData" => intermediate_rep.prose_data.push(<models::ProseSubscriptionData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "mbsData" => intermediate_rep.mbs_data.push(<models::MbsSubscriptionData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ucData" => intermediate_rep.uc_data.push(<models::UcSubscriptionData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ImmediateReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ImmediateReport {
            am_data: intermediate_rep.am_data.into_iter().next(),
            smf_sel_data: intermediate_rep.smf_sel_data.into_iter().next(),
            uec_amf_data: intermediate_rep.uec_amf_data.into_iter().next(),
            uec_smf_data: intermediate_rep.uec_smf_data.into_iter().next(),
            uec_smsf_data: intermediate_rep.uec_smsf_data.into_iter().next(),
            sms_subs_data: intermediate_rep.sms_subs_data.into_iter().next(),
            sm_data: intermediate_rep.sm_data.into_iter().next(),
            trace_data: std::result::Result::Err(
                "Nullable types not supported in ImmediateReport".to_string(),
            )?,
            sms_mng_data: intermediate_rep.sms_mng_data.into_iter().next(),
            lcs_privacy_data: intermediate_rep.lcs_privacy_data.into_iter().next(),
            lcs_mo_data: intermediate_rep.lcs_mo_data.into_iter().next(),
            v2x_data: intermediate_rep.v2x_data.into_iter().next(),
            lcs_broadcast_assistance_types_data: intermediate_rep
                .lcs_broadcast_assistance_types_data
                .into_iter()
                .next(),
            prose_data: intermediate_rep.prose_data.into_iter().next(),
            mbs_data: intermediate_rep.mbs_data.into_iter().next(),
            uc_data: intermediate_rep.uc_data.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ImmediateReport> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ImmediateReport>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ImmediateReport>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ImmediateReport - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ImmediateReport>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ImmediateReport as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ImmediateReport - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Indicates value of the inner radius.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InnerRadius(i32);

impl std::convert::From<i32> for InnerRadius {
    fn from(x: i32) -> Self {
        InnerRadius(x)
    }
}

impl std::convert::From<InnerRadius> for i32 {
    fn from(x: InnerRadius) -> Self {
        x.0
    }
}

impl std::ops::Deref for InnerRadius {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for InnerRadius {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// Indicates the Inter Frequency Target information.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InterFreqTargetInfo {
    /// Integer value indicating the ARFCN applicable for a downlink, uplink or bi-directional (TDD) NR global frequency raster, as definition of \"ARFCN-ValueNR\" IE in clause 6.3.2 of 3GPP TS 38.331.
    #[serde(rename = "dlCarrierFreq")]
    pub dl_carrier_freq: u32,

    /// When present, this IE shall contain a list of the physical cell identities where the UE is requested to perform measurement logging for the indicated frequency.
    #[serde(rename = "cellIdList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cell_id_list: Option<Vec<models::PhysCellId>>,
}

impl InterFreqTargetInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(dl_carrier_freq: u32) -> InterFreqTargetInfo {
        InterFreqTargetInfo {
            dl_carrier_freq,
            cell_id_list: None,
        }
    }
}

/// Converts the InterFreqTargetInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for InterFreqTargetInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("dlCarrierFreq".to_string()),
            Some(self.dl_carrier_freq.to_string()),
            self.cell_id_list.as_ref().map(|cell_id_list| {
                vec![
                    "cellIdList".to_string(),
                    cell_id_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InterFreqTargetInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InterFreqTargetInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub dl_carrier_freq: Vec<u32>,
            pub cell_id_list: Vec<Vec<models::PhysCellId>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing InterFreqTargetInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "dlCarrierFreq" => intermediate_rep.dl_carrier_freq.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "cellIdList" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in InterFreqTargetInfo"
                            .to_string(),
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing InterFreqTargetInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InterFreqTargetInfo {
            dl_carrier_freq: intermediate_rep
                .dl_carrier_freq
                .into_iter()
                .next()
                .ok_or_else(|| "dlCarrierFreq missing in InterFreqTargetInfo".to_string())?,
            cell_id_list: intermediate_rep.cell_id_list.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InterFreqTargetInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<InterFreqTargetInfo>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<InterFreqTargetInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for InterFreqTargetInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<InterFreqTargetInfo>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <InterFreqTargetInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into InterFreqTargetInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// It contains an invalid parameter and a related description.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InvalidParam {
    /// If the invalid parameter is an attribute in a JSON body, this IE shall contain the  attribute's name and shall be encoded as a JSON Pointer. If the invalid parameter is  an HTTP header, this IE shall be formatted as the concatenation of the string \"header \"  plus the name of such header. If the invalid parameter is a query parameter, this IE  shall be formatted as the concatenation of the string \"query \" plus the name of such  query parameter. If the invalid parameter is a variable part in the path of a resource  URI, this IE shall contain the name of the variable, including the symbols \"{\" and \"}\"  used in OpenAPI specification as the notation to represent variable path segments.
    #[serde(rename = "param")]
    pub param: String,

    /// A human-readable reason, e.g. \"must be a positive integer\". In cases involving failed  operations in a PATCH request, the reason string should identify the operation that  failed using the operation's array index to assist in correlation of the invalid  parameter with the failed operation, e.g.\" Replacement value invalid for attribute  (failed operation index= 4)\"
    #[serde(rename = "reason")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
}

impl InvalidParam {
    #[allow(clippy::new_without_default)]
    pub fn new(param: String) -> InvalidParam {
        InvalidParam {
            param,
            reason: None,
        }
    }
}

/// Converts the InvalidParam value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for InvalidParam {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("param".to_string()),
            Some(self.param.to_string()),
            self.reason
                .as_ref()
                .map(|reason| vec!["reason".to_string(), reason.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InvalidParam value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InvalidParam {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub param: Vec<String>,
            pub reason: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing InvalidParam".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "param" => intermediate_rep.param.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "reason" => intermediate_rep.reason.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing InvalidParam".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InvalidParam {
            param: intermediate_rep
                .param
                .into_iter()
                .next()
                .ok_or_else(|| "param missing in InvalidParam".to_string())?,
            reason: intermediate_rep.reason.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InvalidParam> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<InvalidParam>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<InvalidParam>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for InvalidParam - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<InvalidParam> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <InvalidParam as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into InvalidParam - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains an IP adresse.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IpAddr {
    /// String identifying a IPv4 address formatted in the 'dotted decimal' notation as defined in RFC 1166.
    #[serde(rename = "ipv4Addr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv4_addr: Option<String>,

    #[serde(rename = "ipv6Addr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_addr: Option<models::Ipv6Addr>,

    #[serde(rename = "ipv6Prefix")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_prefix: Option<models::Ipv6Prefix>,
}

impl IpAddr {
    #[allow(clippy::new_without_default)]
    pub fn new() -> IpAddr {
        IpAddr {
            ipv4_addr: None,
            ipv6_addr: None,
            ipv6_prefix: None,
        }
    }
}

/// Converts the IpAddr value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for IpAddr {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.ipv4_addr
                .as_ref()
                .map(|ipv4_addr| vec!["ipv4Addr".to_string(), ipv4_addr.to_string()].join(",")),
            // Skipping ipv6Addr in query parameter serialization

            // Skipping ipv6Prefix in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IpAddr value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IpAddr {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ipv4_addr: Vec<String>,
            pub ipv6_addr: Vec<models::Ipv6Addr>,
            pub ipv6_prefix: Vec<models::Ipv6Prefix>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing IpAddr".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ipv4Addr" => intermediate_rep.ipv4_addr.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ipv6Addr" => intermediate_rep.ipv6_addr.push(
                        <models::Ipv6Addr as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ipv6Prefix" => intermediate_rep.ipv6_prefix.push(
                        <models::Ipv6Prefix as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing IpAddr".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IpAddr {
            ipv4_addr: intermediate_rep.ipv4_addr.into_iter().next(),
            ipv6_addr: intermediate_rep.ipv6_addr.into_iter().next(),
            ipv6_prefix: intermediate_rep.ipv6_prefix.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IpAddr> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<IpAddr>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<IpAddr>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for IpAddr - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<IpAddr> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <IpAddr as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into IpAddr - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IpAddress {
    /// String identifying a IPv4 address formatted in the 'dotted decimal' notation as defined in RFC 1166.
    #[serde(rename = "ipv4Addr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv4_addr: Option<String>,

    #[serde(rename = "ipv6Addr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_addr: Option<models::Ipv6Addr>,

    #[serde(rename = "ipv6Prefix")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipv6_prefix: Option<models::Ipv6Prefix>,
}

impl IpAddress {
    #[allow(clippy::new_without_default)]
    pub fn new() -> IpAddress {
        IpAddress {
            ipv4_addr: None,
            ipv6_addr: None,
            ipv6_prefix: None,
        }
    }
}

/// Converts the IpAddress value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for IpAddress {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.ipv4_addr
                .as_ref()
                .map(|ipv4_addr| vec!["ipv4Addr".to_string(), ipv4_addr.to_string()].join(",")),
            // Skipping ipv6Addr in query parameter serialization

            // Skipping ipv6Prefix in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IpAddress value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IpAddress {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ipv4_addr: Vec<String>,
            pub ipv6_addr: Vec<models::Ipv6Addr>,
            pub ipv6_prefix: Vec<models::Ipv6Prefix>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing IpAddress".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ipv4Addr" => intermediate_rep.ipv4_addr.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ipv6Addr" => intermediate_rep.ipv6_addr.push(
                        <models::Ipv6Addr as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ipv6Prefix" => intermediate_rep.ipv6_prefix.push(
                        <models::Ipv6Prefix as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing IpAddress".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IpAddress {
            ipv4_addr: intermediate_rep.ipv4_addr.into_iter().next(),
            ipv6_addr: intermediate_rep.ipv6_addr.into_iter().next(),
            ipv6_prefix: intermediate_rep.ipv6_prefix.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IpAddress> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<IpAddress>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<IpAddress>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for IpAddress - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<IpAddress> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <IpAddress as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into IpAddress - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Represents the IP Index to be sent from UDM to the SMF (its value can be either an integer or a string)
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IpIndex {}

impl IpIndex {
    #[allow(clippy::new_without_default)]
    pub fn new() -> IpIndex {
        IpIndex {}
    }
}

/// Converts the IpIndex value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for IpIndex {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IpIndex value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IpIndex {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing IpIndex".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing IpIndex".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IpIndex {})
    }
}

// Methods for converting between header::IntoHeaderValue<IpIndex> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<IpIndex>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<IpIndex>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for IpIndex - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<IpIndex> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <IpIndex as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into IpIndex - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// String identifying a IPv4 address formatted in the 'dotted decimal' notation as defined in RFC 1166.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Ipv4Addr(String);

impl std::convert::From<String> for Ipv4Addr {
    fn from(x: String) -> Self {
        Ipv4Addr(x)
    }
}

impl std::string::ToString for Ipv4Addr {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Ipv4Addr {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Ipv4Addr(x.to_string()))
    }
}

impl std::convert::From<Ipv4Addr> for String {
    fn from(x: Ipv4Addr) -> Self {
        x.0
    }
}

impl std::ops::Deref for Ipv4Addr {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Ipv4Addr {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// \"String identifying a IPv4 address mask formatted in the 'dotted decimal' notation as defined in RFC 1166.\"
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Ipv4AddrMask(String);

impl std::convert::From<String> for Ipv4AddrMask {
    fn from(x: String) -> Self {
        Ipv4AddrMask(x)
    }
}

impl std::string::ToString for Ipv4AddrMask {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Ipv4AddrMask {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Ipv4AddrMask(x.to_string()))
    }
}

impl std::convert::From<Ipv4AddrMask> for String {
    fn from(x: Ipv4AddrMask) -> Self {
        x.0
    }
}

impl std::ops::Deref for Ipv4AddrMask {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Ipv4AddrMask {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// String identifying an IPv6 address formatted according to clause 4 of RFC5952. The mixed IPv4 IPv6 notation according to clause 5 of RFC5952 shall not be used.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Ipv6Addr(serde_json::Value);

impl std::convert::From<serde_json::Value> for Ipv6Addr {
    fn from(x: serde_json::Value) -> Self {
        Ipv6Addr(x)
    }
}

impl std::convert::From<Ipv6Addr> for serde_json::Value {
    fn from(x: Ipv6Addr) -> Self {
        x.0
    }
}

impl std::ops::Deref for Ipv6Addr {
    type Target = serde_json::Value;
    fn deref(&self) -> &serde_json::Value {
        &self.0
    }
}

impl std::ops::DerefMut for Ipv6Addr {
    fn deref_mut(&mut self) -> &mut serde_json::Value {
        &mut self.0
    }
}

impl FromStr for Ipv6Addr {
    type Err = serde_json::Error;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(Self(serde_json::from_str(s)?))
    }
}

/// String identifying an IPv6 address prefix formatted according to clause 4 of RFC 5952. IPv6Prefix data type may contain an individual /128 IPv6 address.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Ipv6Prefix(serde_json::Value);

impl std::convert::From<serde_json::Value> for Ipv6Prefix {
    fn from(x: serde_json::Value) -> Self {
        Ipv6Prefix(x)
    }
}

impl std::convert::From<Ipv6Prefix> for serde_json::Value {
    fn from(x: Ipv6Prefix) -> Self {
        x.0
    }
}

impl std::ops::Deref for Ipv6Prefix {
    type Target = serde_json::Value;
    fn deref(&self) -> &serde_json::Value {
        &self.0
    }
}

impl std::ops::DerefMut for Ipv6Prefix {
    fn deref_mut(&mut self) -> &mut serde_json::Value {
        &mut self.0
    }
}

impl FromStr for Ipv6Prefix {
    type Err = serde_json::Error;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(Self(serde_json::from_str(s)?))
    }
}

#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IwkEpsInd(bool);

impl std::convert::From<bool> for IwkEpsInd {
    fn from(x: bool) -> Self {
        IwkEpsInd(x)
    }
}

impl std::convert::From<IwkEpsInd> for bool {
    fn from(x: IwkEpsInd) -> Self {
        x.0
    }
}

impl std::ops::Deref for IwkEpsInd {
    type Target = bool;
    fn deref(&self) -> &bool {
        &self.0
    }
}

impl std::ops::DerefMut for IwkEpsInd {
    fn deref_mut(&mut self) -> &mut bool {
        &mut self.0
    }
}

/// The enumeration JobType defines Job Type in the trace. See 3GPP TS 32.422 for further  description of the values. It shall comply with the provisions defined in table 5.6.3.3-1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct JobType {}

impl JobType {
    #[allow(clippy::new_without_default)]
    pub fn new() -> JobType {
        JobType {}
    }
}

/// Converts the JobType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for JobType {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a JobType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for JobType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing JobType".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing JobType".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(JobType {})
    }
}

// Methods for converting between header::IntoHeaderValue<JobType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<JobType>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<JobType>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for JobType - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<JobType> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <JobType as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into JobType - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum JobTypeAnyOf {
    #[serde(rename = "IMMEDIATE_MDT_ONLY")]
    ImmediateMdtOnly,
    #[serde(rename = "LOGGED_MDT_ONLY")]
    LoggedMdtOnly,
    #[serde(rename = "TRACE_ONLY")]
    TraceOnly,
    #[serde(rename = "IMMEDIATE_MDT_AND_TRACE")]
    ImmediateMdtAndTrace,
    #[serde(rename = "RLF_REPORTS_ONLY")]
    RlfReportsOnly,
    #[serde(rename = "RCEF_REPORTS_ONLY")]
    RcefReportsOnly,
    #[serde(rename = "LOGGED_MBSFN_MDT")]
    LoggedMbsfnMdt,
}

impl std::fmt::Display for JobTypeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            JobTypeAnyOf::ImmediateMdtOnly => write!(f, "IMMEDIATE_MDT_ONLY"),
            JobTypeAnyOf::LoggedMdtOnly => write!(f, "LOGGED_MDT_ONLY"),
            JobTypeAnyOf::TraceOnly => write!(f, "TRACE_ONLY"),
            JobTypeAnyOf::ImmediateMdtAndTrace => write!(f, "IMMEDIATE_MDT_AND_TRACE"),
            JobTypeAnyOf::RlfReportsOnly => write!(f, "RLF_REPORTS_ONLY"),
            JobTypeAnyOf::RcefReportsOnly => write!(f, "RCEF_REPORTS_ONLY"),
            JobTypeAnyOf::LoggedMbsfnMdt => write!(f, "LOGGED_MBSFN_MDT"),
        }
    }
}

impl std::str::FromStr for JobTypeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "IMMEDIATE_MDT_ONLY" => std::result::Result::Ok(JobTypeAnyOf::ImmediateMdtOnly),
            "LOGGED_MDT_ONLY" => std::result::Result::Ok(JobTypeAnyOf::LoggedMdtOnly),
            "TRACE_ONLY" => std::result::Result::Ok(JobTypeAnyOf::TraceOnly),
            "IMMEDIATE_MDT_AND_TRACE" => {
                std::result::Result::Ok(JobTypeAnyOf::ImmediateMdtAndTrace)
            }
            "RLF_REPORTS_ONLY" => std::result::Result::Ok(JobTypeAnyOf::RlfReportsOnly),
            "RCEF_REPORTS_ONLY" => std::result::Result::Ok(JobTypeAnyOf::RcefReportsOnly),
            "LOGGED_MBSFN_MDT" => std::result::Result::Ok(JobTypeAnyOf::LoggedMbsfnMdt),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LboRoamingAllowed(bool);

impl std::convert::From<bool> for LboRoamingAllowed {
    fn from(x: bool) -> Self {
        LboRoamingAllowed(x)
    }
}

impl std::convert::From<LboRoamingAllowed> for bool {
    fn from(x: LboRoamingAllowed) -> Self {
        x.0
    }
}

impl std::ops::Deref for LboRoamingAllowed {
    type Target = bool;
    fn deref(&self) -> &bool {
        &self.0
    }
}

impl std::ops::DerefMut for LboRoamingAllowed {
    fn deref_mut(&mut self) -> &mut bool {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LcsBroadcastAssistanceTypesData {
    /// string with format 'binary' as defined in OpenAPI.
    #[serde(rename = "locationAssistanceType")]
    pub location_assistance_type: swagger::ByteArray,
}

impl LcsBroadcastAssistanceTypesData {
    #[allow(clippy::new_without_default)]
    pub fn new(location_assistance_type: swagger::ByteArray) -> LcsBroadcastAssistanceTypesData {
        LcsBroadcastAssistanceTypesData {
            location_assistance_type,
        }
    }
}

/// Converts the LcsBroadcastAssistanceTypesData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for LcsBroadcastAssistanceTypesData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping locationAssistanceType in query parameter serialization
            // Skipping locationAssistanceType in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LcsBroadcastAssistanceTypesData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LcsBroadcastAssistanceTypesData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub location_assistance_type: Vec<swagger::ByteArray>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing LcsBroadcastAssistanceTypesData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "locationAssistanceType" => return std::result::Result::Err("Parsing binary data in this style is not supported in LcsBroadcastAssistanceTypesData".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing LcsBroadcastAssistanceTypesData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LcsBroadcastAssistanceTypesData {
            location_assistance_type: intermediate_rep
                .location_assistance_type
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "locationAssistanceType missing in LcsBroadcastAssistanceTypesData".to_string()
                })?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LcsBroadcastAssistanceTypesData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<LcsBroadcastAssistanceTypesData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<LcsBroadcastAssistanceTypesData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LcsBroadcastAssistanceTypesData - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<LcsBroadcastAssistanceTypesData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LcsBroadcastAssistanceTypesData as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LcsBroadcastAssistanceTypesData - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LcsClientClass {}

impl LcsClientClass {
    #[allow(clippy::new_without_default)]
    pub fn new() -> LcsClientClass {
        LcsClientClass {}
    }
}

/// Converts the LcsClientClass value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for LcsClientClass {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LcsClientClass value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LcsClientClass {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing LcsClientClass".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing LcsClientClass".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LcsClientClass {})
    }
}

// Methods for converting between header::IntoHeaderValue<LcsClientClass> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<LcsClientClass>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<LcsClientClass>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for LcsClientClass - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<LcsClientClass> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <LcsClientClass as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into LcsClientClass - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum LcsClientClassAnyOf {
    #[serde(rename = "BROADCAST_SERVICE")]
    BroadcastService,
    #[serde(rename = "OM_IN_HPLMN")]
    OmInHplmn,
    #[serde(rename = "OM_IN_VPLMN")]
    OmInVplmn,
    #[serde(rename = "ANONYMOUS_LOCATION_SERVICE")]
    AnonymousLocationService,
    #[serde(rename = "SPECIFIC_SERVICE")]
    SpecificService,
}

impl std::fmt::Display for LcsClientClassAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            LcsClientClassAnyOf::BroadcastService => write!(f, "BROADCAST_SERVICE"),
            LcsClientClassAnyOf::OmInHplmn => write!(f, "OM_IN_HPLMN"),
            LcsClientClassAnyOf::OmInVplmn => write!(f, "OM_IN_VPLMN"),
            LcsClientClassAnyOf::AnonymousLocationService => {
                write!(f, "ANONYMOUS_LOCATION_SERVICE")
            }
            LcsClientClassAnyOf::SpecificService => write!(f, "SPECIFIC_SERVICE"),
        }
    }
}

impl std::str::FromStr for LcsClientClassAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "BROADCAST_SERVICE" => std::result::Result::Ok(LcsClientClassAnyOf::BroadcastService),
            "OM_IN_HPLMN" => std::result::Result::Ok(LcsClientClassAnyOf::OmInHplmn),
            "OM_IN_VPLMN" => std::result::Result::Ok(LcsClientClassAnyOf::OmInVplmn),
            "ANONYMOUS_LOCATION_SERVICE" => {
                std::result::Result::Ok(LcsClientClassAnyOf::AnonymousLocationService)
            }
            "SPECIFIC_SERVICE" => std::result::Result::Ok(LcsClientClassAnyOf::SpecificService),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LcsClientExternal {
    #[serde(rename = "allowedGeographicArea")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allowed_geographic_area: Option<Vec<models::GeographicArea>>,

    #[serde(rename = "privacyCheckRelatedAction")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub privacy_check_related_action: Option<models::PrivacyCheckRelatedAction>,

    #[serde(rename = "validTimePeriod")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub valid_time_period: Option<models::ValidTimePeriod>,
}

impl LcsClientExternal {
    #[allow(clippy::new_without_default)]
    pub fn new() -> LcsClientExternal {
        LcsClientExternal {
            allowed_geographic_area: None,
            privacy_check_related_action: None,
            valid_time_period: None,
        }
    }
}

/// Converts the LcsClientExternal value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for LcsClientExternal {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping allowedGeographicArea in query parameter serialization

            // Skipping privacyCheckRelatedAction in query parameter serialization

            // Skipping validTimePeriod in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LcsClientExternal value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LcsClientExternal {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub allowed_geographic_area: Vec<Vec<models::GeographicArea>>,
            pub privacy_check_related_action: Vec<models::PrivacyCheckRelatedAction>,
            pub valid_time_period: Vec<models::ValidTimePeriod>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing LcsClientExternal".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "allowedGeographicArea" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in LcsClientExternal"
                            .to_string(),
                    ),
                    #[allow(clippy::redundant_clone)]
                    "privacyCheckRelatedAction" => {
                        intermediate_rep.privacy_check_related_action.push(
                            <models::PrivacyCheckRelatedAction as std::str::FromStr>::from_str(val)
                                .map_err(|x| x.to_string())?,
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "validTimePeriod" => intermediate_rep.valid_time_period.push(
                        <models::ValidTimePeriod as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing LcsClientExternal".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LcsClientExternal {
            allowed_geographic_area: intermediate_rep.allowed_geographic_area.into_iter().next(),
            privacy_check_related_action: intermediate_rep
                .privacy_check_related_action
                .into_iter()
                .next(),
            valid_time_period: intermediate_rep.valid_time_period.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LcsClientExternal> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<LcsClientExternal>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<LcsClientExternal>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for LcsClientExternal - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<LcsClientExternal>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <LcsClientExternal as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into LcsClientExternal - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LcsClientGroupExternal {
    #[serde(rename = "lcsClientGroupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lcs_client_group_id: Option<String>,

    #[serde(rename = "allowedGeographicArea")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allowed_geographic_area: Option<Vec<models::GeographicArea>>,

    #[serde(rename = "privacyCheckRelatedAction")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub privacy_check_related_action: Option<models::PrivacyCheckRelatedAction>,

    #[serde(rename = "validTimePeriod")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub valid_time_period: Option<models::ValidTimePeriod>,
}

impl LcsClientGroupExternal {
    #[allow(clippy::new_without_default)]
    pub fn new() -> LcsClientGroupExternal {
        LcsClientGroupExternal {
            lcs_client_group_id: None,
            allowed_geographic_area: None,
            privacy_check_related_action: None,
            valid_time_period: None,
        }
    }
}

/// Converts the LcsClientGroupExternal value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for LcsClientGroupExternal {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.lcs_client_group_id
                .as_ref()
                .map(|lcs_client_group_id| {
                    vec![
                        "lcsClientGroupId".to_string(),
                        lcs_client_group_id.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping allowedGeographicArea in query parameter serialization

            // Skipping privacyCheckRelatedAction in query parameter serialization

            // Skipping validTimePeriod in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LcsClientGroupExternal value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LcsClientGroupExternal {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub lcs_client_group_id: Vec<String>,
            pub allowed_geographic_area: Vec<Vec<models::GeographicArea>>,
            pub privacy_check_related_action: Vec<models::PrivacyCheckRelatedAction>,
            pub valid_time_period: Vec<models::ValidTimePeriod>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing LcsClientGroupExternal".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "lcsClientGroupId" => intermediate_rep.lcs_client_group_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "allowedGeographicArea" => return std::result::Result::Err("Parsing a container in this style is not supported in LcsClientGroupExternal".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "privacyCheckRelatedAction" => intermediate_rep.privacy_check_related_action.push(<models::PrivacyCheckRelatedAction as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "validTimePeriod" => intermediate_rep.valid_time_period.push(<models::ValidTimePeriod as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LcsClientGroupExternal".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LcsClientGroupExternal {
            lcs_client_group_id: intermediate_rep.lcs_client_group_id.into_iter().next(),
            allowed_geographic_area: intermediate_rep.allowed_geographic_area.into_iter().next(),
            privacy_check_related_action: intermediate_rep
                .privacy_check_related_action
                .into_iter()
                .next(),
            valid_time_period: intermediate_rep.valid_time_period.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LcsClientGroupExternal> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<LcsClientGroupExternal>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<LcsClientGroupExternal>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for LcsClientGroupExternal - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<LcsClientGroupExternal>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <LcsClientGroupExternal as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into LcsClientGroupExternal - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LcsClientId(String);

impl std::convert::From<String> for LcsClientId {
    fn from(x: String) -> Self {
        LcsClientId(x)
    }
}

impl std::string::ToString for LcsClientId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for LcsClientId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(LcsClientId(x.to_string()))
    }
}

impl std::convert::From<LcsClientId> for String {
    fn from(x: LcsClientId) -> Self {
        x.0
    }
}

impl std::ops::Deref for LcsClientId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for LcsClientId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LcsMoData {
    #[serde(rename = "allowedServiceClasses")]
    pub allowed_service_classes: Vec<models::LcsMoServiceClass>,

    #[serde(rename = "moAssistanceDataTypes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mo_assistance_data_types: Option<models::LcsBroadcastAssistanceTypesData>,
}

impl LcsMoData {
    #[allow(clippy::new_without_default)]
    pub fn new(allowed_service_classes: Vec<models::LcsMoServiceClass>) -> LcsMoData {
        LcsMoData {
            allowed_service_classes,
            mo_assistance_data_types: None,
        }
    }
}

/// Converts the LcsMoData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for LcsMoData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping allowedServiceClasses in query parameter serialization

            // Skipping moAssistanceDataTypes in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LcsMoData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LcsMoData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub allowed_service_classes: Vec<Vec<models::LcsMoServiceClass>>,
            pub mo_assistance_data_types: Vec<models::LcsBroadcastAssistanceTypesData>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing LcsMoData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "allowedServiceClasses" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in LcsMoData"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "moAssistanceDataTypes" => intermediate_rep.mo_assistance_data_types.push(
                        <models::LcsBroadcastAssistanceTypesData as std::str::FromStr>::from_str(
                            val,
                        )
                        .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing LcsMoData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LcsMoData {
            allowed_service_classes: intermediate_rep
                .allowed_service_classes
                .into_iter()
                .next()
                .ok_or_else(|| "allowedServiceClasses missing in LcsMoData".to_string())?,
            mo_assistance_data_types: intermediate_rep.mo_assistance_data_types.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LcsMoData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<LcsMoData>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<LcsMoData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for LcsMoData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<LcsMoData> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <LcsMoData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into LcsMoData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LcsMoServiceClass {}

impl LcsMoServiceClass {
    #[allow(clippy::new_without_default)]
    pub fn new() -> LcsMoServiceClass {
        LcsMoServiceClass {}
    }
}

/// Converts the LcsMoServiceClass value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for LcsMoServiceClass {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LcsMoServiceClass value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LcsMoServiceClass {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing LcsMoServiceClass".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing LcsMoServiceClass".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LcsMoServiceClass {})
    }
}

// Methods for converting between header::IntoHeaderValue<LcsMoServiceClass> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<LcsMoServiceClass>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<LcsMoServiceClass>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for LcsMoServiceClass - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<LcsMoServiceClass>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <LcsMoServiceClass as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into LcsMoServiceClass - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum LcsMoServiceClassAnyOf {
    #[serde(rename = "BASIC_SELF_LOCATION")]
    BasicSelfLocation,
    #[serde(rename = "AUTONOMOUS_SELF_LOCATION")]
    AutonomousSelfLocation,
    #[serde(rename = "TRANSFER_TO_THIRD_PARTY")]
    TransferToThirdParty,
}

impl std::fmt::Display for LcsMoServiceClassAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            LcsMoServiceClassAnyOf::BasicSelfLocation => write!(f, "BASIC_SELF_LOCATION"),
            LcsMoServiceClassAnyOf::AutonomousSelfLocation => write!(f, "AUTONOMOUS_SELF_LOCATION"),
            LcsMoServiceClassAnyOf::TransferToThirdParty => write!(f, "TRANSFER_TO_THIRD_PARTY"),
        }
    }
}

impl std::str::FromStr for LcsMoServiceClassAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "BASIC_SELF_LOCATION" => {
                std::result::Result::Ok(LcsMoServiceClassAnyOf::BasicSelfLocation)
            }
            "AUTONOMOUS_SELF_LOCATION" => {
                std::result::Result::Ok(LcsMoServiceClassAnyOf::AutonomousSelfLocation)
            }
            "TRANSFER_TO_THIRD_PARTY" => {
                std::result::Result::Ok(LcsMoServiceClassAnyOf::TransferToThirdParty)
            }
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LcsPrivacyData {
    #[serde(rename = "lpi")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lpi: Option<models::Lpi>,

    #[serde(rename = "unrelatedClass")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unrelated_class: Option<models::UnrelatedClass>,

    #[serde(rename = "plmnOperatorClasses")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub plmn_operator_classes: Option<Vec<models::PlmnOperatorClass>>,
}

impl LcsPrivacyData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> LcsPrivacyData {
        LcsPrivacyData {
            lpi: None,
            unrelated_class: None,
            plmn_operator_classes: None,
        }
    }
}

/// Converts the LcsPrivacyData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for LcsPrivacyData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping lpi in query parameter serialization

            // Skipping unrelatedClass in query parameter serialization

            // Skipping plmnOperatorClasses in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LcsPrivacyData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LcsPrivacyData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub lpi: Vec<models::Lpi>,
            pub unrelated_class: Vec<models::UnrelatedClass>,
            pub plmn_operator_classes: Vec<Vec<models::PlmnOperatorClass>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing LcsPrivacyData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "lpi" => intermediate_rep.lpi.push(
                        <models::Lpi as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "unrelatedClass" => intermediate_rep.unrelated_class.push(
                        <models::UnrelatedClass as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "plmnOperatorClasses" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in LcsPrivacyData"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing LcsPrivacyData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LcsPrivacyData {
            lpi: intermediate_rep.lpi.into_iter().next(),
            unrelated_class: intermediate_rep.unrelated_class.into_iter().next(),
            plmn_operator_classes: intermediate_rep.plmn_operator_classes.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LcsPrivacyData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<LcsPrivacyData>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<LcsPrivacyData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for LcsPrivacyData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<LcsPrivacyData> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <LcsPrivacyData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into LcsPrivacyData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// LCS service type.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LcsServiceType(i32);

impl std::convert::From<i32> for LcsServiceType {
    fn from(x: i32) -> Self {
        LcsServiceType(x)
    }
}

impl std::convert::From<LcsServiceType> for i32 {
    fn from(x: LcsServiceType) -> Self {
        x.0
    }
}

impl std::ops::Deref for LcsServiceType {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for LcsServiceType {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// Local 2D point with uncertainty ellipse
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Local2dPointUncertaintyEllipse {
    #[serde(rename = "shape")]
    pub shape: models::SupportedGadShapes,

    #[serde(rename = "localOrigin")]
    pub local_origin: models::LocalOrigin,

    #[serde(rename = "point")]
    pub point: models::RelativeCartesianLocation,

    #[serde(rename = "uncertaintyEllipse")]
    pub uncertainty_ellipse: models::UncertaintyEllipse,

    /// Indicates value of confidence.
    #[serde(rename = "confidence")]
    pub confidence: u8,
}

impl Local2dPointUncertaintyEllipse {
    #[allow(clippy::new_without_default)]
    pub fn new(
        shape: models::SupportedGadShapes,
        local_origin: models::LocalOrigin,
        point: models::RelativeCartesianLocation,
        uncertainty_ellipse: models::UncertaintyEllipse,
        confidence: u8,
    ) -> Local2dPointUncertaintyEllipse {
        Local2dPointUncertaintyEllipse {
            shape,
            local_origin,
            point,
            uncertainty_ellipse,
            confidence,
        }
    }
}

/// Converts the Local2dPointUncertaintyEllipse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Local2dPointUncertaintyEllipse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping shape in query parameter serialization

            // Skipping localOrigin in query parameter serialization

            // Skipping point in query parameter serialization

            // Skipping uncertaintyEllipse in query parameter serialization
            Some("confidence".to_string()),
            Some(self.confidence.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Local2dPointUncertaintyEllipse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Local2dPointUncertaintyEllipse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub shape: Vec<models::SupportedGadShapes>,
            pub local_origin: Vec<models::LocalOrigin>,
            pub point: Vec<models::RelativeCartesianLocation>,
            pub uncertainty_ellipse: Vec<models::UncertaintyEllipse>,
            pub confidence: Vec<u8>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Local2dPointUncertaintyEllipse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "shape" => intermediate_rep.shape.push(
                        <models::SupportedGadShapes as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "localOrigin" => intermediate_rep.local_origin.push(
                        <models::LocalOrigin as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "point" => intermediate_rep.point.push(
                        <models::RelativeCartesianLocation as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "uncertaintyEllipse" => intermediate_rep.uncertainty_ellipse.push(
                        <models::UncertaintyEllipse as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "confidence" => intermediate_rep
                        .confidence
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Local2dPointUncertaintyEllipse"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Local2dPointUncertaintyEllipse {
            shape: intermediate_rep
                .shape
                .into_iter()
                .next()
                .ok_or_else(|| "shape missing in Local2dPointUncertaintyEllipse".to_string())?,
            local_origin: intermediate_rep
                .local_origin
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "localOrigin missing in Local2dPointUncertaintyEllipse".to_string()
                })?,
            point: intermediate_rep
                .point
                .into_iter()
                .next()
                .ok_or_else(|| "point missing in Local2dPointUncertaintyEllipse".to_string())?,
            uncertainty_ellipse: intermediate_rep
                .uncertainty_ellipse
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "uncertaintyEllipse missing in Local2dPointUncertaintyEllipse".to_string()
                })?,
            confidence: intermediate_rep
                .confidence
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "confidence missing in Local2dPointUncertaintyEllipse".to_string()
                })?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Local2dPointUncertaintyEllipse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Local2dPointUncertaintyEllipse>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Local2dPointUncertaintyEllipse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Local2dPointUncertaintyEllipse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<Local2dPointUncertaintyEllipse>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Local2dPointUncertaintyEllipse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Local2dPointUncertaintyEllipse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Local2dPointUncertaintyEllipseAllOf {
    #[serde(rename = "localOrigin")]
    pub local_origin: models::LocalOrigin,

    #[serde(rename = "point")]
    pub point: models::RelativeCartesianLocation,

    #[serde(rename = "uncertaintyEllipse")]
    pub uncertainty_ellipse: models::UncertaintyEllipse,

    /// Indicates value of confidence.
    #[serde(rename = "confidence")]
    pub confidence: u8,
}

impl Local2dPointUncertaintyEllipseAllOf {
    #[allow(clippy::new_without_default)]
    pub fn new(
        local_origin: models::LocalOrigin,
        point: models::RelativeCartesianLocation,
        uncertainty_ellipse: models::UncertaintyEllipse,
        confidence: u8,
    ) -> Local2dPointUncertaintyEllipseAllOf {
        Local2dPointUncertaintyEllipseAllOf {
            local_origin,
            point,
            uncertainty_ellipse,
            confidence,
        }
    }
}

/// Converts the Local2dPointUncertaintyEllipseAllOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Local2dPointUncertaintyEllipseAllOf {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping localOrigin in query parameter serialization

            // Skipping point in query parameter serialization

            // Skipping uncertaintyEllipse in query parameter serialization
            Some("confidence".to_string()),
            Some(self.confidence.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Local2dPointUncertaintyEllipseAllOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Local2dPointUncertaintyEllipseAllOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub local_origin: Vec<models::LocalOrigin>,
            pub point: Vec<models::RelativeCartesianLocation>,
            pub uncertainty_ellipse: Vec<models::UncertaintyEllipse>,
            pub confidence: Vec<u8>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Local2dPointUncertaintyEllipseAllOf"
                            .to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "localOrigin" => intermediate_rep.local_origin.push(
                        <models::LocalOrigin as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "point" => intermediate_rep.point.push(
                        <models::RelativeCartesianLocation as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "uncertaintyEllipse" => intermediate_rep.uncertainty_ellipse.push(
                        <models::UncertaintyEllipse as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "confidence" => intermediate_rep
                        .confidence
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Local2dPointUncertaintyEllipseAllOf"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Local2dPointUncertaintyEllipseAllOf {
            local_origin: intermediate_rep
                .local_origin
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "localOrigin missing in Local2dPointUncertaintyEllipseAllOf".to_string()
                })?,
            point: intermediate_rep.point.into_iter().next().ok_or_else(|| {
                "point missing in Local2dPointUncertaintyEllipseAllOf".to_string()
            })?,
            uncertainty_ellipse: intermediate_rep
                .uncertainty_ellipse
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "uncertaintyEllipse missing in Local2dPointUncertaintyEllipseAllOf".to_string()
                })?,
            confidence: intermediate_rep
                .confidence
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "confidence missing in Local2dPointUncertaintyEllipseAllOf".to_string()
                })?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Local2dPointUncertaintyEllipseAllOf> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Local2dPointUncertaintyEllipseAllOf>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Local2dPointUncertaintyEllipseAllOf>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Local2dPointUncertaintyEllipseAllOf - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<Local2dPointUncertaintyEllipseAllOf>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Local2dPointUncertaintyEllipseAllOf as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Local2dPointUncertaintyEllipseAllOf - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

/// Local 3D point with uncertainty ellipsoid
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Local3dPointUncertaintyEllipsoid {
    #[serde(rename = "shape")]
    pub shape: models::SupportedGadShapes,

    #[serde(rename = "localOrigin")]
    pub local_origin: models::LocalOrigin,

    #[serde(rename = "point")]
    pub point: models::RelativeCartesianLocation,

    #[serde(rename = "uncertaintyEllipsoid")]
    pub uncertainty_ellipsoid: models::UncertaintyEllipsoid,

    /// Indicates value of confidence.
    #[serde(rename = "confidence")]
    pub confidence: u8,
}

impl Local3dPointUncertaintyEllipsoid {
    #[allow(clippy::new_without_default)]
    pub fn new(
        shape: models::SupportedGadShapes,
        local_origin: models::LocalOrigin,
        point: models::RelativeCartesianLocation,
        uncertainty_ellipsoid: models::UncertaintyEllipsoid,
        confidence: u8,
    ) -> Local3dPointUncertaintyEllipsoid {
        Local3dPointUncertaintyEllipsoid {
            shape,
            local_origin,
            point,
            uncertainty_ellipsoid,
            confidence,
        }
    }
}

/// Converts the Local3dPointUncertaintyEllipsoid value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Local3dPointUncertaintyEllipsoid {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping shape in query parameter serialization

            // Skipping localOrigin in query parameter serialization

            // Skipping point in query parameter serialization

            // Skipping uncertaintyEllipsoid in query parameter serialization
            Some("confidence".to_string()),
            Some(self.confidence.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Local3dPointUncertaintyEllipsoid value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Local3dPointUncertaintyEllipsoid {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub shape: Vec<models::SupportedGadShapes>,
            pub local_origin: Vec<models::LocalOrigin>,
            pub point: Vec<models::RelativeCartesianLocation>,
            pub uncertainty_ellipsoid: Vec<models::UncertaintyEllipsoid>,
            pub confidence: Vec<u8>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Local3dPointUncertaintyEllipsoid".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "shape" => intermediate_rep.shape.push(
                        <models::SupportedGadShapes as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "localOrigin" => intermediate_rep.local_origin.push(
                        <models::LocalOrigin as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "point" => intermediate_rep.point.push(
                        <models::RelativeCartesianLocation as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "uncertaintyEllipsoid" => intermediate_rep.uncertainty_ellipsoid.push(
                        <models::UncertaintyEllipsoid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "confidence" => intermediate_rep
                        .confidence
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Local3dPointUncertaintyEllipsoid"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Local3dPointUncertaintyEllipsoid {
            shape: intermediate_rep
                .shape
                .into_iter()
                .next()
                .ok_or_else(|| "shape missing in Local3dPointUncertaintyEllipsoid".to_string())?,
            local_origin: intermediate_rep
                .local_origin
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "localOrigin missing in Local3dPointUncertaintyEllipsoid".to_string()
                })?,
            point: intermediate_rep
                .point
                .into_iter()
                .next()
                .ok_or_else(|| "point missing in Local3dPointUncertaintyEllipsoid".to_string())?,
            uncertainty_ellipsoid: intermediate_rep
                .uncertainty_ellipsoid
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "uncertaintyEllipsoid missing in Local3dPointUncertaintyEllipsoid".to_string()
                })?,
            confidence: intermediate_rep
                .confidence
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "confidence missing in Local3dPointUncertaintyEllipsoid".to_string()
                })?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Local3dPointUncertaintyEllipsoid> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Local3dPointUncertaintyEllipsoid>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Local3dPointUncertaintyEllipsoid>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Local3dPointUncertaintyEllipsoid - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<Local3dPointUncertaintyEllipsoid>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Local3dPointUncertaintyEllipsoid as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Local3dPointUncertaintyEllipsoid - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Local3dPointUncertaintyEllipsoidAllOf {
    #[serde(rename = "localOrigin")]
    pub local_origin: models::LocalOrigin,

    #[serde(rename = "point")]
    pub point: models::RelativeCartesianLocation,

    #[serde(rename = "uncertaintyEllipsoid")]
    pub uncertainty_ellipsoid: models::UncertaintyEllipsoid,

    /// Indicates value of confidence.
    #[serde(rename = "confidence")]
    pub confidence: u8,
}

impl Local3dPointUncertaintyEllipsoidAllOf {
    #[allow(clippy::new_without_default)]
    pub fn new(
        local_origin: models::LocalOrigin,
        point: models::RelativeCartesianLocation,
        uncertainty_ellipsoid: models::UncertaintyEllipsoid,
        confidence: u8,
    ) -> Local3dPointUncertaintyEllipsoidAllOf {
        Local3dPointUncertaintyEllipsoidAllOf {
            local_origin,
            point,
            uncertainty_ellipsoid,
            confidence,
        }
    }
}

/// Converts the Local3dPointUncertaintyEllipsoidAllOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Local3dPointUncertaintyEllipsoidAllOf {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping localOrigin in query parameter serialization

            // Skipping point in query parameter serialization

            // Skipping uncertaintyEllipsoid in query parameter serialization
            Some("confidence".to_string()),
            Some(self.confidence.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Local3dPointUncertaintyEllipsoidAllOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Local3dPointUncertaintyEllipsoidAllOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub local_origin: Vec<models::LocalOrigin>,
            pub point: Vec<models::RelativeCartesianLocation>,
            pub uncertainty_ellipsoid: Vec<models::UncertaintyEllipsoid>,
            pub confidence: Vec<u8>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Local3dPointUncertaintyEllipsoidAllOf"
                            .to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "localOrigin" => intermediate_rep.local_origin.push(
                        <models::LocalOrigin as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "point" => intermediate_rep.point.push(
                        <models::RelativeCartesianLocation as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "uncertaintyEllipsoid" => intermediate_rep.uncertainty_ellipsoid.push(
                        <models::UncertaintyEllipsoid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "confidence" => intermediate_rep
                        .confidence
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Local3dPointUncertaintyEllipsoidAllOf"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Local3dPointUncertaintyEllipsoidAllOf {
            local_origin: intermediate_rep
                .local_origin
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "localOrigin missing in Local3dPointUncertaintyEllipsoidAllOf".to_string()
                })?,
            point: intermediate_rep.point.into_iter().next().ok_or_else(|| {
                "point missing in Local3dPointUncertaintyEllipsoidAllOf".to_string()
            })?,
            uncertainty_ellipsoid: intermediate_rep
                .uncertainty_ellipsoid
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "uncertaintyEllipsoid missing in Local3dPointUncertaintyEllipsoidAllOf"
                        .to_string()
                })?,
            confidence: intermediate_rep
                .confidence
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "confidence missing in Local3dPointUncertaintyEllipsoidAllOf".to_string()
                })?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Local3dPointUncertaintyEllipsoidAllOf> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Local3dPointUncertaintyEllipsoidAllOf>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Local3dPointUncertaintyEllipsoidAllOf>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Local3dPointUncertaintyEllipsoidAllOf - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<Local3dPointUncertaintyEllipsoidAllOf>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Local3dPointUncertaintyEllipsoidAllOf as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Local3dPointUncertaintyEllipsoidAllOf - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

/// Indicates a Local origin in a reference system
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LocalOrigin {
    #[serde(rename = "coordinateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub coordinate_id: Option<String>,

    #[serde(rename = "point")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub point: Option<models::GeographicalCoordinates>,
}

impl LocalOrigin {
    #[allow(clippy::new_without_default)]
    pub fn new() -> LocalOrigin {
        LocalOrigin {
            coordinate_id: None,
            point: None,
        }
    }
}

/// Converts the LocalOrigin value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for LocalOrigin {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.coordinate_id.as_ref().map(|coordinate_id| {
                vec!["coordinateId".to_string(), coordinate_id.to_string()].join(",")
            }),
            // Skipping point in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LocalOrigin value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LocalOrigin {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub coordinate_id: Vec<String>,
            pub point: Vec<models::GeographicalCoordinates>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing LocalOrigin".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "coordinateId" => intermediate_rep.coordinate_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "point" => intermediate_rep.point.push(
                        <models::GeographicalCoordinates as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing LocalOrigin".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LocalOrigin {
            coordinate_id: intermediate_rep.coordinate_id.into_iter().next(),
            point: intermediate_rep.point.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LocalOrigin> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<LocalOrigin>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<LocalOrigin>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for LocalOrigin - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<LocalOrigin> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <LocalOrigin as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into LocalOrigin - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LocationArea {
    /// Identifies a list of geographic area of the user where the UE is located.
    #[serde(rename = "geographicAreas")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub geographic_areas: Option<Vec<models::GeographicArea>>,

    /// Identifies a list of civic addresses of the user where the UE is located.
    #[serde(rename = "civicAddresses")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub civic_addresses: Option<Vec<models::CivicAddress>>,

    #[serde(rename = "nwAreaInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nw_area_info: Option<models::NetworkAreaInfo>,

    #[serde(rename = "umtTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub umt_time: Option<models::UmtTime>,
}

impl LocationArea {
    #[allow(clippy::new_without_default)]
    pub fn new() -> LocationArea {
        LocationArea {
            geographic_areas: None,
            civic_addresses: None,
            nw_area_info: None,
            umt_time: None,
        }
    }
}

/// Converts the LocationArea value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for LocationArea {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping geographicAreas in query parameter serialization

            // Skipping civicAddresses in query parameter serialization

            // Skipping nwAreaInfo in query parameter serialization

            // Skipping umtTime in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LocationArea value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LocationArea {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub geographic_areas: Vec<Vec<models::GeographicArea>>,
            pub civic_addresses: Vec<Vec<models::CivicAddress>>,
            pub nw_area_info: Vec<models::NetworkAreaInfo>,
            pub umt_time: Vec<models::UmtTime>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing LocationArea".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "geographicAreas" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in LocationArea"
                                .to_string(),
                        )
                    }
                    "civicAddresses" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in LocationArea"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "nwAreaInfo" => intermediate_rep.nw_area_info.push(
                        <models::NetworkAreaInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "umtTime" => intermediate_rep.umt_time.push(
                        <models::UmtTime as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing LocationArea".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LocationArea {
            geographic_areas: intermediate_rep.geographic_areas.into_iter().next(),
            civic_addresses: intermediate_rep.civic_addresses.into_iter().next(),
            nw_area_info: intermediate_rep.nw_area_info.into_iter().next(),
            umt_time: intermediate_rep.umt_time.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LocationArea> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<LocationArea>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<LocationArea>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for LocationArea - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<LocationArea> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <LocationArea as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into LocationArea - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LocationPrivacyInd {}

impl LocationPrivacyInd {
    #[allow(clippy::new_without_default)]
    pub fn new() -> LocationPrivacyInd {
        LocationPrivacyInd {}
    }
}

/// Converts the LocationPrivacyInd value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for LocationPrivacyInd {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LocationPrivacyInd value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LocationPrivacyInd {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing LocationPrivacyInd".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing LocationPrivacyInd".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LocationPrivacyInd {})
    }
}

// Methods for converting between header::IntoHeaderValue<LocationPrivacyInd> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<LocationPrivacyInd>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<LocationPrivacyInd>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for LocationPrivacyInd - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<LocationPrivacyInd>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <LocationPrivacyInd as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into LocationPrivacyInd - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum LocationPrivacyIndAnyOf {
    #[serde(rename = "LOCATION_DISALLOWED")]
    Disallowed,
    #[serde(rename = "LOCATION_ALLOWED")]
    Allowed,
}

impl std::fmt::Display for LocationPrivacyIndAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            LocationPrivacyIndAnyOf::Disallowed => write!(f, "LOCATION_DISALLOWED"),
            LocationPrivacyIndAnyOf::Allowed => write!(f, "LOCATION_ALLOWED"),
        }
    }
}

impl std::str::FromStr for LocationPrivacyIndAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "LOCATION_DISALLOWED" => std::result::Result::Ok(LocationPrivacyIndAnyOf::Disallowed),
            "LOCATION_ALLOWED" => std::result::Result::Ok(LocationPrivacyIndAnyOf::Allowed),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// The enumeration LoggingIntervalMdt defines Logging Interval for MDT in the trace. See 3GPP TS 32.422 for further description of the values. It shall comply with the provisions defined in table 5.6.3.12-1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LoggingDurationMdt {}

impl LoggingDurationMdt {
    #[allow(clippy::new_without_default)]
    pub fn new() -> LoggingDurationMdt {
        LoggingDurationMdt {}
    }
}

/// Converts the LoggingDurationMdt value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for LoggingDurationMdt {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LoggingDurationMdt value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LoggingDurationMdt {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing LoggingDurationMdt".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing LoggingDurationMdt".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LoggingDurationMdt {})
    }
}

// Methods for converting between header::IntoHeaderValue<LoggingDurationMdt> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<LoggingDurationMdt>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<LoggingDurationMdt>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for LoggingDurationMdt - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<LoggingDurationMdt>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <LoggingDurationMdt as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into LoggingDurationMdt - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum LoggingDurationMdtAnyOf {
    #[serde(rename = "600")]
    Variant600,
    #[serde(rename = "1200")]
    Variant1200,
    #[serde(rename = "2400")]
    Variant2400,
    #[serde(rename = "3600")]
    Variant3600,
    #[serde(rename = "5400")]
    Variant5400,
    #[serde(rename = "7200")]
    Variant7200,
}

impl std::fmt::Display for LoggingDurationMdtAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            LoggingDurationMdtAnyOf::Variant600 => write!(f, "600"),
            LoggingDurationMdtAnyOf::Variant1200 => write!(f, "1200"),
            LoggingDurationMdtAnyOf::Variant2400 => write!(f, "2400"),
            LoggingDurationMdtAnyOf::Variant3600 => write!(f, "3600"),
            LoggingDurationMdtAnyOf::Variant5400 => write!(f, "5400"),
            LoggingDurationMdtAnyOf::Variant7200 => write!(f, "7200"),
        }
    }
}

impl std::str::FromStr for LoggingDurationMdtAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "600" => std::result::Result::Ok(LoggingDurationMdtAnyOf::Variant600),
            "1200" => std::result::Result::Ok(LoggingDurationMdtAnyOf::Variant1200),
            "2400" => std::result::Result::Ok(LoggingDurationMdtAnyOf::Variant2400),
            "3600" => std::result::Result::Ok(LoggingDurationMdtAnyOf::Variant3600),
            "5400" => std::result::Result::Ok(LoggingDurationMdtAnyOf::Variant5400),
            "7200" => std::result::Result::Ok(LoggingDurationMdtAnyOf::Variant7200),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// The enumeration LoggingDurationMdt defines Logging Duration in NR for MDT in the trace. See 3GPP TS 32.422 for further description of the values. It shall comply with the provisions defined in table 5.6.3.20-1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LoggingDurationNrMdt {}

impl LoggingDurationNrMdt {
    #[allow(clippy::new_without_default)]
    pub fn new() -> LoggingDurationNrMdt {
        LoggingDurationNrMdt {}
    }
}

/// Converts the LoggingDurationNrMdt value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for LoggingDurationNrMdt {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LoggingDurationNrMdt value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LoggingDurationNrMdt {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing LoggingDurationNrMdt".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing LoggingDurationNrMdt".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LoggingDurationNrMdt {})
    }
}

// Methods for converting between header::IntoHeaderValue<LoggingDurationNrMdt> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<LoggingDurationNrMdt>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<LoggingDurationNrMdt>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for LoggingDurationNrMdt - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<LoggingDurationNrMdt>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <LoggingDurationNrMdt as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into LoggingDurationNrMdt - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// The enumeration LoggingIntervalMdt defines Logging Interval for MDT in the trace. See 3GPP TS 32.422 for further description of the values. It shall comply with the provisions defined in table 5.6.3.12-1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LoggingIntervalMdt {}

impl LoggingIntervalMdt {
    #[allow(clippy::new_without_default)]
    pub fn new() -> LoggingIntervalMdt {
        LoggingIntervalMdt {}
    }
}

/// Converts the LoggingIntervalMdt value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for LoggingIntervalMdt {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LoggingIntervalMdt value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LoggingIntervalMdt {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing LoggingIntervalMdt".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing LoggingIntervalMdt".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LoggingIntervalMdt {})
    }
}

// Methods for converting between header::IntoHeaderValue<LoggingIntervalMdt> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<LoggingIntervalMdt>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<LoggingIntervalMdt>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for LoggingIntervalMdt - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<LoggingIntervalMdt>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <LoggingIntervalMdt as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into LoggingIntervalMdt - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum LoggingIntervalMdtAnyOf {
    #[serde(rename = "128")]
    Variant128,
    #[serde(rename = "256")]
    Variant256,
    #[serde(rename = "512")]
    Variant512,
    #[serde(rename = "1024")]
    Variant1024,
    #[serde(rename = "2048")]
    Variant2048,
    #[serde(rename = "3072")]
    Variant3072,
    #[serde(rename = "4096")]
    Variant4096,
    #[serde(rename = "6144")]
    Variant6144,
}

impl std::fmt::Display for LoggingIntervalMdtAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            LoggingIntervalMdtAnyOf::Variant128 => write!(f, "128"),
            LoggingIntervalMdtAnyOf::Variant256 => write!(f, "256"),
            LoggingIntervalMdtAnyOf::Variant512 => write!(f, "512"),
            LoggingIntervalMdtAnyOf::Variant1024 => write!(f, "1024"),
            LoggingIntervalMdtAnyOf::Variant2048 => write!(f, "2048"),
            LoggingIntervalMdtAnyOf::Variant3072 => write!(f, "3072"),
            LoggingIntervalMdtAnyOf::Variant4096 => write!(f, "4096"),
            LoggingIntervalMdtAnyOf::Variant6144 => write!(f, "6144"),
        }
    }
}

impl std::str::FromStr for LoggingIntervalMdtAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "128" => std::result::Result::Ok(LoggingIntervalMdtAnyOf::Variant128),
            "256" => std::result::Result::Ok(LoggingIntervalMdtAnyOf::Variant256),
            "512" => std::result::Result::Ok(LoggingIntervalMdtAnyOf::Variant512),
            "1024" => std::result::Result::Ok(LoggingIntervalMdtAnyOf::Variant1024),
            "2048" => std::result::Result::Ok(LoggingIntervalMdtAnyOf::Variant2048),
            "3072" => std::result::Result::Ok(LoggingIntervalMdtAnyOf::Variant3072),
            "4096" => std::result::Result::Ok(LoggingIntervalMdtAnyOf::Variant4096),
            "6144" => std::result::Result::Ok(LoggingIntervalMdtAnyOf::Variant6144),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// The enumeration LoggingIntervalNrMdt defines Logging Interval in NR for MDT in the trace. See 3GPP TS 32.422 for further description of the values. It shall comply with the provisions defined in table 5.6.3.18-1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LoggingIntervalNrMdt {}

impl LoggingIntervalNrMdt {
    #[allow(clippy::new_without_default)]
    pub fn new() -> LoggingIntervalNrMdt {
        LoggingIntervalNrMdt {}
    }
}

/// Converts the LoggingIntervalNrMdt value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for LoggingIntervalNrMdt {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LoggingIntervalNrMdt value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LoggingIntervalNrMdt {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing LoggingIntervalNrMdt".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing LoggingIntervalNrMdt".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LoggingIntervalNrMdt {})
    }
}

// Methods for converting between header::IntoHeaderValue<LoggingIntervalNrMdt> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<LoggingIntervalNrMdt>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<LoggingIntervalNrMdt>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for LoggingIntervalNrMdt - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<LoggingIntervalNrMdt>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <LoggingIntervalNrMdt as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into LoggingIntervalNrMdt - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum LoggingIntervalNrMdtAnyOf {
    #[serde(rename = "128")]
    Variant128,
    #[serde(rename = "256")]
    Variant256,
    #[serde(rename = "512")]
    Variant512,
    #[serde(rename = "1024")]
    Variant1024,
    #[serde(rename = "2048")]
    Variant2048,
    #[serde(rename = "3072")]
    Variant3072,
    #[serde(rename = "4096")]
    Variant4096,
    #[serde(rename = "6144")]
    Variant6144,
    #[serde(rename = "320")]
    Variant320,
    #[serde(rename = "640")]
    Variant640,
    #[serde(rename = "infinity")]
    Infinity,
}

impl std::fmt::Display for LoggingIntervalNrMdtAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            LoggingIntervalNrMdtAnyOf::Variant128 => write!(f, "128"),
            LoggingIntervalNrMdtAnyOf::Variant256 => write!(f, "256"),
            LoggingIntervalNrMdtAnyOf::Variant512 => write!(f, "512"),
            LoggingIntervalNrMdtAnyOf::Variant1024 => write!(f, "1024"),
            LoggingIntervalNrMdtAnyOf::Variant2048 => write!(f, "2048"),
            LoggingIntervalNrMdtAnyOf::Variant3072 => write!(f, "3072"),
            LoggingIntervalNrMdtAnyOf::Variant4096 => write!(f, "4096"),
            LoggingIntervalNrMdtAnyOf::Variant6144 => write!(f, "6144"),
            LoggingIntervalNrMdtAnyOf::Variant320 => write!(f, "320"),
            LoggingIntervalNrMdtAnyOf::Variant640 => write!(f, "640"),
            LoggingIntervalNrMdtAnyOf::Infinity => write!(f, "infinity"),
        }
    }
}

impl std::str::FromStr for LoggingIntervalNrMdtAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "128" => std::result::Result::Ok(LoggingIntervalNrMdtAnyOf::Variant128),
            "256" => std::result::Result::Ok(LoggingIntervalNrMdtAnyOf::Variant256),
            "512" => std::result::Result::Ok(LoggingIntervalNrMdtAnyOf::Variant512),
            "1024" => std::result::Result::Ok(LoggingIntervalNrMdtAnyOf::Variant1024),
            "2048" => std::result::Result::Ok(LoggingIntervalNrMdtAnyOf::Variant2048),
            "3072" => std::result::Result::Ok(LoggingIntervalNrMdtAnyOf::Variant3072),
            "4096" => std::result::Result::Ok(LoggingIntervalNrMdtAnyOf::Variant4096),
            "6144" => std::result::Result::Ok(LoggingIntervalNrMdtAnyOf::Variant6144),
            "320" => std::result::Result::Ok(LoggingIntervalNrMdtAnyOf::Variant320),
            "640" => std::result::Result::Ok(LoggingIntervalNrMdtAnyOf::Variant640),
            "infinity" => std::result::Result::Ok(LoggingIntervalNrMdtAnyOf::Infinity),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Lpi {
    #[serde(rename = "locationPrivacyInd")]
    pub location_privacy_ind: models::LocationPrivacyInd,

    #[serde(rename = "validTimePeriod")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub valid_time_period: Option<models::ValidTimePeriod>,
}

impl Lpi {
    #[allow(clippy::new_without_default)]
    pub fn new(location_privacy_ind: models::LocationPrivacyInd) -> Lpi {
        Lpi {
            location_privacy_ind,
            valid_time_period: None,
        }
    }
}

/// Converts the Lpi value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Lpi {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping locationPrivacyInd in query parameter serialization

            // Skipping validTimePeriod in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Lpi value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Lpi {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub location_privacy_ind: Vec<models::LocationPrivacyInd>,
            pub valid_time_period: Vec<models::ValidTimePeriod>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err("Missing value while parsing Lpi".to_string())
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "locationPrivacyInd" => intermediate_rep.location_privacy_ind.push(
                        <models::LocationPrivacyInd as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "validTimePeriod" => intermediate_rep.valid_time_period.push(
                        <models::ValidTimePeriod as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Lpi".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Lpi {
            location_privacy_ind: intermediate_rep
                .location_privacy_ind
                .into_iter()
                .next()
                .ok_or_else(|| "locationPrivacyInd missing in Lpi".to_string())?,
            valid_time_period: intermediate_rep.valid_time_period.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Lpi> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Lpi>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Lpi>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Lpi - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Lpi> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Lpi as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Lpi - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains LTE V2X services authorized information.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LteV2xAuth {
    #[serde(rename = "vehicleUeAuth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub vehicle_ue_auth: Option<models::UeAuth>,

    #[serde(rename = "pedestrianUeAuth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pedestrian_ue_auth: Option<models::UeAuth>,
}

impl LteV2xAuth {
    #[allow(clippy::new_without_default)]
    pub fn new() -> LteV2xAuth {
        LteV2xAuth {
            vehicle_ue_auth: None,
            pedestrian_ue_auth: None,
        }
    }
}

/// Converts the LteV2xAuth value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for LteV2xAuth {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping vehicleUeAuth in query parameter serialization

            // Skipping pedestrianUeAuth in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LteV2xAuth value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LteV2xAuth {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub vehicle_ue_auth: Vec<models::UeAuth>,
            pub pedestrian_ue_auth: Vec<models::UeAuth>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing LteV2xAuth".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "vehicleUeAuth" => intermediate_rep.vehicle_ue_auth.push(
                        <models::UeAuth as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "pedestrianUeAuth" => intermediate_rep.pedestrian_ue_auth.push(
                        <models::UeAuth as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing LteV2xAuth".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LteV2xAuth {
            vehicle_ue_auth: intermediate_rep.vehicle_ue_auth.into_iter().next(),
            pedestrian_ue_auth: intermediate_rep.pedestrian_ue_auth.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LteV2xAuth> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<LteV2xAuth>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<LteV2xAuth>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for LteV2xAuth - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<LteV2xAuth> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <LteV2xAuth as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into LteV2xAuth - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// MBS Session Identifier
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MbsSessionId {
    #[serde(rename = "tmgi")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tmgi: Option<models::Tmgi>,

    #[serde(rename = "ssm")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ssm: Option<models::Ssm>,

    /// This represents the Network Identifier, which together with a PLMN ID is used to identify an SNPN (see 3GPP TS 23.003 and 3GPP TS 23.501 clause 5.30.2.1).
    #[serde(rename = "nid")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nid: Option<String>,
}

impl MbsSessionId {
    #[allow(clippy::new_without_default)]
    pub fn new() -> MbsSessionId {
        MbsSessionId {
            tmgi: None,
            ssm: None,
            nid: None,
        }
    }
}

/// Converts the MbsSessionId value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MbsSessionId {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping tmgi in query parameter serialization

            // Skipping ssm in query parameter serialization
            self.nid
                .as_ref()
                .map(|nid| vec!["nid".to_string(), nid.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MbsSessionId value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MbsSessionId {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub tmgi: Vec<models::Tmgi>,
            pub ssm: Vec<models::Ssm>,
            pub nid: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing MbsSessionId".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "tmgi" => intermediate_rep.tmgi.push(
                        <models::Tmgi as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ssm" => intermediate_rep.ssm.push(
                        <models::Ssm as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nid" => intermediate_rep.nid.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing MbsSessionId".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MbsSessionId {
            tmgi: intermediate_rep.tmgi.into_iter().next(),
            ssm: intermediate_rep.ssm.into_iter().next(),
            nid: intermediate_rep.nid.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MbsSessionId> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MbsSessionId>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<MbsSessionId>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for MbsSessionId - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<MbsSessionId> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <MbsSessionId as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into MbsSessionId - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains the 5MBS Subscription Data.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MbsSubscriptionData {
    #[serde(rename = "mbsAllowed")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mbs_allowed: Option<bool>,

    #[serde(rename = "mbsSessionIdList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mbs_session_id_list: Option<Vec<models::MbsSessionId>>,
}

impl MbsSubscriptionData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> MbsSubscriptionData {
        MbsSubscriptionData {
            mbs_allowed: Some(false),
            mbs_session_id_list: None,
        }
    }
}

/// Converts the MbsSubscriptionData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MbsSubscriptionData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.mbs_allowed.as_ref().map(|mbs_allowed| {
                vec!["mbsAllowed".to_string(), mbs_allowed.to_string()].join(",")
            }),
            // Skipping mbsSessionIdList in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MbsSubscriptionData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MbsSubscriptionData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub mbs_allowed: Vec<bool>,
            pub mbs_session_id_list: Vec<Vec<models::MbsSessionId>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing MbsSubscriptionData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "mbsAllowed" => intermediate_rep.mbs_allowed.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "mbsSessionIdList" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in MbsSubscriptionData"
                            .to_string(),
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing MbsSubscriptionData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MbsSubscriptionData {
            mbs_allowed: intermediate_rep.mbs_allowed.into_iter().next(),
            mbs_session_id_list: intermediate_rep.mbs_session_id_list.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MbsSubscriptionData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MbsSubscriptionData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<MbsSubscriptionData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for MbsSubscriptionData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<MbsSubscriptionData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <MbsSubscriptionData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into MbsSubscriptionData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains an MBSFN area information.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MbsfnArea {
    /// This IE shall contain the MBSFN Area ID.
    #[serde(rename = "mbsfnAreaId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mbsfn_area_id: Option<u8>,

    /// When present, this IE shall contain the Carrier Frequency (EARFCN).
    #[serde(rename = "carrierFrequency")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub carrier_frequency: Option<u32>,
}

impl MbsfnArea {
    #[allow(clippy::new_without_default)]
    pub fn new() -> MbsfnArea {
        MbsfnArea {
            mbsfn_area_id: None,
            carrier_frequency: None,
        }
    }
}

/// Converts the MbsfnArea value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MbsfnArea {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.mbsfn_area_id.as_ref().map(|mbsfn_area_id| {
                vec!["mbsfnAreaId".to_string(), mbsfn_area_id.to_string()].join(",")
            }),
            self.carrier_frequency.as_ref().map(|carrier_frequency| {
                vec![
                    "carrierFrequency".to_string(),
                    carrier_frequency.to_string(),
                ]
                .join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MbsfnArea value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MbsfnArea {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub mbsfn_area_id: Vec<u8>,
            pub carrier_frequency: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing MbsfnArea".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "mbsfnAreaId" => intermediate_rep
                        .mbsfn_area_id
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "carrierFrequency" => intermediate_rep.carrier_frequency.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing MbsfnArea".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MbsfnArea {
            mbsfn_area_id: intermediate_rep.mbsfn_area_id.into_iter().next(),
            carrier_frequency: intermediate_rep.carrier_frequency.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MbsfnArea> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MbsfnArea>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<MbsfnArea>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for MbsfnArea - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<MbsfnArea> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <MbsfnArea as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into MbsfnArea - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Mobile Country Code part of the PLMN, comprising 3 digits, as defined in clause 9.3.3.5 of 3GPP TS 38.413.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Mcc(String);

impl std::convert::From<String> for Mcc {
    fn from(x: String) -> Self {
        Mcc(x)
    }
}

impl std::string::ToString for Mcc {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Mcc {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Mcc(x.to_string()))
    }
}

impl std::convert::From<Mcc> for String {
    fn from(x: Mcc) -> Self {
        x.0
    }
}

impl std::ops::Deref for Mcc {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Mcc {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct McsPriorityIndicator(bool);

impl std::convert::From<bool> for McsPriorityIndicator {
    fn from(x: bool) -> Self {
        McsPriorityIndicator(x)
    }
}

impl std::convert::From<McsPriorityIndicator> for bool {
    fn from(x: McsPriorityIndicator) -> Self {
        x.0
    }
}

impl std::ops::Deref for McsPriorityIndicator {
    type Target = bool;
    fn deref(&self) -> &bool {
        &self.0
    }
}

impl std::ops::DerefMut for McsPriorityIndicator {
    fn deref_mut(&mut self) -> &mut bool {
        &mut self.0
    }
}

/// contains contain MDT configuration data.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MdtConfiguration {
    #[serde(rename = "jobType")]
    pub job_type: models::JobType,

    #[serde(rename = "reportType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub report_type: Option<models::ReportTypeMdt>,

    #[serde(rename = "areaScope")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub area_scope: Option<models::AreaScope>,

    #[serde(rename = "measurementLteList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub measurement_lte_list: Option<Vec<models::MeasurementLteForMdt>>,

    #[serde(rename = "measurementNrList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub measurement_nr_list: Option<Vec<models::MeasurementNrForMdt>>,

    #[serde(rename = "sensorMeasurementList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sensor_measurement_list: Option<Vec<models::SensorMeasurement>>,

    #[serde(rename = "reportingTriggerList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reporting_trigger_list: Option<Vec<models::ReportingTrigger>>,

    #[serde(rename = "reportInterval")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub report_interval: Option<models::ReportIntervalMdt>,

    #[serde(rename = "reportIntervalNr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub report_interval_nr: Option<models::ReportIntervalNrMdt>,

    #[serde(rename = "reportAmount")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub report_amount: Option<models::ReportAmountMdt>,

    /// This IE shall be present if the report trigger parameter is configured for A2 event reporting or A2 event triggered periodic reporting and the job type parameter is configured for Immediate MDT or combined Immediate MDT and Trace in LTE. When present, this IE shall indicate the Event Threshold for RSRP, and the value shall be between 0-97.
    #[serde(rename = "eventThresholdRsrp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub event_threshold_rsrp: Option<u8>,

    /// This IE shall be present if the report trigger parameter is configured for A2 event reporting or A2 event triggered periodic reporting and the job type parameter is configured for Immediate MDT or combined Immediate MDT and Trace in NR. When present, this IE shall indicate the Event Threshold for RSRP, and the value shall be between 0-127.
    #[serde(rename = "eventThresholdRsrpNr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub event_threshold_rsrp_nr: Option<u8>,

    /// This IE shall be present if the report trigger parameter is configured for A2 event reporting or A2 event triggered periodic reporting and the job type parameter is configured for Immediate MDT or combined Immediate MDT and Trace in LTE.When present, this IE shall indicate the Event Threshold for RSRQ, and the value shall be between 0-34.
    #[serde(rename = "eventThresholdRsrq")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub event_threshold_rsrq: Option<u8>,

    /// This IE shall be present if the report trigger parameter is configured for A2 event reporting or A2 event triggered periodic reporting and the job type parameter is configured for Immediate MDT or combined Immediate MDT and Trace in NR.When present, this IE shall indicate the Event Threshold for RSRQ, and the value shall be between 0-127.
    #[serde(rename = "eventThresholdRsrqNr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub event_threshold_rsrq_nr: Option<u8>,

    #[serde(rename = "eventList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub event_list: Option<Vec<models::EventForMdt>>,

    #[serde(rename = "loggingInterval")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub logging_interval: Option<models::LoggingIntervalMdt>,

    #[serde(rename = "loggingIntervalNr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub logging_interval_nr: Option<models::LoggingIntervalNrMdt>,

    #[serde(rename = "loggingDuration")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub logging_duration: Option<models::LoggingDurationMdt>,

    #[serde(rename = "loggingDurationNr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub logging_duration_nr: Option<models::LoggingDurationNrMdt>,

    #[serde(rename = "positioningMethod")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub positioning_method: Option<models::PositioningMethodMdt>,

    #[serde(rename = "addPositioningMethodList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub add_positioning_method_list: Option<Vec<models::PositioningMethodMdt>>,

    #[serde(rename = "collectionPeriodRmmLte")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub collection_period_rmm_lte: Option<models::CollectionPeriodRmmLteMdt>,

    #[serde(rename = "collectionPeriodRmmNr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub collection_period_rmm_nr: Option<models::CollectionPeriodRmmNrMdt>,

    #[serde(rename = "measurementPeriodLte")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub measurement_period_lte: Option<models::MeasurementPeriodLteMdt>,

    #[serde(rename = "mdtAllowedPlmnIdList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mdt_allowed_plmn_id_list: Option<Vec<models::PlmnId>>,

    #[serde(rename = "mbsfnAreaList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mbsfn_area_list: Option<Vec<models::MbsfnArea>>,

    #[serde(rename = "interFreqTargetList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub inter_freq_target_list: Option<Vec<models::InterFreqTargetInfo>>,
}

impl MdtConfiguration {
    #[allow(clippy::new_without_default)]
    pub fn new(job_type: models::JobType) -> MdtConfiguration {
        MdtConfiguration {
            job_type,
            report_type: None,
            area_scope: None,
            measurement_lte_list: None,
            measurement_nr_list: None,
            sensor_measurement_list: None,
            reporting_trigger_list: None,
            report_interval: None,
            report_interval_nr: None,
            report_amount: None,
            event_threshold_rsrp: None,
            event_threshold_rsrp_nr: None,
            event_threshold_rsrq: None,
            event_threshold_rsrq_nr: None,
            event_list: None,
            logging_interval: None,
            logging_interval_nr: None,
            logging_duration: None,
            logging_duration_nr: None,
            positioning_method: None,
            add_positioning_method_list: None,
            collection_period_rmm_lte: None,
            collection_period_rmm_nr: None,
            measurement_period_lte: None,
            mdt_allowed_plmn_id_list: None,
            mbsfn_area_list: None,
            inter_freq_target_list: None,
        }
    }
}

/// Converts the MdtConfiguration value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MdtConfiguration {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping jobType in query parameter serialization

            // Skipping reportType in query parameter serialization

            // Skipping areaScope in query parameter serialization

            // Skipping measurementLteList in query parameter serialization

            // Skipping measurementNrList in query parameter serialization

            // Skipping sensorMeasurementList in query parameter serialization

            // Skipping reportingTriggerList in query parameter serialization

            // Skipping reportInterval in query parameter serialization

            // Skipping reportIntervalNr in query parameter serialization

            // Skipping reportAmount in query parameter serialization
            self.event_threshold_rsrp
                .as_ref()
                .map(|event_threshold_rsrp| {
                    vec![
                        "eventThresholdRsrp".to_string(),
                        event_threshold_rsrp.to_string(),
                    ]
                    .join(",")
                }),
            self.event_threshold_rsrp_nr
                .as_ref()
                .map(|event_threshold_rsrp_nr| {
                    vec![
                        "eventThresholdRsrpNr".to_string(),
                        event_threshold_rsrp_nr.to_string(),
                    ]
                    .join(",")
                }),
            self.event_threshold_rsrq
                .as_ref()
                .map(|event_threshold_rsrq| {
                    vec![
                        "eventThresholdRsrq".to_string(),
                        event_threshold_rsrq.to_string(),
                    ]
                    .join(",")
                }),
            self.event_threshold_rsrq_nr
                .as_ref()
                .map(|event_threshold_rsrq_nr| {
                    vec![
                        "eventThresholdRsrqNr".to_string(),
                        event_threshold_rsrq_nr.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping eventList in query parameter serialization

            // Skipping loggingInterval in query parameter serialization

            // Skipping loggingIntervalNr in query parameter serialization

            // Skipping loggingDuration in query parameter serialization

            // Skipping loggingDurationNr in query parameter serialization

            // Skipping positioningMethod in query parameter serialization

            // Skipping addPositioningMethodList in query parameter serialization

            // Skipping collectionPeriodRmmLte in query parameter serialization

            // Skipping collectionPeriodRmmNr in query parameter serialization

            // Skipping measurementPeriodLte in query parameter serialization

            // Skipping mdtAllowedPlmnIdList in query parameter serialization

            // Skipping mbsfnAreaList in query parameter serialization

            // Skipping interFreqTargetList in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MdtConfiguration value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MdtConfiguration {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub job_type: Vec<models::JobType>,
            pub report_type: Vec<models::ReportTypeMdt>,
            pub area_scope: Vec<models::AreaScope>,
            pub measurement_lte_list: Vec<Vec<models::MeasurementLteForMdt>>,
            pub measurement_nr_list: Vec<Vec<models::MeasurementNrForMdt>>,
            pub sensor_measurement_list: Vec<Vec<models::SensorMeasurement>>,
            pub reporting_trigger_list: Vec<Vec<models::ReportingTrigger>>,
            pub report_interval: Vec<models::ReportIntervalMdt>,
            pub report_interval_nr: Vec<models::ReportIntervalNrMdt>,
            pub report_amount: Vec<models::ReportAmountMdt>,
            pub event_threshold_rsrp: Vec<u8>,
            pub event_threshold_rsrp_nr: Vec<u8>,
            pub event_threshold_rsrq: Vec<u8>,
            pub event_threshold_rsrq_nr: Vec<u8>,
            pub event_list: Vec<Vec<models::EventForMdt>>,
            pub logging_interval: Vec<models::LoggingIntervalMdt>,
            pub logging_interval_nr: Vec<models::LoggingIntervalNrMdt>,
            pub logging_duration: Vec<models::LoggingDurationMdt>,
            pub logging_duration_nr: Vec<models::LoggingDurationNrMdt>,
            pub positioning_method: Vec<models::PositioningMethodMdt>,
            pub add_positioning_method_list: Vec<Vec<models::PositioningMethodMdt>>,
            pub collection_period_rmm_lte: Vec<models::CollectionPeriodRmmLteMdt>,
            pub collection_period_rmm_nr: Vec<models::CollectionPeriodRmmNrMdt>,
            pub measurement_period_lte: Vec<models::MeasurementPeriodLteMdt>,
            pub mdt_allowed_plmn_id_list: Vec<Vec<models::PlmnId>>,
            pub mbsfn_area_list: Vec<Vec<models::MbsfnArea>>,
            pub inter_freq_target_list: Vec<Vec<models::InterFreqTargetInfo>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing MdtConfiguration".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "jobType" => intermediate_rep.job_type.push(
                        <models::JobType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "reportType" => intermediate_rep.report_type.push(
                        <models::ReportTypeMdt as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "areaScope" => intermediate_rep.area_scope.push(
                        <models::AreaScope as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "measurementLteList" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in MdtConfiguration"
                            .to_string(),
                    ),
                    "measurementNrList" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in MdtConfiguration"
                            .to_string(),
                    ),
                    "sensorMeasurementList" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in MdtConfiguration"
                            .to_string(),
                    ),
                    "reportingTriggerList" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in MdtConfiguration"
                            .to_string(),
                    ),
                    #[allow(clippy::redundant_clone)]
                    "reportInterval" => intermediate_rep.report_interval.push(
                        <models::ReportIntervalMdt as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "reportIntervalNr" => intermediate_rep.report_interval_nr.push(
                        <models::ReportIntervalNrMdt as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "reportAmount" => intermediate_rep.report_amount.push(
                        <models::ReportAmountMdt as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "eventThresholdRsrp" => intermediate_rep
                        .event_threshold_rsrp
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "eventThresholdRsrpNr" => intermediate_rep
                        .event_threshold_rsrp_nr
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "eventThresholdRsrq" => intermediate_rep
                        .event_threshold_rsrq
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "eventThresholdRsrqNr" => intermediate_rep
                        .event_threshold_rsrq_nr
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "eventList" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in MdtConfiguration"
                            .to_string(),
                    ),
                    #[allow(clippy::redundant_clone)]
                    "loggingInterval" => intermediate_rep.logging_interval.push(
                        <models::LoggingIntervalMdt as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "loggingIntervalNr" => intermediate_rep.logging_interval_nr.push(
                        <models::LoggingIntervalNrMdt as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "loggingDuration" => intermediate_rep.logging_duration.push(
                        <models::LoggingDurationMdt as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "loggingDurationNr" => intermediate_rep.logging_duration_nr.push(
                        <models::LoggingDurationNrMdt as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "positioningMethod" => intermediate_rep.positioning_method.push(
                        <models::PositioningMethodMdt as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "addPositioningMethodList" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in MdtConfiguration"
                            .to_string(),
                    ),
                    #[allow(clippy::redundant_clone)]
                    "collectionPeriodRmmLte" => intermediate_rep.collection_period_rmm_lte.push(
                        <models::CollectionPeriodRmmLteMdt as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "collectionPeriodRmmNr" => intermediate_rep.collection_period_rmm_nr.push(
                        <models::CollectionPeriodRmmNrMdt as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "measurementPeriodLte" => intermediate_rep.measurement_period_lte.push(
                        <models::MeasurementPeriodLteMdt as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "mdtAllowedPlmnIdList" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in MdtConfiguration"
                            .to_string(),
                    ),
                    "mbsfnAreaList" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in MdtConfiguration"
                            .to_string(),
                    ),
                    "interFreqTargetList" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in MdtConfiguration"
                            .to_string(),
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing MdtConfiguration".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MdtConfiguration {
            job_type: intermediate_rep
                .job_type
                .into_iter()
                .next()
                .ok_or_else(|| "jobType missing in MdtConfiguration".to_string())?,
            report_type: intermediate_rep.report_type.into_iter().next(),
            area_scope: intermediate_rep.area_scope.into_iter().next(),
            measurement_lte_list: intermediate_rep.measurement_lte_list.into_iter().next(),
            measurement_nr_list: intermediate_rep.measurement_nr_list.into_iter().next(),
            sensor_measurement_list: intermediate_rep.sensor_measurement_list.into_iter().next(),
            reporting_trigger_list: intermediate_rep.reporting_trigger_list.into_iter().next(),
            report_interval: intermediate_rep.report_interval.into_iter().next(),
            report_interval_nr: intermediate_rep.report_interval_nr.into_iter().next(),
            report_amount: intermediate_rep.report_amount.into_iter().next(),
            event_threshold_rsrp: intermediate_rep.event_threshold_rsrp.into_iter().next(),
            event_threshold_rsrp_nr: intermediate_rep.event_threshold_rsrp_nr.into_iter().next(),
            event_threshold_rsrq: intermediate_rep.event_threshold_rsrq.into_iter().next(),
            event_threshold_rsrq_nr: intermediate_rep.event_threshold_rsrq_nr.into_iter().next(),
            event_list: intermediate_rep.event_list.into_iter().next(),
            logging_interval: intermediate_rep.logging_interval.into_iter().next(),
            logging_interval_nr: intermediate_rep.logging_interval_nr.into_iter().next(),
            logging_duration: intermediate_rep.logging_duration.into_iter().next(),
            logging_duration_nr: intermediate_rep.logging_duration_nr.into_iter().next(),
            positioning_method: intermediate_rep.positioning_method.into_iter().next(),
            add_positioning_method_list: intermediate_rep
                .add_positioning_method_list
                .into_iter()
                .next(),
            collection_period_rmm_lte: intermediate_rep
                .collection_period_rmm_lte
                .into_iter()
                .next(),
            collection_period_rmm_nr: intermediate_rep.collection_period_rmm_nr.into_iter().next(),
            measurement_period_lte: intermediate_rep.measurement_period_lte.into_iter().next(),
            mdt_allowed_plmn_id_list: intermediate_rep.mdt_allowed_plmn_id_list.into_iter().next(),
            mbsfn_area_list: intermediate_rep.mbsfn_area_list.into_iter().next(),
            inter_freq_target_list: intermediate_rep.inter_freq_target_list.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MdtConfiguration> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MdtConfiguration>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<MdtConfiguration>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for MdtConfiguration - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<MdtConfiguration>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <MdtConfiguration as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into MdtConfiguration - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MdtUserConsent {}

impl MdtUserConsent {
    #[allow(clippy::new_without_default)]
    pub fn new() -> MdtUserConsent {
        MdtUserConsent {}
    }
}

/// Converts the MdtUserConsent value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MdtUserConsent {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MdtUserConsent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MdtUserConsent {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing MdtUserConsent".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing MdtUserConsent".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MdtUserConsent {})
    }
}

// Methods for converting between header::IntoHeaderValue<MdtUserConsent> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MdtUserConsent>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<MdtUserConsent>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for MdtUserConsent - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<MdtUserConsent> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <MdtUserConsent as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into MdtUserConsent - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// The enumeration MeasurementLteForMdt defines Measurements used for MDT in LTE in the trace. See 3GPP TS 32.422 for further description of the values. It shall comply with the provisions defined in table 5.6.3.5-1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MeasurementLteForMdt {}

impl MeasurementLteForMdt {
    #[allow(clippy::new_without_default)]
    pub fn new() -> MeasurementLteForMdt {
        MeasurementLteForMdt {}
    }
}

/// Converts the MeasurementLteForMdt value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MeasurementLteForMdt {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MeasurementLteForMdt value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MeasurementLteForMdt {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing MeasurementLteForMdt".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing MeasurementLteForMdt".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MeasurementLteForMdt {})
    }
}

// Methods for converting between header::IntoHeaderValue<MeasurementLteForMdt> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MeasurementLteForMdt>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<MeasurementLteForMdt>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for MeasurementLteForMdt - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<MeasurementLteForMdt>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <MeasurementLteForMdt as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into MeasurementLteForMdt - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum MeasurementLteForMdtAnyOf {
    #[serde(rename = "M1")]
    M1,
    #[serde(rename = "M2")]
    M2,
    #[serde(rename = "M3")]
    M3,
    #[serde(rename = "M4_DL")]
    M4Dl,
    #[serde(rename = "M4_UL")]
    M4Ul,
    #[serde(rename = "M5_DL")]
    M5Dl,
    #[serde(rename = "M5_UL")]
    M5Ul,
    #[serde(rename = "M6_DL")]
    M6Dl,
    #[serde(rename = "M6_UL")]
    M6Ul,
    #[serde(rename = "M7_DL")]
    M7Dl,
    #[serde(rename = "M7_UL")]
    M7Ul,
    #[serde(rename = "M8")]
    M8,
    #[serde(rename = "M9")]
    M9,
}

impl std::fmt::Display for MeasurementLteForMdtAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            MeasurementLteForMdtAnyOf::M1 => write!(f, "M1"),
            MeasurementLteForMdtAnyOf::M2 => write!(f, "M2"),
            MeasurementLteForMdtAnyOf::M3 => write!(f, "M3"),
            MeasurementLteForMdtAnyOf::M4Dl => write!(f, "M4_DL"),
            MeasurementLteForMdtAnyOf::M4Ul => write!(f, "M4_UL"),
            MeasurementLteForMdtAnyOf::M5Dl => write!(f, "M5_DL"),
            MeasurementLteForMdtAnyOf::M5Ul => write!(f, "M5_UL"),
            MeasurementLteForMdtAnyOf::M6Dl => write!(f, "M6_DL"),
            MeasurementLteForMdtAnyOf::M6Ul => write!(f, "M6_UL"),
            MeasurementLteForMdtAnyOf::M7Dl => write!(f, "M7_DL"),
            MeasurementLteForMdtAnyOf::M7Ul => write!(f, "M7_UL"),
            MeasurementLteForMdtAnyOf::M8 => write!(f, "M8"),
            MeasurementLteForMdtAnyOf::M9 => write!(f, "M9"),
        }
    }
}

impl std::str::FromStr for MeasurementLteForMdtAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "M1" => std::result::Result::Ok(MeasurementLteForMdtAnyOf::M1),
            "M2" => std::result::Result::Ok(MeasurementLteForMdtAnyOf::M2),
            "M3" => std::result::Result::Ok(MeasurementLteForMdtAnyOf::M3),
            "M4_DL" => std::result::Result::Ok(MeasurementLteForMdtAnyOf::M4Dl),
            "M4_UL" => std::result::Result::Ok(MeasurementLteForMdtAnyOf::M4Ul),
            "M5_DL" => std::result::Result::Ok(MeasurementLteForMdtAnyOf::M5Dl),
            "M5_UL" => std::result::Result::Ok(MeasurementLteForMdtAnyOf::M5Ul),
            "M6_DL" => std::result::Result::Ok(MeasurementLteForMdtAnyOf::M6Dl),
            "M6_UL" => std::result::Result::Ok(MeasurementLteForMdtAnyOf::M6Ul),
            "M7_DL" => std::result::Result::Ok(MeasurementLteForMdtAnyOf::M7Dl),
            "M7_UL" => std::result::Result::Ok(MeasurementLteForMdtAnyOf::M7Ul),
            "M8" => std::result::Result::Ok(MeasurementLteForMdtAnyOf::M8),
            "M9" => std::result::Result::Ok(MeasurementLteForMdtAnyOf::M9),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// The enumeration MeasurementNrForMdt defines Measurements used for MDT in NR in the trace. See 3GPP TS 32.422 for further description of the values. It shall comply with the provisions defined in tableÂ 5.6.3.6-1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MeasurementNrForMdt {}

impl MeasurementNrForMdt {
    #[allow(clippy::new_without_default)]
    pub fn new() -> MeasurementNrForMdt {
        MeasurementNrForMdt {}
    }
}

/// Converts the MeasurementNrForMdt value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MeasurementNrForMdt {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MeasurementNrForMdt value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MeasurementNrForMdt {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing MeasurementNrForMdt".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing MeasurementNrForMdt".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MeasurementNrForMdt {})
    }
}

// Methods for converting between header::IntoHeaderValue<MeasurementNrForMdt> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MeasurementNrForMdt>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<MeasurementNrForMdt>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for MeasurementNrForMdt - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<MeasurementNrForMdt>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <MeasurementNrForMdt as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into MeasurementNrForMdt - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// The enumeration MeasurementPeriodLteMdt defines Measurement period LTE for MDT in the trace.  See 3GPP TS 32.422 for further description of the values. It shall comply with the provisions defined in table 5.6.3.16-1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MeasurementPeriodLteMdt {}

impl MeasurementPeriodLteMdt {
    #[allow(clippy::new_without_default)]
    pub fn new() -> MeasurementPeriodLteMdt {
        MeasurementPeriodLteMdt {}
    }
}

/// Converts the MeasurementPeriodLteMdt value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MeasurementPeriodLteMdt {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MeasurementPeriodLteMdt value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MeasurementPeriodLteMdt {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing MeasurementPeriodLteMdt".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing MeasurementPeriodLteMdt".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MeasurementPeriodLteMdt {})
    }
}

// Methods for converting between header::IntoHeaderValue<MeasurementPeriodLteMdt> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MeasurementPeriodLteMdt>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<MeasurementPeriodLteMdt>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for MeasurementPeriodLteMdt - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<MeasurementPeriodLteMdt>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <MeasurementPeriodLteMdt as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into MeasurementPeriodLteMdt - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MicoAllowed(bool);

impl std::convert::From<bool> for MicoAllowed {
    fn from(x: bool) -> Self {
        MicoAllowed(x)
    }
}

impl std::convert::From<MicoAllowed> for bool {
    fn from(x: MicoAllowed) -> Self {
        x.0
    }
}

impl std::ops::Deref for MicoAllowed {
    type Target = bool;
    fn deref(&self) -> &bool {
        &self.0
    }
}

impl std::ops::DerefMut for MicoAllowed {
    fn deref_mut(&mut self) -> &mut bool {
        &mut self.0
    }
}

/// Mobile Network Code part of the PLMN, comprising 2 or 3 digits, as defined in clause 9.3.3.5 of 3GPP TS 38.413.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Mnc(String);

impl std::convert::From<String> for Mnc {
    fn from(x: String) -> Self {
        Mnc(x)
    }
}

impl std::string::ToString for Mnc {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Mnc {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Mnc(x.to_string()))
    }
}

impl std::convert::From<Mnc> for String {
    fn from(x: Mnc) -> Self {
        x.0
    }
}

impl std::ops::Deref for Mnc {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Mnc {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Model3GppChargingCharacteristics(String);

impl std::convert::From<String> for Model3GppChargingCharacteristics {
    fn from(x: String) -> Self {
        Model3GppChargingCharacteristics(x)
    }
}

impl std::string::ToString for Model3GppChargingCharacteristics {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Model3GppChargingCharacteristics {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Model3GppChargingCharacteristics(x.to_string()))
    }
}

impl std::convert::From<Model3GppChargingCharacteristics> for String {
    fn from(x: Model3GppChargingCharacteristics) -> Self {
        x.0
    }
}

impl std::ops::Deref for Model3GppChargingCharacteristics {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Model3GppChargingCharacteristics {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Unsigned integer representing a 5G QoS Identifier (see clause 5.7.2.1 of 3GPP TS 23.501, within the range 0 to 255.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Model5Qi(i32);

impl std::convert::From<i32> for Model5Qi {
    fn from(x: i32) -> Self {
        Model5Qi(x)
    }
}

impl std::convert::From<Model5Qi> for i32 {
    fn from(x: Model5Qi) -> Self {
        x.0
    }
}

impl std::ops::Deref for Model5Qi {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for Model5Qi {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// Unsigned integer indicating the 5QI Priority Level (see clauses 5.7.3.3 and 5.7.4 of 3GPP TS 23.501, within the range 1 to 127.Values are ordered in decreasing order of priority,  i.e. with 1 as the highest priority and 127 as the lowest priority.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Model5QiPriorityLevel(i32);

impl std::convert::From<i32> for Model5QiPriorityLevel {
    fn from(x: i32) -> Self {
        Model5QiPriorityLevel(x)
    }
}

impl std::convert::From<Model5QiPriorityLevel> for i32 {
    fn from(x: Model5QiPriorityLevel) -> Self {
        x.0
    }
}

impl std::ops::Deref for Model5QiPriorityLevel {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for Model5QiPriorityLevel {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ModificationNotification {
    #[serde(rename = "notifyItems")]
    pub notify_items: Vec<models::NotifyItem>,
}

impl ModificationNotification {
    #[allow(clippy::new_without_default)]
    pub fn new(notify_items: Vec<models::NotifyItem>) -> ModificationNotification {
        ModificationNotification { notify_items }
    }
}

/// Converts the ModificationNotification value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ModificationNotification {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping notifyItems in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ModificationNotification value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ModificationNotification {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub notify_items: Vec<Vec<models::NotifyItem>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ModificationNotification".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "notifyItems" => return std::result::Result::Err("Parsing a container in this style is not supported in ModificationNotification".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ModificationNotification".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ModificationNotification {
            notify_items: intermediate_rep
                .notify_items
                .into_iter()
                .next()
                .ok_or_else(|| "notifyItems missing in ModificationNotification".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ModificationNotification> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ModificationNotification>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ModificationNotification>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ModificationNotification - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ModificationNotification>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ModificationNotification as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ModificationNotification - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Modify200Response {
    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "nfInstanceId")]
    pub nf_instance_id: uuid::Uuid,

    #[serde(rename = "implicitUnsubscribe")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub implicit_unsubscribe: Option<bool>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "expires")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expires: Option<chrono::DateTime<chrono::Utc>>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "callbackReference")]
    pub callback_reference: String,

    #[serde(rename = "amfServiceName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub amf_service_name: Option<models::ServiceName>,

    #[serde(rename = "monitoredResourceUris")]
    pub monitored_resource_uris: Vec<models::Uri>,

    #[serde(rename = "singleNssai")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub single_nssai: Option<models::Snssai>,

    /// String representing a Data Network as defined in clause 9A of 3GPP TS 23.003;  it shall contain either a DNN Network Identifier, or a full DNN with both the Network  Identifier and Operator Identifier, as specified in 3GPP TS 23.003 clause 9.1.1 and 9.1.2. It shall be coded as string in which the labels are separated by dots  (e.g. \"Label1.Label2.Label3\").
    #[serde(rename = "dnn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dnn: Option<String>,

    #[serde(rename = "subscriptionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscription_id: Option<String>,

    #[serde(rename = "plmnId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub plmn_id: Option<models::PlmnId>,

    #[serde(rename = "immediateReport")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub immediate_report: Option<bool>,

    /// The execution report contains an array of report items. Each report item indicates one  failed modification.
    #[serde(rename = "report")]
    pub report: Vec<models::ReportItem>,

    /// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  tableÂ 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.
    #[serde(rename = "supportedFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_features: Option<String>,

    #[serde(rename = "contextInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub context_info: Option<models::ContextInfo>,

    #[serde(rename = "nfChangeFilter")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nf_change_filter: Option<bool>,

    #[serde(rename = "uniqueSubscription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unique_subscription: Option<bool>,

    #[serde(rename = "resetIds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reset_ids: Option<Vec<String>>,

    #[serde(rename = "ueConSmfDataSubFilter")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_con_smf_data_sub_filter: Option<models::UeContextInSmfDataSubFilter>,
}

impl Modify200Response {
    #[allow(clippy::new_without_default)]
    pub fn new(
        nf_instance_id: uuid::Uuid,
        callback_reference: String,
        monitored_resource_uris: Vec<models::Uri>,
        report: Vec<models::ReportItem>,
    ) -> Modify200Response {
        Modify200Response {
            nf_instance_id,
            implicit_unsubscribe: None,
            expires: None,
            callback_reference,
            amf_service_name: None,
            monitored_resource_uris,
            single_nssai: None,
            dnn: None,
            subscription_id: None,
            plmn_id: None,
            immediate_report: Some(false),
            report,
            supported_features: None,
            context_info: None,
            nf_change_filter: Some(false),
            unique_subscription: None,
            reset_ids: None,
            ue_con_smf_data_sub_filter: None,
        }
    }
}

/// Converts the Modify200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Modify200Response {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping nfInstanceId in query parameter serialization
            self.implicit_unsubscribe
                .as_ref()
                .map(|implicit_unsubscribe| {
                    vec![
                        "implicitUnsubscribe".to_string(),
                        implicit_unsubscribe.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping expires in query parameter serialization
            Some("callbackReference".to_string()),
            Some(self.callback_reference.to_string()),
            // Skipping amfServiceName in query parameter serialization
            Some("monitoredResourceUris".to_string()),
            Some(
                self.monitored_resource_uris
                    .iter()
                    .map(|x| x.to_string())
                    .collect::<Vec<_>>()
                    .join(","),
            ),
            // Skipping singleNssai in query parameter serialization
            self.dnn
                .as_ref()
                .map(|dnn| vec!["dnn".to_string(), dnn.to_string()].join(",")),
            self.subscription_id.as_ref().map(|subscription_id| {
                vec!["subscriptionId".to_string(), subscription_id.to_string()].join(",")
            }),
            // Skipping plmnId in query parameter serialization
            self.immediate_report.as_ref().map(|immediate_report| {
                vec!["immediateReport".to_string(), immediate_report.to_string()].join(",")
            }),
            // Skipping report in query parameter serialization
            self.supported_features.as_ref().map(|supported_features| {
                vec![
                    "supportedFeatures".to_string(),
                    supported_features.to_string(),
                ]
                .join(",")
            }),
            // Skipping contextInfo in query parameter serialization
            self.nf_change_filter.as_ref().map(|nf_change_filter| {
                vec!["nfChangeFilter".to_string(), nf_change_filter.to_string()].join(",")
            }),
            self.unique_subscription
                .as_ref()
                .map(|unique_subscription| {
                    vec![
                        "uniqueSubscription".to_string(),
                        unique_subscription.to_string(),
                    ]
                    .join(",")
                }),
            self.reset_ids.as_ref().map(|reset_ids| {
                vec![
                    "resetIds".to_string(),
                    reset_ids
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping ueConSmfDataSubFilter in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Modify200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Modify200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub nf_instance_id: Vec<uuid::Uuid>,
            pub implicit_unsubscribe: Vec<bool>,
            pub expires: Vec<chrono::DateTime<chrono::Utc>>,
            pub callback_reference: Vec<String>,
            pub amf_service_name: Vec<models::ServiceName>,
            pub monitored_resource_uris: Vec<Vec<models::Uri>>,
            pub single_nssai: Vec<models::Snssai>,
            pub dnn: Vec<String>,
            pub subscription_id: Vec<String>,
            pub plmn_id: Vec<models::PlmnId>,
            pub immediate_report: Vec<bool>,
            pub report: Vec<Vec<models::ReportItem>>,
            pub supported_features: Vec<String>,
            pub context_info: Vec<models::ContextInfo>,
            pub nf_change_filter: Vec<bool>,
            pub unique_subscription: Vec<bool>,
            pub reset_ids: Vec<Vec<String>>,
            pub ue_con_smf_data_sub_filter: Vec<models::UeContextInSmfDataSubFilter>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Modify200Response".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "nfInstanceId" => intermediate_rep.nf_instance_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "implicitUnsubscribe" => intermediate_rep.implicit_unsubscribe.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "expires" => intermediate_rep.expires.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "callbackReference" => intermediate_rep.callback_reference.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "amfServiceName" => intermediate_rep.amf_service_name.push(
                        <models::ServiceName as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "monitoredResourceUris" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in Modify200Response"
                            .to_string(),
                    ),
                    #[allow(clippy::redundant_clone)]
                    "singleNssai" => intermediate_rep.single_nssai.push(
                        <models::Snssai as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "dnn" => intermediate_rep.dnn.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "subscriptionId" => intermediate_rep.subscription_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "plmnId" => intermediate_rep.plmn_id.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "immediateReport" => intermediate_rep.immediate_report.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "report" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in Modify200Response"
                            .to_string(),
                    ),
                    #[allow(clippy::redundant_clone)]
                    "supportedFeatures" => intermediate_rep.supported_features.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "contextInfo" => intermediate_rep.context_info.push(
                        <models::ContextInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nfChangeFilter" => intermediate_rep.nf_change_filter.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "uniqueSubscription" => intermediate_rep.unique_subscription.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "resetIds" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in Modify200Response"
                            .to_string(),
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ueConSmfDataSubFilter" => intermediate_rep.ue_con_smf_data_sub_filter.push(
                        <models::UeContextInSmfDataSubFilter as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Modify200Response".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Modify200Response {
            nf_instance_id: intermediate_rep
                .nf_instance_id
                .into_iter()
                .next()
                .ok_or_else(|| "nfInstanceId missing in Modify200Response".to_string())?,
            implicit_unsubscribe: intermediate_rep.implicit_unsubscribe.into_iter().next(),
            expires: intermediate_rep.expires.into_iter().next(),
            callback_reference: intermediate_rep
                .callback_reference
                .into_iter()
                .next()
                .ok_or_else(|| "callbackReference missing in Modify200Response".to_string())?,
            amf_service_name: intermediate_rep.amf_service_name.into_iter().next(),
            monitored_resource_uris: intermediate_rep
                .monitored_resource_uris
                .into_iter()
                .next()
                .ok_or_else(|| "monitoredResourceUris missing in Modify200Response".to_string())?,
            single_nssai: intermediate_rep.single_nssai.into_iter().next(),
            dnn: intermediate_rep.dnn.into_iter().next(),
            subscription_id: intermediate_rep.subscription_id.into_iter().next(),
            plmn_id: intermediate_rep.plmn_id.into_iter().next(),
            immediate_report: intermediate_rep.immediate_report.into_iter().next(),
            report: intermediate_rep
                .report
                .into_iter()
                .next()
                .ok_or_else(|| "report missing in Modify200Response".to_string())?,
            supported_features: intermediate_rep.supported_features.into_iter().next(),
            context_info: intermediate_rep.context_info.into_iter().next(),
            nf_change_filter: intermediate_rep.nf_change_filter.into_iter().next(),
            unique_subscription: intermediate_rep.unique_subscription.into_iter().next(),
            reset_ids: intermediate_rep.reset_ids.into_iter().next(),
            ue_con_smf_data_sub_filter: intermediate_rep
                .ue_con_smf_data_sub_filter
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Modify200Response> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Modify200Response>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Modify200Response>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Modify200Response - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<Modify200Response>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <Modify200Response as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into Modify200Response - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MpsPriorityIndicator(bool);

impl std::convert::From<bool> for MpsPriorityIndicator {
    fn from(x: bool) -> Self {
        MpsPriorityIndicator(x)
    }
}

impl std::convert::From<MpsPriorityIndicator> for bool {
    fn from(x: MpsPriorityIndicator) -> Self {
        x.0
    }
}

impl std::ops::Deref for MpsPriorityIndicator {
    type Target = bool;
    fn deref(&self) -> &bool {
        &self.0
    }
}

impl std::ops::DerefMut for MpsPriorityIndicator {
    fn deref_mut(&mut self) -> &mut bool {
        &mut self.0
    }
}

/// String uniquely identifying MTC provider information.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MtcProviderInformation(String);

impl std::convert::From<String> for MtcProviderInformation {
    fn from(x: String) -> Self {
        MtcProviderInformation(x)
    }
}

impl std::string::ToString for MtcProviderInformation {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for MtcProviderInformation {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(MtcProviderInformation(x.to_string()))
    }
}

impl std::convert::From<MtcProviderInformation> for String {
    fn from(x: MtcProviderInformation) -> Self {
        x.0
    }
}

impl std::ops::Deref for MtcProviderInformation {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for MtcProviderInformation {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// This represents the identifier of the N3IWF ID as specified in clause 9.3.1.57 of  3GPP TS 38.413 in hexadecimal representation. Each character in the string shall take a value  of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant  character representing the 4 most significant bits of the N3IWF ID shall appear first in the  string, and the character representing the 4 least significant bit of the N3IWF ID shall  appear last in the string.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct N3IwfId(String);

impl std::convert::From<String> for N3IwfId {
    fn from(x: String) -> Self {
        N3IwfId(x)
    }
}

impl std::string::ToString for N3IwfId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for N3IwfId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(N3IwfId(x.to_string()))
    }
}

impl std::convert::From<N3IwfId> for String {
    fn from(x: N3IwfId) -> Self {
        x.0
    }
}

impl std::ops::Deref for N3IwfId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for N3IwfId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NbIoTuePriority(i32);

impl std::convert::From<i32> for NbIoTuePriority {
    fn from(x: i32) -> Self {
        NbIoTuePriority(x)
    }
}

impl std::convert::From<NbIoTuePriority> for i32 {
    fn from(x: NbIoTuePriority) -> Self {
        x.0
    }
}

impl std::ops::Deref for NbIoTuePriority {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for NbIoTuePriority {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// Contains the NCGI (NR Cell Global Identity), as described in 3GPP 23.003
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Ncgi {
    #[serde(rename = "plmnId")]
    pub plmn_id: models::PlmnId,

    /// 36-bit string identifying an NR Cell Id as specified in clause 9.3.1.7 of 3GPP TS 38.413,  in hexadecimal representation. Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character  representing the 4 most significant bits of the Cell Id shall appear first in the string, and  the character representing the 4 least significant bit of the Cell Id shall appear last in the  string.
    #[serde(rename = "nrCellId")]
    pub nr_cell_id: String,

    /// This represents the Network Identifier, which together with a PLMN ID is used to identify an SNPN (see 3GPP TS 23.003 and 3GPP TS 23.501 clause 5.30.2.1).
    #[serde(rename = "nid")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nid: Option<String>,
}

impl Ncgi {
    #[allow(clippy::new_without_default)]
    pub fn new(plmn_id: models::PlmnId, nr_cell_id: String) -> Ncgi {
        Ncgi {
            plmn_id,
            nr_cell_id,
            nid: None,
        }
    }
}

/// Converts the Ncgi value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Ncgi {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping plmnId in query parameter serialization
            Some("nrCellId".to_string()),
            Some(self.nr_cell_id.to_string()),
            self.nid
                .as_ref()
                .map(|nid| vec!["nid".to_string(), nid.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Ncgi value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Ncgi {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub plmn_id: Vec<models::PlmnId>,
            pub nr_cell_id: Vec<String>,
            pub nid: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err("Missing value while parsing Ncgi".to_string())
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "plmnId" => intermediate_rep.plmn_id.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nrCellId" => intermediate_rep.nr_cell_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nid" => intermediate_rep.nid.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Ncgi".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Ncgi {
            plmn_id: intermediate_rep
                .plmn_id
                .into_iter()
                .next()
                .ok_or_else(|| "plmnId missing in Ncgi".to_string())?,
            nr_cell_id: intermediate_rep
                .nr_cell_id
                .into_iter()
                .next()
                .ok_or_else(|| "nrCellId missing in Ncgi".to_string())?,
            nid: intermediate_rep.nid.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Ncgi> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Ncgi>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Ncgi>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Ncgi - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Ncgi> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Ncgi as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Ncgi - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Identity of the NEF
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NefId(String);

impl std::convert::From<String> for NefId {
    fn from(x: String) -> Self {
        NefId(x)
    }
}

impl std::string::ToString for NefId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for NefId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(NefId(x.to_string()))
    }
}

impl std::convert::From<NefId> for String {
    fn from(x: NefId) -> Self {
        x.0
    }
}

impl std::ops::Deref for NefId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for NefId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Describes a network area information in which the NF service consumer requests the number of UEs.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NetworkAreaInfo {
    /// Contains a list of E-UTRA cell identities.
    #[serde(rename = "ecgis")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ecgis: Option<Vec<models::Ecgi>>,

    /// Contains a list of NR cell identities.
    #[serde(rename = "ncgis")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ncgis: Option<Vec<models::Ncgi>>,

    /// Contains a list of NG RAN nodes.
    #[serde(rename = "gRanNodeIds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub g_ran_node_ids: Option<Vec<models::GlobalRanNodeId>>,

    /// Contains a list of tracking area identities.
    #[serde(rename = "tais")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tais: Option<Vec<models::Tai>>,
}

impl NetworkAreaInfo {
    #[allow(clippy::new_without_default)]
    pub fn new() -> NetworkAreaInfo {
        NetworkAreaInfo {
            ecgis: None,
            ncgis: None,
            g_ran_node_ids: None,
            tais: None,
        }
    }
}

/// Converts the NetworkAreaInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NetworkAreaInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping ecgis in query parameter serialization

            // Skipping ncgis in query parameter serialization

            // Skipping gRanNodeIds in query parameter serialization

            // Skipping tais in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NetworkAreaInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NetworkAreaInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ecgis: Vec<Vec<models::Ecgi>>,
            pub ncgis: Vec<Vec<models::Ncgi>>,
            pub g_ran_node_ids: Vec<Vec<models::GlobalRanNodeId>>,
            pub tais: Vec<Vec<models::Tai>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NetworkAreaInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "ecgis" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NetworkAreaInfo"
                                .to_string(),
                        )
                    }
                    "ncgis" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NetworkAreaInfo"
                                .to_string(),
                        )
                    }
                    "gRanNodeIds" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NetworkAreaInfo"
                                .to_string(),
                        )
                    }
                    "tais" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NetworkAreaInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NetworkAreaInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NetworkAreaInfo {
            ecgis: intermediate_rep.ecgis.into_iter().next(),
            ncgis: intermediate_rep.ncgis.into_iter().next(),
            g_ran_node_ids: intermediate_rep.g_ran_node_ids.into_iter().next(),
            tais: intermediate_rep.tais.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NetworkAreaInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NetworkAreaInfo>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NetworkAreaInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NetworkAreaInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<NetworkAreaInfo>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NetworkAreaInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NetworkAreaInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Identifier of a group of NFs.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NfGroupId(String);

impl std::convert::From<String> for NfGroupId {
    fn from(x: String) -> Self {
        NfGroupId(x)
    }
}

impl std::string::ToString for NfGroupId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for NfGroupId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(NfGroupId(x.to_string()))
    }
}

impl std::convert::From<NfGroupId> for String {
    fn from(x: NfGroupId) -> Self {
        x.0
    }
}

impl std::ops::Deref for NfGroupId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for NfGroupId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NfInstanceId(uuid::Uuid);

impl std::convert::From<uuid::Uuid> for NfInstanceId {
    fn from(x: uuid::Uuid) -> Self {
        NfInstanceId(x)
    }
}

impl std::convert::From<NfInstanceId> for uuid::Uuid {
    fn from(x: NfInstanceId) -> Self {
        x.0
    }
}

impl std::ops::Deref for NfInstanceId {
    type Target = uuid::Uuid;
    fn deref(&self) -> &uuid::Uuid {
        &self.0
    }
}

impl std::ops::DerefMut for NfInstanceId {
    fn deref_mut(&mut self) -> &mut uuid::Uuid {
        &mut self.0
    }
}

/// NF Service Set Identifier (see clause 28.12 of 3GPP TS 23.003) formatted as the following  string \"set<Set ID>.sn<Service Name>.nfi<NF Instance ID>.5gc.mnc<MNC>.mcc<MCC>\", or  \"set<SetID>.sn<ServiceName>.nfi<NFInstanceID>.5gc.nid<NID>.mnc<MNC>.mcc<MCC>\" with  <MCC> encoded as defined in clause 5.4.2 (\"Mcc\" data type definition)   <MNC> encoding the Mobile Network Code part of the PLMN, comprising 3 digits.    If there are only 2 significant digits in the MNC, one \"0\" digit shall be inserted    at the left side to fill the 3 digits coding of MNC.  Pattern: '^[0-9]{3}$' <NID> encoded as defined in clauseÂ 5.4.2 (\"Nid\" data type definition)  <NFInstanceId> encoded as defined in clause 5.3.2  <ServiceName> encoded as defined in 3GPP TS 29.510  <Set ID> encoded as a string of characters consisting of alphabetic    characters (A-Z and a-z), digits (0-9) and/or the hyphen (-) and that shall end    with either an alphabetic character or a digit.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NfServiceSetId(String);

impl std::convert::From<String> for NfServiceSetId {
    fn from(x: String) -> Self {
        NfServiceSetId(x)
    }
}

impl std::string::ToString for NfServiceSetId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for NfServiceSetId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(NfServiceSetId(x.to_string()))
    }
}

impl std::convert::From<NfServiceSetId> for String {
    fn from(x: NfServiceSetId) -> Self {
        x.0
    }
}

impl std::ops::Deref for NfServiceSetId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for NfServiceSetId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// NF Set Identifier (see clause 28.12 of 3GPP TS 23.003), formatted as the following string \"set<Set ID>.<nftype>set.5gc.mnc<MNC>.mcc<MCC>\", or  \"set<SetID>.<NFType>set.5gc.nid<NID>.mnc<MNC>.mcc<MCC>\" with  <MCC> encoded as defined in clause 5.4.2 (\"Mcc\" data type definition)  <MNC> encoding the Mobile Network Code part of the PLMN, comprising 3 digits.    If there are only 2 significant digits in the MNC, one \"0\" digit shall be inserted    at the left side to fill the 3 digits coding of MNC.  Pattern: '^[0-9]{3}$' <NFType> encoded as a value defined in Table 6.1.6.3.3-1 of 3GPP TS 29.510 but    with lower case characters <Set ID> encoded as a string of characters consisting of    alphabetic characters (A-Z and a-z), digits (0-9) and/or the hyphen (-) and that    shall end with either an alphabetic character or a digit.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NfSetId(String);

impl std::convert::From<String> for NfSetId {
    fn from(x: String) -> Self {
        NfSetId(x)
    }
}

impl std::string::ToString for NfSetId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for NfSetId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(NfSetId(x.to_string()))
    }
}

impl std::convert::From<NfSetId> for String {
    fn from(x: NfSetId) -> Self {
        x.0
    }
}

impl std::ops::Deref for NfSetId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for NfSetId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// NF types known to NRF
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NfType {}

impl NfType {
    #[allow(clippy::new_without_default)]
    pub fn new() -> NfType {
        NfType {}
    }
}

/// Converts the NfType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NfType {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NfType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NfType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NfType".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NfType".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NfType {})
    }
}

// Methods for converting between header::IntoHeaderValue<NfType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NfType>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NfType>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NfType - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<NfType> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NfType as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NfType - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum NfTypeAnyOf {
    #[serde(rename = "NRF")]
    Nrf,
    #[serde(rename = "UDM")]
    Udm,
    #[serde(rename = "AMF")]
    Amf,
    #[serde(rename = "SMF")]
    Smf,
    #[serde(rename = "AUSF")]
    Ausf,
    #[serde(rename = "NEF")]
    Nef,
    #[serde(rename = "PCF")]
    Pcf,
    #[serde(rename = "SMSF")]
    Smsf,
    #[serde(rename = "NSSF")]
    Nssf,
    #[serde(rename = "UDR")]
    Udr,
    #[serde(rename = "LMF")]
    Lmf,
    #[serde(rename = "GMLC")]
    Gmlc,
    #[serde(rename = "5G_EIR")]
    Variant5GEir,
    #[serde(rename = "SEPP")]
    Sepp,
    #[serde(rename = "UPF")]
    Upf,
    #[serde(rename = "N3IWF")]
    N3Iwf,
    #[serde(rename = "AF")]
    Af,
    #[serde(rename = "UDSF")]
    Udsf,
    #[serde(rename = "BSF")]
    Bsf,
    #[serde(rename = "CHF")]
    Chf,
    #[serde(rename = "NWDAF")]
    Nwdaf,
    #[serde(rename = "PCSCF")]
    Pcscf,
    #[serde(rename = "CBCF")]
    Cbcf,
    #[serde(rename = "HSS")]
    Hss,
    #[serde(rename = "UCMF")]
    Ucmf,
    #[serde(rename = "SOR_AF")]
    SorAf,
    #[serde(rename = "SPAF")]
    Spaf,
    #[serde(rename = "MME")]
    Mme,
    #[serde(rename = "SCSAS")]
    Scsas,
    #[serde(rename = "SCEF")]
    Scef,
    #[serde(rename = "SCP")]
    Scp,
    #[serde(rename = "NSSAAF")]
    Nssaaf,
    #[serde(rename = "ICSCF")]
    Icscf,
    #[serde(rename = "SCSCF")]
    Scscf,
    #[serde(rename = "DRA")]
    Dra,
    #[serde(rename = "IMS_AS")]
    ImsAs,
    #[serde(rename = "AANF")]
    Aanf,
    #[serde(rename = "5G_DDNMF")]
    Variant5GDdnmf,
    #[serde(rename = "NSACF")]
    Nsacf,
    #[serde(rename = "MFAF")]
    Mfaf,
    #[serde(rename = "EASDF")]
    Easdf,
    #[serde(rename = "DCCF")]
    Dccf,
    #[serde(rename = "MB_SMF")]
    MbSmf,
    #[serde(rename = "TSCTSF")]
    Tsctsf,
    #[serde(rename = "ADRF")]
    Adrf,
    #[serde(rename = "GBA_BSF")]
    GbaBsf,
    #[serde(rename = "CEF")]
    Cef,
    #[serde(rename = "MB_UPF")]
    MbUpf,
    #[serde(rename = "NSWOF")]
    Nswof,
    #[serde(rename = "PKMF")]
    Pkmf,
    #[serde(rename = "MNPF")]
    Mnpf,
    #[serde(rename = "SMS_GMSC")]
    SmsGmsc,
    #[serde(rename = "SMS_IWMSC")]
    SmsIwmsc,
    #[serde(rename = "MBSF")]
    Mbsf,
    #[serde(rename = "MBSTF")]
    Mbstf,
    #[serde(rename = "PANF")]
    Panf,
}

impl std::fmt::Display for NfTypeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            NfTypeAnyOf::Nrf => write!(f, "NRF"),
            NfTypeAnyOf::Udm => write!(f, "UDM"),
            NfTypeAnyOf::Amf => write!(f, "AMF"),
            NfTypeAnyOf::Smf => write!(f, "SMF"),
            NfTypeAnyOf::Ausf => write!(f, "AUSF"),
            NfTypeAnyOf::Nef => write!(f, "NEF"),
            NfTypeAnyOf::Pcf => write!(f, "PCF"),
            NfTypeAnyOf::Smsf => write!(f, "SMSF"),
            NfTypeAnyOf::Nssf => write!(f, "NSSF"),
            NfTypeAnyOf::Udr => write!(f, "UDR"),
            NfTypeAnyOf::Lmf => write!(f, "LMF"),
            NfTypeAnyOf::Gmlc => write!(f, "GMLC"),
            NfTypeAnyOf::Variant5GEir => write!(f, "5G_EIR"),
            NfTypeAnyOf::Sepp => write!(f, "SEPP"),
            NfTypeAnyOf::Upf => write!(f, "UPF"),
            NfTypeAnyOf::N3Iwf => write!(f, "N3IWF"),
            NfTypeAnyOf::Af => write!(f, "AF"),
            NfTypeAnyOf::Udsf => write!(f, "UDSF"),
            NfTypeAnyOf::Bsf => write!(f, "BSF"),
            NfTypeAnyOf::Chf => write!(f, "CHF"),
            NfTypeAnyOf::Nwdaf => write!(f, "NWDAF"),
            NfTypeAnyOf::Pcscf => write!(f, "PCSCF"),
            NfTypeAnyOf::Cbcf => write!(f, "CBCF"),
            NfTypeAnyOf::Hss => write!(f, "HSS"),
            NfTypeAnyOf::Ucmf => write!(f, "UCMF"),
            NfTypeAnyOf::SorAf => write!(f, "SOR_AF"),
            NfTypeAnyOf::Spaf => write!(f, "SPAF"),
            NfTypeAnyOf::Mme => write!(f, "MME"),
            NfTypeAnyOf::Scsas => write!(f, "SCSAS"),
            NfTypeAnyOf::Scef => write!(f, "SCEF"),
            NfTypeAnyOf::Scp => write!(f, "SCP"),
            NfTypeAnyOf::Nssaaf => write!(f, "NSSAAF"),
            NfTypeAnyOf::Icscf => write!(f, "ICSCF"),
            NfTypeAnyOf::Scscf => write!(f, "SCSCF"),
            NfTypeAnyOf::Dra => write!(f, "DRA"),
            NfTypeAnyOf::ImsAs => write!(f, "IMS_AS"),
            NfTypeAnyOf::Aanf => write!(f, "AANF"),
            NfTypeAnyOf::Variant5GDdnmf => write!(f, "5G_DDNMF"),
            NfTypeAnyOf::Nsacf => write!(f, "NSACF"),
            NfTypeAnyOf::Mfaf => write!(f, "MFAF"),
            NfTypeAnyOf::Easdf => write!(f, "EASDF"),
            NfTypeAnyOf::Dccf => write!(f, "DCCF"),
            NfTypeAnyOf::MbSmf => write!(f, "MB_SMF"),
            NfTypeAnyOf::Tsctsf => write!(f, "TSCTSF"),
            NfTypeAnyOf::Adrf => write!(f, "ADRF"),
            NfTypeAnyOf::GbaBsf => write!(f, "GBA_BSF"),
            NfTypeAnyOf::Cef => write!(f, "CEF"),
            NfTypeAnyOf::MbUpf => write!(f, "MB_UPF"),
            NfTypeAnyOf::Nswof => write!(f, "NSWOF"),
            NfTypeAnyOf::Pkmf => write!(f, "PKMF"),
            NfTypeAnyOf::Mnpf => write!(f, "MNPF"),
            NfTypeAnyOf::SmsGmsc => write!(f, "SMS_GMSC"),
            NfTypeAnyOf::SmsIwmsc => write!(f, "SMS_IWMSC"),
            NfTypeAnyOf::Mbsf => write!(f, "MBSF"),
            NfTypeAnyOf::Mbstf => write!(f, "MBSTF"),
            NfTypeAnyOf::Panf => write!(f, "PANF"),
        }
    }
}

impl std::str::FromStr for NfTypeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "NRF" => std::result::Result::Ok(NfTypeAnyOf::Nrf),
            "UDM" => std::result::Result::Ok(NfTypeAnyOf::Udm),
            "AMF" => std::result::Result::Ok(NfTypeAnyOf::Amf),
            "SMF" => std::result::Result::Ok(NfTypeAnyOf::Smf),
            "AUSF" => std::result::Result::Ok(NfTypeAnyOf::Ausf),
            "NEF" => std::result::Result::Ok(NfTypeAnyOf::Nef),
            "PCF" => std::result::Result::Ok(NfTypeAnyOf::Pcf),
            "SMSF" => std::result::Result::Ok(NfTypeAnyOf::Smsf),
            "NSSF" => std::result::Result::Ok(NfTypeAnyOf::Nssf),
            "UDR" => std::result::Result::Ok(NfTypeAnyOf::Udr),
            "LMF" => std::result::Result::Ok(NfTypeAnyOf::Lmf),
            "GMLC" => std::result::Result::Ok(NfTypeAnyOf::Gmlc),
            "5G_EIR" => std::result::Result::Ok(NfTypeAnyOf::Variant5GEir),
            "SEPP" => std::result::Result::Ok(NfTypeAnyOf::Sepp),
            "UPF" => std::result::Result::Ok(NfTypeAnyOf::Upf),
            "N3IWF" => std::result::Result::Ok(NfTypeAnyOf::N3Iwf),
            "AF" => std::result::Result::Ok(NfTypeAnyOf::Af),
            "UDSF" => std::result::Result::Ok(NfTypeAnyOf::Udsf),
            "BSF" => std::result::Result::Ok(NfTypeAnyOf::Bsf),
            "CHF" => std::result::Result::Ok(NfTypeAnyOf::Chf),
            "NWDAF" => std::result::Result::Ok(NfTypeAnyOf::Nwdaf),
            "PCSCF" => std::result::Result::Ok(NfTypeAnyOf::Pcscf),
            "CBCF" => std::result::Result::Ok(NfTypeAnyOf::Cbcf),
            "HSS" => std::result::Result::Ok(NfTypeAnyOf::Hss),
            "UCMF" => std::result::Result::Ok(NfTypeAnyOf::Ucmf),
            "SOR_AF" => std::result::Result::Ok(NfTypeAnyOf::SorAf),
            "SPAF" => std::result::Result::Ok(NfTypeAnyOf::Spaf),
            "MME" => std::result::Result::Ok(NfTypeAnyOf::Mme),
            "SCSAS" => std::result::Result::Ok(NfTypeAnyOf::Scsas),
            "SCEF" => std::result::Result::Ok(NfTypeAnyOf::Scef),
            "SCP" => std::result::Result::Ok(NfTypeAnyOf::Scp),
            "NSSAAF" => std::result::Result::Ok(NfTypeAnyOf::Nssaaf),
            "ICSCF" => std::result::Result::Ok(NfTypeAnyOf::Icscf),
            "SCSCF" => std::result::Result::Ok(NfTypeAnyOf::Scscf),
            "DRA" => std::result::Result::Ok(NfTypeAnyOf::Dra),
            "IMS_AS" => std::result::Result::Ok(NfTypeAnyOf::ImsAs),
            "AANF" => std::result::Result::Ok(NfTypeAnyOf::Aanf),
            "5G_DDNMF" => std::result::Result::Ok(NfTypeAnyOf::Variant5GDdnmf),
            "NSACF" => std::result::Result::Ok(NfTypeAnyOf::Nsacf),
            "MFAF" => std::result::Result::Ok(NfTypeAnyOf::Mfaf),
            "EASDF" => std::result::Result::Ok(NfTypeAnyOf::Easdf),
            "DCCF" => std::result::Result::Ok(NfTypeAnyOf::Dccf),
            "MB_SMF" => std::result::Result::Ok(NfTypeAnyOf::MbSmf),
            "TSCTSF" => std::result::Result::Ok(NfTypeAnyOf::Tsctsf),
            "ADRF" => std::result::Result::Ok(NfTypeAnyOf::Adrf),
            "GBA_BSF" => std::result::Result::Ok(NfTypeAnyOf::GbaBsf),
            "CEF" => std::result::Result::Ok(NfTypeAnyOf::Cef),
            "MB_UPF" => std::result::Result::Ok(NfTypeAnyOf::MbUpf),
            "NSWOF" => std::result::Result::Ok(NfTypeAnyOf::Nswof),
            "PKMF" => std::result::Result::Ok(NfTypeAnyOf::Pkmf),
            "MNPF" => std::result::Result::Ok(NfTypeAnyOf::Mnpf),
            "SMS_GMSC" => std::result::Result::Ok(NfTypeAnyOf::SmsGmsc),
            "SMS_IWMSC" => std::result::Result::Ok(NfTypeAnyOf::SmsIwmsc),
            "MBSF" => std::result::Result::Ok(NfTypeAnyOf::Mbsf),
            "MBSTF" => std::result::Result::Ok(NfTypeAnyOf::Mbstf),
            "PANF" => std::result::Result::Ok(NfTypeAnyOf::Panf),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// This represents the identifier of the ng-eNB ID as specified in clause 9.3.1.8 of  3GPP TS 38.413. The value of the ng-eNB ID shall be encoded in hexadecimal representation.  Each character in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and  shall represent 4 bits. The padding 0 shall be added to make multiple nibbles, so the most  significant character representing the padding 0 if required together with the 4 most  significant bits of the ng-eNB ID shall appear first in the string, and the character  representing the 4 least significant bit of the ng-eNB ID (to form a nibble) shall appear last  in the string.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NgeNbId(String);

impl std::convert::From<String> for NgeNbId {
    fn from(x: String) -> Self {
        NgeNbId(x)
    }
}

impl std::string::ToString for NgeNbId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for NgeNbId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(NgeNbId(x.to_string()))
    }
}

impl std::convert::From<NgeNbId> for String {
    fn from(x: NgeNbId) -> Self {
        x.0
    }
}

impl std::ops::Deref for NgeNbId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for NgeNbId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// This represents the Network Identifier, which together with a PLMN ID is used to identify an SNPN (see 3GPP TS 23.003 and 3GPP TS 23.501 clause 5.30.2.1).
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Nid(String);

impl std::convert::From<String> for Nid {
    fn from(x: String) -> Self {
        Nid(x)
    }
}

impl std::string::ToString for Nid {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Nid {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Nid(x.to_string()))
    }
}

impl std::convert::From<Nid> for String {
    fn from(x: Nid) -> Self {
        x.0
    }
}

impl std::ops::Deref for Nid {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Nid {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NiddInformation {
    #[serde(rename = "afId")]
    pub af_id: String,

    /// String identifying a Gpsi shall contain either an External Id or an MSISDN.  It shall be formatted as follows -External Identifier= \"extid-'extid', where 'extid'  shall be formatted according to clause 19.7.2 of 3GPP TS 23.003 that describes an  External Identifier.
    #[serde(rename = "gpsi")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gpsi: Option<String>,

    /// String identifying External Group Identifier that identifies a group made up of one or more  subscriptions associated to a group of IMSIs, as specified in clause 19.7.3 of 3GPP TS 23.003.
    #[serde(rename = "extGroupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ext_group_id: Option<String>,
}

impl NiddInformation {
    #[allow(clippy::new_without_default)]
    pub fn new(af_id: String) -> NiddInformation {
        NiddInformation {
            af_id,
            gpsi: None,
            ext_group_id: None,
        }
    }
}

/// Converts the NiddInformation value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NiddInformation {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("afId".to_string()),
            Some(self.af_id.to_string()),
            self.gpsi
                .as_ref()
                .map(|gpsi| vec!["gpsi".to_string(), gpsi.to_string()].join(",")),
            self.ext_group_id.as_ref().map(|ext_group_id| {
                vec!["extGroupId".to_string(), ext_group_id.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NiddInformation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NiddInformation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub af_id: Vec<String>,
            pub gpsi: Vec<String>,
            pub ext_group_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NiddInformation".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "afId" => intermediate_rep.af_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "gpsi" => intermediate_rep.gpsi.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "extGroupId" => intermediate_rep.ext_group_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NiddInformation".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NiddInformation {
            af_id: intermediate_rep
                .af_id
                .into_iter()
                .next()
                .ok_or_else(|| "afId missing in NiddInformation".to_string())?,
            gpsi: intermediate_rep.gpsi.into_iter().next(),
            ext_group_id: intermediate_rep.ext_group_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NiddInformation> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NiddInformation>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NiddInformation>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NiddInformation - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<NiddInformation>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NiddInformation as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NiddInformation - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Indicates changes on a resource.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NotifyItem {
    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "resourceId")]
    pub resource_id: String,

    #[serde(rename = "changes")]
    pub changes: Vec<models::ChangeItem>,
}

impl NotifyItem {
    #[allow(clippy::new_without_default)]
    pub fn new(resource_id: String, changes: Vec<models::ChangeItem>) -> NotifyItem {
        NotifyItem {
            resource_id,
            changes,
        }
    }
}

/// Converts the NotifyItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NotifyItem {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("resourceId".to_string()),
            Some(self.resource_id.to_string()),
            // Skipping changes in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NotifyItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NotifyItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub resource_id: Vec<String>,
            pub changes: Vec<Vec<models::ChangeItem>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NotifyItem".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "resourceId" => intermediate_rep.resource_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "changes" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in NotifyItem"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NotifyItem".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NotifyItem {
            resource_id: intermediate_rep
                .resource_id
                .into_iter()
                .next()
                .ok_or_else(|| "resourceId missing in NotifyItem".to_string())?,
            changes: intermediate_rep
                .changes
                .into_iter()
                .next()
                .ok_or_else(|| "changes missing in NotifyItem".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NotifyItem> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NotifyItem>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NotifyItem>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NotifyItem - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<NotifyItem> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NotifyItem as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NotifyItem - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// 36-bit string identifying an NR Cell Id as specified in clause 9.3.1.7 of 3GPP TS 38.413,  in hexadecimal representation. Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character  representing the 4 most significant bits of the Cell Id shall appear first in the string, and  the character representing the 4 least significant bit of the Cell Id shall appear last in the  string.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NrCellId(String);

impl std::convert::From<String> for NrCellId {
    fn from(x: String) -> Self {
        NrCellId(x)
    }
}

impl std::string::ToString for NrCellId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for NrCellId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(NrCellId(x.to_string()))
    }
}

impl std::convert::From<NrCellId> for String {
    fn from(x: NrCellId) -> Self {
        x.0
    }
}

impl std::ops::Deref for NrCellId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for NrCellId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Contains NR V2X services authorized information.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NrV2xAuth {
    #[serde(rename = "vehicleUeAuth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub vehicle_ue_auth: Option<models::UeAuth>,

    #[serde(rename = "pedestrianUeAuth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pedestrian_ue_auth: Option<models::UeAuth>,
}

impl NrV2xAuth {
    #[allow(clippy::new_without_default)]
    pub fn new() -> NrV2xAuth {
        NrV2xAuth {
            vehicle_ue_auth: None,
            pedestrian_ue_auth: None,
        }
    }
}

/// Converts the NrV2xAuth value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for NrV2xAuth {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping vehicleUeAuth in query parameter serialization

            // Skipping pedestrianUeAuth in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NrV2xAuth value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NrV2xAuth {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub vehicle_ue_auth: Vec<models::UeAuth>,
            pub pedestrian_ue_auth: Vec<models::UeAuth>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing NrV2xAuth".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "vehicleUeAuth" => intermediate_rep.vehicle_ue_auth.push(
                        <models::UeAuth as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "pedestrianUeAuth" => intermediate_rep.pedestrian_ue_auth.push(
                        <models::UeAuth as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing NrV2xAuth".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NrV2xAuth {
            vehicle_ue_auth: intermediate_rep.vehicle_ue_auth.into_iter().next(),
            pedestrian_ue_auth: intermediate_rep.pedestrian_ue_auth.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NrV2xAuth> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<NrV2xAuth>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<NrV2xAuth>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for NrV2xAuth - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<NrV2xAuth> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <NrV2xAuth as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into NrV2xAuth - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// String providing a Network Slice Simultaneous Registration Group. See clause 5.15.12 of  3GPP TS 23.501
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NsSrg(String);

impl std::convert::From<String> for NsSrg {
    fn from(x: String) -> Self {
        NsSrg(x)
    }
}

impl std::string::ToString for NsSrg {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for NsSrg {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(NsSrg(x.to_string()))
    }
}

impl std::convert::From<NsSrg> for String {
    fn from(x: NsSrg) -> Self {
        x.0
    }
}

impl std::ops::Deref for NsSrg {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for NsSrg {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Nssai {
    /// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  tableÂ 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.
    #[serde(rename = "supportedFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_features: Option<String>,

    #[serde(rename = "defaultSingleNssais")]
    pub default_single_nssais: Vec<models::Snssai>,

    #[serde(rename = "singleNssais")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub single_nssais: Option<Vec<models::Snssai>>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "provisioningTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provisioning_time: Option<chrono::DateTime<chrono::Utc>>,

    /// A map(list of key-value pairs) where singleNssai serves as key of AdditionalSnssaiData
    #[serde(rename = "additionalSnssaiData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_snssai_data:
        Option<std::collections::HashMap<String, models::AdditionalSnssaiData>>,

    #[serde(rename = "suppressNssrgInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suppress_nssrg_ind: Option<bool>,
}

impl Nssai {
    #[allow(clippy::new_without_default)]
    pub fn new(default_single_nssais: Vec<models::Snssai>) -> Nssai {
        Nssai {
            supported_features: None,
            default_single_nssais,
            single_nssais: None,
            provisioning_time: None,
            additional_snssai_data: None,
            suppress_nssrg_ind: None,
        }
    }
}

/// Converts the Nssai value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Nssai {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.supported_features.as_ref().map(|supported_features| {
                vec![
                    "supportedFeatures".to_string(),
                    supported_features.to_string(),
                ]
                .join(",")
            }),
            // Skipping defaultSingleNssais in query parameter serialization

            // Skipping singleNssais in query parameter serialization

            // Skipping provisioningTime in query parameter serialization

            // Skipping additionalSnssaiData in query parameter serialization
            // Skipping additionalSnssaiData in query parameter serialization
            self.suppress_nssrg_ind.as_ref().map(|suppress_nssrg_ind| {
                vec![
                    "suppressNssrgInd".to_string(),
                    suppress_nssrg_ind.to_string(),
                ]
                .join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Nssai value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Nssai {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub supported_features: Vec<String>,
            pub default_single_nssais: Vec<Vec<models::Snssai>>,
            pub single_nssais: Vec<Vec<models::Snssai>>,
            pub provisioning_time: Vec<chrono::DateTime<chrono::Utc>>,
            pub additional_snssai_data:
                Vec<std::collections::HashMap<String, models::AdditionalSnssaiData>>,
            pub suppress_nssrg_ind: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Nssai".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "supportedFeatures" => intermediate_rep.supported_features.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "defaultSingleNssais" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Nssai"
                                .to_string(),
                        )
                    }
                    "singleNssais" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Nssai"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "provisioningTime" => intermediate_rep.provisioning_time.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "additionalSnssaiData" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Nssai"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "suppressNssrgInd" => intermediate_rep.suppress_nssrg_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Nssai".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Nssai {
            supported_features: intermediate_rep.supported_features.into_iter().next(),
            default_single_nssais: intermediate_rep
                .default_single_nssais
                .into_iter()
                .next()
                .ok_or_else(|| "defaultSingleNssais missing in Nssai".to_string())?,
            single_nssais: intermediate_rep.single_nssais.into_iter().next(),
            provisioning_time: intermediate_rep.provisioning_time.into_iter().next(),
            additional_snssai_data: intermediate_rep.additional_snssai_data.into_iter().next(),
            suppress_nssrg_ind: intermediate_rep.suppress_nssrg_ind.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Nssai> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Nssai>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Nssai>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Nssai - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Nssai> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Nssai as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Nssai - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// JSON's null value.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum NullValue {
    #[serde(rename = "null")]
    Null,
}

impl std::fmt::Display for NullValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            NullValue::Null => write!(f, "null"),
        }
    }
}

impl std::str::FromStr for NullValue {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "null" => std::result::Result::Ok(NullValue::Null),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// The enumeration OdbPacketServices defines the Barring of Packet Oriented Services. See 3GPP TS 23.015 for further description. It shall comply with the provisions defined in table 5.7.3.2-1
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OdbPacketServices {}

impl OdbPacketServices {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OdbPacketServices {
        OdbPacketServices {}
    }
}

/// Converts the OdbPacketServices value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OdbPacketServices {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OdbPacketServices value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OdbPacketServices {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing OdbPacketServices".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing OdbPacketServices".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OdbPacketServices {})
    }
}

// Methods for converting between header::IntoHeaderValue<OdbPacketServices> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OdbPacketServices>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<OdbPacketServices>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for OdbPacketServices - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<OdbPacketServices>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <OdbPacketServices as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into OdbPacketServices - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OperationMode {}

impl OperationMode {
    #[allow(clippy::new_without_default)]
    pub fn new() -> OperationMode {
        OperationMode {}
    }
}

/// Converts the OperationMode value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OperationMode {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OperationMode value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OperationMode {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing OperationMode".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing OperationMode".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OperationMode {})
    }
}

// Methods for converting between header::IntoHeaderValue<OperationMode> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OperationMode>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<OperationMode>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for OperationMode - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OperationMode> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <OperationMode as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into OperationMode - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum OperationModeAnyOf {
    #[serde(rename = "WB_S1")]
    WbS1,
    #[serde(rename = "NB_S1")]
    NbS1,
    #[serde(rename = "WB_N1")]
    WbN1,
    #[serde(rename = "NB_N1")]
    NbN1,
}

impl std::fmt::Display for OperationModeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            OperationModeAnyOf::WbS1 => write!(f, "WB_S1"),
            OperationModeAnyOf::NbS1 => write!(f, "NB_S1"),
            OperationModeAnyOf::WbN1 => write!(f, "WB_N1"),
            OperationModeAnyOf::NbN1 => write!(f, "NB_N1"),
        }
    }
}

impl std::str::FromStr for OperationModeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "WB_S1" => std::result::Result::Ok(OperationModeAnyOf::WbS1),
            "NB_S1" => std::result::Result::Ok(OperationModeAnyOf::NbS1),
            "WB_N1" => std::result::Result::Ok(OperationModeAnyOf::WbN1),
            "NB_N1" => std::result::Result::Ok(OperationModeAnyOf::NbN1),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Indicates value of orientation angle.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Orientation(i32);

impl std::convert::From<i32> for Orientation {
    fn from(x: i32) -> Self {
        Orientation(x)
    }
}

impl std::convert::From<Orientation> for i32 {
    fn from(x: Orientation) -> Self {
        x.0
    }
}

impl std::ops::Deref for Orientation {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for Orientation {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// Represents the Operating System of the served UE.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OsId(uuid::Uuid);

impl std::convert::From<uuid::Uuid> for OsId {
    fn from(x: uuid::Uuid) -> Self {
        OsId(x)
    }
}

impl std::convert::From<OsId> for uuid::Uuid {
    fn from(x: OsId) -> Self {
        x.0
    }
}

impl std::ops::Deref for OsId {
    type Target = uuid::Uuid;
    fn deref(&self) -> &uuid::Uuid {
        &self.0
    }
}

impl std::ops::DerefMut for OsId {
    fn deref_mut(&mut self) -> &mut uuid::Uuid {
        &mut self.0
    }
}

/// The execution report result on failed modification.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PatchResult {
    /// The execution report contains an array of report items. Each report item indicates one  failed modification.
    #[serde(rename = "report")]
    pub report: Vec<models::ReportItem>,
}

impl PatchResult {
    #[allow(clippy::new_without_default)]
    pub fn new(report: Vec<models::ReportItem>) -> PatchResult {
        PatchResult { report }
    }
}

/// Converts the PatchResult value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PatchResult {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping report in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PatchResult value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PatchResult {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub report: Vec<Vec<models::ReportItem>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PatchResult".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "report" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PatchResult"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PatchResult".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PatchResult {
            report: intermediate_rep
                .report
                .into_iter()
                .next()
                .ok_or_else(|| "report missing in PatchResult".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PatchResult> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PatchResult>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PatchResult>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PatchResult - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PatchResult> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PatchResult as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PatchResult - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PcfSelectionAssistanceInfo {
    /// String representing a Data Network as defined in clause 9A of 3GPP TS 23.003;  it shall contain either a DNN Network Identifier, or a full DNN with both the Network  Identifier and Operator Identifier, as specified in 3GPP TS 23.003 clause 9.1.1 and 9.1.2. It shall be coded as string in which the labels are separated by dots  (e.g. \"Label1.Label2.Label3\").
    #[serde(rename = "dnn")]
    pub dnn: String,

    #[serde(rename = "singleNssai")]
    pub single_nssai: models::Snssai,
}

impl PcfSelectionAssistanceInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(dnn: String, single_nssai: models::Snssai) -> PcfSelectionAssistanceInfo {
        PcfSelectionAssistanceInfo { dnn, single_nssai }
    }
}

/// Converts the PcfSelectionAssistanceInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PcfSelectionAssistanceInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("dnn".to_string()),
            Some(self.dnn.to_string()),
            // Skipping singleNssai in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PcfSelectionAssistanceInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PcfSelectionAssistanceInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub dnn: Vec<String>,
            pub single_nssai: Vec<models::Snssai>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PcfSelectionAssistanceInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "dnn" => intermediate_rep.dnn.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "singleNssai" => intermediate_rep.single_nssai.push(
                        <models::Snssai as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PcfSelectionAssistanceInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PcfSelectionAssistanceInfo {
            dnn: intermediate_rep
                .dnn
                .into_iter()
                .next()
                .ok_or_else(|| "dnn missing in PcfSelectionAssistanceInfo".to_string())?,
            single_nssai: intermediate_rep
                .single_nssai
                .into_iter()
                .next()
                .ok_or_else(|| "singleNssai missing in PcfSelectionAssistanceInfo".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PcfSelectionAssistanceInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PcfSelectionAssistanceInfo>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PcfSelectionAssistanceInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PcfSelectionAssistanceInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<PcfSelectionAssistanceInfo>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PcfSelectionAssistanceInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PcfSelectionAssistanceInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PduSession {
    /// String representing a Data Network as defined in clause 9A of 3GPP TS 23.003;  it shall contain either a DNN Network Identifier, or a full DNN with both the Network  Identifier and Operator Identifier, as specified in 3GPP TS 23.003 clause 9.1.1 and 9.1.2. It shall be coded as string in which the labels are separated by dots  (e.g. \"Label1.Label2.Label3\").
    #[serde(rename = "dnn")]
    pub dnn: String,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "smfInstanceId")]
    pub smf_instance_id: uuid::Uuid,

    #[serde(rename = "plmnId")]
    pub plmn_id: models::PlmnId,

    #[serde(rename = "singleNssai")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub single_nssai: Option<models::Snssai>,
}

impl PduSession {
    #[allow(clippy::new_without_default)]
    pub fn new(dnn: String, smf_instance_id: uuid::Uuid, plmn_id: models::PlmnId) -> PduSession {
        PduSession {
            dnn,
            smf_instance_id,
            plmn_id,
            single_nssai: None,
        }
    }
}

/// Converts the PduSession value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PduSession {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("dnn".to_string()),
            Some(self.dnn.to_string()),
            // Skipping smfInstanceId in query parameter serialization

            // Skipping plmnId in query parameter serialization

            // Skipping singleNssai in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PduSession value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PduSession {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub dnn: Vec<String>,
            pub smf_instance_id: Vec<uuid::Uuid>,
            pub plmn_id: Vec<models::PlmnId>,
            pub single_nssai: Vec<models::Snssai>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PduSession".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "dnn" => intermediate_rep.dnn.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "smfInstanceId" => intermediate_rep.smf_instance_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "plmnId" => intermediate_rep.plmn_id.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "singleNssai" => intermediate_rep.single_nssai.push(
                        <models::Snssai as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PduSession".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PduSession {
            dnn: intermediate_rep
                .dnn
                .into_iter()
                .next()
                .ok_or_else(|| "dnn missing in PduSession".to_string())?,
            smf_instance_id: intermediate_rep
                .smf_instance_id
                .into_iter()
                .next()
                .ok_or_else(|| "smfInstanceId missing in PduSession".to_string())?,
            plmn_id: intermediate_rep
                .plmn_id
                .into_iter()
                .next()
                .ok_or_else(|| "plmnId missing in PduSession".to_string())?,
            single_nssai: intermediate_rep.single_nssai.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PduSession> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PduSession>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PduSession>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PduSession - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PduSession> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PduSession as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PduSession - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PduSessionContinuityInd {}

impl PduSessionContinuityInd {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PduSessionContinuityInd {
        PduSessionContinuityInd {}
    }
}

/// Converts the PduSessionContinuityInd value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PduSessionContinuityInd {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PduSessionContinuityInd value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PduSessionContinuityInd {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PduSessionContinuityInd".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PduSessionContinuityInd".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PduSessionContinuityInd {})
    }
}

// Methods for converting between header::IntoHeaderValue<PduSessionContinuityInd> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PduSessionContinuityInd>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PduSessionContinuityInd>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PduSessionContinuityInd - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<PduSessionContinuityInd>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PduSessionContinuityInd as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PduSessionContinuityInd - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PduSessionContinuityIndAnyOf {
    #[serde(rename = "MAINTAIN_PDUSESSION")]
    MaintainPdusession,
    #[serde(rename = "RECONNECT_PDUSESSION")]
    ReconnectPdusession,
    #[serde(rename = "RELEASE_PDUSESSION")]
    ReleasePdusession,
}

impl std::fmt::Display for PduSessionContinuityIndAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PduSessionContinuityIndAnyOf::MaintainPdusession => write!(f, "MAINTAIN_PDUSESSION"),
            PduSessionContinuityIndAnyOf::ReconnectPdusession => write!(f, "RECONNECT_PDUSESSION"),
            PduSessionContinuityIndAnyOf::ReleasePdusession => write!(f, "RELEASE_PDUSESSION"),
        }
    }
}

impl std::str::FromStr for PduSessionContinuityIndAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "MAINTAIN_PDUSESSION" => {
                std::result::Result::Ok(PduSessionContinuityIndAnyOf::MaintainPdusession)
            }
            "RECONNECT_PDUSESSION" => {
                std::result::Result::Ok(PduSessionContinuityIndAnyOf::ReconnectPdusession)
            }
            "RELEASE_PDUSESSION" => {
                std::result::Result::Ok(PduSessionContinuityIndAnyOf::ReleasePdusession)
            }
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// PduSessionType indicates the type of a PDU session. It shall comply with the provisions defined in table 5.4.3.3-1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PduSessionType(String);

impl PduSessionType {
    #[allow(clippy::new_without_default)]
    pub fn new(s: String) -> PduSessionType {
        PduSessionType(s)
    }
}

/// Converts the PduSessionType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PduSessionType {
    fn to_string(&self) -> String {
        self.0.clone()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PduSessionType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PduSessionType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(PduSessionType(s.to_string()))
    }
}

// Methods for converting between header::IntoHeaderValue<PduSessionType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PduSessionType>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PduSessionType>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PduSessionType - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PduSessionType> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PduSessionType as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PduSessionType - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PduSessionTypeAnyOf {
    #[serde(rename = "IPV4")]
    Ipv4,
    #[serde(rename = "IPV6")]
    Ipv6,
    #[serde(rename = "IPV4V6")]
    Ipv4V6,
    #[serde(rename = "UNSTRUCTURED")]
    Unstructured,
    #[serde(rename = "ETHERNET")]
    Ethernet,
}

impl std::fmt::Display for PduSessionTypeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PduSessionTypeAnyOf::Ipv4 => write!(f, "IPV4"),
            PduSessionTypeAnyOf::Ipv6 => write!(f, "IPV6"),
            PduSessionTypeAnyOf::Ipv4V6 => write!(f, "IPV4V6"),
            PduSessionTypeAnyOf::Unstructured => write!(f, "UNSTRUCTURED"),
            PduSessionTypeAnyOf::Ethernet => write!(f, "ETHERNET"),
        }
    }
}

impl std::str::FromStr for PduSessionTypeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "IPV4" => std::result::Result::Ok(PduSessionTypeAnyOf::Ipv4),
            "IPV6" => std::result::Result::Ok(PduSessionTypeAnyOf::Ipv6),
            "IPV4V6" => std::result::Result::Ok(PduSessionTypeAnyOf::Ipv4V6),
            "UNSTRUCTURED" => std::result::Result::Ok(PduSessionTypeAnyOf::Unstructured),
            "ETHERNET" => std::result::Result::Ok(PduSessionTypeAnyOf::Ethernet),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PduSessionTypes {
    #[serde(rename = "defaultSessionType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_session_type: Option<models::PduSessionType>,

    #[serde(rename = "allowedSessionTypes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allowed_session_types: Option<Vec<models::PduSessionType>>,
}

impl PduSessionTypes {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PduSessionTypes {
        PduSessionTypes {
            default_session_type: None,
            allowed_session_types: None,
        }
    }
}

/// Converts the PduSessionTypes value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PduSessionTypes {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping defaultSessionType in query parameter serialization

            // Skipping allowedSessionTypes in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PduSessionTypes value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PduSessionTypes {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub default_session_type: Vec<models::PduSessionType>,
            pub allowed_session_types: Vec<Vec<models::PduSessionType>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PduSessionTypes".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "defaultSessionType" => intermediate_rep.default_session_type.push(
                        <models::PduSessionType as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "allowedSessionTypes" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PduSessionTypes"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PduSessionTypes".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PduSessionTypes {
            default_session_type: intermediate_rep.default_session_type.into_iter().next(),
            allowed_session_types: intermediate_rep.allowed_session_types.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PduSessionTypes> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PduSessionTypes>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PduSessionTypes>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PduSessionTypes - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<PduSessionTypes>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PduSessionTypes as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PduSessionTypes - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PgwInfo {
    /// String representing a Data Network as defined in clause 9A of 3GPP TS 23.003;  it shall contain either a DNN Network Identifier, or a full DNN with both the Network  Identifier and Operator Identifier, as specified in 3GPP TS 23.003 clause 9.1.1 and 9.1.2. It shall be coded as string in which the labels are separated by dots  (e.g. \"Label1.Label2.Label3\").
    #[serde(rename = "dnn")]
    pub dnn: String,

    /// Fully Qualified Domain Name
    #[serde(rename = "pgwFqdn")]
    pub pgw_fqdn: String,

    #[serde(rename = "pgwIpAddr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pgw_ip_addr: Option<models::IpAddress>,

    #[serde(rename = "plmnId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub plmn_id: Option<models::PlmnId>,

    #[serde(rename = "epdgInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub epdg_ind: Option<bool>,

    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "pcfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pcf_id: Option<uuid::Uuid>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "registrationTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub registration_time: Option<chrono::DateTime<chrono::Utc>>,
}

impl PgwInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(dnn: String, pgw_fqdn: String) -> PgwInfo {
        PgwInfo {
            dnn,
            pgw_fqdn,
            pgw_ip_addr: None,
            plmn_id: None,
            epdg_ind: Some(false),
            pcf_id: None,
            registration_time: None,
        }
    }
}

/// Converts the PgwInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PgwInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("dnn".to_string()),
            Some(self.dnn.to_string()),
            Some("pgwFqdn".to_string()),
            Some(self.pgw_fqdn.to_string()),
            // Skipping pgwIpAddr in query parameter serialization

            // Skipping plmnId in query parameter serialization
            self.epdg_ind
                .as_ref()
                .map(|epdg_ind| vec!["epdgInd".to_string(), epdg_ind.to_string()].join(",")),
            // Skipping pcfId in query parameter serialization

            // Skipping registrationTime in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PgwInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PgwInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub dnn: Vec<String>,
            pub pgw_fqdn: Vec<String>,
            pub pgw_ip_addr: Vec<models::IpAddress>,
            pub plmn_id: Vec<models::PlmnId>,
            pub epdg_ind: Vec<bool>,
            pub pcf_id: Vec<uuid::Uuid>,
            pub registration_time: Vec<chrono::DateTime<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PgwInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "dnn" => intermediate_rep.dnn.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "pgwFqdn" => intermediate_rep.pgw_fqdn.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "pgwIpAddr" => intermediate_rep.pgw_ip_addr.push(
                        <models::IpAddress as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "plmnId" => intermediate_rep.plmn_id.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "epdgInd" => intermediate_rep.epdg_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "pcfId" => intermediate_rep.pcf_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "registrationTime" => intermediate_rep.registration_time.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PgwInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PgwInfo {
            dnn: intermediate_rep
                .dnn
                .into_iter()
                .next()
                .ok_or_else(|| "dnn missing in PgwInfo".to_string())?,
            pgw_fqdn: intermediate_rep
                .pgw_fqdn
                .into_iter()
                .next()
                .ok_or_else(|| "pgwFqdn missing in PgwInfo".to_string())?,
            pgw_ip_addr: intermediate_rep.pgw_ip_addr.into_iter().next(),
            plmn_id: intermediate_rep.plmn_id.into_iter().next(),
            epdg_ind: intermediate_rep.epdg_ind.into_iter().next(),
            pcf_id: intermediate_rep.pcf_id.into_iter().next(),
            registration_time: intermediate_rep.registration_time.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PgwInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PgwInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PgwInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PgwInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PgwInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PgwInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PgwInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Integer value identifying the physical cell identity (PCI), as definition of \"PhysCellId\" IE  in clause 6.3.2 of 3GPP TS 38.331.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PhysCellId(i32);

impl std::convert::From<i32> for PhysCellId {
    fn from(x: i32) -> Self {
        PhysCellId(x)
    }
}

impl std::convert::From<PhysCellId> for i32 {
    fn from(x: PhysCellId) -> Self {
        x.0
    }
}

impl std::ops::Deref for PhysCellId {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for PhysCellId {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PlmnEcInfo {
    #[serde(rename = "plmnId")]
    pub plmn_id: models::PlmnId,

    #[serde(rename = "ecRestrictionDataWb")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ec_restriction_data_wb: Option<models::EcRestrictionDataWb>,

    #[serde(rename = "ecRestrictionDataNb")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ec_restriction_data_nb: Option<bool>,
}

impl PlmnEcInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(plmn_id: models::PlmnId) -> PlmnEcInfo {
        PlmnEcInfo {
            plmn_id,
            ec_restriction_data_wb: None,
            ec_restriction_data_nb: Some(false),
        }
    }
}

/// Converts the PlmnEcInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PlmnEcInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping plmnId in query parameter serialization

            // Skipping ecRestrictionDataWb in query parameter serialization
            self.ec_restriction_data_nb
                .as_ref()
                .map(|ec_restriction_data_nb| {
                    vec![
                        "ecRestrictionDataNb".to_string(),
                        ec_restriction_data_nb.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PlmnEcInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PlmnEcInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub plmn_id: Vec<models::PlmnId>,
            pub ec_restriction_data_wb: Vec<models::EcRestrictionDataWb>,
            pub ec_restriction_data_nb: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PlmnEcInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "plmnId" => intermediate_rep.plmn_id.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ecRestrictionDataWb" => intermediate_rep.ec_restriction_data_wb.push(
                        <models::EcRestrictionDataWb as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ecRestrictionDataNb" => intermediate_rep.ec_restriction_data_nb.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PlmnEcInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PlmnEcInfo {
            plmn_id: intermediate_rep
                .plmn_id
                .into_iter()
                .next()
                .ok_or_else(|| "plmnId missing in PlmnEcInfo".to_string())?,
            ec_restriction_data_wb: intermediate_rep.ec_restriction_data_wb.into_iter().next(),
            ec_restriction_data_nb: intermediate_rep.ec_restriction_data_nb.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PlmnEcInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PlmnEcInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PlmnEcInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PlmnEcInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PlmnEcInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PlmnEcInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PlmnEcInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// When PlmnId needs to be converted to string (e.g. when used in maps as key), the string  shall be composed of three digits \"mcc\" followed by \"-\" and two or three digits \"mnc\".
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PlmnId {
    /// Mobile Country Code part of the PLMN, comprising 3 digits, as defined in clause 9.3.3.5 of 3GPP TS 38.413.
    #[serde(rename = "mcc")]
    pub mcc: String,

    /// Mobile Network Code part of the PLMN, comprising 2 or 3 digits, as defined in clause 9.3.3.5 of 3GPP TS 38.413.
    #[serde(rename = "mnc")]
    pub mnc: String,
}

impl PlmnId {
    #[allow(clippy::new_without_default)]
    pub fn new(mcc: String, mnc: String) -> PlmnId {
        PlmnId { mcc, mnc }
    }
}

/// Converts the PlmnId value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PlmnId {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("mcc".to_string()),
            Some(self.mcc.to_string()),
            Some("mnc".to_string()),
            Some(self.mnc.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PlmnId value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PlmnId {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub mcc: Vec<String>,
            pub mnc: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PlmnId".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "mcc" => intermediate_rep.mcc.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "mnc" => intermediate_rep.mnc.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PlmnId".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PlmnId {
            mcc: intermediate_rep
                .mcc
                .into_iter()
                .next()
                .ok_or_else(|| "mcc missing in PlmnId".to_string())?,
            mnc: intermediate_rep
                .mnc
                .into_iter()
                .next()
                .ok_or_else(|| "mnc missing in PlmnId".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PlmnId> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PlmnId>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PlmnId>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PlmnId - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PlmnId> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PlmnId as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PlmnId - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains the serving core network operator PLMN ID and, for an SNPN, the NID that together with the PLMN ID identifies the SNPN.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PlmnIdNid {
    /// Mobile Country Code part of the PLMN, comprising 3 digits, as defined in clause 9.3.3.5 of 3GPP TS 38.413.
    #[serde(rename = "mcc")]
    pub mcc: String,

    /// Mobile Network Code part of the PLMN, comprising 2 or 3 digits, as defined in clause 9.3.3.5 of 3GPP TS 38.413.
    #[serde(rename = "mnc")]
    pub mnc: String,

    /// This represents the Network Identifier, which together with a PLMN ID is used to identify an SNPN (see 3GPP TS 23.003 and 3GPP TS 23.501 clause 5.30.2.1).
    #[serde(rename = "nid")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nid: Option<String>,
}

impl PlmnIdNid {
    #[allow(clippy::new_without_default)]
    pub fn new(mcc: String, mnc: String) -> PlmnIdNid {
        PlmnIdNid {
            mcc,
            mnc,
            nid: None,
        }
    }
}

/// Converts the PlmnIdNid value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PlmnIdNid {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("mcc".to_string()),
            Some(self.mcc.to_string()),
            Some("mnc".to_string()),
            Some(self.mnc.to_string()),
            self.nid
                .as_ref()
                .map(|nid| vec!["nid".to_string(), nid.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PlmnIdNid value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PlmnIdNid {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub mcc: Vec<String>,
            pub mnc: Vec<String>,
            pub nid: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PlmnIdNid".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "mcc" => intermediate_rep.mcc.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "mnc" => intermediate_rep.mnc.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nid" => intermediate_rep.nid.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PlmnIdNid".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PlmnIdNid {
            mcc: intermediate_rep
                .mcc
                .into_iter()
                .next()
                .ok_or_else(|| "mcc missing in PlmnIdNid".to_string())?,
            mnc: intermediate_rep
                .mnc
                .into_iter()
                .next()
                .ok_or_else(|| "mnc missing in PlmnIdNid".to_string())?,
            nid: intermediate_rep.nid.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PlmnIdNid> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PlmnIdNid>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PlmnIdNid>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PlmnIdNid - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PlmnIdNid> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PlmnIdNid as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PlmnIdNid - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PlmnOperatorClass {
    #[serde(rename = "lcsClientClass")]
    pub lcs_client_class: models::LcsClientClass,

    #[serde(rename = "lcsClientIds")]
    pub lcs_client_ids: Vec<models::LcsClientId>,
}

impl PlmnOperatorClass {
    #[allow(clippy::new_without_default)]
    pub fn new(
        lcs_client_class: models::LcsClientClass,
        lcs_client_ids: Vec<models::LcsClientId>,
    ) -> PlmnOperatorClass {
        PlmnOperatorClass {
            lcs_client_class,
            lcs_client_ids,
        }
    }
}

/// Converts the PlmnOperatorClass value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PlmnOperatorClass {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping lcsClientClass in query parameter serialization
            Some("lcsClientIds".to_string()),
            Some(
                self.lcs_client_ids
                    .iter()
                    .map(|x| x.to_string())
                    .collect::<Vec<_>>()
                    .join(","),
            ),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PlmnOperatorClass value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PlmnOperatorClass {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub lcs_client_class: Vec<models::LcsClientClass>,
            pub lcs_client_ids: Vec<Vec<models::LcsClientId>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PlmnOperatorClass".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "lcsClientClass" => intermediate_rep.lcs_client_class.push(
                        <models::LcsClientClass as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "lcsClientIds" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in PlmnOperatorClass"
                            .to_string(),
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PlmnOperatorClass".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PlmnOperatorClass {
            lcs_client_class: intermediate_rep
                .lcs_client_class
                .into_iter()
                .next()
                .ok_or_else(|| "lcsClientClass missing in PlmnOperatorClass".to_string())?,
            lcs_client_ids: intermediate_rep
                .lcs_client_ids
                .into_iter()
                .next()
                .ok_or_else(|| "lcsClientIds missing in PlmnOperatorClass".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PlmnOperatorClass> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PlmnOperatorClass>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PlmnOperatorClass>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PlmnOperatorClass - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<PlmnOperatorClass>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PlmnOperatorClass as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PlmnOperatorClass - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PlmnRestriction {
    #[serde(rename = "ratRestrictions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rat_restrictions: Option<Vec<models::RatType>>,

    #[serde(rename = "forbiddenAreas")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub forbidden_areas: Option<Vec<models::Area>>,

    #[serde(rename = "serviceAreaRestriction")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_area_restriction: Option<models::ServiceAreaRestriction>,

    #[serde(rename = "coreNetworkTypeRestrictions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub core_network_type_restrictions: Option<Vec<models::CoreNetworkType>>,

    #[serde(rename = "primaryRatRestrictions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub primary_rat_restrictions: Option<Vec<models::RatType>>,

    #[serde(rename = "secondaryRatRestrictions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub secondary_rat_restrictions: Option<Vec<models::RatType>>,
}

impl PlmnRestriction {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PlmnRestriction {
        PlmnRestriction {
            rat_restrictions: None,
            forbidden_areas: None,
            service_area_restriction: None,
            core_network_type_restrictions: None,
            primary_rat_restrictions: None,
            secondary_rat_restrictions: None,
        }
    }
}

/// Converts the PlmnRestriction value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PlmnRestriction {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping ratRestrictions in query parameter serialization

            // Skipping forbiddenAreas in query parameter serialization

            // Skipping serviceAreaRestriction in query parameter serialization

            // Skipping coreNetworkTypeRestrictions in query parameter serialization

            // Skipping primaryRatRestrictions in query parameter serialization

            // Skipping secondaryRatRestrictions in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PlmnRestriction value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PlmnRestriction {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub rat_restrictions: Vec<Vec<models::RatType>>,
            pub forbidden_areas: Vec<Vec<models::Area>>,
            pub service_area_restriction: Vec<models::ServiceAreaRestriction>,
            pub core_network_type_restrictions: Vec<Vec<models::CoreNetworkType>>,
            pub primary_rat_restrictions: Vec<Vec<models::RatType>>,
            pub secondary_rat_restrictions: Vec<Vec<models::RatType>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PlmnRestriction".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "ratRestrictions" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PlmnRestriction"
                                .to_string(),
                        )
                    }
                    "forbiddenAreas" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PlmnRestriction"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "serviceAreaRestriction" => intermediate_rep.service_area_restriction.push(
                        <models::ServiceAreaRestriction as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "coreNetworkTypeRestrictions" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PlmnRestriction"
                                .to_string(),
                        )
                    }
                    "primaryRatRestrictions" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PlmnRestriction"
                                .to_string(),
                        )
                    }
                    "secondaryRatRestrictions" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PlmnRestriction"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PlmnRestriction".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PlmnRestriction {
            rat_restrictions: intermediate_rep.rat_restrictions.into_iter().next(),
            forbidden_areas: intermediate_rep.forbidden_areas.into_iter().next(),
            service_area_restriction: intermediate_rep.service_area_restriction.into_iter().next(),
            core_network_type_restrictions: intermediate_rep
                .core_network_type_restrictions
                .into_iter()
                .next(),
            primary_rat_restrictions: intermediate_rep.primary_rat_restrictions.into_iter().next(),
            secondary_rat_restrictions: intermediate_rep
                .secondary_rat_restrictions
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PlmnRestriction> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PlmnRestriction>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PlmnRestriction>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PlmnRestriction - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<PlmnRestriction>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PlmnRestriction as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PlmnRestriction - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Ellipsoid Point.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Point {
    #[serde(rename = "shape")]
    pub shape: models::SupportedGadShapes,

    #[serde(rename = "point")]
    pub point: models::GeographicalCoordinates,
}

impl Point {
    #[allow(clippy::new_without_default)]
    pub fn new(shape: models::SupportedGadShapes, point: models::GeographicalCoordinates) -> Point {
        Point { shape, point }
    }
}

/// Converts the Point value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Point {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping shape in query parameter serialization

            // Skipping point in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Point value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Point {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub shape: Vec<models::SupportedGadShapes>,
            pub point: Vec<models::GeographicalCoordinates>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Point".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "shape" => intermediate_rep.shape.push(
                        <models::SupportedGadShapes as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "point" => intermediate_rep.point.push(
                        <models::GeographicalCoordinates as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Point".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Point {
            shape: intermediate_rep
                .shape
                .into_iter()
                .next()
                .ok_or_else(|| "shape missing in Point".to_string())?,
            point: intermediate_rep
                .point
                .into_iter()
                .next()
                .ok_or_else(|| "point missing in Point".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Point> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Point>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Point>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Point - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Point> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Point as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Point - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PointAllOf {
    #[serde(rename = "point")]
    pub point: models::GeographicalCoordinates,
}

impl PointAllOf {
    #[allow(clippy::new_without_default)]
    pub fn new(point: models::GeographicalCoordinates) -> PointAllOf {
        PointAllOf { point }
    }
}

/// Converts the PointAllOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PointAllOf {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping point in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PointAllOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PointAllOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub point: Vec<models::GeographicalCoordinates>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PointAllOf".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "point" => intermediate_rep.point.push(
                        <models::GeographicalCoordinates as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PointAllOf".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PointAllOf {
            point: intermediate_rep
                .point
                .into_iter()
                .next()
                .ok_or_else(|| "point missing in PointAllOf".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PointAllOf> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PointAllOf>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PointAllOf>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PointAllOf - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PointAllOf> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PointAllOf as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PointAllOf - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Ellipsoid point with altitude.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PointAltitude {
    #[serde(rename = "shape")]
    pub shape: models::SupportedGadShapes,

    #[serde(rename = "point")]
    pub point: models::GeographicalCoordinates,

    /// Indicates value of altitude.
    #[serde(rename = "altitude")]
    pub altitude: f64,
}

impl PointAltitude {
    #[allow(clippy::new_without_default)]
    pub fn new(
        shape: models::SupportedGadShapes,
        point: models::GeographicalCoordinates,
        altitude: f64,
    ) -> PointAltitude {
        PointAltitude {
            shape,
            point,
            altitude,
        }
    }
}

/// Converts the PointAltitude value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PointAltitude {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping shape in query parameter serialization

            // Skipping point in query parameter serialization
            Some("altitude".to_string()),
            Some(self.altitude.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PointAltitude value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PointAltitude {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub shape: Vec<models::SupportedGadShapes>,
            pub point: Vec<models::GeographicalCoordinates>,
            pub altitude: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PointAltitude".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "shape" => intermediate_rep.shape.push(
                        <models::SupportedGadShapes as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "point" => intermediate_rep.point.push(
                        <models::GeographicalCoordinates as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "altitude" => intermediate_rep.altitude.push(
                        <f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PointAltitude".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PointAltitude {
            shape: intermediate_rep
                .shape
                .into_iter()
                .next()
                .ok_or_else(|| "shape missing in PointAltitude".to_string())?,
            point: intermediate_rep
                .point
                .into_iter()
                .next()
                .ok_or_else(|| "point missing in PointAltitude".to_string())?,
            altitude: intermediate_rep
                .altitude
                .into_iter()
                .next()
                .ok_or_else(|| "altitude missing in PointAltitude".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PointAltitude> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PointAltitude>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PointAltitude>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PointAltitude - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PointAltitude> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PointAltitude as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PointAltitude - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PointAltitudeAllOf {
    #[serde(rename = "point")]
    pub point: models::GeographicalCoordinates,

    /// Indicates value of altitude.
    #[serde(rename = "altitude")]
    pub altitude: f64,
}

impl PointAltitudeAllOf {
    #[allow(clippy::new_without_default)]
    pub fn new(point: models::GeographicalCoordinates, altitude: f64) -> PointAltitudeAllOf {
        PointAltitudeAllOf { point, altitude }
    }
}

/// Converts the PointAltitudeAllOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PointAltitudeAllOf {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping point in query parameter serialization
            Some("altitude".to_string()),
            Some(self.altitude.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PointAltitudeAllOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PointAltitudeAllOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub point: Vec<models::GeographicalCoordinates>,
            pub altitude: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PointAltitudeAllOf".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "point" => intermediate_rep.point.push(
                        <models::GeographicalCoordinates as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "altitude" => intermediate_rep.altitude.push(
                        <f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PointAltitudeAllOf".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PointAltitudeAllOf {
            point: intermediate_rep
                .point
                .into_iter()
                .next()
                .ok_or_else(|| "point missing in PointAltitudeAllOf".to_string())?,
            altitude: intermediate_rep
                .altitude
                .into_iter()
                .next()
                .ok_or_else(|| "altitude missing in PointAltitudeAllOf".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PointAltitudeAllOf> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PointAltitudeAllOf>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PointAltitudeAllOf>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PointAltitudeAllOf - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<PointAltitudeAllOf>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PointAltitudeAllOf as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PointAltitudeAllOf - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Ellipsoid point with altitude and uncertainty ellipsoid.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PointAltitudeUncertainty {
    #[serde(rename = "shape")]
    pub shape: models::SupportedGadShapes,

    #[serde(rename = "point")]
    pub point: models::GeographicalCoordinates,

    /// Indicates value of altitude.
    #[serde(rename = "altitude")]
    pub altitude: f64,

    #[serde(rename = "uncertaintyEllipse")]
    pub uncertainty_ellipse: models::UncertaintyEllipse,

    /// Indicates value of uncertainty.
    #[serde(rename = "uncertaintyAltitude")]
    pub uncertainty_altitude: f32,

    /// Indicates value of confidence.
    #[serde(rename = "confidence")]
    pub confidence: u8,
}

impl PointAltitudeUncertainty {
    #[allow(clippy::new_without_default)]
    pub fn new(
        shape: models::SupportedGadShapes,
        point: models::GeographicalCoordinates,
        altitude: f64,
        uncertainty_ellipse: models::UncertaintyEllipse,
        uncertainty_altitude: f32,
        confidence: u8,
    ) -> PointAltitudeUncertainty {
        PointAltitudeUncertainty {
            shape,
            point,
            altitude,
            uncertainty_ellipse,
            uncertainty_altitude,
            confidence,
        }
    }
}

/// Converts the PointAltitudeUncertainty value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PointAltitudeUncertainty {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping shape in query parameter serialization

            // Skipping point in query parameter serialization
            Some("altitude".to_string()),
            Some(self.altitude.to_string()),
            // Skipping uncertaintyEllipse in query parameter serialization
            Some("uncertaintyAltitude".to_string()),
            Some(self.uncertainty_altitude.to_string()),
            Some("confidence".to_string()),
            Some(self.confidence.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PointAltitudeUncertainty value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PointAltitudeUncertainty {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub shape: Vec<models::SupportedGadShapes>,
            pub point: Vec<models::GeographicalCoordinates>,
            pub altitude: Vec<f64>,
            pub uncertainty_ellipse: Vec<models::UncertaintyEllipse>,
            pub uncertainty_altitude: Vec<f32>,
            pub confidence: Vec<u8>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PointAltitudeUncertainty".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "shape" => intermediate_rep.shape.push(
                        <models::SupportedGadShapes as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "point" => intermediate_rep.point.push(
                        <models::GeographicalCoordinates as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "altitude" => intermediate_rep.altitude.push(
                        <f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "uncertaintyEllipse" => intermediate_rep.uncertainty_ellipse.push(
                        <models::UncertaintyEllipse as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "uncertaintyAltitude" => intermediate_rep.uncertainty_altitude.push(
                        <f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "confidence" => intermediate_rep
                        .confidence
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PointAltitudeUncertainty".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PointAltitudeUncertainty {
            shape: intermediate_rep
                .shape
                .into_iter()
                .next()
                .ok_or_else(|| "shape missing in PointAltitudeUncertainty".to_string())?,
            point: intermediate_rep
                .point
                .into_iter()
                .next()
                .ok_or_else(|| "point missing in PointAltitudeUncertainty".to_string())?,
            altitude: intermediate_rep
                .altitude
                .into_iter()
                .next()
                .ok_or_else(|| "altitude missing in PointAltitudeUncertainty".to_string())?,
            uncertainty_ellipse: intermediate_rep
                .uncertainty_ellipse
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "uncertaintyEllipse missing in PointAltitudeUncertainty".to_string()
                })?,
            uncertainty_altitude: intermediate_rep
                .uncertainty_altitude
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "uncertaintyAltitude missing in PointAltitudeUncertainty".to_string()
                })?,
            confidence: intermediate_rep
                .confidence
                .into_iter()
                .next()
                .ok_or_else(|| "confidence missing in PointAltitudeUncertainty".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PointAltitudeUncertainty> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PointAltitudeUncertainty>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PointAltitudeUncertainty>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PointAltitudeUncertainty - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<PointAltitudeUncertainty>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PointAltitudeUncertainty as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PointAltitudeUncertainty - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PointAltitudeUncertaintyAllOf {
    #[serde(rename = "point")]
    pub point: models::GeographicalCoordinates,

    /// Indicates value of altitude.
    #[serde(rename = "altitude")]
    pub altitude: f64,

    #[serde(rename = "uncertaintyEllipse")]
    pub uncertainty_ellipse: models::UncertaintyEllipse,

    /// Indicates value of uncertainty.
    #[serde(rename = "uncertaintyAltitude")]
    pub uncertainty_altitude: f32,

    /// Indicates value of confidence.
    #[serde(rename = "confidence")]
    pub confidence: u8,
}

impl PointAltitudeUncertaintyAllOf {
    #[allow(clippy::new_without_default)]
    pub fn new(
        point: models::GeographicalCoordinates,
        altitude: f64,
        uncertainty_ellipse: models::UncertaintyEllipse,
        uncertainty_altitude: f32,
        confidence: u8,
    ) -> PointAltitudeUncertaintyAllOf {
        PointAltitudeUncertaintyAllOf {
            point,
            altitude,
            uncertainty_ellipse,
            uncertainty_altitude,
            confidence,
        }
    }
}

/// Converts the PointAltitudeUncertaintyAllOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PointAltitudeUncertaintyAllOf {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping point in query parameter serialization
            Some("altitude".to_string()),
            Some(self.altitude.to_string()),
            // Skipping uncertaintyEllipse in query parameter serialization
            Some("uncertaintyAltitude".to_string()),
            Some(self.uncertainty_altitude.to_string()),
            Some("confidence".to_string()),
            Some(self.confidence.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PointAltitudeUncertaintyAllOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PointAltitudeUncertaintyAllOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub point: Vec<models::GeographicalCoordinates>,
            pub altitude: Vec<f64>,
            pub uncertainty_ellipse: Vec<models::UncertaintyEllipse>,
            pub uncertainty_altitude: Vec<f32>,
            pub confidence: Vec<u8>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PointAltitudeUncertaintyAllOf".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "point" => intermediate_rep.point.push(
                        <models::GeographicalCoordinates as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "altitude" => intermediate_rep.altitude.push(
                        <f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "uncertaintyEllipse" => intermediate_rep.uncertainty_ellipse.push(
                        <models::UncertaintyEllipse as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "uncertaintyAltitude" => intermediate_rep.uncertainty_altitude.push(
                        <f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "confidence" => intermediate_rep
                        .confidence
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PointAltitudeUncertaintyAllOf"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PointAltitudeUncertaintyAllOf {
            point: intermediate_rep
                .point
                .into_iter()
                .next()
                .ok_or_else(|| "point missing in PointAltitudeUncertaintyAllOf".to_string())?,
            altitude: intermediate_rep
                .altitude
                .into_iter()
                .next()
                .ok_or_else(|| "altitude missing in PointAltitudeUncertaintyAllOf".to_string())?,
            uncertainty_ellipse: intermediate_rep
                .uncertainty_ellipse
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "uncertaintyEllipse missing in PointAltitudeUncertaintyAllOf".to_string()
                })?,
            uncertainty_altitude: intermediate_rep
                .uncertainty_altitude
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "uncertaintyAltitude missing in PointAltitudeUncertaintyAllOf".to_string()
                })?,
            confidence: intermediate_rep
                .confidence
                .into_iter()
                .next()
                .ok_or_else(|| "confidence missing in PointAltitudeUncertaintyAllOf".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PointAltitudeUncertaintyAllOf> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PointAltitudeUncertaintyAllOf>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PointAltitudeUncertaintyAllOf>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PointAltitudeUncertaintyAllOf - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<PointAltitudeUncertaintyAllOf>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PointAltitudeUncertaintyAllOf as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PointAltitudeUncertaintyAllOf - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

/// Ellipsoid point with uncertainty circle.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PointUncertaintyCircle {
    #[serde(rename = "shape")]
    pub shape: models::SupportedGadShapes,

    #[serde(rename = "point")]
    pub point: models::GeographicalCoordinates,

    /// Indicates value of uncertainty.
    #[serde(rename = "uncertainty")]
    pub uncertainty: f32,
}

impl PointUncertaintyCircle {
    #[allow(clippy::new_without_default)]
    pub fn new(
        shape: models::SupportedGadShapes,
        point: models::GeographicalCoordinates,
        uncertainty: f32,
    ) -> PointUncertaintyCircle {
        PointUncertaintyCircle {
            shape,
            point,
            uncertainty,
        }
    }
}

/// Converts the PointUncertaintyCircle value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PointUncertaintyCircle {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping shape in query parameter serialization

            // Skipping point in query parameter serialization
            Some("uncertainty".to_string()),
            Some(self.uncertainty.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PointUncertaintyCircle value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PointUncertaintyCircle {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub shape: Vec<models::SupportedGadShapes>,
            pub point: Vec<models::GeographicalCoordinates>,
            pub uncertainty: Vec<f32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PointUncertaintyCircle".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "shape" => intermediate_rep.shape.push(
                        <models::SupportedGadShapes as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "point" => intermediate_rep.point.push(
                        <models::GeographicalCoordinates as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "uncertainty" => intermediate_rep.uncertainty.push(
                        <f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PointUncertaintyCircle".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PointUncertaintyCircle {
            shape: intermediate_rep
                .shape
                .into_iter()
                .next()
                .ok_or_else(|| "shape missing in PointUncertaintyCircle".to_string())?,
            point: intermediate_rep
                .point
                .into_iter()
                .next()
                .ok_or_else(|| "point missing in PointUncertaintyCircle".to_string())?,
            uncertainty: intermediate_rep
                .uncertainty
                .into_iter()
                .next()
                .ok_or_else(|| "uncertainty missing in PointUncertaintyCircle".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PointUncertaintyCircle> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PointUncertaintyCircle>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PointUncertaintyCircle>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PointUncertaintyCircle - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<PointUncertaintyCircle>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PointUncertaintyCircle as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PointUncertaintyCircle - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PointUncertaintyCircleAllOf {
    #[serde(rename = "point")]
    pub point: models::GeographicalCoordinates,

    /// Indicates value of uncertainty.
    #[serde(rename = "uncertainty")]
    pub uncertainty: f32,
}

impl PointUncertaintyCircleAllOf {
    #[allow(clippy::new_without_default)]
    pub fn new(
        point: models::GeographicalCoordinates,
        uncertainty: f32,
    ) -> PointUncertaintyCircleAllOf {
        PointUncertaintyCircleAllOf { point, uncertainty }
    }
}

/// Converts the PointUncertaintyCircleAllOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PointUncertaintyCircleAllOf {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping point in query parameter serialization
            Some("uncertainty".to_string()),
            Some(self.uncertainty.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PointUncertaintyCircleAllOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PointUncertaintyCircleAllOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub point: Vec<models::GeographicalCoordinates>,
            pub uncertainty: Vec<f32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PointUncertaintyCircleAllOf".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "point" => intermediate_rep.point.push(
                        <models::GeographicalCoordinates as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "uncertainty" => intermediate_rep.uncertainty.push(
                        <f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PointUncertaintyCircleAllOf".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PointUncertaintyCircleAllOf {
            point: intermediate_rep
                .point
                .into_iter()
                .next()
                .ok_or_else(|| "point missing in PointUncertaintyCircleAllOf".to_string())?,
            uncertainty: intermediate_rep
                .uncertainty
                .into_iter()
                .next()
                .ok_or_else(|| "uncertainty missing in PointUncertaintyCircleAllOf".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PointUncertaintyCircleAllOf> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PointUncertaintyCircleAllOf>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PointUncertaintyCircleAllOf>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PointUncertaintyCircleAllOf - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<PointUncertaintyCircleAllOf>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PointUncertaintyCircleAllOf as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PointUncertaintyCircleAllOf - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Ellipsoid point with uncertainty ellipse.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PointUncertaintyEllipse {
    #[serde(rename = "shape")]
    pub shape: models::SupportedGadShapes,

    #[serde(rename = "point")]
    pub point: models::GeographicalCoordinates,

    #[serde(rename = "uncertaintyEllipse")]
    pub uncertainty_ellipse: models::UncertaintyEllipse,

    /// Indicates value of confidence.
    #[serde(rename = "confidence")]
    pub confidence: u8,
}

impl PointUncertaintyEllipse {
    #[allow(clippy::new_without_default)]
    pub fn new(
        shape: models::SupportedGadShapes,
        point: models::GeographicalCoordinates,
        uncertainty_ellipse: models::UncertaintyEllipse,
        confidence: u8,
    ) -> PointUncertaintyEllipse {
        PointUncertaintyEllipse {
            shape,
            point,
            uncertainty_ellipse,
            confidence,
        }
    }
}

/// Converts the PointUncertaintyEllipse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PointUncertaintyEllipse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping shape in query parameter serialization

            // Skipping point in query parameter serialization

            // Skipping uncertaintyEllipse in query parameter serialization
            Some("confidence".to_string()),
            Some(self.confidence.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PointUncertaintyEllipse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PointUncertaintyEllipse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub shape: Vec<models::SupportedGadShapes>,
            pub point: Vec<models::GeographicalCoordinates>,
            pub uncertainty_ellipse: Vec<models::UncertaintyEllipse>,
            pub confidence: Vec<u8>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PointUncertaintyEllipse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "shape" => intermediate_rep.shape.push(
                        <models::SupportedGadShapes as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "point" => intermediate_rep.point.push(
                        <models::GeographicalCoordinates as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "uncertaintyEllipse" => intermediate_rep.uncertainty_ellipse.push(
                        <models::UncertaintyEllipse as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "confidence" => intermediate_rep
                        .confidence
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PointUncertaintyEllipse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PointUncertaintyEllipse {
            shape: intermediate_rep
                .shape
                .into_iter()
                .next()
                .ok_or_else(|| "shape missing in PointUncertaintyEllipse".to_string())?,
            point: intermediate_rep
                .point
                .into_iter()
                .next()
                .ok_or_else(|| "point missing in PointUncertaintyEllipse".to_string())?,
            uncertainty_ellipse: intermediate_rep
                .uncertainty_ellipse
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "uncertaintyEllipse missing in PointUncertaintyEllipse".to_string()
                })?,
            confidence: intermediate_rep
                .confidence
                .into_iter()
                .next()
                .ok_or_else(|| "confidence missing in PointUncertaintyEllipse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PointUncertaintyEllipse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PointUncertaintyEllipse>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PointUncertaintyEllipse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PointUncertaintyEllipse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<PointUncertaintyEllipse>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PointUncertaintyEllipse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PointUncertaintyEllipse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PointUncertaintyEllipseAllOf {
    #[serde(rename = "point")]
    pub point: models::GeographicalCoordinates,

    #[serde(rename = "uncertaintyEllipse")]
    pub uncertainty_ellipse: models::UncertaintyEllipse,

    /// Indicates value of confidence.
    #[serde(rename = "confidence")]
    pub confidence: u8,
}

impl PointUncertaintyEllipseAllOf {
    #[allow(clippy::new_without_default)]
    pub fn new(
        point: models::GeographicalCoordinates,
        uncertainty_ellipse: models::UncertaintyEllipse,
        confidence: u8,
    ) -> PointUncertaintyEllipseAllOf {
        PointUncertaintyEllipseAllOf {
            point,
            uncertainty_ellipse,
            confidence,
        }
    }
}

/// Converts the PointUncertaintyEllipseAllOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PointUncertaintyEllipseAllOf {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping point in query parameter serialization

            // Skipping uncertaintyEllipse in query parameter serialization
            Some("confidence".to_string()),
            Some(self.confidence.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PointUncertaintyEllipseAllOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PointUncertaintyEllipseAllOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub point: Vec<models::GeographicalCoordinates>,
            pub uncertainty_ellipse: Vec<models::UncertaintyEllipse>,
            pub confidence: Vec<u8>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PointUncertaintyEllipseAllOf".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "point" => intermediate_rep.point.push(
                        <models::GeographicalCoordinates as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "uncertaintyEllipse" => intermediate_rep.uncertainty_ellipse.push(
                        <models::UncertaintyEllipse as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "confidence" => intermediate_rep
                        .confidence
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PointUncertaintyEllipseAllOf".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PointUncertaintyEllipseAllOf {
            point: intermediate_rep
                .point
                .into_iter()
                .next()
                .ok_or_else(|| "point missing in PointUncertaintyEllipseAllOf".to_string())?,
            uncertainty_ellipse: intermediate_rep
                .uncertainty_ellipse
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "uncertaintyEllipse missing in PointUncertaintyEllipseAllOf".to_string()
                })?,
            confidence: intermediate_rep
                .confidence
                .into_iter()
                .next()
                .ok_or_else(|| "confidence missing in PointUncertaintyEllipseAllOf".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PointUncertaintyEllipseAllOf> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PointUncertaintyEllipseAllOf>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PointUncertaintyEllipseAllOf>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PointUncertaintyEllipseAllOf - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<PointUncertaintyEllipseAllOf>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PointUncertaintyEllipseAllOf as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PointUncertaintyEllipseAllOf - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

/// Polygon.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Polygon {
    #[serde(rename = "shape")]
    pub shape: models::SupportedGadShapes,

    /// List of points.
    #[serde(rename = "pointList")]
    pub point_list: Vec<models::GeographicalCoordinates>,
}

impl Polygon {
    #[allow(clippy::new_without_default)]
    pub fn new(
        shape: models::SupportedGadShapes,
        point_list: Vec<models::GeographicalCoordinates>,
    ) -> Polygon {
        Polygon { shape, point_list }
    }
}

/// Converts the Polygon value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Polygon {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping shape in query parameter serialization

            // Skipping pointList in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Polygon value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Polygon {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub shape: Vec<models::SupportedGadShapes>,
            pub point_list: Vec<Vec<models::GeographicalCoordinates>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Polygon".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "shape" => intermediate_rep.shape.push(
                        <models::SupportedGadShapes as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "pointList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in Polygon"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Polygon".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Polygon {
            shape: intermediate_rep
                .shape
                .into_iter()
                .next()
                .ok_or_else(|| "shape missing in Polygon".to_string())?,
            point_list: intermediate_rep
                .point_list
                .into_iter()
                .next()
                .ok_or_else(|| "pointList missing in Polygon".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Polygon> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Polygon>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Polygon>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Polygon - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Polygon> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <Polygon as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into Polygon - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PolygonAllOf {
    /// List of points.
    #[serde(rename = "pointList")]
    pub point_list: Vec<models::GeographicalCoordinates>,
}

impl PolygonAllOf {
    #[allow(clippy::new_without_default)]
    pub fn new(point_list: Vec<models::GeographicalCoordinates>) -> PolygonAllOf {
        PolygonAllOf { point_list }
    }
}

/// Converts the PolygonAllOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PolygonAllOf {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping pointList in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PolygonAllOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PolygonAllOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub point_list: Vec<Vec<models::GeographicalCoordinates>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PolygonAllOf".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "pointList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in PolygonAllOf"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PolygonAllOf".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PolygonAllOf {
            point_list: intermediate_rep
                .point_list
                .into_iter()
                .next()
                .ok_or_else(|| "pointList missing in PolygonAllOf".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PolygonAllOf> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PolygonAllOf>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PolygonAllOf>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PolygonAllOf - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PolygonAllOf> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PolygonAllOf as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PolygonAllOf - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// The enumeration LoggingDurationMdt defines Logging Duration for MDT in the trace. See 3GPP TS 32.422 for further description of the values. It shall comply with the provisions defined in table 5.6.3.13-1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PositioningMethodMdt {}

impl PositioningMethodMdt {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PositioningMethodMdt {
        PositioningMethodMdt {}
    }
}

/// Converts the PositioningMethodMdt value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PositioningMethodMdt {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PositioningMethodMdt value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PositioningMethodMdt {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PositioningMethodMdt".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PositioningMethodMdt".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PositioningMethodMdt {})
    }
}

// Methods for converting between header::IntoHeaderValue<PositioningMethodMdt> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PositioningMethodMdt>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PositioningMethodMdt>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PositioningMethodMdt - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<PositioningMethodMdt>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PositioningMethodMdt as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PositioningMethodMdt - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PositioningMethodMdtAnyOf {
    #[serde(rename = "GNSS")]
    Gnss,
    #[serde(rename = "E_CELL_ID")]
    ECellId,
}

impl std::fmt::Display for PositioningMethodMdtAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PositioningMethodMdtAnyOf::Gnss => write!(f, "GNSS"),
            PositioningMethodMdtAnyOf::ECellId => write!(f, "E_CELL_ID"),
        }
    }
}

impl std::str::FromStr for PositioningMethodMdtAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "GNSS" => std::result::Result::Ok(PositioningMethodMdtAnyOf::Gnss),
            "E_CELL_ID" => std::result::Result::Ok(PositioningMethodMdtAnyOf::ECellId),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// The enumeration PreemptionCapability indicates the pre-emption capability of a request on other QoS flows. See clause 5.7.2.2 of 3GPP TS 23.501. It shall comply with the provisions defined in table 5.5.3.1-1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PreemptionCapability(String);

impl PreemptionCapability {
    #[allow(clippy::new_without_default)]
    pub fn new(s: String) -> PreemptionCapability {
        PreemptionCapability(s)
    }
}

/// Converts the PreemptionCapability value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PreemptionCapability {
    fn to_string(&self) -> String {
        self.0.clone()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PreemptionCapability value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PreemptionCapability {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(PreemptionCapability(s.to_string()))
    }
}

// Methods for converting between header::IntoHeaderValue<PreemptionCapability> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PreemptionCapability>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PreemptionCapability>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PreemptionCapability - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<PreemptionCapability>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PreemptionCapability as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PreemptionCapability - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PreemptionCapabilityAnyOf {
    #[serde(rename = "NOT_PREEMPT")]
    NotPreempt,
    #[serde(rename = "MAY_PREEMPT")]
    MayPreempt,
}

impl std::fmt::Display for PreemptionCapabilityAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PreemptionCapabilityAnyOf::NotPreempt => write!(f, "NOT_PREEMPT"),
            PreemptionCapabilityAnyOf::MayPreempt => write!(f, "MAY_PREEMPT"),
        }
    }
}

impl std::str::FromStr for PreemptionCapabilityAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "NOT_PREEMPT" => std::result::Result::Ok(PreemptionCapabilityAnyOf::NotPreempt),
            "MAY_PREEMPT" => std::result::Result::Ok(PreemptionCapabilityAnyOf::MayPreempt),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// The enumeration PreemptionVulnerability indicates the pre-emption vulnerability of the QoS flow to pre-emption from other QoS flows. See clause 5.7.2.2 of 3GPP TS 23.501. It shall comply with the provisions defined in table 5.5.3.2-1
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PreemptionVulnerability(String);

impl PreemptionVulnerability {
    #[allow(clippy::new_without_default)]
    pub fn new(s: String) -> PreemptionVulnerability {
        PreemptionVulnerability(s)
    }
}

/// Converts the PreemptionVulnerability value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PreemptionVulnerability {
    fn to_string(&self) -> String {
        self.0.clone()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PreemptionVulnerability value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PreemptionVulnerability {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(PreemptionVulnerability(s.to_string()))
    }
}

// Methods for converting between header::IntoHeaderValue<PreemptionVulnerability> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PreemptionVulnerability>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PreemptionVulnerability>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PreemptionVulnerability - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<PreemptionVulnerability>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PreemptionVulnerability as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PreemptionVulnerability - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PreemptionVulnerabilityAnyOf {
    #[serde(rename = "NOT_PREEMPTABLE")]
    NotPreemptable,
    #[serde(rename = "PREEMPTABLE")]
    Preemptable,
}

impl std::fmt::Display for PreemptionVulnerabilityAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PreemptionVulnerabilityAnyOf::NotPreemptable => write!(f, "NOT_PREEMPTABLE"),
            PreemptionVulnerabilityAnyOf::Preemptable => write!(f, "PREEMPTABLE"),
        }
    }
}

impl std::str::FromStr for PreemptionVulnerabilityAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "NOT_PREEMPTABLE" => {
                std::result::Result::Ok(PreemptionVulnerabilityAnyOf::NotPreemptable)
            }
            "PREEMPTABLE" => std::result::Result::Ok(PreemptionVulnerabilityAnyOf::Preemptable),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PrivacyCheckRelatedAction {}

impl PrivacyCheckRelatedAction {
    #[allow(clippy::new_without_default)]
    pub fn new() -> PrivacyCheckRelatedAction {
        PrivacyCheckRelatedAction {}
    }
}

/// Converts the PrivacyCheckRelatedAction value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PrivacyCheckRelatedAction {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PrivacyCheckRelatedAction value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PrivacyCheckRelatedAction {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PrivacyCheckRelatedAction".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PrivacyCheckRelatedAction".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PrivacyCheckRelatedAction {})
    }
}

// Methods for converting between header::IntoHeaderValue<PrivacyCheckRelatedAction> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PrivacyCheckRelatedAction>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PrivacyCheckRelatedAction>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PrivacyCheckRelatedAction - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<PrivacyCheckRelatedAction>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PrivacyCheckRelatedAction as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PrivacyCheckRelatedAction - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PrivacyCheckRelatedActionAnyOf {
    #[serde(rename = "LOCATION_NOT_ALLOWED")]
    NotAllowed,
    #[serde(rename = "LOCATION_ALLOWED_WITH_NOTIFICATION")]
    AllowedWithNotification,
    #[serde(rename = "LOCATION_ALLOWED_WITHOUT_NOTIFICATION")]
    AllowedWithoutNotification,
    #[serde(rename = "LOCATION_ALLOWED_WITHOUT_RESPONSE")]
    AllowedWithoutResponse,
    #[serde(rename = "LOCATION_RESTRICTED_WITHOUT_RESPONSE")]
    RestrictedWithoutResponse,
}

impl std::fmt::Display for PrivacyCheckRelatedActionAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PrivacyCheckRelatedActionAnyOf::NotAllowed => write!(f, "LOCATION_NOT_ALLOWED"),
            PrivacyCheckRelatedActionAnyOf::AllowedWithNotification => {
                write!(f, "LOCATION_ALLOWED_WITH_NOTIFICATION")
            }
            PrivacyCheckRelatedActionAnyOf::AllowedWithoutNotification => {
                write!(f, "LOCATION_ALLOWED_WITHOUT_NOTIFICATION")
            }
            PrivacyCheckRelatedActionAnyOf::AllowedWithoutResponse => {
                write!(f, "LOCATION_ALLOWED_WITHOUT_RESPONSE")
            }
            PrivacyCheckRelatedActionAnyOf::RestrictedWithoutResponse => {
                write!(f, "LOCATION_RESTRICTED_WITHOUT_RESPONSE")
            }
        }
    }
}

impl std::str::FromStr for PrivacyCheckRelatedActionAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "LOCATION_NOT_ALLOWED" => {
                std::result::Result::Ok(PrivacyCheckRelatedActionAnyOf::NotAllowed)
            }
            "LOCATION_ALLOWED_WITH_NOTIFICATION" => {
                std::result::Result::Ok(PrivacyCheckRelatedActionAnyOf::AllowedWithNotification)
            }
            "LOCATION_ALLOWED_WITHOUT_NOTIFICATION" => {
                std::result::Result::Ok(PrivacyCheckRelatedActionAnyOf::AllowedWithoutNotification)
            }
            "LOCATION_ALLOWED_WITHOUT_RESPONSE" => {
                std::result::Result::Ok(PrivacyCheckRelatedActionAnyOf::AllowedWithoutResponse)
            }
            "LOCATION_RESTRICTED_WITHOUT_RESPONSE" => {
                std::result::Result::Ok(PrivacyCheckRelatedActionAnyOf::RestrictedWithoutResponse)
            }
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Contains the PLMN identities where the Prose services are authorised to use and the authorised Prose services on this given PLMNs.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProSeAllowedPlmn {
    #[serde(rename = "visitedPlmn")]
    pub visited_plmn: models::PlmnId,

    #[serde(rename = "proseDirectAllowed")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prose_direct_allowed: Option<Vec<models::ProseDirectAllowed>>,
}

impl ProSeAllowedPlmn {
    #[allow(clippy::new_without_default)]
    pub fn new(visited_plmn: models::PlmnId) -> ProSeAllowedPlmn {
        ProSeAllowedPlmn {
            visited_plmn,
            prose_direct_allowed: None,
        }
    }
}

/// Converts the ProSeAllowedPlmn value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ProSeAllowedPlmn {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping visitedPlmn in query parameter serialization

            // Skipping proseDirectAllowed in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProSeAllowedPlmn value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProSeAllowedPlmn {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub visited_plmn: Vec<models::PlmnId>,
            pub prose_direct_allowed: Vec<Vec<models::ProseDirectAllowed>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ProSeAllowedPlmn".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "visitedPlmn" => intermediate_rep.visited_plmn.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "proseDirectAllowed" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in ProSeAllowedPlmn"
                            .to_string(),
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ProSeAllowedPlmn".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProSeAllowedPlmn {
            visited_plmn: intermediate_rep
                .visited_plmn
                .into_iter()
                .next()
                .ok_or_else(|| "visitedPlmn missing in ProSeAllowedPlmn".to_string())?,
            prose_direct_allowed: intermediate_rep.prose_direct_allowed.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProSeAllowedPlmn> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ProSeAllowedPlmn>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ProSeAllowedPlmn>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ProSeAllowedPlmn - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ProSeAllowedPlmn>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ProSeAllowedPlmn as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ProSeAllowedPlmn - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Provides additional information in an error response.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProblemDetails {
    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub r#type: Option<String>,

    #[serde(rename = "title")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<i32>,

    /// A human-readable explanation specific to this occurrence of the problem.
    #[serde(rename = "detail")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub detail: Option<String>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "instance")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub instance: Option<String>,

    /// A machine-readable application error cause specific to this occurrence of the problem.  This IE should be present and provide application-related error information, if available.
    #[serde(rename = "cause")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cause: Option<String>,

    #[serde(rename = "invalidParams")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub invalid_params: Option<Vec<models::InvalidParam>>,

    /// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  tableÂ 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.
    #[serde(rename = "supportedFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_features: Option<String>,

    #[serde(rename = "accessTokenError")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub access_token_error: Option<models::AccessTokenErr>,

    #[serde(rename = "accessTokenRequest")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub access_token_request: Option<models::AccessTokenReq>,

    /// Fully Qualified Domain Name
    #[serde(rename = "nrfId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nrf_id: Option<String>,
}

impl ProblemDetails {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ProblemDetails {
        ProblemDetails {
            r#type: None,
            title: None,
            status: None,
            detail: None,
            instance: None,
            cause: None,
            invalid_params: None,
            supported_features: None,
            access_token_error: None,
            access_token_request: None,
            nrf_id: None,
        }
    }
}

/// Converts the ProblemDetails value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ProblemDetails {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.r#type
                .as_ref()
                .map(|r#type| vec!["type".to_string(), r#type.to_string()].join(",")),
            self.title
                .as_ref()
                .map(|title| vec!["title".to_string(), title.to_string()].join(",")),
            self.status
                .as_ref()
                .map(|status| vec!["status".to_string(), status.to_string()].join(",")),
            self.detail
                .as_ref()
                .map(|detail| vec!["detail".to_string(), detail.to_string()].join(",")),
            self.instance
                .as_ref()
                .map(|instance| vec!["instance".to_string(), instance.to_string()].join(",")),
            self.cause
                .as_ref()
                .map(|cause| vec!["cause".to_string(), cause.to_string()].join(",")),
            // Skipping invalidParams in query parameter serialization
            self.supported_features.as_ref().map(|supported_features| {
                vec![
                    "supportedFeatures".to_string(),
                    supported_features.to_string(),
                ]
                .join(",")
            }),
            // Skipping accessTokenError in query parameter serialization

            // Skipping accessTokenRequest in query parameter serialization
            self.nrf_id
                .as_ref()
                .map(|nrf_id| vec!["nrfId".to_string(), nrf_id.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProblemDetails value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProblemDetails {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
            pub title: Vec<String>,
            pub status: Vec<i32>,
            pub detail: Vec<String>,
            pub instance: Vec<String>,
            pub cause: Vec<String>,
            pub invalid_params: Vec<Vec<models::InvalidParam>>,
            pub supported_features: Vec<String>,
            pub access_token_error: Vec<models::AccessTokenErr>,
            pub access_token_request: Vec<models::AccessTokenReq>,
            pub nrf_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ProblemDetails".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "title" => intermediate_rep.title.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(
                        <i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "detail" => intermediate_rep.detail.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "instance" => intermediate_rep.instance.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "cause" => intermediate_rep.cause.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "invalidParams" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in ProblemDetails"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "supportedFeatures" => intermediate_rep.supported_features.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "accessTokenError" => intermediate_rep.access_token_error.push(
                        <models::AccessTokenErr as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "accessTokenRequest" => intermediate_rep.access_token_request.push(
                        <models::AccessTokenReq as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nrfId" => intermediate_rep.nrf_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ProblemDetails".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProblemDetails {
            r#type: intermediate_rep.r#type.into_iter().next(),
            title: intermediate_rep.title.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            detail: intermediate_rep.detail.into_iter().next(),
            instance: intermediate_rep.instance.into_iter().next(),
            cause: intermediate_rep.cause.into_iter().next(),
            invalid_params: intermediate_rep.invalid_params.into_iter().next(),
            supported_features: intermediate_rep.supported_features.into_iter().next(),
            access_token_error: intermediate_rep.access_token_error.into_iter().next(),
            access_token_request: intermediate_rep.access_token_request.into_iter().next(),
            nrf_id: intermediate_rep.nrf_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProblemDetails> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ProblemDetails>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ProblemDetails>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ProblemDetails - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ProblemDetails> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ProblemDetails as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ProblemDetails - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Indicates the 5G ProSe Direct services that can be authorised to use in the given PLMN for the UE.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProseDirectAllowed {}

impl ProseDirectAllowed {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ProseDirectAllowed {
        ProseDirectAllowed {}
    }
}

/// Converts the ProseDirectAllowed value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ProseDirectAllowed {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProseDirectAllowed value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProseDirectAllowed {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ProseDirectAllowed".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ProseDirectAllowed".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProseDirectAllowed {})
    }
}

// Methods for converting between header::IntoHeaderValue<ProseDirectAllowed> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ProseDirectAllowed>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ProseDirectAllowed>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ProseDirectAllowed - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ProseDirectAllowed>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ProseDirectAllowed as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ProseDirectAllowed - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ProseDirectAllowedAnyOf {
    #[serde(rename = "ANNOUNCE")]
    Announce,
    #[serde(rename = "MONITOR")]
    Monitor,
    #[serde(rename = "RESTRICTD_ANNOUNCE")]
    RestrictdAnnounce,
    #[serde(rename = "RESTRICTD_MONITOR")]
    RestrictdMonitor,
    #[serde(rename = "DISCOVERER")]
    Discoverer,
    #[serde(rename = "DISCOVEREE")]
    Discoveree,
    #[serde(rename = "BROADCAST")]
    Broadcast,
    #[serde(rename = "GROUPCAST")]
    Groupcast,
    #[serde(rename = "UNICAST")]
    Unicast,
    #[serde(rename = "LAYER2_RELAY")]
    Layer2Relay,
    #[serde(rename = "LAYER3_RELAY")]
    Layer3Relay,
}

impl std::fmt::Display for ProseDirectAllowedAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ProseDirectAllowedAnyOf::Announce => write!(f, "ANNOUNCE"),
            ProseDirectAllowedAnyOf::Monitor => write!(f, "MONITOR"),
            ProseDirectAllowedAnyOf::RestrictdAnnounce => write!(f, "RESTRICTD_ANNOUNCE"),
            ProseDirectAllowedAnyOf::RestrictdMonitor => write!(f, "RESTRICTD_MONITOR"),
            ProseDirectAllowedAnyOf::Discoverer => write!(f, "DISCOVERER"),
            ProseDirectAllowedAnyOf::Discoveree => write!(f, "DISCOVEREE"),
            ProseDirectAllowedAnyOf::Broadcast => write!(f, "BROADCAST"),
            ProseDirectAllowedAnyOf::Groupcast => write!(f, "GROUPCAST"),
            ProseDirectAllowedAnyOf::Unicast => write!(f, "UNICAST"),
            ProseDirectAllowedAnyOf::Layer2Relay => write!(f, "LAYER2_RELAY"),
            ProseDirectAllowedAnyOf::Layer3Relay => write!(f, "LAYER3_RELAY"),
        }
    }
}

impl std::str::FromStr for ProseDirectAllowedAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ANNOUNCE" => std::result::Result::Ok(ProseDirectAllowedAnyOf::Announce),
            "MONITOR" => std::result::Result::Ok(ProseDirectAllowedAnyOf::Monitor),
            "RESTRICTD_ANNOUNCE" => {
                std::result::Result::Ok(ProseDirectAllowedAnyOf::RestrictdAnnounce)
            }
            "RESTRICTD_MONITOR" => {
                std::result::Result::Ok(ProseDirectAllowedAnyOf::RestrictdMonitor)
            }
            "DISCOVERER" => std::result::Result::Ok(ProseDirectAllowedAnyOf::Discoverer),
            "DISCOVEREE" => std::result::Result::Ok(ProseDirectAllowedAnyOf::Discoveree),
            "BROADCAST" => std::result::Result::Ok(ProseDirectAllowedAnyOf::Broadcast),
            "GROUPCAST" => std::result::Result::Ok(ProseDirectAllowedAnyOf::Groupcast),
            "UNICAST" => std::result::Result::Ok(ProseDirectAllowedAnyOf::Unicast),
            "LAYER2_RELAY" => std::result::Result::Ok(ProseDirectAllowedAnyOf::Layer2Relay),
            "LAYER3_RELAY" => std::result::Result::Ok(ProseDirectAllowedAnyOf::Layer3Relay),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Indicates whether the UE is authorized to use ProSe Direct Discovery, ProSe Direct Communication, or both.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProseServiceAuth {
    #[serde(rename = "proseDirectDiscoveryAuth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prose_direct_discovery_auth: Option<models::UeAuth>,

    #[serde(rename = "proseDirectCommunicationAuth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prose_direct_communication_auth: Option<models::UeAuth>,
}

impl ProseServiceAuth {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ProseServiceAuth {
        ProseServiceAuth {
            prose_direct_discovery_auth: None,
            prose_direct_communication_auth: None,
        }
    }
}

/// Converts the ProseServiceAuth value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ProseServiceAuth {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping proseDirectDiscoveryAuth in query parameter serialization

            // Skipping proseDirectCommunicationAuth in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProseServiceAuth value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProseServiceAuth {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub prose_direct_discovery_auth: Vec<models::UeAuth>,
            pub prose_direct_communication_auth: Vec<models::UeAuth>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ProseServiceAuth".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "proseDirectDiscoveryAuth" => {
                        intermediate_rep.prose_direct_discovery_auth.push(
                            <models::UeAuth as std::str::FromStr>::from_str(val)
                                .map_err(|x| x.to_string())?,
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "proseDirectCommunicationAuth" => {
                        intermediate_rep.prose_direct_communication_auth.push(
                            <models::UeAuth as std::str::FromStr>::from_str(val)
                                .map_err(|x| x.to_string())?,
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ProseServiceAuth".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProseServiceAuth {
            prose_direct_discovery_auth: intermediate_rep
                .prose_direct_discovery_auth
                .into_iter()
                .next(),
            prose_direct_communication_auth: intermediate_rep
                .prose_direct_communication_auth
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProseServiceAuth> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ProseServiceAuth>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ProseServiceAuth>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ProseServiceAuth - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ProseServiceAuth>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ProseServiceAuth as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ProseServiceAuth - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains the ProSe Subscription Data.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProseSubscriptionData {
    #[serde(rename = "proseServiceAuth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prose_service_auth: Option<models::ProseServiceAuth>,

    /// String representing a bit rate; the prefixes follow the standard symbols from The International System of Units, and represent x1000 multipliers, with the exception that prefix \"K\" is used to represent the standard symbol \"k\".
    #[serde(rename = "nrUePc5Ambr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nr_ue_pc5_ambr: Option<String>,

    #[serde(rename = "proseAllowedPlmn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prose_allowed_plmn: Option<Vec<models::ProSeAllowedPlmn>>,
}

impl ProseSubscriptionData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ProseSubscriptionData {
        ProseSubscriptionData {
            prose_service_auth: None,
            nr_ue_pc5_ambr: None,
            prose_allowed_plmn: None,
        }
    }
}

/// Converts the ProseSubscriptionData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ProseSubscriptionData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping proseServiceAuth in query parameter serialization
            self.nr_ue_pc5_ambr.as_ref().map(|nr_ue_pc5_ambr| {
                vec!["nrUePc5Ambr".to_string(), nr_ue_pc5_ambr.to_string()].join(",")
            }),
            // Skipping proseAllowedPlmn in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProseSubscriptionData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProseSubscriptionData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub prose_service_auth: Vec<models::ProseServiceAuth>,
            pub nr_ue_pc5_ambr: Vec<String>,
            pub prose_allowed_plmn: Vec<Vec<models::ProSeAllowedPlmn>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ProseSubscriptionData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "proseServiceAuth" => intermediate_rep.prose_service_auth.push(<models::ProseServiceAuth as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "nrUePc5Ambr" => intermediate_rep.nr_ue_pc5_ambr.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "proseAllowedPlmn" => return std::result::Result::Err("Parsing a container in this style is not supported in ProseSubscriptionData".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProseSubscriptionData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProseSubscriptionData {
            prose_service_auth: intermediate_rep.prose_service_auth.into_iter().next(),
            nr_ue_pc5_ambr: intermediate_rep.nr_ue_pc5_ambr.into_iter().next(),
            prose_allowed_plmn: intermediate_rep.prose_allowed_plmn.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProseSubscriptionData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ProseSubscriptionData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ProseSubscriptionData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ProseSubscriptionData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ProseSubscriptionData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ProseSubscriptionData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ProseSubscriptionData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PtwParameters {
    #[serde(rename = "operationMode")]
    pub operation_mode: models::OperationMode,

    #[serde(rename = "ptwValue")]
    pub ptw_value: String,
}

impl PtwParameters {
    #[allow(clippy::new_without_default)]
    pub fn new(operation_mode: models::OperationMode, ptw_value: String) -> PtwParameters {
        PtwParameters {
            operation_mode,
            ptw_value,
        }
    }
}

/// Converts the PtwParameters value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PtwParameters {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping operationMode in query parameter serialization
            Some("ptwValue".to_string()),
            Some(self.ptw_value.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PtwParameters value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PtwParameters {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub operation_mode: Vec<models::OperationMode>,
            pub ptw_value: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing PtwParameters".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "operationMode" => intermediate_rep.operation_mode.push(
                        <models::OperationMode as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ptwValue" => intermediate_rep.ptw_value.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing PtwParameters".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PtwParameters {
            operation_mode: intermediate_rep
                .operation_mode
                .into_iter()
                .next()
                .ok_or_else(|| "operationMode missing in PtwParameters".to_string())?,
            ptw_value: intermediate_rep
                .ptw_value
                .into_iter()
                .next()
                .ok_or_else(|| "ptwValue missing in PtwParameters".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PtwParameters> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PtwParameters>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<PtwParameters>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for PtwParameters - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PtwParameters> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <PtwParameters as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into PtwParameters - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Indicates the radio access used.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RatType {}

impl RatType {
    #[allow(clippy::new_without_default)]
    pub fn new() -> RatType {
        RatType {}
    }
}

/// Converts the RatType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RatType {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RatType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RatType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing RatType".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing RatType".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RatType {})
    }
}

// Methods for converting between header::IntoHeaderValue<RatType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RatType>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<RatType>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for RatType - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<RatType> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <RatType as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into RatType - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum RatTypeAnyOf {
    #[serde(rename = "NR")]
    Nr,
    #[serde(rename = "EUTRA")]
    Eutra,
    #[serde(rename = "WLAN")]
    Wlan,
    #[serde(rename = "VIRTUAL")]
    Virtual,
    #[serde(rename = "NBIOT")]
    Nbiot,
    #[serde(rename = "WIRELINE")]
    Wireline,
    #[serde(rename = "WIRELINE_CABLE")]
    WirelineCable,
    #[serde(rename = "WIRELINE_BBF")]
    WirelineBbf,
    #[serde(rename = "LTE-M")]
    LteM,
    #[serde(rename = "NR_U")]
    NrU,
    #[serde(rename = "EUTRA_U")]
    EutraU,
    #[serde(rename = "TRUSTED_N3GA")]
    TrustedN3Ga,
    #[serde(rename = "TRUSTED_WLAN")]
    TrustedWlan,
    #[serde(rename = "UTRA")]
    Utra,
    #[serde(rename = "GERA")]
    Gera,
    #[serde(rename = "NR_LEO")]
    NrLeo,
    #[serde(rename = "NR_MEO")]
    NrMeo,
    #[serde(rename = "NR_GEO")]
    NrGeo,
    #[serde(rename = "NR_OTHER_SAT")]
    NrOtherSat,
    #[serde(rename = "NR_REDCAP")]
    NrRedcap,
}

impl std::fmt::Display for RatTypeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            RatTypeAnyOf::Nr => write!(f, "NR"),
            RatTypeAnyOf::Eutra => write!(f, "EUTRA"),
            RatTypeAnyOf::Wlan => write!(f, "WLAN"),
            RatTypeAnyOf::Virtual => write!(f, "VIRTUAL"),
            RatTypeAnyOf::Nbiot => write!(f, "NBIOT"),
            RatTypeAnyOf::Wireline => write!(f, "WIRELINE"),
            RatTypeAnyOf::WirelineCable => write!(f, "WIRELINE_CABLE"),
            RatTypeAnyOf::WirelineBbf => write!(f, "WIRELINE_BBF"),
            RatTypeAnyOf::LteM => write!(f, "LTE-M"),
            RatTypeAnyOf::NrU => write!(f, "NR_U"),
            RatTypeAnyOf::EutraU => write!(f, "EUTRA_U"),
            RatTypeAnyOf::TrustedN3Ga => write!(f, "TRUSTED_N3GA"),
            RatTypeAnyOf::TrustedWlan => write!(f, "TRUSTED_WLAN"),
            RatTypeAnyOf::Utra => write!(f, "UTRA"),
            RatTypeAnyOf::Gera => write!(f, "GERA"),
            RatTypeAnyOf::NrLeo => write!(f, "NR_LEO"),
            RatTypeAnyOf::NrMeo => write!(f, "NR_MEO"),
            RatTypeAnyOf::NrGeo => write!(f, "NR_GEO"),
            RatTypeAnyOf::NrOtherSat => write!(f, "NR_OTHER_SAT"),
            RatTypeAnyOf::NrRedcap => write!(f, "NR_REDCAP"),
        }
    }
}

impl std::str::FromStr for RatTypeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "NR" => std::result::Result::Ok(RatTypeAnyOf::Nr),
            "EUTRA" => std::result::Result::Ok(RatTypeAnyOf::Eutra),
            "WLAN" => std::result::Result::Ok(RatTypeAnyOf::Wlan),
            "VIRTUAL" => std::result::Result::Ok(RatTypeAnyOf::Virtual),
            "NBIOT" => std::result::Result::Ok(RatTypeAnyOf::Nbiot),
            "WIRELINE" => std::result::Result::Ok(RatTypeAnyOf::Wireline),
            "WIRELINE_CABLE" => std::result::Result::Ok(RatTypeAnyOf::WirelineCable),
            "WIRELINE_BBF" => std::result::Result::Ok(RatTypeAnyOf::WirelineBbf),
            "LTE-M" => std::result::Result::Ok(RatTypeAnyOf::LteM),
            "NR_U" => std::result::Result::Ok(RatTypeAnyOf::NrU),
            "EUTRA_U" => std::result::Result::Ok(RatTypeAnyOf::EutraU),
            "TRUSTED_N3GA" => std::result::Result::Ok(RatTypeAnyOf::TrustedN3Ga),
            "TRUSTED_WLAN" => std::result::Result::Ok(RatTypeAnyOf::TrustedWlan),
            "UTRA" => std::result::Result::Ok(RatTypeAnyOf::Utra),
            "GERA" => std::result::Result::Ok(RatTypeAnyOf::Gera),
            "NR_LEO" => std::result::Result::Ok(RatTypeAnyOf::NrLeo),
            "NR_MEO" => std::result::Result::Ok(RatTypeAnyOf::NrMeo),
            "NR_GEO" => std::result::Result::Ok(RatTypeAnyOf::NrGeo),
            "NR_OTHER_SAT" => std::result::Result::Ok(RatTypeAnyOf::NrOtherSat),
            "NR_REDCAP" => std::result::Result::Ok(RatTypeAnyOf::NrRedcap),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// The response shall include a Location header field containing a different URI  (pointing to a different URI of an other service instance), or the same URI if a request  is redirected to the same target resource via a different SCP.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RedirectResponse {
    #[serde(rename = "cause")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cause: Option<String>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "targetScp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_scp: Option<String>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "targetSepp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_sepp: Option<String>,
}

impl RedirectResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> RedirectResponse {
        RedirectResponse {
            cause: None,
            target_scp: None,
            target_sepp: None,
        }
    }
}

/// Converts the RedirectResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RedirectResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.cause
                .as_ref()
                .map(|cause| vec!["cause".to_string(), cause.to_string()].join(",")),
            self.target_scp
                .as_ref()
                .map(|target_scp| vec!["targetScp".to_string(), target_scp.to_string()].join(",")),
            self.target_sepp.as_ref().map(|target_sepp| {
                vec!["targetSepp".to_string(), target_sepp.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RedirectResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RedirectResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cause: Vec<String>,
            pub target_scp: Vec<String>,
            pub target_sepp: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing RedirectResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "cause" => intermediate_rep.cause.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "targetScp" => intermediate_rep.target_scp.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "targetSepp" => intermediate_rep.target_sepp.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing RedirectResponse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RedirectResponse {
            cause: intermediate_rep.cause.into_iter().next(),
            target_scp: intermediate_rep.target_scp.into_iter().next(),
            target_sepp: intermediate_rep.target_sepp.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RedirectResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RedirectResponse>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<RedirectResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for RedirectResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<RedirectResponse>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <RedirectResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into RedirectResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Relative Cartesian Location
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RelativeCartesianLocation {
    /// string with format 'float' as defined in OpenAPI.
    #[serde(rename = "x")]
    pub x: f32,

    /// string with format 'float' as defined in OpenAPI.
    #[serde(rename = "y")]
    pub y: f32,

    /// string with format 'float' as defined in OpenAPI.
    #[serde(rename = "z")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub z: Option<f32>,
}

impl RelativeCartesianLocation {
    #[allow(clippy::new_without_default)]
    pub fn new(x: f32, y: f32) -> RelativeCartesianLocation {
        RelativeCartesianLocation { x, y, z: None }
    }
}

/// Converts the RelativeCartesianLocation value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RelativeCartesianLocation {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("x".to_string()),
            Some(self.x.to_string()),
            Some("y".to_string()),
            Some(self.y.to_string()),
            self.z
                .as_ref()
                .map(|z| vec!["z".to_string(), z.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RelativeCartesianLocation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RelativeCartesianLocation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub x: Vec<f32>,
            pub y: Vec<f32>,
            pub z: Vec<f32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing RelativeCartesianLocation".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "x" => intermediate_rep.x.push(
                        <f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "y" => intermediate_rep.y.push(
                        <f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "z" => intermediate_rep.z.push(
                        <f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing RelativeCartesianLocation".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RelativeCartesianLocation {
            x: intermediate_rep
                .x
                .into_iter()
                .next()
                .ok_or_else(|| "x missing in RelativeCartesianLocation".to_string())?,
            y: intermediate_rep
                .y
                .into_iter()
                .next()
                .ok_or_else(|| "y missing in RelativeCartesianLocation".to_string())?,
            z: intermediate_rep.z.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RelativeCartesianLocation> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RelativeCartesianLocation>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<RelativeCartesianLocation>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for RelativeCartesianLocation - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<RelativeCartesianLocation>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <RelativeCartesianLocation as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into RelativeCartesianLocation - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// The enumeration ReportAmountMdt defines Report Amount for MDT in the trace. See 3GPP TS 32.422 for further description of the values. It shall comply with the provisions defined in table 5.6.3.10-1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ReportAmountMdt {}

impl ReportAmountMdt {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ReportAmountMdt {
        ReportAmountMdt {}
    }
}

/// Converts the ReportAmountMdt value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ReportAmountMdt {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ReportAmountMdt value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ReportAmountMdt {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ReportAmountMdt".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ReportAmountMdt".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ReportAmountMdt {})
    }
}

// Methods for converting between header::IntoHeaderValue<ReportAmountMdt> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ReportAmountMdt>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ReportAmountMdt>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ReportAmountMdt - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ReportAmountMdt>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ReportAmountMdt as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ReportAmountMdt - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ReportAmountMdtAnyOf {
    #[serde(rename = "1")]
    Variant1,
    #[serde(rename = "2")]
    Variant2,
    #[serde(rename = "4")]
    Variant4,
    #[serde(rename = "8")]
    Variant8,
    #[serde(rename = "16")]
    Variant16,
    #[serde(rename = "32")]
    Variant32,
    #[serde(rename = "64")]
    Variant64,
    #[serde(rename = "infinity")]
    Infinity,
}

impl std::fmt::Display for ReportAmountMdtAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ReportAmountMdtAnyOf::Variant1 => write!(f, "1"),
            ReportAmountMdtAnyOf::Variant2 => write!(f, "2"),
            ReportAmountMdtAnyOf::Variant4 => write!(f, "4"),
            ReportAmountMdtAnyOf::Variant8 => write!(f, "8"),
            ReportAmountMdtAnyOf::Variant16 => write!(f, "16"),
            ReportAmountMdtAnyOf::Variant32 => write!(f, "32"),
            ReportAmountMdtAnyOf::Variant64 => write!(f, "64"),
            ReportAmountMdtAnyOf::Infinity => write!(f, "infinity"),
        }
    }
}

impl std::str::FromStr for ReportAmountMdtAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "1" => std::result::Result::Ok(ReportAmountMdtAnyOf::Variant1),
            "2" => std::result::Result::Ok(ReportAmountMdtAnyOf::Variant2),
            "4" => std::result::Result::Ok(ReportAmountMdtAnyOf::Variant4),
            "8" => std::result::Result::Ok(ReportAmountMdtAnyOf::Variant8),
            "16" => std::result::Result::Ok(ReportAmountMdtAnyOf::Variant16),
            "32" => std::result::Result::Ok(ReportAmountMdtAnyOf::Variant32),
            "64" => std::result::Result::Ok(ReportAmountMdtAnyOf::Variant64),
            "infinity" => std::result::Result::Ok(ReportAmountMdtAnyOf::Infinity),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// The enumeration ReportIntervalMdt defines Report Interval for MDT in the trace. See 3GPP TS 32.422 for further description of the values. It shall comply with the provisions defined in table 5.6.3.9-1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ReportIntervalMdt {}

impl ReportIntervalMdt {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ReportIntervalMdt {
        ReportIntervalMdt {}
    }
}

/// Converts the ReportIntervalMdt value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ReportIntervalMdt {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ReportIntervalMdt value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ReportIntervalMdt {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ReportIntervalMdt".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ReportIntervalMdt".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ReportIntervalMdt {})
    }
}

// Methods for converting between header::IntoHeaderValue<ReportIntervalMdt> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ReportIntervalMdt>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ReportIntervalMdt>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ReportIntervalMdt - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ReportIntervalMdt>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ReportIntervalMdt as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ReportIntervalMdt - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ReportIntervalMdtAnyOf {
    #[serde(rename = "120")]
    Variant120,
    #[serde(rename = "240")]
    Variant240,
    #[serde(rename = "480")]
    Variant480,
    #[serde(rename = "640")]
    Variant640,
    #[serde(rename = "1024")]
    Variant1024,
    #[serde(rename = "2048")]
    Variant2048,
    #[serde(rename = "5120")]
    Variant5120,
    #[serde(rename = "10240")]
    Variant10240,
    #[serde(rename = "60000")]
    Variant60000,
    #[serde(rename = "360000")]
    Variant360000,
    #[serde(rename = "720000")]
    Variant720000,
    #[serde(rename = "1800000")]
    Variant1800000,
    #[serde(rename = "3600000")]
    Variant3600000,
}

impl std::fmt::Display for ReportIntervalMdtAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ReportIntervalMdtAnyOf::Variant120 => write!(f, "120"),
            ReportIntervalMdtAnyOf::Variant240 => write!(f, "240"),
            ReportIntervalMdtAnyOf::Variant480 => write!(f, "480"),
            ReportIntervalMdtAnyOf::Variant640 => write!(f, "640"),
            ReportIntervalMdtAnyOf::Variant1024 => write!(f, "1024"),
            ReportIntervalMdtAnyOf::Variant2048 => write!(f, "2048"),
            ReportIntervalMdtAnyOf::Variant5120 => write!(f, "5120"),
            ReportIntervalMdtAnyOf::Variant10240 => write!(f, "10240"),
            ReportIntervalMdtAnyOf::Variant60000 => write!(f, "60000"),
            ReportIntervalMdtAnyOf::Variant360000 => write!(f, "360000"),
            ReportIntervalMdtAnyOf::Variant720000 => write!(f, "720000"),
            ReportIntervalMdtAnyOf::Variant1800000 => write!(f, "1800000"),
            ReportIntervalMdtAnyOf::Variant3600000 => write!(f, "3600000"),
        }
    }
}

impl std::str::FromStr for ReportIntervalMdtAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "120" => std::result::Result::Ok(ReportIntervalMdtAnyOf::Variant120),
            "240" => std::result::Result::Ok(ReportIntervalMdtAnyOf::Variant240),
            "480" => std::result::Result::Ok(ReportIntervalMdtAnyOf::Variant480),
            "640" => std::result::Result::Ok(ReportIntervalMdtAnyOf::Variant640),
            "1024" => std::result::Result::Ok(ReportIntervalMdtAnyOf::Variant1024),
            "2048" => std::result::Result::Ok(ReportIntervalMdtAnyOf::Variant2048),
            "5120" => std::result::Result::Ok(ReportIntervalMdtAnyOf::Variant5120),
            "10240" => std::result::Result::Ok(ReportIntervalMdtAnyOf::Variant10240),
            "60000" => std::result::Result::Ok(ReportIntervalMdtAnyOf::Variant60000),
            "360000" => std::result::Result::Ok(ReportIntervalMdtAnyOf::Variant360000),
            "720000" => std::result::Result::Ok(ReportIntervalMdtAnyOf::Variant720000),
            "1800000" => std::result::Result::Ok(ReportIntervalMdtAnyOf::Variant1800000),
            "3600000" => std::result::Result::Ok(ReportIntervalMdtAnyOf::Variant3600000),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// The enumeration ReportIntervalNrMdt defines Report Interval in NR for MDT in the trace. See 3GPP TS 32.422 for further description of the values. It shall comply with the provisions defined in table 5.6.3.17-1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ReportIntervalNrMdt {}

impl ReportIntervalNrMdt {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ReportIntervalNrMdt {
        ReportIntervalNrMdt {}
    }
}

/// Converts the ReportIntervalNrMdt value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ReportIntervalNrMdt {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ReportIntervalNrMdt value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ReportIntervalNrMdt {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ReportIntervalNrMdt".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ReportIntervalNrMdt".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ReportIntervalNrMdt {})
    }
}

// Methods for converting between header::IntoHeaderValue<ReportIntervalNrMdt> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ReportIntervalNrMdt>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ReportIntervalNrMdt>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ReportIntervalNrMdt - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ReportIntervalNrMdt>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ReportIntervalNrMdt as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ReportIntervalNrMdt - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ReportIntervalNrMdtAnyOf {
    #[serde(rename = "120")]
    Variant120,
    #[serde(rename = "240")]
    Variant240,
    #[serde(rename = "480")]
    Variant480,
    #[serde(rename = "640")]
    Variant640,
    #[serde(rename = "1024")]
    Variant1024,
    #[serde(rename = "2048")]
    Variant2048,
    #[serde(rename = "5120")]
    Variant5120,
    #[serde(rename = "10240")]
    Variant10240,
    #[serde(rename = "20480")]
    Variant20480,
    #[serde(rename = "40960")]
    Variant40960,
    #[serde(rename = "60000")]
    Variant60000,
    #[serde(rename = "360000")]
    Variant360000,
    #[serde(rename = "720000")]
    Variant720000,
    #[serde(rename = "1800000")]
    Variant1800000,
    #[serde(rename = "3600000")]
    Variant3600000,
}

impl std::fmt::Display for ReportIntervalNrMdtAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ReportIntervalNrMdtAnyOf::Variant120 => write!(f, "120"),
            ReportIntervalNrMdtAnyOf::Variant240 => write!(f, "240"),
            ReportIntervalNrMdtAnyOf::Variant480 => write!(f, "480"),
            ReportIntervalNrMdtAnyOf::Variant640 => write!(f, "640"),
            ReportIntervalNrMdtAnyOf::Variant1024 => write!(f, "1024"),
            ReportIntervalNrMdtAnyOf::Variant2048 => write!(f, "2048"),
            ReportIntervalNrMdtAnyOf::Variant5120 => write!(f, "5120"),
            ReportIntervalNrMdtAnyOf::Variant10240 => write!(f, "10240"),
            ReportIntervalNrMdtAnyOf::Variant20480 => write!(f, "20480"),
            ReportIntervalNrMdtAnyOf::Variant40960 => write!(f, "40960"),
            ReportIntervalNrMdtAnyOf::Variant60000 => write!(f, "60000"),
            ReportIntervalNrMdtAnyOf::Variant360000 => write!(f, "360000"),
            ReportIntervalNrMdtAnyOf::Variant720000 => write!(f, "720000"),
            ReportIntervalNrMdtAnyOf::Variant1800000 => write!(f, "1800000"),
            ReportIntervalNrMdtAnyOf::Variant3600000 => write!(f, "3600000"),
        }
    }
}

impl std::str::FromStr for ReportIntervalNrMdtAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "120" => std::result::Result::Ok(ReportIntervalNrMdtAnyOf::Variant120),
            "240" => std::result::Result::Ok(ReportIntervalNrMdtAnyOf::Variant240),
            "480" => std::result::Result::Ok(ReportIntervalNrMdtAnyOf::Variant480),
            "640" => std::result::Result::Ok(ReportIntervalNrMdtAnyOf::Variant640),
            "1024" => std::result::Result::Ok(ReportIntervalNrMdtAnyOf::Variant1024),
            "2048" => std::result::Result::Ok(ReportIntervalNrMdtAnyOf::Variant2048),
            "5120" => std::result::Result::Ok(ReportIntervalNrMdtAnyOf::Variant5120),
            "10240" => std::result::Result::Ok(ReportIntervalNrMdtAnyOf::Variant10240),
            "20480" => std::result::Result::Ok(ReportIntervalNrMdtAnyOf::Variant20480),
            "40960" => std::result::Result::Ok(ReportIntervalNrMdtAnyOf::Variant40960),
            "60000" => std::result::Result::Ok(ReportIntervalNrMdtAnyOf::Variant60000),
            "360000" => std::result::Result::Ok(ReportIntervalNrMdtAnyOf::Variant360000),
            "720000" => std::result::Result::Ok(ReportIntervalNrMdtAnyOf::Variant720000),
            "1800000" => std::result::Result::Ok(ReportIntervalNrMdtAnyOf::Variant1800000),
            "3600000" => std::result::Result::Ok(ReportIntervalNrMdtAnyOf::Variant3600000),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// indicates performed modivications.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ReportItem {
    /// Contains a JSON pointer value (as defined in IETF RFC 6901) that references a  location of a resource to which the modification is subject.
    #[serde(rename = "path")]
    pub path: String,

    /// A human-readable reason providing details on the reported modification failure.  The reason string should identify the operation that failed using the operation's  array index to assist in correlation of the invalid parameter with the failed  operation, e.g. \"Replacement value invalid for attribute (failed operation index= 4)\".
    #[serde(rename = "reason")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
}

impl ReportItem {
    #[allow(clippy::new_without_default)]
    pub fn new(path: String) -> ReportItem {
        ReportItem { path, reason: None }
    }
}

/// Converts the ReportItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ReportItem {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("path".to_string()),
            Some(self.path.to_string()),
            self.reason
                .as_ref()
                .map(|reason| vec!["reason".to_string(), reason.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ReportItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ReportItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub path: Vec<String>,
            pub reason: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ReportItem".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "path" => intermediate_rep.path.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "reason" => intermediate_rep.reason.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ReportItem".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ReportItem {
            path: intermediate_rep
                .path
                .into_iter()
                .next()
                .ok_or_else(|| "path missing in ReportItem".to_string())?,
            reason: intermediate_rep.reason.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ReportItem> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ReportItem>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ReportItem>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ReportItem - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ReportItem> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ReportItem as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ReportItem - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// The enumeration ReportTypeMdt defines Report Type for logged MDT in the trace. See 3GPP TS 32.422 for further description of the values. It shall comply with the provisions defined in table 5.6.3.4-1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ReportTypeMdt {}

impl ReportTypeMdt {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ReportTypeMdt {
        ReportTypeMdt {}
    }
}

/// Converts the ReportTypeMdt value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ReportTypeMdt {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ReportTypeMdt value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ReportTypeMdt {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ReportTypeMdt".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ReportTypeMdt".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ReportTypeMdt {})
    }
}

// Methods for converting between header::IntoHeaderValue<ReportTypeMdt> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ReportTypeMdt>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ReportTypeMdt>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ReportTypeMdt - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ReportTypeMdt> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ReportTypeMdt as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ReportTypeMdt - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ReportTypeMdtAnyOf {
    #[serde(rename = "PERIODICAL")]
    Periodical,
    #[serde(rename = "EVENT_TRIGGED")]
    EventTrigged,
}

impl std::fmt::Display for ReportTypeMdtAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ReportTypeMdtAnyOf::Periodical => write!(f, "PERIODICAL"),
            ReportTypeMdtAnyOf::EventTrigged => write!(f, "EVENT_TRIGGED"),
        }
    }
}

impl std::str::FromStr for ReportTypeMdtAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "PERIODICAL" => std::result::Result::Ok(ReportTypeMdtAnyOf::Periodical),
            "EVENT_TRIGGED" => std::result::Result::Ok(ReportTypeMdtAnyOf::EventTrigged),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// The enumeration ReportingTrigger defines Reporting Triggers for MDT in the trace. See 3GPP TS 32.42] for further  description of the values. It shall comply with the provisions defined in table 5.6.3.8-1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ReportingTrigger {}

impl ReportingTrigger {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ReportingTrigger {
        ReportingTrigger {}
    }
}

/// Converts the ReportingTrigger value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ReportingTrigger {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ReportingTrigger value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ReportingTrigger {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ReportingTrigger".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ReportingTrigger".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ReportingTrigger {})
    }
}

// Methods for converting between header::IntoHeaderValue<ReportingTrigger> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ReportingTrigger>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ReportingTrigger>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ReportingTrigger - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ReportingTrigger>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ReportingTrigger as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ReportingTrigger - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ReportingTriggerAnyOf {
    #[serde(rename = "PERIODICAL")]
    Periodical,
    #[serde(rename = "EVENT_A2")]
    EventA2,
    #[serde(rename = "EVENT_A2_PERIODIC")]
    EventA2Periodic,
    #[serde(rename = "ALL_RRM_EVENT_TRIGGERS")]
    AllRrmEventTriggers,
}

impl std::fmt::Display for ReportingTriggerAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ReportingTriggerAnyOf::Periodical => write!(f, "PERIODICAL"),
            ReportingTriggerAnyOf::EventA2 => write!(f, "EVENT_A2"),
            ReportingTriggerAnyOf::EventA2Periodic => write!(f, "EVENT_A2_PERIODIC"),
            ReportingTriggerAnyOf::AllRrmEventTriggers => write!(f, "ALL_RRM_EVENT_TRIGGERS"),
        }
    }
}

impl std::str::FromStr for ReportingTriggerAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "PERIODICAL" => std::result::Result::Ok(ReportingTriggerAnyOf::Periodical),
            "EVENT_A2" => std::result::Result::Ok(ReportingTriggerAnyOf::EventA2),
            "EVENT_A2_PERIODIC" => std::result::Result::Ok(ReportingTriggerAnyOf::EventA2Periodic),
            "ALL_RRM_EVENT_TRIGGERS" => {
                std::result::Result::Ok(ReportingTriggerAnyOf::AllRrmEventTriggers)
            }
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// It contains the restriction type ALLOWED_AREAS or NOT_ALLOWED_AREAS.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RestrictionType {}

impl RestrictionType {
    #[allow(clippy::new_without_default)]
    pub fn new() -> RestrictionType {
        RestrictionType {}
    }
}

/// Converts the RestrictionType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RestrictionType {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RestrictionType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RestrictionType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing RestrictionType".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing RestrictionType".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RestrictionType {})
    }
}

// Methods for converting between header::IntoHeaderValue<RestrictionType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RestrictionType>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<RestrictionType>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for RestrictionType - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<RestrictionType>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <RestrictionType as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into RestrictionType - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum RestrictionTypeAnyOf {
    #[serde(rename = "ALLOWED_AREAS")]
    AllowedAreas,
    #[serde(rename = "NOT_ALLOWED_AREAS")]
    NotAllowedAreas,
}

impl std::fmt::Display for RestrictionTypeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            RestrictionTypeAnyOf::AllowedAreas => write!(f, "ALLOWED_AREAS"),
            RestrictionTypeAnyOf::NotAllowedAreas => write!(f, "NOT_ALLOWED_AREAS"),
        }
    }
}

impl std::str::FromStr for RestrictionTypeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ALLOWED_AREAS" => std::result::Result::Ok(RestrictionTypeAnyOf::AllowedAreas),
            "NOT_ALLOWED_AREAS" => std::result::Result::Ok(RestrictionTypeAnyOf::NotAllowedAreas),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Unsigned integer representing the 'Subscriber Profile ID for RAT/Frequency Priority'  as specified in 3GPP TS 36.413 with the OpenAPI 'nullable: true' property.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RfspIndexRm(i32);

impl std::convert::From<i32> for RfspIndexRm {
    fn from(x: i32) -> Self {
        RfspIndexRm(x)
    }
}

impl std::convert::From<RfspIndexRm> for i32 {
    fn from(x: RfspIndexRm) -> Self {
        x.0
    }
}

impl std::ops::Deref for RfspIndexRm {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for RfspIndexRm {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// string with format 'bytes' as defined in OpenAPI
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RgWirelineCharacteristics {}

impl RgWirelineCharacteristics {
    #[allow(clippy::new_without_default)]
    pub fn new() -> RgWirelineCharacteristics {
        RgWirelineCharacteristics {}
    }
}

/// Converts the RgWirelineCharacteristics value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RgWirelineCharacteristics {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RgWirelineCharacteristics value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RgWirelineCharacteristics {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing RgWirelineCharacteristics".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing RgWirelineCharacteristics".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RgWirelineCharacteristics {})
    }
}

// Methods for converting between header::IntoHeaderValue<RgWirelineCharacteristics> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RgWirelineCharacteristics>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<RgWirelineCharacteristics>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for RgWirelineCharacteristics - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<RgWirelineCharacteristics>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <RgWirelineCharacteristics as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into RgWirelineCharacteristics - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Indicates if access is allowed to a given serving network, e.g. a PLMN (MCC, MNC) or an  SNPN (MCC, MNC, NID).
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RoamingRestrictions {
    #[serde(rename = "accessAllowed")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub access_allowed: Option<bool>,
}

impl RoamingRestrictions {
    #[allow(clippy::new_without_default)]
    pub fn new() -> RoamingRestrictions {
        RoamingRestrictions {
            access_allowed: None,
        }
    }
}

/// Converts the RoamingRestrictions value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for RoamingRestrictions {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> =
            vec![self.access_allowed.as_ref().map(|access_allowed| {
                vec!["accessAllowed".to_string(), access_allowed.to_string()].join(",")
            })];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RoamingRestrictions value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RoamingRestrictions {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub access_allowed: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing RoamingRestrictions".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "accessAllowed" => intermediate_rep.access_allowed.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing RoamingRestrictions".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RoamingRestrictions {
            access_allowed: intermediate_rep.access_allowed.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RoamingRestrictions> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<RoamingRestrictions>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<RoamingRestrictions>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for RoamingRestrictions - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<RoamingRestrictions>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <RoamingRestrictions as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into RoamingRestrictions - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Represents a routing indicator.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RoutingId(String);

impl std::convert::From<String> for RoutingId {
    fn from(x: String) -> Self {
        RoutingId(x)
    }
}

impl std::string::ToString for RoutingId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for RoutingId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(RoutingId(x.to_string()))
    }
}

impl std::convert::From<RoutingId> for String {
    fn from(x: RoutingId) -> Self {
        x.0
    }
}

impl std::ops::Deref for RoutingId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for RoutingId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Identifies time and day of the week when the UE is available for communication.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ScheduledCommunicationTime {
    /// Identifies the day(s) of the week. If absent, it indicates every day of the week.
    #[serde(rename = "daysOfWeek")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub days_of_week: Option<Vec<models::DayOfWeek>>,

    /// String with format partial-time or full-time as defined in clause 5.6 of IETF RFC 3339. Examples, 20:15:00, 20:15:00-08:00 (for 8 hours behind UTC).
    #[serde(rename = "timeOfDayStart")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub time_of_day_start: Option<String>,

    /// String with format partial-time or full-time as defined in clause 5.6 of IETF RFC 3339. Examples, 20:15:00, 20:15:00-08:00 (for 8 hours behind UTC).
    #[serde(rename = "timeOfDayEnd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub time_of_day_end: Option<String>,
}

impl ScheduledCommunicationTime {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ScheduledCommunicationTime {
        ScheduledCommunicationTime {
            days_of_week: None,
            time_of_day_start: None,
            time_of_day_end: None,
        }
    }
}

/// Converts the ScheduledCommunicationTime value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ScheduledCommunicationTime {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.days_of_week.as_ref().map(|days_of_week| {
                vec![
                    "daysOfWeek".to_string(),
                    days_of_week
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.time_of_day_start.as_ref().map(|time_of_day_start| {
                vec!["timeOfDayStart".to_string(), time_of_day_start.to_string()].join(",")
            }),
            self.time_of_day_end.as_ref().map(|time_of_day_end| {
                vec!["timeOfDayEnd".to_string(), time_of_day_end.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ScheduledCommunicationTime value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ScheduledCommunicationTime {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub days_of_week: Vec<Vec<models::DayOfWeek>>,
            pub time_of_day_start: Vec<String>,
            pub time_of_day_end: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ScheduledCommunicationTime".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "daysOfWeek" => return std::result::Result::Err("Parsing a container in this style is not supported in ScheduledCommunicationTime".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "timeOfDayStart" => intermediate_rep.time_of_day_start.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "timeOfDayEnd" => intermediate_rep.time_of_day_end.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ScheduledCommunicationTime".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ScheduledCommunicationTime {
            days_of_week: intermediate_rep.days_of_week.into_iter().next(),
            time_of_day_start: intermediate_rep.time_of_day_start.into_iter().next(),
            time_of_day_end: intermediate_rep.time_of_day_end.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ScheduledCommunicationTime> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ScheduledCommunicationTime>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ScheduledCommunicationTime>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ScheduledCommunicationTime - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ScheduledCommunicationTime>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ScheduledCommunicationTime as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ScheduledCommunicationTime - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Possible values are: -DOWNLINK_ONLY: Downlink only -UPLINK_ONLY: Uplink only -BIDIRECTIONA: Bi-directional
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ScheduledCommunicationType {}

impl ScheduledCommunicationType {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ScheduledCommunicationType {
        ScheduledCommunicationType {}
    }
}

/// Converts the ScheduledCommunicationType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ScheduledCommunicationType {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ScheduledCommunicationType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ScheduledCommunicationType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ScheduledCommunicationType".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ScheduledCommunicationType".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ScheduledCommunicationType {})
    }
}

// Methods for converting between header::IntoHeaderValue<ScheduledCommunicationType> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ScheduledCommunicationType>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ScheduledCommunicationType>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ScheduledCommunicationType - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ScheduledCommunicationType>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ScheduledCommunicationType as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ScheduledCommunicationType - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ScheduledCommunicationTypeAnyOf {
    #[serde(rename = "DOWNLINK_ONLY")]
    DownlinkOnly,
    #[serde(rename = "UPLINK_ONLY")]
    UplinkOnly,
    #[serde(rename = "BIDIRECTIONAL")]
    Bidirectional,
}

impl std::fmt::Display for ScheduledCommunicationTypeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ScheduledCommunicationTypeAnyOf::DownlinkOnly => write!(f, "DOWNLINK_ONLY"),
            ScheduledCommunicationTypeAnyOf::UplinkOnly => write!(f, "UPLINK_ONLY"),
            ScheduledCommunicationTypeAnyOf::Bidirectional => write!(f, "BIDIRECTIONAL"),
        }
    }
}

impl std::str::FromStr for ScheduledCommunicationTypeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "DOWNLINK_ONLY" => {
                std::result::Result::Ok(ScheduledCommunicationTypeAnyOf::DownlinkOnly)
            }
            "UPLINK_ONLY" => std::result::Result::Ok(ScheduledCommunicationTypeAnyOf::UplinkOnly),
            "BIDIRECTIONAL" => {
                std::result::Result::Ok(ScheduledCommunicationTypeAnyOf::Bidirectional)
            }
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SdmSubsModification {
    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "expires")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expires: Option<chrono::DateTime<chrono::Utc>>,

    #[serde(rename = "monitoredResourceUris")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub monitored_resource_uris: Option<Vec<models::Uri>>,
}

impl SdmSubsModification {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SdmSubsModification {
        SdmSubsModification {
            expires: None,
            monitored_resource_uris: None,
        }
    }
}

/// Converts the SdmSubsModification value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SdmSubsModification {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping expires in query parameter serialization
            self.monitored_resource_uris
                .as_ref()
                .map(|monitored_resource_uris| {
                    vec![
                        "monitoredResourceUris".to_string(),
                        monitored_resource_uris
                            .iter()
                            .map(|x| x.to_string())
                            .collect::<Vec<_>>()
                            .join(","),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SdmSubsModification value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SdmSubsModification {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub expires: Vec<chrono::DateTime<chrono::Utc>>,
            pub monitored_resource_uris: Vec<Vec<models::Uri>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SdmSubsModification".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "expires" => intermediate_rep.expires.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "monitoredResourceUris" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in SdmSubsModification"
                            .to_string(),
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SdmSubsModification".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SdmSubsModification {
            expires: intermediate_rep.expires.into_iter().next(),
            monitored_resource_uris: intermediate_rep.monitored_resource_uris.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SdmSubsModification> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SdmSubsModification>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SdmSubsModification>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SdmSubsModification - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SdmSubsModification>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SdmSubsModification as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SdmSubsModification - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SdmSubscription {
    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "nfInstanceId")]
    pub nf_instance_id: uuid::Uuid,

    #[serde(rename = "implicitUnsubscribe")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub implicit_unsubscribe: Option<bool>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "expires")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expires: Option<chrono::DateTime<chrono::Utc>>,

    /// String providing an URI formatted according to RFC 3986.
    #[serde(rename = "callbackReference")]
    pub callback_reference: String,

    #[serde(rename = "amfServiceName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub amf_service_name: Option<models::ServiceName>,

    #[serde(rename = "monitoredResourceUris")]
    pub monitored_resource_uris: Vec<models::Uri>,

    #[serde(rename = "singleNssai")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub single_nssai: Option<models::Snssai>,

    /// String representing a Data Network as defined in clause 9A of 3GPP TS 23.003;  it shall contain either a DNN Network Identifier, or a full DNN with both the Network  Identifier and Operator Identifier, as specified in 3GPP TS 23.003 clause 9.1.1 and 9.1.2. It shall be coded as string in which the labels are separated by dots  (e.g. \"Label1.Label2.Label3\").
    #[serde(rename = "dnn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dnn: Option<String>,

    #[serde(rename = "subscriptionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscription_id: Option<String>,

    #[serde(rename = "plmnId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub plmn_id: Option<models::PlmnId>,

    #[serde(rename = "immediateReport")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub immediate_report: Option<bool>,

    #[serde(rename = "report")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub report: Option<models::ImmediateReport>,

    /// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  tableÂ 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.
    #[serde(rename = "supportedFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_features: Option<String>,

    #[serde(rename = "contextInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub context_info: Option<models::ContextInfo>,

    #[serde(rename = "nfChangeFilter")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nf_change_filter: Option<bool>,

    #[serde(rename = "uniqueSubscription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unique_subscription: Option<bool>,

    #[serde(rename = "resetIds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reset_ids: Option<Vec<String>>,

    #[serde(rename = "ueConSmfDataSubFilter")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ue_con_smf_data_sub_filter: Option<models::UeContextInSmfDataSubFilter>,
}

impl SdmSubscription {
    #[allow(clippy::new_without_default)]
    pub fn new(
        nf_instance_id: uuid::Uuid,
        callback_reference: String,
        monitored_resource_uris: Vec<models::Uri>,
    ) -> SdmSubscription {
        SdmSubscription {
            nf_instance_id,
            implicit_unsubscribe: None,
            expires: None,
            callback_reference,
            amf_service_name: None,
            monitored_resource_uris,
            single_nssai: None,
            dnn: None,
            subscription_id: None,
            plmn_id: None,
            immediate_report: Some(false),
            report: None,
            supported_features: None,
            context_info: None,
            nf_change_filter: Some(false),
            unique_subscription: None,
            reset_ids: None,
            ue_con_smf_data_sub_filter: None,
        }
    }
}

/// Converts the SdmSubscription value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SdmSubscription {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping nfInstanceId in query parameter serialization
            self.implicit_unsubscribe
                .as_ref()
                .map(|implicit_unsubscribe| {
                    vec![
                        "implicitUnsubscribe".to_string(),
                        implicit_unsubscribe.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping expires in query parameter serialization
            Some("callbackReference".to_string()),
            Some(self.callback_reference.to_string()),
            // Skipping amfServiceName in query parameter serialization
            Some("monitoredResourceUris".to_string()),
            Some(
                self.monitored_resource_uris
                    .iter()
                    .map(|x| x.to_string())
                    .collect::<Vec<_>>()
                    .join(","),
            ),
            // Skipping singleNssai in query parameter serialization
            self.dnn
                .as_ref()
                .map(|dnn| vec!["dnn".to_string(), dnn.to_string()].join(",")),
            self.subscription_id.as_ref().map(|subscription_id| {
                vec!["subscriptionId".to_string(), subscription_id.to_string()].join(",")
            }),
            // Skipping plmnId in query parameter serialization
            self.immediate_report.as_ref().map(|immediate_report| {
                vec!["immediateReport".to_string(), immediate_report.to_string()].join(",")
            }),
            // Skipping report in query parameter serialization
            self.supported_features.as_ref().map(|supported_features| {
                vec![
                    "supportedFeatures".to_string(),
                    supported_features.to_string(),
                ]
                .join(",")
            }),
            // Skipping contextInfo in query parameter serialization
            self.nf_change_filter.as_ref().map(|nf_change_filter| {
                vec!["nfChangeFilter".to_string(), nf_change_filter.to_string()].join(",")
            }),
            self.unique_subscription
                .as_ref()
                .map(|unique_subscription| {
                    vec![
                        "uniqueSubscription".to_string(),
                        unique_subscription.to_string(),
                    ]
                    .join(",")
                }),
            self.reset_ids.as_ref().map(|reset_ids| {
                vec![
                    "resetIds".to_string(),
                    reset_ids
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping ueConSmfDataSubFilter in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SdmSubscription value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SdmSubscription {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub nf_instance_id: Vec<uuid::Uuid>,
            pub implicit_unsubscribe: Vec<bool>,
            pub expires: Vec<chrono::DateTime<chrono::Utc>>,
            pub callback_reference: Vec<String>,
            pub amf_service_name: Vec<models::ServiceName>,
            pub monitored_resource_uris: Vec<Vec<models::Uri>>,
            pub single_nssai: Vec<models::Snssai>,
            pub dnn: Vec<String>,
            pub subscription_id: Vec<String>,
            pub plmn_id: Vec<models::PlmnId>,
            pub immediate_report: Vec<bool>,
            pub report: Vec<models::ImmediateReport>,
            pub supported_features: Vec<String>,
            pub context_info: Vec<models::ContextInfo>,
            pub nf_change_filter: Vec<bool>,
            pub unique_subscription: Vec<bool>,
            pub reset_ids: Vec<Vec<String>>,
            pub ue_con_smf_data_sub_filter: Vec<models::UeContextInSmfDataSubFilter>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SdmSubscription".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "nfInstanceId" => intermediate_rep.nf_instance_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "implicitUnsubscribe" => intermediate_rep.implicit_unsubscribe.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "expires" => intermediate_rep.expires.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "callbackReference" => intermediate_rep.callback_reference.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "amfServiceName" => intermediate_rep.amf_service_name.push(
                        <models::ServiceName as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "monitoredResourceUris" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SdmSubscription"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "singleNssai" => intermediate_rep.single_nssai.push(
                        <models::Snssai as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "dnn" => intermediate_rep.dnn.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "subscriptionId" => intermediate_rep.subscription_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "plmnId" => intermediate_rep.plmn_id.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "immediateReport" => intermediate_rep.immediate_report.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "report" => intermediate_rep.report.push(
                        <models::ImmediateReport as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "supportedFeatures" => intermediate_rep.supported_features.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "contextInfo" => intermediate_rep.context_info.push(
                        <models::ContextInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nfChangeFilter" => intermediate_rep.nf_change_filter.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "uniqueSubscription" => intermediate_rep.unique_subscription.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "resetIds" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SdmSubscription"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "ueConSmfDataSubFilter" => intermediate_rep.ue_con_smf_data_sub_filter.push(
                        <models::UeContextInSmfDataSubFilter as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SdmSubscription".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SdmSubscription {
            nf_instance_id: intermediate_rep
                .nf_instance_id
                .into_iter()
                .next()
                .ok_or_else(|| "nfInstanceId missing in SdmSubscription".to_string())?,
            implicit_unsubscribe: intermediate_rep.implicit_unsubscribe.into_iter().next(),
            expires: intermediate_rep.expires.into_iter().next(),
            callback_reference: intermediate_rep
                .callback_reference
                .into_iter()
                .next()
                .ok_or_else(|| "callbackReference missing in SdmSubscription".to_string())?,
            amf_service_name: intermediate_rep.amf_service_name.into_iter().next(),
            monitored_resource_uris: intermediate_rep
                .monitored_resource_uris
                .into_iter()
                .next()
                .ok_or_else(|| "monitoredResourceUris missing in SdmSubscription".to_string())?,
            single_nssai: intermediate_rep.single_nssai.into_iter().next(),
            dnn: intermediate_rep.dnn.into_iter().next(),
            subscription_id: intermediate_rep.subscription_id.into_iter().next(),
            plmn_id: intermediate_rep.plmn_id.into_iter().next(),
            immediate_report: intermediate_rep.immediate_report.into_iter().next(),
            report: intermediate_rep.report.into_iter().next(),
            supported_features: intermediate_rep.supported_features.into_iter().next(),
            context_info: intermediate_rep.context_info.into_iter().next(),
            nf_change_filter: intermediate_rep.nf_change_filter.into_iter().next(),
            unique_subscription: intermediate_rep.unique_subscription.into_iter().next(),
            reset_ids: intermediate_rep.reset_ids.into_iter().next(),
            ue_con_smf_data_sub_filter: intermediate_rep
                .ue_con_smf_data_sub_filter
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SdmSubscription> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SdmSubscription>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SdmSubscription>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SdmSubscription - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SdmSubscription>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SdmSubscription as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SdmSubscription - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SecuredPacket(swagger::ByteArray);

impl std::convert::From<swagger::ByteArray> for SecuredPacket {
    fn from(x: swagger::ByteArray) -> Self {
        SecuredPacket(x)
    }
}

impl std::convert::From<SecuredPacket> for swagger::ByteArray {
    fn from(x: SecuredPacket) -> Self {
        x.0
    }
}

impl std::ops::Deref for SecuredPacket {
    type Target = swagger::ByteArray;
    fn deref(&self) -> &swagger::ByteArray {
        &self.0
    }
}

impl std::ops::DerefMut for SecuredPacket {
    fn deref_mut(&mut self) -> &mut swagger::ByteArray {
        &mut self.0
    }
}

/// Contains a secure packet.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SecuredPacket1(swagger::ByteArray);

impl std::convert::From<swagger::ByteArray> for SecuredPacket1 {
    fn from(x: swagger::ByteArray) -> Self {
        SecuredPacket1(x)
    }
}

impl std::convert::From<SecuredPacket1> for swagger::ByteArray {
    fn from(x: SecuredPacket1) -> Self {
        x.0
    }
}

impl std::ops::Deref for SecuredPacket1 {
    type Target = swagger::ByteArray;
    fn deref(&self) -> &swagger::ByteArray {
        &self.0
    }
}

impl std::ops::DerefMut for SecuredPacket1 {
    fn deref_mut(&mut self) -> &mut swagger::ByteArray {
        &mut self.0
    }
}

/// The enumeration SensorMeasurement defines sensor measurement type for MDT in the trace. See 3GPP TS 32.422 for further description of the values. It shall comply with the provisions defined in table 5.6.3.7-1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SensorMeasurement {}

impl SensorMeasurement {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SensorMeasurement {
        SensorMeasurement {}
    }
}

/// Converts the SensorMeasurement value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SensorMeasurement {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SensorMeasurement value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SensorMeasurement {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SensorMeasurement".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SensorMeasurement".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SensorMeasurement {})
    }
}

// Methods for converting between header::IntoHeaderValue<SensorMeasurement> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SensorMeasurement>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SensorMeasurement>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SensorMeasurement - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SensorMeasurement>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SensorMeasurement as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SensorMeasurement - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum SensorMeasurementAnyOf {
    #[serde(rename = "BAROMETRIC_PRESSURE")]
    BarometricPressure,
    #[serde(rename = "UE_SPEED")]
    UeSpeed,
    #[serde(rename = "UE_ORIENTATION")]
    UeOrientation,
}

impl std::fmt::Display for SensorMeasurementAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            SensorMeasurementAnyOf::BarometricPressure => write!(f, "BAROMETRIC_PRESSURE"),
            SensorMeasurementAnyOf::UeSpeed => write!(f, "UE_SPEED"),
            SensorMeasurementAnyOf::UeOrientation => write!(f, "UE_ORIENTATION"),
        }
    }
}

impl std::str::FromStr for SensorMeasurementAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "BAROMETRIC_PRESSURE" => {
                std::result::Result::Ok(SensorMeasurementAnyOf::BarometricPressure)
            }
            "UE_SPEED" => std::result::Result::Ok(SensorMeasurementAnyOf::UeSpeed),
            "UE_ORIENTATION" => std::result::Result::Ok(SensorMeasurementAnyOf::UeOrientation),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Provides information about allowed or not allowed areas.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ServiceAreaRestriction(serde_json::Value);

impl std::convert::From<serde_json::Value> for ServiceAreaRestriction {
    fn from(x: serde_json::Value) -> Self {
        ServiceAreaRestriction(x)
    }
}

impl std::convert::From<ServiceAreaRestriction> for serde_json::Value {
    fn from(x: ServiceAreaRestriction) -> Self {
        x.0
    }
}

impl std::ops::Deref for ServiceAreaRestriction {
    type Target = serde_json::Value;
    fn deref(&self) -> &serde_json::Value {
        &self.0
    }
}

impl std::ops::DerefMut for ServiceAreaRestriction {
    fn deref_mut(&mut self) -> &mut serde_json::Value {
        &mut self.0
    }
}

impl FromStr for ServiceAreaRestriction {
    type Err = serde_json::Error;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(Self(serde_json::from_str(s)?))
    }
}

/// Service names known to NRF
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ServiceName {}

impl ServiceName {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ServiceName {
        ServiceName {}
    }
}

/// Converts the ServiceName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ServiceName {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ServiceName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ServiceName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ServiceName".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ServiceName".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ServiceName {})
    }
}

// Methods for converting between header::IntoHeaderValue<ServiceName> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ServiceName>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ServiceName>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ServiceName - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ServiceName> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ServiceName as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ServiceName - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ServiceNameAnyOf {
    #[serde(rename = "nnrf-nfm")]
    NnrfNfm,
    #[serde(rename = "nnrf-disc")]
    NnrfDisc,
    #[serde(rename = "nnrf-oauth2")]
    NnrfOauth2,
    #[serde(rename = "nudm-sdm")]
    NudmSdm,
    #[serde(rename = "nudm-uecm")]
    NudmUecm,
    #[serde(rename = "nudm-ueau")]
    NudmUeau,
    #[serde(rename = "nudm-ee")]
    NudmEe,
    #[serde(rename = "nudm-pp")]
    NudmPp,
    #[serde(rename = "nudm-niddau")]
    NudmNiddau,
    #[serde(rename = "nudm-mt")]
    NudmMt,
    #[serde(rename = "nudm-ssau")]
    NudmSsau,
    #[serde(rename = "nudm-rsds")]
    NudmRsds,
    #[serde(rename = "namf-comm")]
    NamfComm,
    #[serde(rename = "namf-evts")]
    NamfEvts,
    #[serde(rename = "namf-mt")]
    NamfMt,
    #[serde(rename = "namf-loc")]
    NamfLoc,
    #[serde(rename = "namf-mbs-comm")]
    NamfMbsComm,
    #[serde(rename = "namf-mbs-bc")]
    NamfMbsBc,
    #[serde(rename = "nsmf-pdusession")]
    NsmfPdusession,
    #[serde(rename = "nsmf-event-exposure")]
    NsmfEventExposure,
    #[serde(rename = "nsmf-nidd")]
    NsmfNidd,
    #[serde(rename = "nausf-auth")]
    NausfAuth,
    #[serde(rename = "nausf-sorprotection")]
    NausfSorprotection,
    #[serde(rename = "nausf-upuprotection")]
    NausfUpuprotection,
    #[serde(rename = "nnef-pfdmanagement")]
    NnefPfdmanagement,
    #[serde(rename = "nnef-smcontext")]
    NnefSmcontext,
    #[serde(rename = "nnef-eventexposure")]
    NnefEventexposure,
    #[serde(rename = "nnef-eas-deployment-info")]
    NnefEasDeploymentInfo,
    #[serde(rename = "3gpp-cp-parameter-provisioning")]
    Variant3gppCpParameterProvisioning,
    #[serde(rename = "3gpp-device-triggering")]
    Variant3gppDeviceTriggering,
    #[serde(rename = "3gpp-bdt")]
    Variant3gppBdt,
    #[serde(rename = "3gpp-traffic-influence")]
    Variant3gppTrafficInfluence,
    #[serde(rename = "3gpp-chargeable-party")]
    Variant3gppChargeableParty,
    #[serde(rename = "3gpp-as-session-with-qos")]
    Variant3gppAsSessionWithQos,
    #[serde(rename = "3gpp-msisdn-less-mo-sms")]
    Variant3gppMsisdnLessMoSms,
    #[serde(rename = "3gpp-service-parameter")]
    Variant3gppServiceParameter,
    #[serde(rename = "3gpp-monitoring-event")]
    Variant3gppMonitoringEvent,
    #[serde(rename = "3gpp-nidd-configuration-trigger")]
    Variant3gppNiddConfigurationTrigger,
    #[serde(rename = "3gpp-nidd")]
    Variant3gppNidd,
    #[serde(rename = "3gpp-analyticsexposure")]
    Variant3gppAnalyticsexposure,
    #[serde(rename = "3gpp-racs-parameter-provisioning")]
    Variant3gppRacsParameterProvisioning,
    #[serde(rename = "3gpp-ecr-control")]
    Variant3gppEcrControl,
    #[serde(rename = "3gpp-applying-bdt-policy")]
    Variant3gppApplyingBdtPolicy,
    #[serde(rename = "3gpp-mo-lcs-notify")]
    Variant3gppMoLcsNotify,
    #[serde(rename = "3gpp-time-sync")]
    Variant3gppTimeSync,
    #[serde(rename = "3gpp-am-influence")]
    Variant3gppAmInfluence,
    #[serde(rename = "3gpp-am-policyauthorization")]
    Variant3gppAmPolicyauthorization,
    #[serde(rename = "3gpp-akma")]
    Variant3gppAkma,
    #[serde(rename = "3gpp-eas-deployment")]
    Variant3gppEasDeployment,
    #[serde(rename = "3gpp-iptvconfiguration")]
    Variant3gppIptvconfiguration,
    #[serde(rename = "3gpp-mbs-tmgi")]
    Variant3gppMbsTmgi,
    #[serde(rename = "3gpp-mbs-session")]
    Variant3gppMbsSession,
    #[serde(rename = "3gpp-authentication")]
    Variant3gppAuthentication,
    #[serde(rename = "3gpp-asti")]
    Variant3gppAsti,
    #[serde(rename = "npcf-am-policy-control")]
    NpcfAmPolicyControl,
    #[serde(rename = "npcf-smpolicycontrol")]
    NpcfSmpolicycontrol,
    #[serde(rename = "npcf-policyauthorization")]
    NpcfPolicyauthorization,
    #[serde(rename = "npcf-bdtpolicycontrol")]
    NpcfBdtpolicycontrol,
    #[serde(rename = "npcf-eventexposure")]
    NpcfEventexposure,
    #[serde(rename = "npcf-ue-policy-control")]
    NpcfUePolicyControl,
    #[serde(rename = "npcf-am-policyauthorization")]
    NpcfAmPolicyauthorization,
    #[serde(rename = "nsmsf-sms")]
    NsmsfSms,
    #[serde(rename = "nnssf-nsselection")]
    NnssfNsselection,
    #[serde(rename = "nnssf-nssaiavailability")]
    NnssfNssaiavailability,
    #[serde(rename = "nudr-dr")]
    NudrDr,
    #[serde(rename = "nudr-group-id-map")]
    NudrGroupIdMap,
    #[serde(rename = "nlmf-loc")]
    NlmfLoc,
    #[serde(rename = "n5g-eir-eic")]
    N5gEirEic,
    #[serde(rename = "nbsf-management")]
    NbsfManagement,
    #[serde(rename = "nchf-spendinglimitcontrol")]
    NchfSpendinglimitcontrol,
    #[serde(rename = "nchf-convergedcharging")]
    NchfConvergedcharging,
    #[serde(rename = "nchf-offlineonlycharging")]
    NchfOfflineonlycharging,
    #[serde(rename = "nnwdaf-eventssubscription")]
    NnwdafEventssubscription,
    #[serde(rename = "nnwdaf-analyticsinfo")]
    NnwdafAnalyticsinfo,
    #[serde(rename = "nnwdaf-datamanagement")]
    NnwdafDatamanagement,
    #[serde(rename = "nnwdaf-mlmodelprovision")]
    NnwdafMlmodelprovision,
    #[serde(rename = "ngmlc-loc")]
    NgmlcLoc,
    #[serde(rename = "nucmf-provisioning")]
    NucmfProvisioning,
    #[serde(rename = "nucmf-uecapabilitymanagement")]
    NucmfUecapabilitymanagement,
    #[serde(rename = "nhss-sdm")]
    NhssSdm,
    #[serde(rename = "nhss-uecm")]
    NhssUecm,
    #[serde(rename = "nhss-ueau")]
    NhssUeau,
    #[serde(rename = "nhss-ee")]
    NhssEe,
    #[serde(rename = "nhss-ims-sdm")]
    NhssImsSdm,
    #[serde(rename = "nhss-ims-uecm")]
    NhssImsUecm,
    #[serde(rename = "nhss-ims-ueau")]
    NhssImsUeau,
    #[serde(rename = "nhss-gba-sdm")]
    NhssGbaSdm,
    #[serde(rename = "nhss-gba-ueau")]
    NhssGbaUeau,
    #[serde(rename = "nsepp-telescopic")]
    NseppTelescopic,
    #[serde(rename = "nsoraf-sor")]
    NsorafSor,
    #[serde(rename = "nspaf-secured-packet")]
    NspafSecuredPacket,
    #[serde(rename = "nudsf-dr")]
    NudsfDr,
    #[serde(rename = "nudsf-timer")]
    NudsfTimer,
    #[serde(rename = "nnssaaf-nssaa")]
    NnssaafNssaa,
    #[serde(rename = "nnssaaf-aiw")]
    NnssaafAiw,
    #[serde(rename = "naanf-akma")]
    NaanfAkma,
    #[serde(rename = "n5gddnmf-discovery")]
    N5gddnmfDiscovery,
    #[serde(rename = "nmfaf-3dadm")]
    Nmfaf3dadm,
    #[serde(rename = "nmfaf-3cadm")]
    Nmfaf3cadm,
    #[serde(rename = "neasdf-dnscontext")]
    NeasdfDnscontext,
    #[serde(rename = "neasdf-baselinednspattern")]
    NeasdfBaselinednspattern,
    #[serde(rename = "ndccf-dm")]
    NdccfDm,
    #[serde(rename = "ndccf-cm")]
    NdccfCm,
    #[serde(rename = "nnsacf-nsac")]
    NnsacfNsac,
    #[serde(rename = "nnsacf-slice-ee")]
    NnsacfSliceEe,
    #[serde(rename = "nmbsmf-tmgi")]
    NmbsmfTmgi,
    #[serde(rename = "nmbsmf-mbssession")]
    NmbsmfMbssession,
    #[serde(rename = "nadrf-dm")]
    NadrfDm,
    #[serde(rename = "nbsp-gba")]
    NbspGba,
    #[serde(rename = "ntsctsf-time-sync")]
    NtsctsfTimeSync,
    #[serde(rename = "ntsctsf-qos-tscai")]
    NtsctsfQosTscai,
    #[serde(rename = "ntsctsf-asti")]
    NtsctsfAsti,
    #[serde(rename = "npkmf-keyreq")]
    NpkmfKeyreq,
    #[serde(rename = "nmnpf-npstatus")]
    NmnpfNpstatus,
    #[serde(rename = "niwmsc-smservice")]
    NiwmscSmservice,
    #[serde(rename = "nmbsf-mbsuserserv")]
    NmbsfMbsuserserv,
    #[serde(rename = "nmbsf-mbsuserdataing")]
    NmbsfMbsuserdataing,
    #[serde(rename = "nmbstf-distsession")]
    NmbstfDistsession,
    #[serde(rename = "npanf-prosekey")]
    NpanfProsekey,
}

impl std::fmt::Display for ServiceNameAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ServiceNameAnyOf::NnrfNfm => write!(f, "nnrf-nfm"),
            ServiceNameAnyOf::NnrfDisc => write!(f, "nnrf-disc"),
            ServiceNameAnyOf::NnrfOauth2 => write!(f, "nnrf-oauth2"),
            ServiceNameAnyOf::NudmSdm => write!(f, "nudm-sdm"),
            ServiceNameAnyOf::NudmUecm => write!(f, "nudm-uecm"),
            ServiceNameAnyOf::NudmUeau => write!(f, "nudm-ueau"),
            ServiceNameAnyOf::NudmEe => write!(f, "nudm-ee"),
            ServiceNameAnyOf::NudmPp => write!(f, "nudm-pp"),
            ServiceNameAnyOf::NudmNiddau => write!(f, "nudm-niddau"),
            ServiceNameAnyOf::NudmMt => write!(f, "nudm-mt"),
            ServiceNameAnyOf::NudmSsau => write!(f, "nudm-ssau"),
            ServiceNameAnyOf::NudmRsds => write!(f, "nudm-rsds"),
            ServiceNameAnyOf::NamfComm => write!(f, "namf-comm"),
            ServiceNameAnyOf::NamfEvts => write!(f, "namf-evts"),
            ServiceNameAnyOf::NamfMt => write!(f, "namf-mt"),
            ServiceNameAnyOf::NamfLoc => write!(f, "namf-loc"),
            ServiceNameAnyOf::NamfMbsComm => write!(f, "namf-mbs-comm"),
            ServiceNameAnyOf::NamfMbsBc => write!(f, "namf-mbs-bc"),
            ServiceNameAnyOf::NsmfPdusession => write!(f, "nsmf-pdusession"),
            ServiceNameAnyOf::NsmfEventExposure => write!(f, "nsmf-event-exposure"),
            ServiceNameAnyOf::NsmfNidd => write!(f, "nsmf-nidd"),
            ServiceNameAnyOf::NausfAuth => write!(f, "nausf-auth"),
            ServiceNameAnyOf::NausfSorprotection => write!(f, "nausf-sorprotection"),
            ServiceNameAnyOf::NausfUpuprotection => write!(f, "nausf-upuprotection"),
            ServiceNameAnyOf::NnefPfdmanagement => write!(f, "nnef-pfdmanagement"),
            ServiceNameAnyOf::NnefSmcontext => write!(f, "nnef-smcontext"),
            ServiceNameAnyOf::NnefEventexposure => write!(f, "nnef-eventexposure"),
            ServiceNameAnyOf::NnefEasDeploymentInfo => write!(f, "nnef-eas-deployment-info"),
            ServiceNameAnyOf::Variant3gppCpParameterProvisioning => {
                write!(f, "3gpp-cp-parameter-provisioning")
            }
            ServiceNameAnyOf::Variant3gppDeviceTriggering => write!(f, "3gpp-device-triggering"),
            ServiceNameAnyOf::Variant3gppBdt => write!(f, "3gpp-bdt"),
            ServiceNameAnyOf::Variant3gppTrafficInfluence => write!(f, "3gpp-traffic-influence"),
            ServiceNameAnyOf::Variant3gppChargeableParty => write!(f, "3gpp-chargeable-party"),
            ServiceNameAnyOf::Variant3gppAsSessionWithQos => write!(f, "3gpp-as-session-with-qos"),
            ServiceNameAnyOf::Variant3gppMsisdnLessMoSms => write!(f, "3gpp-msisdn-less-mo-sms"),
            ServiceNameAnyOf::Variant3gppServiceParameter => write!(f, "3gpp-service-parameter"),
            ServiceNameAnyOf::Variant3gppMonitoringEvent => write!(f, "3gpp-monitoring-event"),
            ServiceNameAnyOf::Variant3gppNiddConfigurationTrigger => {
                write!(f, "3gpp-nidd-configuration-trigger")
            }
            ServiceNameAnyOf::Variant3gppNidd => write!(f, "3gpp-nidd"),
            ServiceNameAnyOf::Variant3gppAnalyticsexposure => write!(f, "3gpp-analyticsexposure"),
            ServiceNameAnyOf::Variant3gppRacsParameterProvisioning => {
                write!(f, "3gpp-racs-parameter-provisioning")
            }
            ServiceNameAnyOf::Variant3gppEcrControl => write!(f, "3gpp-ecr-control"),
            ServiceNameAnyOf::Variant3gppApplyingBdtPolicy => write!(f, "3gpp-applying-bdt-policy"),
            ServiceNameAnyOf::Variant3gppMoLcsNotify => write!(f, "3gpp-mo-lcs-notify"),
            ServiceNameAnyOf::Variant3gppTimeSync => write!(f, "3gpp-time-sync"),
            ServiceNameAnyOf::Variant3gppAmInfluence => write!(f, "3gpp-am-influence"),
            ServiceNameAnyOf::Variant3gppAmPolicyauthorization => {
                write!(f, "3gpp-am-policyauthorization")
            }
            ServiceNameAnyOf::Variant3gppAkma => write!(f, "3gpp-akma"),
            ServiceNameAnyOf::Variant3gppEasDeployment => write!(f, "3gpp-eas-deployment"),
            ServiceNameAnyOf::Variant3gppIptvconfiguration => write!(f, "3gpp-iptvconfiguration"),
            ServiceNameAnyOf::Variant3gppMbsTmgi => write!(f, "3gpp-mbs-tmgi"),
            ServiceNameAnyOf::Variant3gppMbsSession => write!(f, "3gpp-mbs-session"),
            ServiceNameAnyOf::Variant3gppAuthentication => write!(f, "3gpp-authentication"),
            ServiceNameAnyOf::Variant3gppAsti => write!(f, "3gpp-asti"),
            ServiceNameAnyOf::NpcfAmPolicyControl => write!(f, "npcf-am-policy-control"),
            ServiceNameAnyOf::NpcfSmpolicycontrol => write!(f, "npcf-smpolicycontrol"),
            ServiceNameAnyOf::NpcfPolicyauthorization => write!(f, "npcf-policyauthorization"),
            ServiceNameAnyOf::NpcfBdtpolicycontrol => write!(f, "npcf-bdtpolicycontrol"),
            ServiceNameAnyOf::NpcfEventexposure => write!(f, "npcf-eventexposure"),
            ServiceNameAnyOf::NpcfUePolicyControl => write!(f, "npcf-ue-policy-control"),
            ServiceNameAnyOf::NpcfAmPolicyauthorization => write!(f, "npcf-am-policyauthorization"),
            ServiceNameAnyOf::NsmsfSms => write!(f, "nsmsf-sms"),
            ServiceNameAnyOf::NnssfNsselection => write!(f, "nnssf-nsselection"),
            ServiceNameAnyOf::NnssfNssaiavailability => write!(f, "nnssf-nssaiavailability"),
            ServiceNameAnyOf::NudrDr => write!(f, "nudr-dr"),
            ServiceNameAnyOf::NudrGroupIdMap => write!(f, "nudr-group-id-map"),
            ServiceNameAnyOf::NlmfLoc => write!(f, "nlmf-loc"),
            ServiceNameAnyOf::N5gEirEic => write!(f, "n5g-eir-eic"),
            ServiceNameAnyOf::NbsfManagement => write!(f, "nbsf-management"),
            ServiceNameAnyOf::NchfSpendinglimitcontrol => write!(f, "nchf-spendinglimitcontrol"),
            ServiceNameAnyOf::NchfConvergedcharging => write!(f, "nchf-convergedcharging"),
            ServiceNameAnyOf::NchfOfflineonlycharging => write!(f, "nchf-offlineonlycharging"),
            ServiceNameAnyOf::NnwdafEventssubscription => write!(f, "nnwdaf-eventssubscription"),
            ServiceNameAnyOf::NnwdafAnalyticsinfo => write!(f, "nnwdaf-analyticsinfo"),
            ServiceNameAnyOf::NnwdafDatamanagement => write!(f, "nnwdaf-datamanagement"),
            ServiceNameAnyOf::NnwdafMlmodelprovision => write!(f, "nnwdaf-mlmodelprovision"),
            ServiceNameAnyOf::NgmlcLoc => write!(f, "ngmlc-loc"),
            ServiceNameAnyOf::NucmfProvisioning => write!(f, "nucmf-provisioning"),
            ServiceNameAnyOf::NucmfUecapabilitymanagement => {
                write!(f, "nucmf-uecapabilitymanagement")
            }
            ServiceNameAnyOf::NhssSdm => write!(f, "nhss-sdm"),
            ServiceNameAnyOf::NhssUecm => write!(f, "nhss-uecm"),
            ServiceNameAnyOf::NhssUeau => write!(f, "nhss-ueau"),
            ServiceNameAnyOf::NhssEe => write!(f, "nhss-ee"),
            ServiceNameAnyOf::NhssImsSdm => write!(f, "nhss-ims-sdm"),
            ServiceNameAnyOf::NhssImsUecm => write!(f, "nhss-ims-uecm"),
            ServiceNameAnyOf::NhssImsUeau => write!(f, "nhss-ims-ueau"),
            ServiceNameAnyOf::NhssGbaSdm => write!(f, "nhss-gba-sdm"),
            ServiceNameAnyOf::NhssGbaUeau => write!(f, "nhss-gba-ueau"),
            ServiceNameAnyOf::NseppTelescopic => write!(f, "nsepp-telescopic"),
            ServiceNameAnyOf::NsorafSor => write!(f, "nsoraf-sor"),
            ServiceNameAnyOf::NspafSecuredPacket => write!(f, "nspaf-secured-packet"),
            ServiceNameAnyOf::NudsfDr => write!(f, "nudsf-dr"),
            ServiceNameAnyOf::NudsfTimer => write!(f, "nudsf-timer"),
            ServiceNameAnyOf::NnssaafNssaa => write!(f, "nnssaaf-nssaa"),
            ServiceNameAnyOf::NnssaafAiw => write!(f, "nnssaaf-aiw"),
            ServiceNameAnyOf::NaanfAkma => write!(f, "naanf-akma"),
            ServiceNameAnyOf::N5gddnmfDiscovery => write!(f, "n5gddnmf-discovery"),
            ServiceNameAnyOf::Nmfaf3dadm => write!(f, "nmfaf-3dadm"),
            ServiceNameAnyOf::Nmfaf3cadm => write!(f, "nmfaf-3cadm"),
            ServiceNameAnyOf::NeasdfDnscontext => write!(f, "neasdf-dnscontext"),
            ServiceNameAnyOf::NeasdfBaselinednspattern => write!(f, "neasdf-baselinednspattern"),
            ServiceNameAnyOf::NdccfDm => write!(f, "ndccf-dm"),
            ServiceNameAnyOf::NdccfCm => write!(f, "ndccf-cm"),
            ServiceNameAnyOf::NnsacfNsac => write!(f, "nnsacf-nsac"),
            ServiceNameAnyOf::NnsacfSliceEe => write!(f, "nnsacf-slice-ee"),
            ServiceNameAnyOf::NmbsmfTmgi => write!(f, "nmbsmf-tmgi"),
            ServiceNameAnyOf::NmbsmfMbssession => write!(f, "nmbsmf-mbssession"),
            ServiceNameAnyOf::NadrfDm => write!(f, "nadrf-dm"),
            ServiceNameAnyOf::NbspGba => write!(f, "nbsp-gba"),
            ServiceNameAnyOf::NtsctsfTimeSync => write!(f, "ntsctsf-time-sync"),
            ServiceNameAnyOf::NtsctsfQosTscai => write!(f, "ntsctsf-qos-tscai"),
            ServiceNameAnyOf::NtsctsfAsti => write!(f, "ntsctsf-asti"),
            ServiceNameAnyOf::NpkmfKeyreq => write!(f, "npkmf-keyreq"),
            ServiceNameAnyOf::NmnpfNpstatus => write!(f, "nmnpf-npstatus"),
            ServiceNameAnyOf::NiwmscSmservice => write!(f, "niwmsc-smservice"),
            ServiceNameAnyOf::NmbsfMbsuserserv => write!(f, "nmbsf-mbsuserserv"),
            ServiceNameAnyOf::NmbsfMbsuserdataing => write!(f, "nmbsf-mbsuserdataing"),
            ServiceNameAnyOf::NmbstfDistsession => write!(f, "nmbstf-distsession"),
            ServiceNameAnyOf::NpanfProsekey => write!(f, "npanf-prosekey"),
        }
    }
}

impl std::str::FromStr for ServiceNameAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "nnrf-nfm" => std::result::Result::Ok(ServiceNameAnyOf::NnrfNfm),
            "nnrf-disc" => std::result::Result::Ok(ServiceNameAnyOf::NnrfDisc),
            "nnrf-oauth2" => std::result::Result::Ok(ServiceNameAnyOf::NnrfOauth2),
            "nudm-sdm" => std::result::Result::Ok(ServiceNameAnyOf::NudmSdm),
            "nudm-uecm" => std::result::Result::Ok(ServiceNameAnyOf::NudmUecm),
            "nudm-ueau" => std::result::Result::Ok(ServiceNameAnyOf::NudmUeau),
            "nudm-ee" => std::result::Result::Ok(ServiceNameAnyOf::NudmEe),
            "nudm-pp" => std::result::Result::Ok(ServiceNameAnyOf::NudmPp),
            "nudm-niddau" => std::result::Result::Ok(ServiceNameAnyOf::NudmNiddau),
            "nudm-mt" => std::result::Result::Ok(ServiceNameAnyOf::NudmMt),
            "nudm-ssau" => std::result::Result::Ok(ServiceNameAnyOf::NudmSsau),
            "nudm-rsds" => std::result::Result::Ok(ServiceNameAnyOf::NudmRsds),
            "namf-comm" => std::result::Result::Ok(ServiceNameAnyOf::NamfComm),
            "namf-evts" => std::result::Result::Ok(ServiceNameAnyOf::NamfEvts),
            "namf-mt" => std::result::Result::Ok(ServiceNameAnyOf::NamfMt),
            "namf-loc" => std::result::Result::Ok(ServiceNameAnyOf::NamfLoc),
            "namf-mbs-comm" => std::result::Result::Ok(ServiceNameAnyOf::NamfMbsComm),
            "namf-mbs-bc" => std::result::Result::Ok(ServiceNameAnyOf::NamfMbsBc),
            "nsmf-pdusession" => std::result::Result::Ok(ServiceNameAnyOf::NsmfPdusession),
            "nsmf-event-exposure" => std::result::Result::Ok(ServiceNameAnyOf::NsmfEventExposure),
            "nsmf-nidd" => std::result::Result::Ok(ServiceNameAnyOf::NsmfNidd),
            "nausf-auth" => std::result::Result::Ok(ServiceNameAnyOf::NausfAuth),
            "nausf-sorprotection" => std::result::Result::Ok(ServiceNameAnyOf::NausfSorprotection),
            "nausf-upuprotection" => std::result::Result::Ok(ServiceNameAnyOf::NausfUpuprotection),
            "nnef-pfdmanagement" => std::result::Result::Ok(ServiceNameAnyOf::NnefPfdmanagement),
            "nnef-smcontext" => std::result::Result::Ok(ServiceNameAnyOf::NnefSmcontext),
            "nnef-eventexposure" => std::result::Result::Ok(ServiceNameAnyOf::NnefEventexposure),
            "nnef-eas-deployment-info" => {
                std::result::Result::Ok(ServiceNameAnyOf::NnefEasDeploymentInfo)
            }
            "3gpp-cp-parameter-provisioning" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppCpParameterProvisioning)
            }
            "3gpp-device-triggering" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppDeviceTriggering)
            }
            "3gpp-bdt" => std::result::Result::Ok(ServiceNameAnyOf::Variant3gppBdt),
            "3gpp-traffic-influence" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppTrafficInfluence)
            }
            "3gpp-chargeable-party" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppChargeableParty)
            }
            "3gpp-as-session-with-qos" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppAsSessionWithQos)
            }
            "3gpp-msisdn-less-mo-sms" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppMsisdnLessMoSms)
            }
            "3gpp-service-parameter" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppServiceParameter)
            }
            "3gpp-monitoring-event" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppMonitoringEvent)
            }
            "3gpp-nidd-configuration-trigger" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppNiddConfigurationTrigger)
            }
            "3gpp-nidd" => std::result::Result::Ok(ServiceNameAnyOf::Variant3gppNidd),
            "3gpp-analyticsexposure" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppAnalyticsexposure)
            }
            "3gpp-racs-parameter-provisioning" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppRacsParameterProvisioning)
            }
            "3gpp-ecr-control" => std::result::Result::Ok(ServiceNameAnyOf::Variant3gppEcrControl),
            "3gpp-applying-bdt-policy" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppApplyingBdtPolicy)
            }
            "3gpp-mo-lcs-notify" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppMoLcsNotify)
            }
            "3gpp-time-sync" => std::result::Result::Ok(ServiceNameAnyOf::Variant3gppTimeSync),
            "3gpp-am-influence" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppAmInfluence)
            }
            "3gpp-am-policyauthorization" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppAmPolicyauthorization)
            }
            "3gpp-akma" => std::result::Result::Ok(ServiceNameAnyOf::Variant3gppAkma),
            "3gpp-eas-deployment" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppEasDeployment)
            }
            "3gpp-iptvconfiguration" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppIptvconfiguration)
            }
            "3gpp-mbs-tmgi" => std::result::Result::Ok(ServiceNameAnyOf::Variant3gppMbsTmgi),
            "3gpp-mbs-session" => std::result::Result::Ok(ServiceNameAnyOf::Variant3gppMbsSession),
            "3gpp-authentication" => {
                std::result::Result::Ok(ServiceNameAnyOf::Variant3gppAuthentication)
            }
            "3gpp-asti" => std::result::Result::Ok(ServiceNameAnyOf::Variant3gppAsti),
            "npcf-am-policy-control" => {
                std::result::Result::Ok(ServiceNameAnyOf::NpcfAmPolicyControl)
            }
            "npcf-smpolicycontrol" => {
                std::result::Result::Ok(ServiceNameAnyOf::NpcfSmpolicycontrol)
            }
            "npcf-policyauthorization" => {
                std::result::Result::Ok(ServiceNameAnyOf::NpcfPolicyauthorization)
            }
            "npcf-bdtpolicycontrol" => {
                std::result::Result::Ok(ServiceNameAnyOf::NpcfBdtpolicycontrol)
            }
            "npcf-eventexposure" => std::result::Result::Ok(ServiceNameAnyOf::NpcfEventexposure),
            "npcf-ue-policy-control" => {
                std::result::Result::Ok(ServiceNameAnyOf::NpcfUePolicyControl)
            }
            "npcf-am-policyauthorization" => {
                std::result::Result::Ok(ServiceNameAnyOf::NpcfAmPolicyauthorization)
            }
            "nsmsf-sms" => std::result::Result::Ok(ServiceNameAnyOf::NsmsfSms),
            "nnssf-nsselection" => std::result::Result::Ok(ServiceNameAnyOf::NnssfNsselection),
            "nnssf-nssaiavailability" => {
                std::result::Result::Ok(ServiceNameAnyOf::NnssfNssaiavailability)
            }
            "nudr-dr" => std::result::Result::Ok(ServiceNameAnyOf::NudrDr),
            "nudr-group-id-map" => std::result::Result::Ok(ServiceNameAnyOf::NudrGroupIdMap),
            "nlmf-loc" => std::result::Result::Ok(ServiceNameAnyOf::NlmfLoc),
            "n5g-eir-eic" => std::result::Result::Ok(ServiceNameAnyOf::N5gEirEic),
            "nbsf-management" => std::result::Result::Ok(ServiceNameAnyOf::NbsfManagement),
            "nchf-spendinglimitcontrol" => {
                std::result::Result::Ok(ServiceNameAnyOf::NchfSpendinglimitcontrol)
            }
            "nchf-convergedcharging" => {
                std::result::Result::Ok(ServiceNameAnyOf::NchfConvergedcharging)
            }
            "nchf-offlineonlycharging" => {
                std::result::Result::Ok(ServiceNameAnyOf::NchfOfflineonlycharging)
            }
            "nnwdaf-eventssubscription" => {
                std::result::Result::Ok(ServiceNameAnyOf::NnwdafEventssubscription)
            }
            "nnwdaf-analyticsinfo" => {
                std::result::Result::Ok(ServiceNameAnyOf::NnwdafAnalyticsinfo)
            }
            "nnwdaf-datamanagement" => {
                std::result::Result::Ok(ServiceNameAnyOf::NnwdafDatamanagement)
            }
            "nnwdaf-mlmodelprovision" => {
                std::result::Result::Ok(ServiceNameAnyOf::NnwdafMlmodelprovision)
            }
            "ngmlc-loc" => std::result::Result::Ok(ServiceNameAnyOf::NgmlcLoc),
            "nucmf-provisioning" => std::result::Result::Ok(ServiceNameAnyOf::NucmfProvisioning),
            "nucmf-uecapabilitymanagement" => {
                std::result::Result::Ok(ServiceNameAnyOf::NucmfUecapabilitymanagement)
            }
            "nhss-sdm" => std::result::Result::Ok(ServiceNameAnyOf::NhssSdm),
            "nhss-uecm" => std::result::Result::Ok(ServiceNameAnyOf::NhssUecm),
            "nhss-ueau" => std::result::Result::Ok(ServiceNameAnyOf::NhssUeau),
            "nhss-ee" => std::result::Result::Ok(ServiceNameAnyOf::NhssEe),
            "nhss-ims-sdm" => std::result::Result::Ok(ServiceNameAnyOf::NhssImsSdm),
            "nhss-ims-uecm" => std::result::Result::Ok(ServiceNameAnyOf::NhssImsUecm),
            "nhss-ims-ueau" => std::result::Result::Ok(ServiceNameAnyOf::NhssImsUeau),
            "nhss-gba-sdm" => std::result::Result::Ok(ServiceNameAnyOf::NhssGbaSdm),
            "nhss-gba-ueau" => std::result::Result::Ok(ServiceNameAnyOf::NhssGbaUeau),
            "nsepp-telescopic" => std::result::Result::Ok(ServiceNameAnyOf::NseppTelescopic),
            "nsoraf-sor" => std::result::Result::Ok(ServiceNameAnyOf::NsorafSor),
            "nspaf-secured-packet" => std::result::Result::Ok(ServiceNameAnyOf::NspafSecuredPacket),
            "nudsf-dr" => std::result::Result::Ok(ServiceNameAnyOf::NudsfDr),
            "nudsf-timer" => std::result::Result::Ok(ServiceNameAnyOf::NudsfTimer),
            "nnssaaf-nssaa" => std::result::Result::Ok(ServiceNameAnyOf::NnssaafNssaa),
            "nnssaaf-aiw" => std::result::Result::Ok(ServiceNameAnyOf::NnssaafAiw),
            "naanf-akma" => std::result::Result::Ok(ServiceNameAnyOf::NaanfAkma),
            "n5gddnmf-discovery" => std::result::Result::Ok(ServiceNameAnyOf::N5gddnmfDiscovery),
            "nmfaf-3dadm" => std::result::Result::Ok(ServiceNameAnyOf::Nmfaf3dadm),
            "nmfaf-3cadm" => std::result::Result::Ok(ServiceNameAnyOf::Nmfaf3cadm),
            "neasdf-dnscontext" => std::result::Result::Ok(ServiceNameAnyOf::NeasdfDnscontext),
            "neasdf-baselinednspattern" => {
                std::result::Result::Ok(ServiceNameAnyOf::NeasdfBaselinednspattern)
            }
            "ndccf-dm" => std::result::Result::Ok(ServiceNameAnyOf::NdccfDm),
            "ndccf-cm" => std::result::Result::Ok(ServiceNameAnyOf::NdccfCm),
            "nnsacf-nsac" => std::result::Result::Ok(ServiceNameAnyOf::NnsacfNsac),
            "nnsacf-slice-ee" => std::result::Result::Ok(ServiceNameAnyOf::NnsacfSliceEe),
            "nmbsmf-tmgi" => std::result::Result::Ok(ServiceNameAnyOf::NmbsmfTmgi),
            "nmbsmf-mbssession" => std::result::Result::Ok(ServiceNameAnyOf::NmbsmfMbssession),
            "nadrf-dm" => std::result::Result::Ok(ServiceNameAnyOf::NadrfDm),
            "nbsp-gba" => std::result::Result::Ok(ServiceNameAnyOf::NbspGba),
            "ntsctsf-time-sync" => std::result::Result::Ok(ServiceNameAnyOf::NtsctsfTimeSync),
            "ntsctsf-qos-tscai" => std::result::Result::Ok(ServiceNameAnyOf::NtsctsfQosTscai),
            "ntsctsf-asti" => std::result::Result::Ok(ServiceNameAnyOf::NtsctsfAsti),
            "npkmf-keyreq" => std::result::Result::Ok(ServiceNameAnyOf::NpkmfKeyreq),
            "nmnpf-npstatus" => std::result::Result::Ok(ServiceNameAnyOf::NmnpfNpstatus),
            "niwmsc-smservice" => std::result::Result::Ok(ServiceNameAnyOf::NiwmscSmservice),
            "nmbsf-mbsuserserv" => std::result::Result::Ok(ServiceNameAnyOf::NmbsfMbsuserserv),
            "nmbsf-mbsuserdataing" => {
                std::result::Result::Ok(ServiceNameAnyOf::NmbsfMbsuserdataing)
            }
            "nmbstf-distsession" => std::result::Result::Ok(ServiceNameAnyOf::NmbstfDistsession),
            "npanf-prosekey" => std::result::Result::Ok(ServiceNameAnyOf::NpanfProsekey),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ServiceTypeUnrelatedClass {
    /// LCS service type.
    #[serde(rename = "serviceType")]
    pub service_type: u8,

    #[serde(rename = "allowedGeographicArea")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allowed_geographic_area: Option<Vec<models::GeographicArea>>,

    #[serde(rename = "privacyCheckRelatedAction")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub privacy_check_related_action: Option<models::PrivacyCheckRelatedAction>,

    #[serde(rename = "codeWordInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub code_word_ind: Option<models::CodeWordInd>,

    #[serde(rename = "validTimePeriod")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub valid_time_period: Option<models::ValidTimePeriod>,

    #[serde(rename = "codeWordList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub code_word_list: Option<Vec<models::CodeWord>>,
}

impl ServiceTypeUnrelatedClass {
    #[allow(clippy::new_without_default)]
    pub fn new(service_type: u8) -> ServiceTypeUnrelatedClass {
        ServiceTypeUnrelatedClass {
            service_type,
            allowed_geographic_area: None,
            privacy_check_related_action: None,
            code_word_ind: None,
            valid_time_period: None,
            code_word_list: None,
        }
    }
}

/// Converts the ServiceTypeUnrelatedClass value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ServiceTypeUnrelatedClass {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("serviceType".to_string()),
            Some(self.service_type.to_string()),
            // Skipping allowedGeographicArea in query parameter serialization

            // Skipping privacyCheckRelatedAction in query parameter serialization

            // Skipping codeWordInd in query parameter serialization

            // Skipping validTimePeriod in query parameter serialization
            self.code_word_list.as_ref().map(|code_word_list| {
                vec![
                    "codeWordList".to_string(),
                    code_word_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ServiceTypeUnrelatedClass value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ServiceTypeUnrelatedClass {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub service_type: Vec<u8>,
            pub allowed_geographic_area: Vec<Vec<models::GeographicArea>>,
            pub privacy_check_related_action: Vec<models::PrivacyCheckRelatedAction>,
            pub code_word_ind: Vec<models::CodeWordInd>,
            pub valid_time_period: Vec<models::ValidTimePeriod>,
            pub code_word_list: Vec<Vec<models::CodeWord>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ServiceTypeUnrelatedClass".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "serviceType" => intermediate_rep.service_type.push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "allowedGeographicArea" => return std::result::Result::Err("Parsing a container in this style is not supported in ServiceTypeUnrelatedClass".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "privacyCheckRelatedAction" => intermediate_rep.privacy_check_related_action.push(<models::PrivacyCheckRelatedAction as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "codeWordInd" => intermediate_rep.code_word_ind.push(<models::CodeWordInd as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "validTimePeriod" => intermediate_rep.valid_time_period.push(<models::ValidTimePeriod as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "codeWordList" => return std::result::Result::Err("Parsing a container in this style is not supported in ServiceTypeUnrelatedClass".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ServiceTypeUnrelatedClass".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ServiceTypeUnrelatedClass {
            service_type: intermediate_rep
                .service_type
                .into_iter()
                .next()
                .ok_or_else(|| "serviceType missing in ServiceTypeUnrelatedClass".to_string())?,
            allowed_geographic_area: intermediate_rep.allowed_geographic_area.into_iter().next(),
            privacy_check_related_action: intermediate_rep
                .privacy_check_related_action
                .into_iter()
                .next(),
            code_word_ind: intermediate_rep.code_word_ind.into_iter().next(),
            valid_time_period: intermediate_rep.valid_time_period.into_iter().next(),
            code_word_list: intermediate_rep.code_word_list.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ServiceTypeUnrelatedClass> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ServiceTypeUnrelatedClass>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ServiceTypeUnrelatedClass>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ServiceTypeUnrelatedClass - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ServiceTypeUnrelatedClass>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ServiceTypeUnrelatedClass as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ServiceTypeUnrelatedClass - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SessionManagementSubscriptionData {
    #[serde(rename = "singleNssai")]
    pub single_nssai: models::Snssai,

    /// A map (list of key-value pairs where Dnn, or optionally the Wildcard DNN, serves as key) of DnnConfigurations
    #[serde(rename = "dnnConfigurations")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dnn_configurations: Option<std::collections::HashMap<String, models::DnnConfiguration>>,

    #[serde(rename = "internalGroupIds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub internal_group_ids: Option<Vec<models::GroupId>>,

    /// A map(list of key-value pairs) where GroupId serves as key of SharedDataId
    #[serde(rename = "sharedVnGroupDataIds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shared_vn_group_data_ids: Option<std::collections::HashMap<String, models::SharedDataId>>,

    #[serde(rename = "sharedDnnConfigurationsId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shared_dnn_configurations_id: Option<String>,

    #[serde(rename = "odbPacketServices")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub odb_packet_services: Option<models::OdbPacketServices>,

    #[serde(rename = "traceData")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trace_data: Option<swagger::Nullable<models::TraceData>>,

    #[serde(rename = "sharedTraceDataId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shared_trace_data_id: Option<String>,

    /// A map(list of key-value pairs) where Dnn serves as key of ExpectedUeBehaviourData
    #[serde(rename = "expectedUeBehavioursList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expected_ue_behaviours_list:
        Option<std::collections::HashMap<String, models::ExpectedUeBehaviourData>>,

    /// A map(list of key-value pairs) where Dnn serves as key of SuggestedPacketNumDl
    #[serde(rename = "suggestedPacketNumDlList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggested_packet_num_dl_list:
        Option<std::collections::HashMap<String, models::SuggestedPacketNumDl>>,

    #[serde(rename = "3gppChargingCharacteristics")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub param_3gpp_charging_characteristics: Option<String>,

    /// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  tableÂ 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.
    #[serde(rename = "supportedFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_features: Option<String>,
}

impl SessionManagementSubscriptionData {
    #[allow(clippy::new_without_default)]
    pub fn new(single_nssai: models::Snssai) -> SessionManagementSubscriptionData {
        SessionManagementSubscriptionData {
            single_nssai,
            dnn_configurations: None,
            internal_group_ids: None,
            shared_vn_group_data_ids: None,
            shared_dnn_configurations_id: None,
            odb_packet_services: None,
            trace_data: None,
            shared_trace_data_id: None,
            expected_ue_behaviours_list: None,
            suggested_packet_num_dl_list: None,
            param_3gpp_charging_characteristics: None,
            supported_features: None,
        }
    }
}

/// Converts the SessionManagementSubscriptionData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SessionManagementSubscriptionData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping singleNssai in query parameter serialization

            // Skipping dnnConfigurations in query parameter serialization
            // Skipping dnnConfigurations in query parameter serialization
            self.internal_group_ids.as_ref().map(|internal_group_ids| {
                vec![
                    "internalGroupIds".to_string(),
                    internal_group_ids
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping sharedVnGroupDataIds in query parameter serialization
            self.shared_dnn_configurations_id
                .as_ref()
                .map(|shared_dnn_configurations_id| {
                    vec![
                        "sharedDnnConfigurationsId".to_string(),
                        shared_dnn_configurations_id.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping odbPacketServices in query parameter serialization

            // Skipping traceData in query parameter serialization
            self.shared_trace_data_id
                .as_ref()
                .map(|shared_trace_data_id| {
                    vec![
                        "sharedTraceDataId".to_string(),
                        shared_trace_data_id.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping expectedUeBehavioursList in query parameter serialization
            // Skipping expectedUeBehavioursList in query parameter serialization

            // Skipping suggestedPacketNumDlList in query parameter serialization
            // Skipping suggestedPacketNumDlList in query parameter serialization
            self.param_3gpp_charging_characteristics.as_ref().map(
                |param_3gpp_charging_characteristics| {
                    vec![
                        "3gppChargingCharacteristics".to_string(),
                        param_3gpp_charging_characteristics.to_string(),
                    ]
                    .join(",")
                },
            ),
            self.supported_features.as_ref().map(|supported_features| {
                vec![
                    "supportedFeatures".to_string(),
                    supported_features.to_string(),
                ]
                .join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SessionManagementSubscriptionData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SessionManagementSubscriptionData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub single_nssai: Vec<models::Snssai>,
            pub dnn_configurations:
                Vec<std::collections::HashMap<String, models::DnnConfiguration>>,
            pub internal_group_ids: Vec<Vec<models::GroupId>>,
            pub shared_vn_group_data_ids:
                Vec<std::collections::HashMap<String, models::SharedDataId>>,
            pub shared_dnn_configurations_id: Vec<String>,
            pub odb_packet_services: Vec<models::OdbPacketServices>,
            pub trace_data: Vec<models::TraceData>,
            pub shared_trace_data_id: Vec<String>,
            pub expected_ue_behaviours_list:
                Vec<std::collections::HashMap<String, models::ExpectedUeBehaviourData>>,
            pub suggested_packet_num_dl_list:
                Vec<std::collections::HashMap<String, models::SuggestedPacketNumDl>>,
            pub param_3gpp_charging_characteristics: Vec<String>,
            pub supported_features: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SessionManagementSubscriptionData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "singleNssai" => intermediate_rep.single_nssai.push(<models::Snssai as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "dnnConfigurations" => return std::result::Result::Err("Parsing a container in this style is not supported in SessionManagementSubscriptionData".to_string()),
                    "internalGroupIds" => return std::result::Result::Err("Parsing a container in this style is not supported in SessionManagementSubscriptionData".to_string()),
                    "sharedVnGroupDataIds" => return std::result::Result::Err("Parsing a container in this style is not supported in SessionManagementSubscriptionData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "sharedDnnConfigurationsId" => intermediate_rep.shared_dnn_configurations_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "odbPacketServices" => intermediate_rep.odb_packet_services.push(<models::OdbPacketServices as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "traceData" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SessionManagementSubscriptionData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "sharedTraceDataId" => intermediate_rep.shared_trace_data_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "expectedUeBehavioursList" => return std::result::Result::Err("Parsing a container in this style is not supported in SessionManagementSubscriptionData".to_string()),
                    "suggestedPacketNumDlList" => return std::result::Result::Err("Parsing a container in this style is not supported in SessionManagementSubscriptionData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "3gppChargingCharacteristics" => intermediate_rep.param_3gpp_charging_characteristics.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "supportedFeatures" => intermediate_rep.supported_features.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SessionManagementSubscriptionData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SessionManagementSubscriptionData {
            single_nssai: intermediate_rep
                .single_nssai
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "singleNssai missing in SessionManagementSubscriptionData".to_string()
                })?,
            dnn_configurations: intermediate_rep.dnn_configurations.into_iter().next(),
            internal_group_ids: intermediate_rep.internal_group_ids.into_iter().next(),
            shared_vn_group_data_ids: intermediate_rep.shared_vn_group_data_ids.into_iter().next(),
            shared_dnn_configurations_id: intermediate_rep
                .shared_dnn_configurations_id
                .into_iter()
                .next(),
            odb_packet_services: intermediate_rep.odb_packet_services.into_iter().next(),
            trace_data: std::result::Result::Err(
                "Nullable types not supported in SessionManagementSubscriptionData".to_string(),
            )?,
            shared_trace_data_id: intermediate_rep.shared_trace_data_id.into_iter().next(),
            expected_ue_behaviours_list: intermediate_rep
                .expected_ue_behaviours_list
                .into_iter()
                .next(),
            suggested_packet_num_dl_list: intermediate_rep
                .suggested_packet_num_dl_list
                .into_iter()
                .next(),
            param_3gpp_charging_characteristics: intermediate_rep
                .param_3gpp_charging_characteristics
                .into_iter()
                .next(),
            supported_features: intermediate_rep.supported_features.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SessionManagementSubscriptionData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SessionManagementSubscriptionData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SessionManagementSubscriptionData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SessionManagementSubscriptionData - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SessionManagementSubscriptionData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SessionManagementSubscriptionData as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SessionManagementSubscriptionData - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SharedData {
    #[serde(rename = "sharedDataId")]
    pub shared_data_id: String,

    #[serde(rename = "sharedAmData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shared_am_data: Option<models::AccessAndMobilitySubscriptionData>,

    #[serde(rename = "sharedSmsSubsData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shared_sms_subs_data: Option<models::SmsSubscriptionData>,

    #[serde(rename = "sharedSmsMngSubsData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shared_sms_mng_subs_data: Option<models::SmsManagementSubscriptionData>,

    /// A map(list of key-value pairs) where Dnn, or optionally the Wildcard DNN, serves as key of DnnConfiguration
    #[serde(rename = "sharedDnnConfigurations")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shared_dnn_configurations:
        Option<std::collections::HashMap<String, models::DnnConfiguration>>,

    #[serde(rename = "sharedTraceData")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shared_trace_data: Option<swagger::Nullable<models::TraceData>>,

    /// A map(list of key-value pairs) where singleNssai serves as key of SnssaiInfo
    #[serde(rename = "sharedSnssaiInfos")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shared_snssai_infos: Option<std::collections::HashMap<String, models::SnssaiInfo>>,

    /// A map(list of key-value pairs) where GroupId serves as key of VnGroupData
    #[serde(rename = "sharedVnGroupDatas")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shared_vn_group_datas: Option<std::collections::HashMap<String, models::VnGroupData>>,

    /// A map(list of key-value pairs) where JSON pointer pointing to an attribute within the SharedData serves as key of SharedDataTreatmentInstruction
    #[serde(rename = "treatmentInstructions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub treatment_instructions:
        Option<std::collections::HashMap<String, models::SharedDataTreatmentInstruction>>,

    #[serde(rename = "sharedSmSubsData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shared_sm_subs_data: Option<models::SessionManagementSubscriptionData>,

    #[serde(rename = "sharedEcsAddrConfigInfo")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shared_ecs_addr_config_info: Option<swagger::Nullable<models::EcsAddrConfigInfo>>,
}

impl SharedData {
    #[allow(clippy::new_without_default)]
    pub fn new(shared_data_id: String) -> SharedData {
        SharedData {
            shared_data_id,
            shared_am_data: None,
            shared_sms_subs_data: None,
            shared_sms_mng_subs_data: None,
            shared_dnn_configurations: None,
            shared_trace_data: None,
            shared_snssai_infos: None,
            shared_vn_group_datas: None,
            treatment_instructions: None,
            shared_sm_subs_data: None,
            shared_ecs_addr_config_info: None,
        }
    }
}

/// Converts the SharedData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SharedData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("sharedDataId".to_string()),
            Some(self.shared_data_id.to_string()),
            // Skipping sharedAmData in query parameter serialization

            // Skipping sharedSmsSubsData in query parameter serialization

            // Skipping sharedSmsMngSubsData in query parameter serialization

            // Skipping sharedDnnConfigurations in query parameter serialization
            // Skipping sharedDnnConfigurations in query parameter serialization

            // Skipping sharedTraceData in query parameter serialization

            // Skipping sharedSnssaiInfos in query parameter serialization
            // Skipping sharedSnssaiInfos in query parameter serialization

            // Skipping sharedVnGroupDatas in query parameter serialization
            // Skipping sharedVnGroupDatas in query parameter serialization

            // Skipping treatmentInstructions in query parameter serialization
            // Skipping treatmentInstructions in query parameter serialization

            // Skipping sharedSmSubsData in query parameter serialization

            // Skipping sharedEcsAddrConfigInfo in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SharedData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SharedData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub shared_data_id: Vec<String>,
            pub shared_am_data: Vec<models::AccessAndMobilitySubscriptionData>,
            pub shared_sms_subs_data: Vec<models::SmsSubscriptionData>,
            pub shared_sms_mng_subs_data: Vec<models::SmsManagementSubscriptionData>,
            pub shared_dnn_configurations:
                Vec<std::collections::HashMap<String, models::DnnConfiguration>>,
            pub shared_trace_data: Vec<models::TraceData>,
            pub shared_snssai_infos: Vec<std::collections::HashMap<String, models::SnssaiInfo>>,
            pub shared_vn_group_datas: Vec<std::collections::HashMap<String, models::VnGroupData>>,
            pub treatment_instructions:
                Vec<std::collections::HashMap<String, models::SharedDataTreatmentInstruction>>,
            pub shared_sm_subs_data: Vec<models::SessionManagementSubscriptionData>,
            pub shared_ecs_addr_config_info: Vec<models::EcsAddrConfigInfo>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SharedData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "sharedDataId" => intermediate_rep.shared_data_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "sharedAmData" => intermediate_rep.shared_am_data.push(
                        <models::AccessAndMobilitySubscriptionData as std::str::FromStr>::from_str(
                            val,
                        )
                        .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "sharedSmsSubsData" => intermediate_rep.shared_sms_subs_data.push(
                        <models::SmsSubscriptionData as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "sharedSmsMngSubsData" => intermediate_rep.shared_sms_mng_subs_data.push(
                        <models::SmsManagementSubscriptionData as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "sharedDnnConfigurations" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SharedData"
                                .to_string(),
                        )
                    }
                    "sharedTraceData" => {
                        return std::result::Result::Err(
                            "Parsing a nullable type in this style is not supported in SharedData"
                                .to_string(),
                        )
                    }
                    "sharedSnssaiInfos" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SharedData"
                                .to_string(),
                        )
                    }
                    "sharedVnGroupDatas" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SharedData"
                                .to_string(),
                        )
                    }
                    "treatmentInstructions" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SharedData"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "sharedSmSubsData" => intermediate_rep.shared_sm_subs_data.push(
                        <models::SessionManagementSubscriptionData as std::str::FromStr>::from_str(
                            val,
                        )
                        .map_err(|x| x.to_string())?,
                    ),
                    "sharedEcsAddrConfigInfo" => {
                        return std::result::Result::Err(
                            "Parsing a nullable type in this style is not supported in SharedData"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SharedData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SharedData {
            shared_data_id: intermediate_rep
                .shared_data_id
                .into_iter()
                .next()
                .ok_or_else(|| "sharedDataId missing in SharedData".to_string())?,
            shared_am_data: intermediate_rep.shared_am_data.into_iter().next(),
            shared_sms_subs_data: intermediate_rep.shared_sms_subs_data.into_iter().next(),
            shared_sms_mng_subs_data: intermediate_rep.shared_sms_mng_subs_data.into_iter().next(),
            shared_dnn_configurations: intermediate_rep
                .shared_dnn_configurations
                .into_iter()
                .next(),
            shared_trace_data: std::result::Result::Err(
                "Nullable types not supported in SharedData".to_string(),
            )?,
            shared_snssai_infos: intermediate_rep.shared_snssai_infos.into_iter().next(),
            shared_vn_group_datas: intermediate_rep.shared_vn_group_datas.into_iter().next(),
            treatment_instructions: intermediate_rep.treatment_instructions.into_iter().next(),
            shared_sm_subs_data: intermediate_rep.shared_sm_subs_data.into_iter().next(),
            shared_ecs_addr_config_info: std::result::Result::Err(
                "Nullable types not supported in SharedData".to_string(),
            )?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SharedData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SharedData>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SharedData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SharedData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SharedData> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SharedData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SharedData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SharedDataId(String);

impl SharedDataId {
    pub fn from_vec_str(s: &str) -> Result<Vec<SharedDataId>, std::string::ParseError> {
        let chunks = s.split(",");
        Ok(chunks.map(|x| SharedDataId::from_str(x).unwrap()).collect())
    }

    pub fn to_vec_str(v: &Vec<SharedDataId>) -> String {
        let mut res = String::new();

        for sdi in v {
            res.push_str(&format!("{},", sdi.0));
        }

        res
    }
}

impl std::convert::From<String> for SharedDataId {
    fn from(x: String) -> Self {
        SharedDataId(x)
    }
}

impl std::string::ToString for SharedDataId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::convert::From<SharedDataId> for String {
    fn from(x: SharedDataId) -> Self {
        x.0
    }
}

impl std::ops::Deref for SharedDataId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for SharedDataId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

impl FromStr for SharedDataId {
    type Err = std::string::ParseError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(Self(s.to_string()))
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SharedDataTreatmentInstruction {}

impl SharedDataTreatmentInstruction {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SharedDataTreatmentInstruction {
        SharedDataTreatmentInstruction {}
    }
}

/// Converts the SharedDataTreatmentInstruction value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SharedDataTreatmentInstruction {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SharedDataTreatmentInstruction value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SharedDataTreatmentInstruction {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SharedDataTreatmentInstruction".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SharedDataTreatmentInstruction"
                                .to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SharedDataTreatmentInstruction {})
    }
}

// Methods for converting between header::IntoHeaderValue<SharedDataTreatmentInstruction> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SharedDataTreatmentInstruction>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SharedDataTreatmentInstruction>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SharedDataTreatmentInstruction - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SharedDataTreatmentInstruction>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SharedDataTreatmentInstruction as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SharedDataTreatmentInstruction - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum SharedDataTreatmentInstructionAnyOf {
    #[serde(rename = "USE_IF_NO_CLASH")]
    UseIfNoClash,
    #[serde(rename = "OVERWRITE")]
    Overwrite,
    #[serde(rename = "MAX")]
    Max,
    #[serde(rename = "MIN")]
    Min,
}

impl std::fmt::Display for SharedDataTreatmentInstructionAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            SharedDataTreatmentInstructionAnyOf::UseIfNoClash => write!(f, "USE_IF_NO_CLASH"),
            SharedDataTreatmentInstructionAnyOf::Overwrite => write!(f, "OVERWRITE"),
            SharedDataTreatmentInstructionAnyOf::Max => write!(f, "MAX"),
            SharedDataTreatmentInstructionAnyOf::Min => write!(f, "MIN"),
        }
    }
}

impl std::str::FromStr for SharedDataTreatmentInstructionAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "USE_IF_NO_CLASH" => {
                std::result::Result::Ok(SharedDataTreatmentInstructionAnyOf::UseIfNoClash)
            }
            "OVERWRITE" => std::result::Result::Ok(SharedDataTreatmentInstructionAnyOf::Overwrite),
            "MAX" => std::result::Result::Ok(SharedDataTreatmentInstructionAnyOf::Max),
            "MIN" => std::result::Result::Ok(SharedDataTreatmentInstructionAnyOf::Min),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// MBR related to slice
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SliceMbr {
    /// String representing a bit rate; the prefixes follow the standard symbols from The International System of Units, and represent x1000 multipliers, with the exception that prefix \"K\" is used to represent the standard symbol \"k\".
    #[serde(rename = "uplink")]
    pub uplink: String,

    /// String representing a bit rate; the prefixes follow the standard symbols from The International System of Units, and represent x1000 multipliers, with the exception that prefix \"K\" is used to represent the standard symbol \"k\".
    #[serde(rename = "downlink")]
    pub downlink: String,
}

impl SliceMbr {
    #[allow(clippy::new_without_default)]
    pub fn new(uplink: String, downlink: String) -> SliceMbr {
        SliceMbr { uplink, downlink }
    }
}

/// Converts the SliceMbr value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SliceMbr {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("uplink".to_string()),
            Some(self.uplink.to_string()),
            Some("downlink".to_string()),
            Some(self.downlink.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SliceMbr value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SliceMbr {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub uplink: Vec<String>,
            pub downlink: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SliceMbr".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "uplink" => intermediate_rep.uplink.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "downlink" => intermediate_rep.downlink.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SliceMbr".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SliceMbr {
            uplink: intermediate_rep
                .uplink
                .into_iter()
                .next()
                .ok_or_else(|| "uplink missing in SliceMbr".to_string())?,
            downlink: intermediate_rep
                .downlink
                .into_iter()
                .next()
                .ok_or_else(|| "downlink missing in SliceMbr".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SliceMbr> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SliceMbr>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SliceMbr>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SliceMbr - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SliceMbr> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SliceMbr as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SliceMbr - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// SliceMbr with nullable: true
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SliceMbrRm {
    /// String representing a bit rate; the prefixes follow the standard symbols from The International System of Units, and represent x1000 multipliers, with the exception that prefix \"K\" is used to represent the standard symbol \"k\".
    #[serde(rename = "uplink")]
    pub uplink: String,

    /// String representing a bit rate; the prefixes follow the standard symbols from The International System of Units, and represent x1000 multipliers, with the exception that prefix \"K\" is used to represent the standard symbol \"k\".
    #[serde(rename = "downlink")]
    pub downlink: String,
}

impl SliceMbrRm {
    #[allow(clippy::new_without_default)]
    pub fn new(uplink: String, downlink: String) -> SliceMbrRm {
        SliceMbrRm { uplink, downlink }
    }
}

/// Converts the SliceMbrRm value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SliceMbrRm {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("uplink".to_string()),
            Some(self.uplink.to_string()),
            Some("downlink".to_string()),
            Some(self.downlink.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SliceMbrRm value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SliceMbrRm {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub uplink: Vec<String>,
            pub downlink: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SliceMbrRm".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "uplink" => intermediate_rep.uplink.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "downlink" => intermediate_rep.downlink.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SliceMbrRm".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SliceMbrRm {
            uplink: intermediate_rep
                .uplink
                .into_iter()
                .next()
                .ok_or_else(|| "uplink missing in SliceMbrRm".to_string())?,
            downlink: intermediate_rep
                .downlink
                .into_iter()
                .next()
                .ok_or_else(|| "downlink missing in SliceMbrRm".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SliceMbrRm> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SliceMbrRm>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SliceMbrRm>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SliceMbrRm - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SliceMbrRm> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SliceMbrRm as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SliceMbrRm - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SmSubsData {
    #[serde(rename = "sharedSmSubsDataIds")]
    pub shared_sm_subs_data_ids: Vec<models::SharedDataId>,

    #[serde(rename = "individualSmSubsData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub individual_sm_subs_data: Option<Vec<models::SessionManagementSubscriptionData>>,
}

impl SmSubsData {
    #[allow(clippy::new_without_default)]
    pub fn new(shared_sm_subs_data_ids: Vec<models::SharedDataId>) -> SmSubsData {
        SmSubsData {
            shared_sm_subs_data_ids,
            individual_sm_subs_data: None,
        }
    }
}

/// Converts the SmSubsData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SmSubsData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("sharedSmSubsDataIds".to_string()),
            Some(
                self.shared_sm_subs_data_ids
                    .iter()
                    .map(|x| x.to_string())
                    .collect::<Vec<_>>()
                    .join(","),
            ),
            // Skipping individualSmSubsData in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SmSubsData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SmSubsData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub shared_sm_subs_data_ids: Vec<Vec<models::SharedDataId>>,
            pub individual_sm_subs_data: Vec<Vec<models::SessionManagementSubscriptionData>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SmSubsData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "sharedSmSubsDataIds" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SmSubsData"
                                .to_string(),
                        )
                    }
                    "individualSmSubsData" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SmSubsData"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SmSubsData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SmSubsData {
            shared_sm_subs_data_ids: intermediate_rep
                .shared_sm_subs_data_ids
                .into_iter()
                .next()
                .ok_or_else(|| "sharedSmSubsDataIds missing in SmSubsData".to_string())?,
            individual_sm_subs_data: intermediate_rep.individual_sm_subs_data.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SmSubsData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SmSubsData>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SmSubsData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SmSubsData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SmSubsData> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SmSubsData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SmSubsData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SmfSelectionSubscriptionData {
    /// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  tableÂ 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.
    #[serde(rename = "supportedFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_features: Option<String>,

    /// A map(list of key-value pairs) where singleNssai serves as key of SnssaiInfo
    #[serde(rename = "subscribedSnssaiInfos")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscribed_snssai_infos: Option<std::collections::HashMap<String, models::SnssaiInfo>>,

    #[serde(rename = "sharedSnssaiInfosId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shared_snssai_infos_id: Option<String>,

    /// Identifier of a group of NFs.
    #[serde(rename = "hssGroupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hss_group_id: Option<String>,
}

impl SmfSelectionSubscriptionData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SmfSelectionSubscriptionData {
        SmfSelectionSubscriptionData {
            supported_features: None,
            subscribed_snssai_infos: None,
            shared_snssai_infos_id: None,
            hss_group_id: None,
        }
    }
}

/// Converts the SmfSelectionSubscriptionData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SmfSelectionSubscriptionData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.supported_features.as_ref().map(|supported_features| {
                vec![
                    "supportedFeatures".to_string(),
                    supported_features.to_string(),
                ]
                .join(",")
            }),
            // Skipping subscribedSnssaiInfos in query parameter serialization
            // Skipping subscribedSnssaiInfos in query parameter serialization
            self.shared_snssai_infos_id
                .as_ref()
                .map(|shared_snssai_infos_id| {
                    vec![
                        "sharedSnssaiInfosId".to_string(),
                        shared_snssai_infos_id.to_string(),
                    ]
                    .join(",")
                }),
            self.hss_group_id.as_ref().map(|hss_group_id| {
                vec!["hssGroupId".to_string(), hss_group_id.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SmfSelectionSubscriptionData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SmfSelectionSubscriptionData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub supported_features: Vec<String>,
            pub subscribed_snssai_infos: Vec<std::collections::HashMap<String, models::SnssaiInfo>>,
            pub shared_snssai_infos_id: Vec<String>,
            pub hss_group_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SmfSelectionSubscriptionData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "supportedFeatures" => intermediate_rep.supported_features.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "subscribedSnssaiInfos" => return std::result::Result::Err("Parsing a container in this style is not supported in SmfSelectionSubscriptionData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "sharedSnssaiInfosId" => intermediate_rep.shared_snssai_infos_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hssGroupId" => intermediate_rep.hss_group_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SmfSelectionSubscriptionData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SmfSelectionSubscriptionData {
            supported_features: intermediate_rep.supported_features.into_iter().next(),
            subscribed_snssai_infos: intermediate_rep.subscribed_snssai_infos.into_iter().next(),
            shared_snssai_infos_id: intermediate_rep.shared_snssai_infos_id.into_iter().next(),
            hss_group_id: intermediate_rep.hss_group_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SmfSelectionSubscriptionData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SmfSelectionSubscriptionData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SmfSelectionSubscriptionData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SmfSelectionSubscriptionData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SmfSelectionSubscriptionData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SmfSelectionSubscriptionData as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SmfSelectionSubscriptionData - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SmsManagementSubscriptionData {
    /// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  tableÂ 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.
    #[serde(rename = "supportedFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_features: Option<String>,

    #[serde(rename = "mtSmsSubscribed")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mt_sms_subscribed: Option<bool>,

    #[serde(rename = "mtSmsBarringAll")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mt_sms_barring_all: Option<bool>,

    #[serde(rename = "mtSmsBarringRoaming")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mt_sms_barring_roaming: Option<bool>,

    #[serde(rename = "moSmsSubscribed")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mo_sms_subscribed: Option<bool>,

    #[serde(rename = "moSmsBarringAll")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mo_sms_barring_all: Option<bool>,

    #[serde(rename = "moSmsBarringRoaming")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mo_sms_barring_roaming: Option<bool>,

    #[serde(rename = "sharedSmsMngDataIds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shared_sms_mng_data_ids: Option<Vec<models::SharedDataId>>,

    #[serde(rename = "traceData")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trace_data: Option<swagger::Nullable<models::TraceData>>,
}

impl SmsManagementSubscriptionData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SmsManagementSubscriptionData {
        SmsManagementSubscriptionData {
            supported_features: None,
            mt_sms_subscribed: None,
            mt_sms_barring_all: None,
            mt_sms_barring_roaming: None,
            mo_sms_subscribed: None,
            mo_sms_barring_all: None,
            mo_sms_barring_roaming: None,
            shared_sms_mng_data_ids: None,
            trace_data: None,
        }
    }
}

/// Converts the SmsManagementSubscriptionData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SmsManagementSubscriptionData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.supported_features.as_ref().map(|supported_features| {
                vec![
                    "supportedFeatures".to_string(),
                    supported_features.to_string(),
                ]
                .join(",")
            }),
            self.mt_sms_subscribed.as_ref().map(|mt_sms_subscribed| {
                vec!["mtSmsSubscribed".to_string(), mt_sms_subscribed.to_string()].join(",")
            }),
            self.mt_sms_barring_all.as_ref().map(|mt_sms_barring_all| {
                vec![
                    "mtSmsBarringAll".to_string(),
                    mt_sms_barring_all.to_string(),
                ]
                .join(",")
            }),
            self.mt_sms_barring_roaming
                .as_ref()
                .map(|mt_sms_barring_roaming| {
                    vec![
                        "mtSmsBarringRoaming".to_string(),
                        mt_sms_barring_roaming.to_string(),
                    ]
                    .join(",")
                }),
            self.mo_sms_subscribed.as_ref().map(|mo_sms_subscribed| {
                vec!["moSmsSubscribed".to_string(), mo_sms_subscribed.to_string()].join(",")
            }),
            self.mo_sms_barring_all.as_ref().map(|mo_sms_barring_all| {
                vec![
                    "moSmsBarringAll".to_string(),
                    mo_sms_barring_all.to_string(),
                ]
                .join(",")
            }),
            self.mo_sms_barring_roaming
                .as_ref()
                .map(|mo_sms_barring_roaming| {
                    vec![
                        "moSmsBarringRoaming".to_string(),
                        mo_sms_barring_roaming.to_string(),
                    ]
                    .join(",")
                }),
            self.shared_sms_mng_data_ids
                .as_ref()
                .map(|shared_sms_mng_data_ids| {
                    vec![
                        "sharedSmsMngDataIds".to_string(),
                        shared_sms_mng_data_ids
                            .iter()
                            .map(|x| x.to_string())
                            .collect::<Vec<_>>()
                            .join(","),
                    ]
                    .join(",")
                }),
            // Skipping traceData in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SmsManagementSubscriptionData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SmsManagementSubscriptionData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub supported_features: Vec<String>,
            pub mt_sms_subscribed: Vec<bool>,
            pub mt_sms_barring_all: Vec<bool>,
            pub mt_sms_barring_roaming: Vec<bool>,
            pub mo_sms_subscribed: Vec<bool>,
            pub mo_sms_barring_all: Vec<bool>,
            pub mo_sms_barring_roaming: Vec<bool>,
            pub shared_sms_mng_data_ids: Vec<Vec<models::SharedDataId>>,
            pub trace_data: Vec<models::TraceData>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SmsManagementSubscriptionData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "supportedFeatures" => intermediate_rep.supported_features.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "mtSmsSubscribed" => intermediate_rep.mt_sms_subscribed.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "mtSmsBarringAll" => intermediate_rep.mt_sms_barring_all.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "mtSmsBarringRoaming" => intermediate_rep.mt_sms_barring_roaming.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "moSmsSubscribed" => intermediate_rep.mo_sms_subscribed.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "moSmsBarringAll" => intermediate_rep.mo_sms_barring_all.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "moSmsBarringRoaming" => intermediate_rep.mo_sms_barring_roaming.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "sharedSmsMngDataIds" => return std::result::Result::Err("Parsing a container in this style is not supported in SmsManagementSubscriptionData".to_string()),
                    "traceData" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SmsManagementSubscriptionData".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing SmsManagementSubscriptionData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SmsManagementSubscriptionData {
            supported_features: intermediate_rep.supported_features.into_iter().next(),
            mt_sms_subscribed: intermediate_rep.mt_sms_subscribed.into_iter().next(),
            mt_sms_barring_all: intermediate_rep.mt_sms_barring_all.into_iter().next(),
            mt_sms_barring_roaming: intermediate_rep.mt_sms_barring_roaming.into_iter().next(),
            mo_sms_subscribed: intermediate_rep.mo_sms_subscribed.into_iter().next(),
            mo_sms_barring_all: intermediate_rep.mo_sms_barring_all.into_iter().next(),
            mo_sms_barring_roaming: intermediate_rep.mo_sms_barring_roaming.into_iter().next(),
            shared_sms_mng_data_ids: intermediate_rep.shared_sms_mng_data_ids.into_iter().next(),
            trace_data: std::result::Result::Err(
                "Nullable types not supported in SmsManagementSubscriptionData".to_string(),
            )?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SmsManagementSubscriptionData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SmsManagementSubscriptionData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SmsManagementSubscriptionData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SmsManagementSubscriptionData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SmsManagementSubscriptionData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SmsManagementSubscriptionData as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SmsManagementSubscriptionData - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SmsSubscribed(bool);

impl std::convert::From<bool> for SmsSubscribed {
    fn from(x: bool) -> Self {
        SmsSubscribed(x)
    }
}

impl std::convert::From<SmsSubscribed> for bool {
    fn from(x: SmsSubscribed) -> Self {
        x.0
    }
}

impl std::ops::Deref for SmsSubscribed {
    type Target = bool;
    fn deref(&self) -> &bool {
        &self.0
    }
}

impl std::ops::DerefMut for SmsSubscribed {
    fn deref_mut(&mut self) -> &mut bool {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SmsSubscriptionData {
    #[serde(rename = "smsSubscribed")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sms_subscribed: Option<bool>,

    #[serde(rename = "sharedSmsSubsDataId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shared_sms_subs_data_id: Option<String>,

    /// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  tableÂ 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.
    #[serde(rename = "supportedFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_features: Option<String>,
}

impl SmsSubscriptionData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SmsSubscriptionData {
        SmsSubscriptionData {
            sms_subscribed: None,
            shared_sms_subs_data_id: None,
            supported_features: None,
        }
    }
}

/// Converts the SmsSubscriptionData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SmsSubscriptionData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.sms_subscribed.as_ref().map(|sms_subscribed| {
                vec!["smsSubscribed".to_string(), sms_subscribed.to_string()].join(",")
            }),
            self.shared_sms_subs_data_id
                .as_ref()
                .map(|shared_sms_subs_data_id| {
                    vec![
                        "sharedSmsSubsDataId".to_string(),
                        shared_sms_subs_data_id.to_string(),
                    ]
                    .join(",")
                }),
            self.supported_features.as_ref().map(|supported_features| {
                vec![
                    "supportedFeatures".to_string(),
                    supported_features.to_string(),
                ]
                .join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SmsSubscriptionData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SmsSubscriptionData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub sms_subscribed: Vec<bool>,
            pub shared_sms_subs_data_id: Vec<String>,
            pub supported_features: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SmsSubscriptionData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "smsSubscribed" => intermediate_rep.sms_subscribed.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "sharedSmsSubsDataId" => intermediate_rep.shared_sms_subs_data_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "supportedFeatures" => intermediate_rep.supported_features.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SmsSubscriptionData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SmsSubscriptionData {
            sms_subscribed: intermediate_rep.sms_subscribed.into_iter().next(),
            shared_sms_subs_data_id: intermediate_rep.shared_sms_subs_data_id.into_iter().next(),
            supported_features: intermediate_rep.supported_features.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SmsSubscriptionData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SmsSubscriptionData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SmsSubscriptionData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SmsSubscriptionData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SmsSubscriptionData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SmsSubscriptionData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SmsSubscriptionData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SmsfInfo {
    /// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
    #[serde(rename = "smsfInstanceId")]
    pub smsf_instance_id: uuid::Uuid,

    #[serde(rename = "plmnId")]
    pub plmn_id: models::PlmnId,

    /// NF Set Identifier (see clause 28.12 of 3GPP TS 23.003), formatted as the following string \"set<Set ID>.<nftype>set.5gc.mnc<MNC>.mcc<MCC>\", or  \"set<SetID>.<NFType>set.5gc.nid<NID>.mnc<MNC>.mcc<MCC>\" with  <MCC> encoded as defined in clause 5.4.2 (\"Mcc\" data type definition)  <MNC> encoding the Mobile Network Code part of the PLMN, comprising 3 digits.    If there are only 2 significant digits in the MNC, one \"0\" digit shall be inserted    at the left side to fill the 3 digits coding of MNC.  Pattern: '^[0-9]{3}$' <NFType> encoded as a value defined in Table 6.1.6.3.3-1 of 3GPP TS 29.510 but    with lower case characters <Set ID> encoded as a string of characters consisting of    alphabetic characters (A-Z and a-z), digits (0-9) and/or the hyphen (-) and that    shall end with either an alphabetic character or a digit.
    #[serde(rename = "smsfSetId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub smsf_set_id: Option<String>,
}

impl SmsfInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(smsf_instance_id: uuid::Uuid, plmn_id: models::PlmnId) -> SmsfInfo {
        SmsfInfo {
            smsf_instance_id,
            plmn_id,
            smsf_set_id: None,
        }
    }
}

/// Converts the SmsfInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SmsfInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping smsfInstanceId in query parameter serialization

            // Skipping plmnId in query parameter serialization
            self.smsf_set_id.as_ref().map(|smsf_set_id| {
                vec!["smsfSetId".to_string(), smsf_set_id.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SmsfInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SmsfInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub smsf_instance_id: Vec<uuid::Uuid>,
            pub plmn_id: Vec<models::PlmnId>,
            pub smsf_set_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SmsfInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "smsfInstanceId" => intermediate_rep.smsf_instance_id.push(
                        <uuid::Uuid as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "plmnId" => intermediate_rep.plmn_id.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "smsfSetId" => intermediate_rep.smsf_set_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SmsfInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SmsfInfo {
            smsf_instance_id: intermediate_rep
                .smsf_instance_id
                .into_iter()
                .next()
                .ok_or_else(|| "smsfInstanceId missing in SmsfInfo".to_string())?,
            plmn_id: intermediate_rep
                .plmn_id
                .into_iter()
                .next()
                .ok_or_else(|| "plmnId missing in SmsfInfo".to_string())?,
            smsf_set_id: intermediate_rep.smsf_set_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SmsfInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SmsfInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SmsfInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SmsfInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SmsfInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SmsfInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SmsfInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// When Snssai needs to be converted to string (e.g. when used in maps as key), the string shall be composed of one to three digits \"sst\" optionally followed by \"-\" and 6 hexadecimal digits \"sd\".
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Snssai {
    /// Unsigned integer, within the range 0 to 255, representing the Slice/Service Type.  It indicates the expected Network Slice behaviour in terms of features and services. Values 0 to 127 correspond to the standardized SST range. Values 128 to 255 correspond  to the Operator-specific range. See clause 28.4.2 of 3GPP TS 23.003. Standardized values are defined in clause 5.15.2.2 of 3GPP TS 23.501.
    #[serde(rename = "sst")]
    pub sst: u8,

    /// 3-octet string, representing the Slice Differentiator, in hexadecimal representation. Each character in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character representing the 4 most significant bits of the SD shall appear first in the string, and the character representing the 4 least significant bit of the SD shall appear last in the string. This is an optional parameter that complements the Slice/Service type(s) to allow to  differentiate amongst multiple Network Slices of the same Slice/Service type. This IE shall be absent if no SD value is associated with the SST.
    #[serde(rename = "sd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sd: Option<String>,
}

impl Snssai {
    #[allow(clippy::new_without_default)]
    pub fn new(sst: u8) -> Snssai {
        Snssai { sst, sd: None }
    }
}

/// Converts the Snssai value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Snssai {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("sst".to_string()),
            Some(self.sst.to_string()),
            self.sd
                .as_ref()
                .map(|sd| vec!["sd".to_string(), sd.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Snssai value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Snssai {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub sst: Vec<u8>,
            pub sd: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing Snssai".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "sst" => intermediate_rep
                        .sst
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sd" => intermediate_rep.sd.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Snssai".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Snssai {
            sst: intermediate_rep
                .sst
                .into_iter()
                .next()
                .ok_or_else(|| "sst missing in Snssai".to_string())?,
            sd: intermediate_rep.sd.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Snssai> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Snssai>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Snssai>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Snssai - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Snssai> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <Snssai as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into Snssai - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SnssaiInfo {
    #[serde(rename = "dnnInfos")]
    pub dnn_infos: Vec<models::DnnInfo>,
}

impl SnssaiInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(dnn_infos: Vec<models::DnnInfo>) -> SnssaiInfo {
        SnssaiInfo { dnn_infos }
    }
}

/// Converts the SnssaiInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SnssaiInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping dnnInfos in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SnssaiInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SnssaiInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub dnn_infos: Vec<Vec<models::DnnInfo>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SnssaiInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "dnnInfos" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SnssaiInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SnssaiInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SnssaiInfo {
            dnn_infos: intermediate_rep
                .dnn_infos
                .into_iter()
                .next()
                .ok_or_else(|| "dnnInfos missing in SnssaiInfo".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SnssaiInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SnssaiInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SnssaiInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SnssaiInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SnssaiInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SnssaiInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SnssaiInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// string with format 'bytes' as defined in OpenAPI
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SorCmci(swagger::ByteArray);

impl std::convert::From<swagger::ByteArray> for SorCmci {
    fn from(x: swagger::ByteArray) -> Self {
        SorCmci(x)
    }
}

impl std::convert::From<SorCmci> for swagger::ByteArray {
    fn from(x: SorCmci) -> Self {
        x.0
    }
}

impl std::ops::Deref for SorCmci {
    type Target = swagger::ByteArray;
    fn deref(&self) -> &swagger::ByteArray {
        &self.0
    }
}

impl std::ops::DerefMut for SorCmci {
    fn deref_mut(&mut self) -> &mut swagger::ByteArray {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SorInfo {
    #[serde(rename = "steeringContainer")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub steering_container: Option<models::SteeringContainer>,

    /// Contains indication whether the acknowledgement from UE is needed.
    #[serde(rename = "ackInd")]
    pub ack_ind: bool,

    /// MAC value for protecting SOR procedure (SoR-MAC-IAUSF and SoR-XMAC-IUE).
    #[serde(rename = "sorMacIausf")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sor_mac_iausf: Option<String>,

    /// CounterSoR.
    #[serde(rename = "countersor")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub countersor: Option<String>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "provisioningTime")]
    pub provisioning_time: chrono::DateTime<chrono::Utc>,

    /// string with format 'bytes' as defined in OpenAPI
    #[serde(rename = "sorTransparentContainer")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sor_transparent_container: Option<swagger::ByteArray>,

    /// string with format 'bytes' as defined in OpenAPI
    #[serde(rename = "sorCmci")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sor_cmci: Option<swagger::ByteArray>,

    #[serde(rename = "storeSorCmciInMe")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub store_sor_cmci_in_me: Option<bool>,

    #[serde(rename = "usimSupportOfSorCmci")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub usim_support_of_sor_cmci: Option<bool>,
}

impl SorInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(ack_ind: bool, provisioning_time: chrono::DateTime<chrono::Utc>) -> SorInfo {
        SorInfo {
            steering_container: None,
            ack_ind,
            sor_mac_iausf: None,
            countersor: None,
            provisioning_time,
            sor_transparent_container: None,
            sor_cmci: None,
            store_sor_cmci_in_me: None,
            usim_support_of_sor_cmci: None,
        }
    }
}

/// Converts the SorInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SorInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping steeringContainer in query parameter serialization
            Some("ackInd".to_string()),
            Some(self.ack_ind.to_string()),
            self.sor_mac_iausf.as_ref().map(|sor_mac_iausf| {
                vec!["sorMacIausf".to_string(), sor_mac_iausf.to_string()].join(",")
            }),
            self.countersor
                .as_ref()
                .map(|countersor| vec!["countersor".to_string(), countersor.to_string()].join(",")),
            // Skipping provisioningTime in query parameter serialization

            // Skipping sorTransparentContainer in query parameter serialization
            // Skipping sorTransparentContainer in query parameter serialization

            // Skipping sorCmci in query parameter serialization
            // Skipping sorCmci in query parameter serialization
            self.store_sor_cmci_in_me
                .as_ref()
                .map(|store_sor_cmci_in_me| {
                    vec![
                        "storeSorCmciInMe".to_string(),
                        store_sor_cmci_in_me.to_string(),
                    ]
                    .join(",")
                }),
            self.usim_support_of_sor_cmci
                .as_ref()
                .map(|usim_support_of_sor_cmci| {
                    vec![
                        "usimSupportOfSorCmci".to_string(),
                        usim_support_of_sor_cmci.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SorInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SorInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub steering_container: Vec<models::SteeringContainer>,
            pub ack_ind: Vec<bool>,
            pub sor_mac_iausf: Vec<String>,
            pub countersor: Vec<String>,
            pub provisioning_time: Vec<chrono::DateTime<chrono::Utc>>,
            pub sor_transparent_container: Vec<swagger::ByteArray>,
            pub sor_cmci: Vec<swagger::ByteArray>,
            pub store_sor_cmci_in_me: Vec<bool>,
            pub usim_support_of_sor_cmci: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SorInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "steeringContainer" => intermediate_rep.steering_container.push(
                        <models::SteeringContainer as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ackInd" => intermediate_rep.ack_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "sorMacIausf" => intermediate_rep.sor_mac_iausf.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "countersor" => intermediate_rep.countersor.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "provisioningTime" => intermediate_rep.provisioning_time.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "sorTransparentContainer" => {
                        return std::result::Result::Err(
                            "Parsing binary data in this style is not supported in SorInfo"
                                .to_string(),
                        )
                    }
                    "sorCmci" => {
                        return std::result::Result::Err(
                            "Parsing binary data in this style is not supported in SorInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "storeSorCmciInMe" => intermediate_rep.store_sor_cmci_in_me.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "usimSupportOfSorCmci" => intermediate_rep.usim_support_of_sor_cmci.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SorInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SorInfo {
            steering_container: intermediate_rep.steering_container.into_iter().next(),
            ack_ind: intermediate_rep
                .ack_ind
                .into_iter()
                .next()
                .ok_or_else(|| "ackInd missing in SorInfo".to_string())?,
            sor_mac_iausf: intermediate_rep.sor_mac_iausf.into_iter().next(),
            countersor: intermediate_rep.countersor.into_iter().next(),
            provisioning_time: intermediate_rep
                .provisioning_time
                .into_iter()
                .next()
                .ok_or_else(|| "provisioningTime missing in SorInfo".to_string())?,
            sor_transparent_container: intermediate_rep
                .sor_transparent_container
                .into_iter()
                .next(),
            sor_cmci: intermediate_rep.sor_cmci.into_iter().next(),
            store_sor_cmci_in_me: intermediate_rep.store_sor_cmci_in_me.into_iter().next(),
            usim_support_of_sor_cmci: intermediate_rep.usim_support_of_sor_cmci.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SorInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SorInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SorInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SorInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SorInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SorInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SorInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// MAC value for protecting SOR procedure (SoR-MAC-IAUSF and SoR-XMAC-IUE).
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SorMac(String);

impl std::convert::From<String> for SorMac {
    fn from(x: String) -> Self {
        SorMac(x)
    }
}

impl std::string::ToString for SorMac {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for SorMac {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(SorMac(x.to_string()))
    }
}

impl std::convert::From<SorMac> for String {
    fn from(x: SorMac) -> Self {
        x.0
    }
}

impl std::ops::Deref for SorMac {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for SorMac {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// string with format 'bytes' as defined in OpenAPI
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SorTransparentContainer(swagger::ByteArray);

impl std::convert::From<swagger::ByteArray> for SorTransparentContainer {
    fn from(x: swagger::ByteArray) -> Self {
        SorTransparentContainer(x)
    }
}

impl std::convert::From<SorTransparentContainer> for swagger::ByteArray {
    fn from(x: SorTransparentContainer) -> Self {
        x.0
    }
}

impl std::ops::Deref for SorTransparentContainer {
    type Target = swagger::ByteArray;
    fn deref(&self) -> &swagger::ByteArray {
        &self.0
    }
}

impl std::ops::DerefMut for SorTransparentContainer {
    fn deref_mut(&mut self) -> &mut swagger::ByteArray {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SorUpdateIndicator {}

impl SorUpdateIndicator {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SorUpdateIndicator {
        SorUpdateIndicator {}
    }
}

/// Converts the SorUpdateIndicator value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SorUpdateIndicator {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SorUpdateIndicator value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SorUpdateIndicator {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SorUpdateIndicator".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SorUpdateIndicator".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SorUpdateIndicator {})
    }
}

// Methods for converting between header::IntoHeaderValue<SorUpdateIndicator> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SorUpdateIndicator>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SorUpdateIndicator>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SorUpdateIndicator - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SorUpdateIndicator>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SorUpdateIndicator as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SorUpdateIndicator - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum SorUpdateIndicatorAnyOf {
    #[serde(rename = "INITIAL_REGISTRATION")]
    InitialRegistration,
    #[serde(rename = "EMERGENCY_REGISTRATION")]
    EmergencyRegistration,
}

impl std::fmt::Display for SorUpdateIndicatorAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            SorUpdateIndicatorAnyOf::InitialRegistration => write!(f, "INITIAL_REGISTRATION"),
            SorUpdateIndicatorAnyOf::EmergencyRegistration => write!(f, "EMERGENCY_REGISTRATION"),
        }
    }
}

impl std::str::FromStr for SorUpdateIndicatorAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "INITIAL_REGISTRATION" => {
                std::result::Result::Ok(SorUpdateIndicatorAnyOf::InitialRegistration)
            }
            "EMERGENCY_REGISTRATION" => {
                std::result::Result::Ok(SorUpdateIndicatorAnyOf::EmergencyRegistration)
            }
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SorUpdateInfo {
    #[serde(rename = "vplmnId")]
    pub vplmn_id: models::PlmnId,

    /// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  tableÂ 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.
    #[serde(rename = "supportedFeatures")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub supported_features: Option<String>,
}

impl SorUpdateInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(vplmn_id: models::PlmnId) -> SorUpdateInfo {
        SorUpdateInfo {
            vplmn_id,
            supported_features: None,
        }
    }
}

/// Converts the SorUpdateInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SorUpdateInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping vplmnId in query parameter serialization
            self.supported_features.as_ref().map(|supported_features| {
                vec![
                    "supportedFeatures".to_string(),
                    supported_features.to_string(),
                ]
                .join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SorUpdateInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SorUpdateInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub vplmn_id: Vec<models::PlmnId>,
            pub supported_features: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SorUpdateInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "vplmnId" => intermediate_rep.vplmn_id.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "supportedFeatures" => intermediate_rep.supported_features.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SorUpdateInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SorUpdateInfo {
            vplmn_id: intermediate_rep
                .vplmn_id
                .into_iter()
                .next()
                .ok_or_else(|| "vplmnId missing in SorUpdateInfo".to_string())?,
            supported_features: intermediate_rep.supported_features.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SorUpdateInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SorUpdateInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SorUpdateInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SorUpdateInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SorUpdateInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SorUpdateInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SorUpdateInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains the Spatial Validity Condition.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SpatialValidityCond {
    #[serde(rename = "trackingAreaList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tracking_area_list: Option<Vec<models::Tai>>,

    #[serde(rename = "countries")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub countries: Option<Vec<models::Mcc>>,

    #[serde(rename = "geographicalServiceArea")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub geographical_service_area: Option<models::GeoServiceArea>,
}

impl SpatialValidityCond {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SpatialValidityCond {
        SpatialValidityCond {
            tracking_area_list: None,
            countries: None,
            geographical_service_area: None,
        }
    }
}

/// Converts the SpatialValidityCond value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SpatialValidityCond {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping trackingAreaList in query parameter serialization
            self.countries.as_ref().map(|countries| {
                vec![
                    "countries".to_string(),
                    countries
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping geographicalServiceArea in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SpatialValidityCond value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SpatialValidityCond {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub tracking_area_list: Vec<Vec<models::Tai>>,
            pub countries: Vec<Vec<models::Mcc>>,
            pub geographical_service_area: Vec<models::GeoServiceArea>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SpatialValidityCond".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "trackingAreaList" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in SpatialValidityCond"
                            .to_string(),
                    ),
                    "countries" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in SpatialValidityCond"
                            .to_string(),
                    ),
                    #[allow(clippy::redundant_clone)]
                    "geographicalServiceArea" => intermediate_rep.geographical_service_area.push(
                        <models::GeoServiceArea as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SpatialValidityCond".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SpatialValidityCond {
            tracking_area_list: intermediate_rep.tracking_area_list.into_iter().next(),
            countries: intermediate_rep.countries.into_iter().next(),
            geographical_service_area: intermediate_rep
                .geographical_service_area
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SpatialValidityCond> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SpatialValidityCond>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SpatialValidityCond>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SpatialValidityCond - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SpatialValidityCond>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SpatialValidityCond as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SpatialValidityCond - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// represents the service and session continuity mode It shall comply with the provisions defined in table 5.4.3.6-1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SscMode(String);

impl SscMode {
    #[allow(clippy::new_without_default)]
    pub fn new(s: String) -> SscMode {
        SscMode(s)
    }
}

/// Converts the SscMode value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SscMode {
    fn to_string(&self) -> String {
        self.0.clone()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SscMode value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SscMode {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SscMode(s.to_string()))
    }
}

// Methods for converting between header::IntoHeaderValue<SscMode> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SscMode>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SscMode>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SscMode - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SscMode> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SscMode as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SscMode - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum SscModeAnyOf {
    #[serde(rename = "SSC_MODE_1")]
    Variant1,
    #[serde(rename = "SSC_MODE_2")]
    Variant2,
    #[serde(rename = "SSC_MODE_3")]
    Variant3,
}

impl std::fmt::Display for SscModeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            SscModeAnyOf::Variant1 => write!(f, "SSC_MODE_1"),
            SscModeAnyOf::Variant2 => write!(f, "SSC_MODE_2"),
            SscModeAnyOf::Variant3 => write!(f, "SSC_MODE_3"),
        }
    }
}

impl std::str::FromStr for SscModeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "SSC_MODE_1" => std::result::Result::Ok(SscModeAnyOf::Variant1),
            "SSC_MODE_2" => std::result::Result::Ok(SscModeAnyOf::Variant2),
            "SSC_MODE_3" => std::result::Result::Ok(SscModeAnyOf::Variant3),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SscModes {
    #[serde(rename = "defaultSscMode")]
    pub default_ssc_mode: models::SscMode,

    #[serde(rename = "allowedSscModes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allowed_ssc_modes: Option<Vec<models::SscMode>>,
}

impl SscModes {
    #[allow(clippy::new_without_default)]
    pub fn new(default_ssc_mode: models::SscMode) -> SscModes {
        SscModes {
            default_ssc_mode,
            allowed_ssc_modes: None,
        }
    }
}

/// Converts the SscModes value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SscModes {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping defaultSscMode in query parameter serialization

            // Skipping allowedSscModes in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SscModes value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SscModes {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub default_ssc_mode: Vec<models::SscMode>,
            pub allowed_ssc_modes: Vec<Vec<models::SscMode>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SscModes".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "defaultSscMode" => intermediate_rep.default_ssc_mode.push(
                        <models::SscMode as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "allowedSscModes" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SscModes"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SscModes".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SscModes {
            default_ssc_mode: intermediate_rep
                .default_ssc_mode
                .into_iter()
                .next()
                .ok_or_else(|| "defaultSscMode missing in SscModes".to_string())?,
            allowed_ssc_modes: intermediate_rep.allowed_ssc_modes.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SscModes> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SscModes>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SscModes>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SscModes - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SscModes> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SscModes as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SscModes - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Source specific IP multicast address
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Ssm {
    #[serde(rename = "sourceIpAddr")]
    pub source_ip_addr: models::IpAddr,

    #[serde(rename = "destIpAddr")]
    pub dest_ip_addr: models::IpAddr,
}

impl Ssm {
    #[allow(clippy::new_without_default)]
    pub fn new(source_ip_addr: models::IpAddr, dest_ip_addr: models::IpAddr) -> Ssm {
        Ssm {
            source_ip_addr,
            dest_ip_addr,
        }
    }
}

/// Converts the Ssm value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Ssm {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping sourceIpAddr in query parameter serialization

            // Skipping destIpAddr in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Ssm value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Ssm {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub source_ip_addr: Vec<models::IpAddr>,
            pub dest_ip_addr: Vec<models::IpAddr>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err("Missing value while parsing Ssm".to_string())
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "sourceIpAddr" => intermediate_rep.source_ip_addr.push(
                        <models::IpAddr as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "destIpAddr" => intermediate_rep.dest_ip_addr.push(
                        <models::IpAddr as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Ssm".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Ssm {
            source_ip_addr: intermediate_rep
                .source_ip_addr
                .into_iter()
                .next()
                .ok_or_else(|| "sourceIpAddr missing in Ssm".to_string())?,
            dest_ip_addr: intermediate_rep
                .dest_ip_addr
                .into_iter()
                .next()
                .ok_or_else(|| "destIpAddr missing in Ssm".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Ssm> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Ssm>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Ssm>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Ssm - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Ssm> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Ssm as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Ssm - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Possible values are: - STATIONARY: Identifies the UE is stationary - MOBILE: Identifies the UE is mobile
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct StationaryIndication {}

impl StationaryIndication {
    #[allow(clippy::new_without_default)]
    pub fn new() -> StationaryIndication {
        StationaryIndication {}
    }
}

/// Converts the StationaryIndication value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for StationaryIndication {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a StationaryIndication value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for StationaryIndication {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing StationaryIndication".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing StationaryIndication".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(StationaryIndication {})
    }
}

// Methods for converting between header::IntoHeaderValue<StationaryIndication> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<StationaryIndication>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<StationaryIndication>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for StationaryIndication - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<StationaryIndication>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <StationaryIndication as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into StationaryIndication - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum StationaryIndicationAnyOf {
    #[serde(rename = "STATIONARY")]
    Stationary,
    #[serde(rename = "MOBILE")]
    Mobile,
}

impl std::fmt::Display for StationaryIndicationAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            StationaryIndicationAnyOf::Stationary => write!(f, "STATIONARY"),
            StationaryIndicationAnyOf::Mobile => write!(f, "MOBILE"),
        }
    }
}

impl std::str::FromStr for StationaryIndicationAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "STATIONARY" => std::result::Result::Ok(StationaryIndicationAnyOf::Stationary),
            "MOBILE" => std::result::Result::Ok(StationaryIndicationAnyOf::Mobile),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SteeringContainer {}

impl SteeringContainer {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SteeringContainer {
        SteeringContainer {}
    }
}

/// Converts the SteeringContainer value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SteeringContainer {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SteeringContainer value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SteeringContainer {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SteeringContainer".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SteeringContainer".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SteeringContainer {})
    }
}

// Methods for converting between header::IntoHeaderValue<SteeringContainer> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SteeringContainer>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SteeringContainer>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SteeringContainer - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SteeringContainer>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SteeringContainer as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SteeringContainer - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains a combination of one PLMN identity and zero or more access technologies.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SteeringInfo {
    #[serde(rename = "plmnId")]
    pub plmn_id: models::PlmnId,

    #[serde(rename = "accessTechList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub access_tech_list: Option<Vec<models::AccessTech>>,
}

impl SteeringInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(plmn_id: models::PlmnId) -> SteeringInfo {
        SteeringInfo {
            plmn_id,
            access_tech_list: None,
        }
    }
}

/// Converts the SteeringInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SteeringInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping plmnId in query parameter serialization

            // Skipping accessTechList in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SteeringInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SteeringInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub plmn_id: Vec<models::PlmnId>,
            pub access_tech_list: Vec<Vec<models::AccessTech>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SteeringInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "plmnId" => intermediate_rep.plmn_id.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "accessTechList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SteeringInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SteeringInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SteeringInfo {
            plmn_id: intermediate_rep
                .plmn_id
                .into_iter()
                .next()
                .ok_or_else(|| "plmnId missing in SteeringInfo".to_string())?,
            access_tech_list: intermediate_rep.access_tech_list.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SteeringInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SteeringInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SteeringInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SteeringInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SteeringInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SteeringInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SteeringInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// String representing the STN-SR as defined in clause 18.6 of 3GPP TS 23.003.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct StnSr(String);

impl std::convert::From<String> for StnSr {
    fn from(x: String) -> Self {
        StnSr(x)
    }
}

impl std::string::ToString for StnSr {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for StnSr {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(StnSr(x.to_string()))
    }
}

impl std::convert::From<StnSr> for String {
    fn from(x: StnSr) -> Self {
        x.0
    }
}

impl std::ops::Deref for StnSr {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for StnSr {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Provides the subsribed 5QI and the ARP, it may contain the priority level.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SubscribedDefaultQos {
    /// Unsigned integer representing a 5G QoS Identifier (see clause 5.7.2.1 of 3GPP TS 23.501, within the range 0 to 255.
    #[serde(rename = "5qi")]
    pub param_5qi: u8,

    #[serde(rename = "arp")]
    pub arp: models::Arp,

    /// Unsigned integer indicating the 5QI Priority Level (see clauses 5.7.3.3 and 5.7.4 of 3GPP TS 23.501, within the range 1 to 127.Values are ordered in decreasing order of priority,  i.e. with 1 as the highest priority and 127 as the lowest priority.
    #[serde(rename = "priorityLevel")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priority_level: Option<u8>,
}

impl SubscribedDefaultQos {
    #[allow(clippy::new_without_default)]
    pub fn new(param_5qi: u8, arp: models::Arp) -> SubscribedDefaultQos {
        SubscribedDefaultQos {
            param_5qi,
            arp,
            priority_level: None,
        }
    }
}

/// Converts the SubscribedDefaultQos value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SubscribedDefaultQos {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("5qi".to_string()),
            Some(self.param_5qi.to_string()),
            // Skipping arp in query parameter serialization
            self.priority_level.as_ref().map(|priority_level| {
                vec!["priorityLevel".to_string(), priority_level.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SubscribedDefaultQos value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SubscribedDefaultQos {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub param_5qi: Vec<u8>,
            pub arp: Vec<models::Arp>,
            pub priority_level: Vec<u8>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SubscribedDefaultQos".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "5qi" => intermediate_rep
                        .param_5qi
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "arp" => intermediate_rep.arp.push(
                        <models::Arp as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "priorityLevel" => intermediate_rep
                        .priority_level
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SubscribedDefaultQos".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SubscribedDefaultQos {
            param_5qi: intermediate_rep
                .param_5qi
                .into_iter()
                .next()
                .ok_or_else(|| "5qi missing in SubscribedDefaultQos".to_string())?,
            arp: intermediate_rep
                .arp
                .into_iter()
                .next()
                .ok_or_else(|| "arp missing in SubscribedDefaultQos".to_string())?,
            priority_level: intermediate_rep.priority_level.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SubscribedDefaultQos> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SubscribedDefaultQos>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SubscribedDefaultQos>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SubscribedDefaultQos - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SubscribedDefaultQos>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SubscribedDefaultQos as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SubscribedDefaultQos - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SubscriptionDataSets {
    #[serde(rename = "amData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub am_data: Option<models::AccessAndMobilitySubscriptionData>,

    #[serde(rename = "smfSelData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub smf_sel_data: Option<models::SmfSelectionSubscriptionData>,

    #[serde(rename = "uecAmfData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub uec_amf_data: Option<models::UeContextInAmfData>,

    #[serde(rename = "uecSmfData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub uec_smf_data: Option<models::UeContextInSmfData>,

    #[serde(rename = "uecSmsfData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub uec_smsf_data: Option<models::UeContextInSmsfData>,

    #[serde(rename = "smsSubsData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sms_subs_data: Option<models::SmsSubscriptionData>,

    #[serde(rename = "smData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sm_data: Option<models::SmSubsData>,

    #[serde(rename = "traceData")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trace_data: Option<swagger::Nullable<models::TraceData>>,

    #[serde(rename = "smsMngData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sms_mng_data: Option<models::SmsManagementSubscriptionData>,

    #[serde(rename = "lcsPrivacyData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lcs_privacy_data: Option<models::LcsPrivacyData>,

    #[serde(rename = "lcsMoData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lcs_mo_data: Option<models::LcsMoData>,

    #[serde(rename = "v2xData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub v2x_data: Option<models::V2xSubscriptionData>,

    #[serde(rename = "lcsBroadcastAssistanceTypesData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lcs_broadcast_assistance_types_data: Option<models::LcsBroadcastAssistanceTypesData>,

    #[serde(rename = "proseData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prose_data: Option<models::ProseSubscriptionData>,

    #[serde(rename = "mbsData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mbs_data: Option<models::MbsSubscriptionData>,

    #[serde(rename = "ucData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub uc_data: Option<models::UcSubscriptionData>,
}

impl SubscriptionDataSets {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SubscriptionDataSets {
        SubscriptionDataSets {
            am_data: None,
            smf_sel_data: None,
            uec_amf_data: None,
            uec_smf_data: None,
            uec_smsf_data: None,
            sms_subs_data: None,
            sm_data: None,
            trace_data: None,
            sms_mng_data: None,
            lcs_privacy_data: None,
            lcs_mo_data: None,
            v2x_data: None,
            lcs_broadcast_assistance_types_data: None,
            prose_data: None,
            mbs_data: None,
            uc_data: None,
        }
    }
}

/// Converts the SubscriptionDataSets value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SubscriptionDataSets {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping amData in query parameter serialization

            // Skipping smfSelData in query parameter serialization

            // Skipping uecAmfData in query parameter serialization

            // Skipping uecSmfData in query parameter serialization

            // Skipping uecSmsfData in query parameter serialization

            // Skipping smsSubsData in query parameter serialization

            // Skipping smData in query parameter serialization

            // Skipping traceData in query parameter serialization

            // Skipping smsMngData in query parameter serialization

            // Skipping lcsPrivacyData in query parameter serialization

            // Skipping lcsMoData in query parameter serialization

            // Skipping v2xData in query parameter serialization

            // Skipping lcsBroadcastAssistanceTypesData in query parameter serialization

            // Skipping proseData in query parameter serialization

            // Skipping mbsData in query parameter serialization

            // Skipping ucData in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SubscriptionDataSets value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SubscriptionDataSets {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub am_data: Vec<models::AccessAndMobilitySubscriptionData>,
            pub smf_sel_data: Vec<models::SmfSelectionSubscriptionData>,
            pub uec_amf_data: Vec<models::UeContextInAmfData>,
            pub uec_smf_data: Vec<models::UeContextInSmfData>,
            pub uec_smsf_data: Vec<models::UeContextInSmsfData>,
            pub sms_subs_data: Vec<models::SmsSubscriptionData>,
            pub sm_data: Vec<models::SmSubsData>,
            pub trace_data: Vec<models::TraceData>,
            pub sms_mng_data: Vec<models::SmsManagementSubscriptionData>,
            pub lcs_privacy_data: Vec<models::LcsPrivacyData>,
            pub lcs_mo_data: Vec<models::LcsMoData>,
            pub v2x_data: Vec<models::V2xSubscriptionData>,
            pub lcs_broadcast_assistance_types_data: Vec<models::LcsBroadcastAssistanceTypesData>,
            pub prose_data: Vec<models::ProseSubscriptionData>,
            pub mbs_data: Vec<models::MbsSubscriptionData>,
            pub uc_data: Vec<models::UcSubscriptionData>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SubscriptionDataSets".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "amData" => intermediate_rep.am_data.push(<models::AccessAndMobilitySubscriptionData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "smfSelData" => intermediate_rep.smf_sel_data.push(<models::SmfSelectionSubscriptionData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "uecAmfData" => intermediate_rep.uec_amf_data.push(<models::UeContextInAmfData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "uecSmfData" => intermediate_rep.uec_smf_data.push(<models::UeContextInSmfData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "uecSmsfData" => intermediate_rep.uec_smsf_data.push(<models::UeContextInSmsfData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "smsSubsData" => intermediate_rep.sms_subs_data.push(<models::SmsSubscriptionData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "smData" => intermediate_rep.sm_data.push(<models::SmSubsData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "traceData" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SubscriptionDataSets".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "smsMngData" => intermediate_rep.sms_mng_data.push(<models::SmsManagementSubscriptionData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lcsPrivacyData" => intermediate_rep.lcs_privacy_data.push(<models::LcsPrivacyData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lcsMoData" => intermediate_rep.lcs_mo_data.push(<models::LcsMoData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "v2xData" => intermediate_rep.v2x_data.push(<models::V2xSubscriptionData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lcsBroadcastAssistanceTypesData" => intermediate_rep.lcs_broadcast_assistance_types_data.push(<models::LcsBroadcastAssistanceTypesData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "proseData" => intermediate_rep.prose_data.push(<models::ProseSubscriptionData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "mbsData" => intermediate_rep.mbs_data.push(<models::MbsSubscriptionData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ucData" => intermediate_rep.uc_data.push(<models::UcSubscriptionData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SubscriptionDataSets".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SubscriptionDataSets {
            am_data: intermediate_rep.am_data.into_iter().next(),
            smf_sel_data: intermediate_rep.smf_sel_data.into_iter().next(),
            uec_amf_data: intermediate_rep.uec_amf_data.into_iter().next(),
            uec_smf_data: intermediate_rep.uec_smf_data.into_iter().next(),
            uec_smsf_data: intermediate_rep.uec_smsf_data.into_iter().next(),
            sms_subs_data: intermediate_rep.sms_subs_data.into_iter().next(),
            sm_data: intermediate_rep.sm_data.into_iter().next(),
            trace_data: std::result::Result::Err(
                "Nullable types not supported in SubscriptionDataSets".to_string(),
            )?,
            sms_mng_data: intermediate_rep.sms_mng_data.into_iter().next(),
            lcs_privacy_data: intermediate_rep.lcs_privacy_data.into_iter().next(),
            lcs_mo_data: intermediate_rep.lcs_mo_data.into_iter().next(),
            v2x_data: intermediate_rep.v2x_data.into_iter().next(),
            lcs_broadcast_assistance_types_data: intermediate_rep
                .lcs_broadcast_assistance_types_data
                .into_iter()
                .next(),
            prose_data: intermediate_rep.prose_data.into_iter().next(),
            mbs_data: intermediate_rep.mbs_data.into_iter().next(),
            uc_data: intermediate_rep.uc_data.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SubscriptionDataSets> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SubscriptionDataSets>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SubscriptionDataSets>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SubscriptionDataSets - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SubscriptionDataSets>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SubscriptionDataSets as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SubscriptionDataSets - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SuggestedPacketNumDl {
    #[serde(rename = "suggestedPacketNumDl")]
    pub suggested_packet_num_dl: u32,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "validityTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub validity_time: Option<chrono::DateTime<chrono::Utc>>,
}

impl SuggestedPacketNumDl {
    #[allow(clippy::new_without_default)]
    pub fn new(suggested_packet_num_dl: u32) -> SuggestedPacketNumDl {
        SuggestedPacketNumDl {
            suggested_packet_num_dl,
            validity_time: None,
        }
    }
}

/// Converts the SuggestedPacketNumDl value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SuggestedPacketNumDl {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("suggestedPacketNumDl".to_string()),
            Some(self.suggested_packet_num_dl.to_string()),
            // Skipping validityTime in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SuggestedPacketNumDl value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SuggestedPacketNumDl {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub suggested_packet_num_dl: Vec<u32>,
            pub validity_time: Vec<chrono::DateTime<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SuggestedPacketNumDl".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "suggestedPacketNumDl" => intermediate_rep.suggested_packet_num_dl.push(
                        <u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "validityTime" => intermediate_rep.validity_time.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SuggestedPacketNumDl".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SuggestedPacketNumDl {
            suggested_packet_num_dl: intermediate_rep
                .suggested_packet_num_dl
                .into_iter()
                .next()
                .ok_or_else(|| {
                    "suggestedPacketNumDl missing in SuggestedPacketNumDl".to_string()
                })?,
            validity_time: intermediate_rep.validity_time.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SuggestedPacketNumDl> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SuggestedPacketNumDl>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SuggestedPacketNumDl>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SuggestedPacketNumDl - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SuggestedPacketNumDl>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SuggestedPacketNumDl as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SuggestedPacketNumDl - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// String identifying a Supi that shall contain either an IMSI, a network specific identifier, a Global Cable Identifier (GCI) or a Global Line Identifier (GLI) as specified in clause  2.2A of 3GPP TS 23.003. It shall be formatted as follows  - for an IMSI \"imsi-<imsi>\", where <imsi> shall be formatted according to clause 2.2    of 3GPP TS 23.003 that describes an IMSI.  - for a network specific identifier \"nai-<nai>, where <nai> shall be formatted    according to clause 28.7.2 of 3GPP TS 23.003 that describes an NAI.  - for a GCI \"gci-<gci>\", where <gci> shall be formatted according to clause 28.15.2    of 3GPP TS 23.003.  - for a GLI \"gli-<gli>\", where <gli> shall be formatted according to clause 28.16.2 of    3GPP TS 23.003.To enable that the value is used as part of an URI, the string shall    only contain characters allowed according to the \"lower-with-hyphen\" naming convention    defined in 3GPP TS 29.501.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Supi(String);

impl std::convert::From<String> for Supi {
    fn from(x: String) -> Self {
        Supi(x)
    }
}

impl std::string::ToString for Supi {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Supi {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Supi(x.to_string()))
    }
}

impl std::convert::From<Supi> for String {
    fn from(x: Supi) -> Self {
        x.0
    }
}

impl std::ops::Deref for Supi {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Supi {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// List of Supis.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SupiInfo {
    #[serde(rename = "supiList")]
    pub supi_list: Vec<models::Supi>,
}

impl SupiInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(supi_list: Vec<models::Supi>) -> SupiInfo {
        SupiInfo { supi_list }
    }
}

/// Converts the SupiInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SupiInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("supiList".to_string()),
            Some(
                self.supi_list
                    .iter()
                    .map(|x| x.to_string())
                    .collect::<Vec<_>>()
                    .join(","),
            ),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SupiInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SupiInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub supi_list: Vec<Vec<models::Supi>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SupiInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "supiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in SupiInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SupiInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SupiInfo {
            supi_list: intermediate_rep
                .supi_list
                .into_iter()
                .next()
                .ok_or_else(|| "supiList missing in SupiInfo".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SupiInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SupiInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SupiInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SupiInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<SupiInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SupiInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SupiInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  tableÂ 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SupportedFeatures(String);

impl std::convert::From<String> for SupportedFeatures {
    fn from(x: String) -> Self {
        SupportedFeatures(x)
    }
}

impl std::string::ToString for SupportedFeatures {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for SupportedFeatures {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(SupportedFeatures(x.to_string()))
    }
}

impl std::convert::From<SupportedFeatures> for String {
    fn from(x: SupportedFeatures) -> Self {
        x.0
    }
}

impl std::ops::Deref for SupportedFeatures {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for SupportedFeatures {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Indicates supported GAD shapes.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SupportedGadShapes {}

impl SupportedGadShapes {
    #[allow(clippy::new_without_default)]
    pub fn new() -> SupportedGadShapes {
        SupportedGadShapes {}
    }
}

/// Converts the SupportedGadShapes value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for SupportedGadShapes {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SupportedGadShapes value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SupportedGadShapes {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing SupportedGadShapes".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing SupportedGadShapes".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SupportedGadShapes {})
    }
}

// Methods for converting between header::IntoHeaderValue<SupportedGadShapes> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<SupportedGadShapes>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<SupportedGadShapes>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for SupportedGadShapes - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<SupportedGadShapes>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <SupportedGadShapes as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into SupportedGadShapes - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum SupportedGadShapesAnyOf {
    #[serde(rename = "POINT")]
    Point,
    #[serde(rename = "POINT_UNCERTAINTY_CIRCLE")]
    PointUncertaintyCircle,
    #[serde(rename = "POINT_UNCERTAINTY_ELLIPSE")]
    PointUncertaintyEllipse,
    #[serde(rename = "POLYGON")]
    Polygon,
    #[serde(rename = "POINT_ALTITUDE")]
    PointAltitude,
    #[serde(rename = "POINT_ALTITUDE_UNCERTAINTY")]
    PointAltitudeUncertainty,
    #[serde(rename = "ELLIPSOID_ARC")]
    EllipsoidArc,
    #[serde(rename = "LOCAL_2D_POINT_UNCERTAINTY_ELLIPSE")]
    Local2DPointUncertaintyEllipse,
    #[serde(rename = "LOCAL_3D_POINT_UNCERTAINTY_ELLIPSOID")]
    Local3DPointUncertaintyEllipsoid,
}

impl std::fmt::Display for SupportedGadShapesAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            SupportedGadShapesAnyOf::Point => write!(f, "POINT"),
            SupportedGadShapesAnyOf::PointUncertaintyCircle => {
                write!(f, "POINT_UNCERTAINTY_CIRCLE")
            }
            SupportedGadShapesAnyOf::PointUncertaintyEllipse => {
                write!(f, "POINT_UNCERTAINTY_ELLIPSE")
            }
            SupportedGadShapesAnyOf::Polygon => write!(f, "POLYGON"),
            SupportedGadShapesAnyOf::PointAltitude => write!(f, "POINT_ALTITUDE"),
            SupportedGadShapesAnyOf::PointAltitudeUncertainty => {
                write!(f, "POINT_ALTITUDE_UNCERTAINTY")
            }
            SupportedGadShapesAnyOf::EllipsoidArc => write!(f, "ELLIPSOID_ARC"),
            SupportedGadShapesAnyOf::Local2DPointUncertaintyEllipse => {
                write!(f, "LOCAL_2D_POINT_UNCERTAINTY_ELLIPSE")
            }
            SupportedGadShapesAnyOf::Local3DPointUncertaintyEllipsoid => {
                write!(f, "LOCAL_3D_POINT_UNCERTAINTY_ELLIPSOID")
            }
        }
    }
}

impl std::str::FromStr for SupportedGadShapesAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "POINT" => std::result::Result::Ok(SupportedGadShapesAnyOf::Point),
            "POINT_UNCERTAINTY_CIRCLE" => {
                std::result::Result::Ok(SupportedGadShapesAnyOf::PointUncertaintyCircle)
            }
            "POINT_UNCERTAINTY_ELLIPSE" => {
                std::result::Result::Ok(SupportedGadShapesAnyOf::PointUncertaintyEllipse)
            }
            "POLYGON" => std::result::Result::Ok(SupportedGadShapesAnyOf::Polygon),
            "POINT_ALTITUDE" => std::result::Result::Ok(SupportedGadShapesAnyOf::PointAltitude),
            "POINT_ALTITUDE_UNCERTAINTY" => {
                std::result::Result::Ok(SupportedGadShapesAnyOf::PointAltitudeUncertainty)
            }
            "ELLIPSOID_ARC" => std::result::Result::Ok(SupportedGadShapesAnyOf::EllipsoidArc),
            "LOCAL_2D_POINT_UNCERTAINTY_ELLIPSE" => {
                std::result::Result::Ok(SupportedGadShapesAnyOf::Local2DPointUncertaintyEllipse)
            }
            "LOCAL_3D_POINT_UNCERTAINTY_ELLIPSOID" => {
                std::result::Result::Ok(SupportedGadShapesAnyOf::Local3DPointUncertaintyEllipsoid)
            }
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// 2 or 3-octet string identifying a tracking area code as specified in clause 9.3.3.10  of 3GPP TS 38.413, in hexadecimal representation. Each character in the string shall  take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character representing the 4 most significant bits of the TAC shall  appear first in the string, and the character representing the 4 least significant bit  of the TAC shall appear last in the string.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Tac(String);

impl std::convert::From<String> for Tac {
    fn from(x: String) -> Self {
        Tac(x)
    }
}

impl std::string::ToString for Tac {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Tac {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Tac(x.to_string()))
    }
}

impl std::convert::From<Tac> for String {
    fn from(x: Tac) -> Self {
        x.0
    }
}

impl std::ops::Deref for Tac {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Tac {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// contains tracking area information (tracking area codes).
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TacInfo {
    #[serde(rename = "tacList")]
    pub tac_list: Vec<models::Tac>,
}

impl TacInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(tac_list: Vec<models::Tac>) -> TacInfo {
        TacInfo { tac_list }
    }
}

/// Converts the TacInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TacInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("tacList".to_string()),
            Some(
                self.tac_list
                    .iter()
                    .map(|x| x.to_string())
                    .collect::<Vec<_>>()
                    .join(","),
            ),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TacInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TacInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub tac_list: Vec<Vec<models::Tac>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TacInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "tacList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in TacInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing TacInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TacInfo {
            tac_list: intermediate_rep
                .tac_list
                .into_iter()
                .next()
                .ok_or_else(|| "tacList missing in TacInfo".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TacInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TacInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TacInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TacInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TacInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TacInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TacInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains the tracking area identity as described in 3GPP 23.003
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Tai {
    #[serde(rename = "plmnId")]
    pub plmn_id: models::PlmnId,

    /// 2 or 3-octet string identifying a tracking area code as specified in clause 9.3.3.10  of 3GPP TS 38.413, in hexadecimal representation. Each character in the string shall  take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character representing the 4 most significant bits of the TAC shall  appear first in the string, and the character representing the 4 least significant bit  of the TAC shall appear last in the string.
    #[serde(rename = "tac")]
    pub tac: String,

    /// This represents the Network Identifier, which together with a PLMN ID is used to identify an SNPN (see 3GPP TS 23.003 and 3GPP TS 23.501 clause 5.30.2.1).
    #[serde(rename = "nid")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nid: Option<String>,
}

impl Tai {
    #[allow(clippy::new_without_default)]
    pub fn new(plmn_id: models::PlmnId, tac: String) -> Tai {
        Tai {
            plmn_id,
            tac,
            nid: None,
        }
    }
}

/// Converts the Tai value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Tai {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping plmnId in query parameter serialization
            Some("tac".to_string()),
            Some(self.tac.to_string()),
            self.nid
                .as_ref()
                .map(|nid| vec!["nid".to_string(), nid.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Tai value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Tai {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub plmn_id: Vec<models::PlmnId>,
            pub tac: Vec<String>,
            pub nid: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err("Missing value while parsing Tai".to_string())
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "plmnId" => intermediate_rep.plmn_id.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "tac" => intermediate_rep.tac.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nid" => intermediate_rep.nid.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Tai".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Tai {
            plmn_id: intermediate_rep
                .plmn_id
                .into_iter()
                .next()
                .ok_or_else(|| "plmnId missing in Tai".to_string())?,
            tac: intermediate_rep
                .tac
                .into_iter()
                .next()
                .ok_or_else(|| "tac missing in Tai".to_string())?,
            nid: intermediate_rep.nid.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Tai> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Tai>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Tai>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Tai - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Tai> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Tai as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Tai - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// String with format partial-time or full-time as defined in clause 5.6 of IETF RFC 3339. Examples, 20:15:00, 20:15:00-08:00 (for 8 hours behind UTC).
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TimeOfDay(String);

impl std::convert::From<String> for TimeOfDay {
    fn from(x: String) -> Self {
        TimeOfDay(x)
    }
}

impl std::string::ToString for TimeOfDay {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for TimeOfDay {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(TimeOfDay(x.to_string()))
    }
}

impl std::convert::From<TimeOfDay> for String {
    fn from(x: TimeOfDay) -> Self {
        x.0
    }
}

impl std::ops::Deref for TimeOfDay {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for TimeOfDay {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// Temporary Mobile Group Identity
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Tmgi {
    /// MBS Service ID
    #[serde(rename = "mbsServiceId")]
    pub mbs_service_id: String,

    #[serde(rename = "plmnId")]
    pub plmn_id: models::PlmnId,
}

impl Tmgi {
    #[allow(clippy::new_without_default)]
    pub fn new(mbs_service_id: String, plmn_id: models::PlmnId) -> Tmgi {
        Tmgi {
            mbs_service_id,
            plmn_id,
        }
    }
}

/// Converts the Tmgi value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Tmgi {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("mbsServiceId".to_string()),
            Some(self.mbs_service_id.to_string()),
            // Skipping plmnId in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Tmgi value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Tmgi {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub mbs_service_id: Vec<String>,
            pub plmn_id: Vec<models::PlmnId>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err("Missing value while parsing Tmgi".to_string())
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "mbsServiceId" => intermediate_rep.mbs_service_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "plmnId" => intermediate_rep.plmn_id.push(
                        <models::PlmnId as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing Tmgi".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Tmgi {
            mbs_service_id: intermediate_rep
                .mbs_service_id
                .into_iter()
                .next()
                .ok_or_else(|| "mbsServiceId missing in Tmgi".to_string())?,
            plmn_id: intermediate_rep
                .plmn_id
                .into_iter()
                .next()
                .ok_or_else(|| "plmnId missing in Tmgi".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Tmgi> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Tmgi>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<Tmgi>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for Tmgi - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Tmgi> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <Tmgi as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into Tmgi - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// This represents the identifier of the TNGF ID as specified in clause 9.3.1.161 of  3GPP TS 38.413  in hexadecimal representation. Each character in the string shall take a value of \"0\" to \"9\", \"a\"  to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character representing the  4 most significant bits of the TNGF ID shall appear first in the string, and the character  representing the 4 least significant bit of the TNGF ID shall appear last in the string.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TngfId(String);

impl std::convert::From<String> for TngfId {
    fn from(x: String) -> Self {
        TngfId(x)
    }
}

impl std::string::ToString for TngfId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for TngfId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(TngfId(x.to_string()))
    }
}

impl std::convert::From<TngfId> for String {
    fn from(x: TngfId) -> Self {
        x.0
    }
}

impl std::ops::Deref for TngfId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for TngfId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// contains Trace control and configuration parameters.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TraceData {
    /// Trace Reference (see 3GPP TS 32.422).It shall be encoded as the concatenation of MCC, MNC and Trace ID as follows: 'MCC'<MNC'-'Trace ID'The Trace ID shall be encoded as a 3 octet string in hexadecimal representation. Each character in the Trace ID string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character representing the 4 most significant bits of the Trace ID shall appear first  in the string, and the character representing the 4 least significant bit of the Trace ID shall appear last in the string.
    #[serde(rename = "traceRef")]
    pub trace_ref: String,

    #[serde(rename = "traceDepth")]
    pub trace_depth: models::TraceDepth,

    /// List of NE Types (see 3GPP TS 32.422).It shall be encoded as an octet string in hexadecimal representation. Each character in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character representing the 4 most significant bits shall appear first in the string, and the character representing the 4 least significant bit shall appear last in the string.Octets shall be coded according to 3GPP TS 32.422.
    #[serde(rename = "neTypeList")]
    pub ne_type_list: String,

    /// Triggering events (see 3GPP TS 32.422).It shall be encoded as an octet string in hexadecimal representation. Each character in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character representing the 4 most significant bits shall appear first in the string, and the character representing the 4 least significant bit shall appear last in the string. Octets shall be coded according to 3GPP TS 32.422.
    #[serde(rename = "eventList")]
    pub event_list: String,

    /// String identifying a IPv4 address formatted in the 'dotted decimal' notation as defined in RFC 1166.
    #[serde(rename = "collectionEntityIpv4Addr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub collection_entity_ipv4_addr: Option<String>,

    #[serde(rename = "collectionEntityIpv6Addr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub collection_entity_ipv6_addr: Option<models::Ipv6Addr>,

    /// List of Interfaces (see 3GPP TS 32.422).It shall be encoded as an octet string in hexadecimal representation. Each character in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character representing the 4 most significant bits shall appear first in the string, and the character representing the  4 least significant bit shall appear last in the string. Octets shall be coded according to 3GPP TS 32.422. If this attribute is not present, all the interfaces applicable to the list of NE types indicated in the neTypeList attribute should be traced.
    #[serde(rename = "interfaceList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub interface_list: Option<String>,
}

impl TraceData {
    #[allow(clippy::new_without_default)]
    pub fn new(
        trace_ref: String,
        trace_depth: models::TraceDepth,
        ne_type_list: String,
        event_list: String,
    ) -> TraceData {
        TraceData {
            trace_ref,
            trace_depth,
            ne_type_list,
            event_list,
            collection_entity_ipv4_addr: None,
            collection_entity_ipv6_addr: None,
            interface_list: None,
        }
    }
}

/// Converts the TraceData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TraceData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("traceRef".to_string()),
            Some(self.trace_ref.to_string()),
            // Skipping traceDepth in query parameter serialization
            Some("neTypeList".to_string()),
            Some(self.ne_type_list.to_string()),
            Some("eventList".to_string()),
            Some(self.event_list.to_string()),
            self.collection_entity_ipv4_addr
                .as_ref()
                .map(|collection_entity_ipv4_addr| {
                    vec![
                        "collectionEntityIpv4Addr".to_string(),
                        collection_entity_ipv4_addr.to_string(),
                    ]
                    .join(",")
                }),
            // Skipping collectionEntityIpv6Addr in query parameter serialization
            self.interface_list.as_ref().map(|interface_list| {
                vec!["interfaceList".to_string(), interface_list.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TraceData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TraceData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub trace_ref: Vec<String>,
            pub trace_depth: Vec<models::TraceDepth>,
            pub ne_type_list: Vec<String>,
            pub event_list: Vec<String>,
            pub collection_entity_ipv4_addr: Vec<String>,
            pub collection_entity_ipv6_addr: Vec<models::Ipv6Addr>,
            pub interface_list: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TraceData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "traceRef" => intermediate_rep.trace_ref.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "traceDepth" => intermediate_rep.trace_depth.push(
                        <models::TraceDepth as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "neTypeList" => intermediate_rep.ne_type_list.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "eventList" => intermediate_rep.event_list.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "collectionEntityIpv4Addr" => {
                        intermediate_rep.collection_entity_ipv4_addr.push(
                            <String as std::str::FromStr>::from_str(val)
                                .map_err(|x| x.to_string())?,
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "collectionEntityIpv6Addr" => {
                        intermediate_rep.collection_entity_ipv6_addr.push(
                            <models::Ipv6Addr as std::str::FromStr>::from_str(val)
                                .map_err(|x| x.to_string())?,
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "interfaceList" => intermediate_rep.interface_list.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing TraceData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TraceData {
            trace_ref: intermediate_rep
                .trace_ref
                .into_iter()
                .next()
                .ok_or_else(|| "traceRef missing in TraceData".to_string())?,
            trace_depth: intermediate_rep
                .trace_depth
                .into_iter()
                .next()
                .ok_or_else(|| "traceDepth missing in TraceData".to_string())?,
            ne_type_list: intermediate_rep
                .ne_type_list
                .into_iter()
                .next()
                .ok_or_else(|| "neTypeList missing in TraceData".to_string())?,
            event_list: intermediate_rep
                .event_list
                .into_iter()
                .next()
                .ok_or_else(|| "eventList missing in TraceData".to_string())?,
            collection_entity_ipv4_addr: intermediate_rep
                .collection_entity_ipv4_addr
                .into_iter()
                .next(),
            collection_entity_ipv6_addr: intermediate_rep
                .collection_entity_ipv6_addr
                .into_iter()
                .next(),
            interface_list: intermediate_rep.interface_list.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TraceData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TraceData>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TraceData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TraceData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TraceData> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TraceData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TraceData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TraceDataResponse {
    #[serde(rename = "traceData")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trace_data: Option<swagger::Nullable<models::TraceData>>,

    #[serde(rename = "sharedTraceDataId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shared_trace_data_id: Option<String>,
}

impl TraceDataResponse {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TraceDataResponse {
        TraceDataResponse {
            trace_data: None,
            shared_trace_data_id: None,
        }
    }
}

/// Converts the TraceDataResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TraceDataResponse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping traceData in query parameter serialization
            self.shared_trace_data_id
                .as_ref()
                .map(|shared_trace_data_id| {
                    vec![
                        "sharedTraceDataId".to_string(),
                        shared_trace_data_id.to_string(),
                    ]
                    .join(",")
                }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TraceDataResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TraceDataResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub trace_data: Vec<models::TraceData>,
            pub shared_trace_data_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TraceDataResponse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "traceData" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in TraceDataResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "sharedTraceDataId" => intermediate_rep.shared_trace_data_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TraceDataResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TraceDataResponse {
            trace_data: std::result::Result::Err(
                "Nullable types not supported in TraceDataResponse".to_string(),
            )?,
            shared_trace_data_id: intermediate_rep.shared_trace_data_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TraceDataResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TraceDataResponse>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TraceDataResponse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TraceDataResponse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<TraceDataResponse>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TraceDataResponse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TraceDataResponse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// The enumeration TraceDepth defines how detailed information should be recorded in the trace. See 3GPP TS 32.422 for further description of the values. It shall comply with the provisions defined in table 5.6.3.1-1
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TraceDepth {}

impl TraceDepth {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TraceDepth {
        TraceDepth {}
    }
}

/// Converts the TraceDepth value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TraceDepth {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TraceDepth value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TraceDepth {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TraceDepth".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing TraceDepth".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TraceDepth {})
    }
}

// Methods for converting between header::IntoHeaderValue<TraceDepth> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TraceDepth>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TraceDepth>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TraceDepth - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TraceDepth> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TraceDepth as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TraceDepth - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum TraceDepthAnyOf {
    #[serde(rename = "MINIMUM")]
    Minimum,
    #[serde(rename = "MEDIUM")]
    Medium,
    #[serde(rename = "MAXIMUM")]
    Maximum,
    #[serde(rename = "MINIMUM_WO_VENDOR_EXTENSION")]
    MinimumWoVendorExtension,
    #[serde(rename = "MEDIUM_WO_VENDOR_EXTENSION")]
    MediumWoVendorExtension,
    #[serde(rename = "MAXIMUM_WO_VENDOR_EXTENSION")]
    MaximumWoVendorExtension,
}

impl std::fmt::Display for TraceDepthAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            TraceDepthAnyOf::Minimum => write!(f, "MINIMUM"),
            TraceDepthAnyOf::Medium => write!(f, "MEDIUM"),
            TraceDepthAnyOf::Maximum => write!(f, "MAXIMUM"),
            TraceDepthAnyOf::MinimumWoVendorExtension => write!(f, "MINIMUM_WO_VENDOR_EXTENSION"),
            TraceDepthAnyOf::MediumWoVendorExtension => write!(f, "MEDIUM_WO_VENDOR_EXTENSION"),
            TraceDepthAnyOf::MaximumWoVendorExtension => write!(f, "MAXIMUM_WO_VENDOR_EXTENSION"),
        }
    }
}

impl std::str::FromStr for TraceDepthAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "MINIMUM" => std::result::Result::Ok(TraceDepthAnyOf::Minimum),
            "MEDIUM" => std::result::Result::Ok(TraceDepthAnyOf::Medium),
            "MAXIMUM" => std::result::Result::Ok(TraceDepthAnyOf::Maximum),
            "MINIMUM_WO_VENDOR_EXTENSION" => {
                std::result::Result::Ok(TraceDepthAnyOf::MinimumWoVendorExtension)
            }
            "MEDIUM_WO_VENDOR_EXTENSION" => {
                std::result::Result::Ok(TraceDepthAnyOf::MediumWoVendorExtension)
            }
            "MAXIMUM_WO_VENDOR_EXTENSION" => {
                std::result::Result::Ok(TraceDepthAnyOf::MaximumWoVendorExtension)
            }
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Possible values are: - SINGLE_TRANS_UL: Uplink single packet transmission. - SINGLE_TRANS_DL: Downlink single packet transmission. - DUAL_TRANS_UL_FIRST: Dual packet transmission, firstly uplink packet transmission   with subsequent downlink packet transmission. - DUAL_TRANS_DL_FIRST: Dual packet transmission, firstly downlink packet transmission   with subsequent uplink packet transmission.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TrafficProfile {}

impl TrafficProfile {
    #[allow(clippy::new_without_default)]
    pub fn new() -> TrafficProfile {
        TrafficProfile {}
    }
}

/// Converts the TrafficProfile value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TrafficProfile {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TrafficProfile value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TrafficProfile {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing TrafficProfile".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing TrafficProfile".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TrafficProfile {})
    }
}

// Methods for converting between header::IntoHeaderValue<TrafficProfile> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TrafficProfile>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<TrafficProfile>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for TrafficProfile - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TrafficProfile> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <TrafficProfile as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into TrafficProfile - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum TrafficProfileAnyOf {
    #[serde(rename = "SINGLE_TRANS_UL")]
    SingleTransUl,
    #[serde(rename = "SINGLE_TRANS_DL")]
    SingleTransDl,
    #[serde(rename = "DUAL_TRANS_UL_FIRST")]
    DualTransUlFirst,
    #[serde(rename = "DUAL_TRANS_DL_FIRST")]
    DualTransDlFirst,
    #[serde(rename = "MULTI_TRANS")]
    MultiTrans,
}

impl std::fmt::Display for TrafficProfileAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            TrafficProfileAnyOf::SingleTransUl => write!(f, "SINGLE_TRANS_UL"),
            TrafficProfileAnyOf::SingleTransDl => write!(f, "SINGLE_TRANS_DL"),
            TrafficProfileAnyOf::DualTransUlFirst => write!(f, "DUAL_TRANS_UL_FIRST"),
            TrafficProfileAnyOf::DualTransDlFirst => write!(f, "DUAL_TRANS_DL_FIRST"),
            TrafficProfileAnyOf::MultiTrans => write!(f, "MULTI_TRANS"),
        }
    }
}

impl std::str::FromStr for TrafficProfileAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "SINGLE_TRANS_UL" => std::result::Result::Ok(TrafficProfileAnyOf::SingleTransUl),
            "SINGLE_TRANS_DL" => std::result::Result::Ok(TrafficProfileAnyOf::SingleTransDl),
            "DUAL_TRANS_UL_FIRST" => std::result::Result::Ok(TrafficProfileAnyOf::DualTransUlFirst),
            "DUAL_TRANS_DL_FIRST" => std::result::Result::Ok(TrafficProfileAnyOf::DualTransDlFirst),
            "MULTI_TRANS" => std::result::Result::Ok(TrafficProfileAnyOf::MultiTrans),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Indicates the purpose of the user consent.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UcPurpose {}

impl UcPurpose {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UcPurpose {
        UcPurpose {}
    }
}

/// Converts the UcPurpose value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UcPurpose {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UcPurpose value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UcPurpose {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UcPurpose".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UcPurpose".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UcPurpose {})
    }
}

// Methods for converting between header::IntoHeaderValue<UcPurpose> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UcPurpose>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UcPurpose>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UcPurpose - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UcPurpose> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UcPurpose as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UcPurpose - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum UcPurposeAnyOf {
    #[serde(rename = "ANALYTICS")]
    Analytics,
    #[serde(rename = "MODEL_TRAINING")]
    ModelTraining,
    #[serde(rename = "NW_CAP_EXPOSURE")]
    NwCapExposure,
    #[serde(rename = "EDGEAPP_UE_LOCATION")]
    EdgeappUeLocation,
}

impl std::fmt::Display for UcPurposeAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            UcPurposeAnyOf::Analytics => write!(f, "ANALYTICS"),
            UcPurposeAnyOf::ModelTraining => write!(f, "MODEL_TRAINING"),
            UcPurposeAnyOf::NwCapExposure => write!(f, "NW_CAP_EXPOSURE"),
            UcPurposeAnyOf::EdgeappUeLocation => write!(f, "EDGEAPP_UE_LOCATION"),
        }
    }
}

impl std::str::FromStr for UcPurposeAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ANALYTICS" => std::result::Result::Ok(UcPurposeAnyOf::Analytics),
            "MODEL_TRAINING" => std::result::Result::Ok(UcPurposeAnyOf::ModelTraining),
            "NW_CAP_EXPOSURE" => std::result::Result::Ok(UcPurposeAnyOf::NwCapExposure),
            "EDGEAPP_UE_LOCATION" => std::result::Result::Ok(UcPurposeAnyOf::EdgeappUeLocation),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Contains the User Consent Subscription Data.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UcSubscriptionData {
    /// A map(list of key-value pairs) where user consent purpose serves as key of user consent
    #[serde(rename = "userConsentPerPurposeList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_consent_per_purpose_list:
        Option<std::collections::HashMap<String, models::UserConsent>>,
}

impl UcSubscriptionData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UcSubscriptionData {
        UcSubscriptionData {
            user_consent_per_purpose_list: None,
        }
    }
}

/// Converts the UcSubscriptionData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UcSubscriptionData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping userConsentPerPurposeList in query parameter serialization
            // Skipping userConsentPerPurposeList in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UcSubscriptionData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UcSubscriptionData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub user_consent_per_purpose_list:
                Vec<std::collections::HashMap<String, models::UserConsent>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UcSubscriptionData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "userConsentPerPurposeList" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in UcSubscriptionData"
                            .to_string(),
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UcSubscriptionData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UcSubscriptionData {
            user_consent_per_purpose_list: intermediate_rep
                .user_consent_per_purpose_list
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UcSubscriptionData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UcSubscriptionData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UcSubscriptionData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UcSubscriptionData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<UcSubscriptionData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UcSubscriptionData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UcSubscriptionData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Possible values are: - AUTHORIZED: Indicates that the UE is authorized. - NOT_AUTHORIZED: Indicates that the UE is not authorized.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UeAuth {}

impl UeAuth {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UeAuth {
        UeAuth {}
    }
}

/// Converts the UeAuth value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UeAuth {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UeAuth value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UeAuth {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UeAuth".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UeAuth".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UeAuth {})
    }
}

// Methods for converting between header::IntoHeaderValue<UeAuth> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UeAuth>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UeAuth>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UeAuth - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UeAuth> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UeAuth as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UeAuth - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum UeAuthAnyOf {
    #[serde(rename = "AUTHORIZED")]
    Authorized,
    #[serde(rename = "NOT_AUTHORIZED")]
    NotAuthorized,
}

impl std::fmt::Display for UeAuthAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            UeAuthAnyOf::Authorized => write!(f, "AUTHORIZED"),
            UeAuthAnyOf::NotAuthorized => write!(f, "NOT_AUTHORIZED"),
        }
    }
}

impl std::str::FromStr for UeAuthAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "AUTHORIZED" => std::result::Result::Ok(UeAuthAnyOf::Authorized),
            "NOT_AUTHORIZED" => std::result::Result::Ok(UeAuthAnyOf::NotAuthorized),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UeContextInAmfData {
    #[serde(rename = "epsInterworkingInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub eps_interworking_info: Option<models::EpsInterworkingInfo>,

    /// AMF information
    #[serde(rename = "amfInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub amf_info: Option<Vec<models::AmfInfo>>,
}

impl UeContextInAmfData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UeContextInAmfData {
        UeContextInAmfData {
            eps_interworking_info: None,
            amf_info: None,
        }
    }
}

/// Converts the UeContextInAmfData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UeContextInAmfData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping epsInterworkingInfo in query parameter serialization

            // Skipping amfInfo in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UeContextInAmfData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UeContextInAmfData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub eps_interworking_info: Vec<models::EpsInterworkingInfo>,
            pub amf_info: Vec<Vec<models::AmfInfo>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UeContextInAmfData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "epsInterworkingInfo" => intermediate_rep.eps_interworking_info.push(
                        <models::EpsInterworkingInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "amfInfo" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in UeContextInAmfData"
                            .to_string(),
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UeContextInAmfData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UeContextInAmfData {
            eps_interworking_info: intermediate_rep.eps_interworking_info.into_iter().next(),
            amf_info: intermediate_rep.amf_info.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UeContextInAmfData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UeContextInAmfData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UeContextInAmfData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UeContextInAmfData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<UeContextInAmfData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UeContextInAmfData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UeContextInAmfData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UeContextInSmfData {
    /// A map (list of key-value pairs where PduSessionId serves as key) of PduSessions
    #[serde(rename = "pduSessions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pdu_sessions: Option<std::collections::HashMap<String, models::PduSession>>,

    #[serde(rename = "pgwInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pgw_info: Option<Vec<models::PgwInfo>>,

    #[serde(rename = "emergencyInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub emergency_info: Option<models::EmergencyInfo>,
}

impl UeContextInSmfData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UeContextInSmfData {
        UeContextInSmfData {
            pdu_sessions: None,
            pgw_info: None,
            emergency_info: None,
        }
    }
}

/// Converts the UeContextInSmfData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UeContextInSmfData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping pduSessions in query parameter serialization
            // Skipping pduSessions in query parameter serialization

            // Skipping pgwInfo in query parameter serialization

            // Skipping emergencyInfo in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UeContextInSmfData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UeContextInSmfData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub pdu_sessions: Vec<std::collections::HashMap<String, models::PduSession>>,
            pub pgw_info: Vec<Vec<models::PgwInfo>>,
            pub emergency_info: Vec<models::EmergencyInfo>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UeContextInSmfData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "pduSessions" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in UeContextInSmfData"
                            .to_string(),
                    ),
                    "pgwInfo" => return std::result::Result::Err(
                        "Parsing a container in this style is not supported in UeContextInSmfData"
                            .to_string(),
                    ),
                    #[allow(clippy::redundant_clone)]
                    "emergencyInfo" => intermediate_rep.emergency_info.push(
                        <models::EmergencyInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UeContextInSmfData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UeContextInSmfData {
            pdu_sessions: intermediate_rep.pdu_sessions.into_iter().next(),
            pgw_info: intermediate_rep.pgw_info.into_iter().next(),
            emergency_info: intermediate_rep.emergency_info.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UeContextInSmfData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UeContextInSmfData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UeContextInSmfData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UeContextInSmfData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<UeContextInSmfData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UeContextInSmfData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UeContextInSmfData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// UE Context In Smf Data Subscription Filter.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UeContextInSmfDataSubFilter {
    #[serde(rename = "dnnList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dnn_list: Option<Vec<models::Dnn>>,

    #[serde(rename = "snssaiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub snssai_list: Option<Vec<models::Snssai>>,

    #[serde(rename = "emergencyInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub emergency_ind: Option<bool>,
}

impl UeContextInSmfDataSubFilter {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UeContextInSmfDataSubFilter {
        UeContextInSmfDataSubFilter {
            dnn_list: None,
            snssai_list: None,
            emergency_ind: Some(false),
        }
    }
}

/// Converts the UeContextInSmfDataSubFilter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UeContextInSmfDataSubFilter {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            self.dnn_list.as_ref().map(|dnn_list| {
                vec![
                    "dnnList".to_string(),
                    dnn_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            // Skipping snssaiList in query parameter serialization
            self.emergency_ind.as_ref().map(|emergency_ind| {
                vec!["emergencyInd".to_string(), emergency_ind.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UeContextInSmfDataSubFilter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UeContextInSmfDataSubFilter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub dnn_list: Vec<Vec<models::Dnn>>,
            pub snssai_list: Vec<Vec<models::Snssai>>,
            pub emergency_ind: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UeContextInSmfDataSubFilter".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "dnnList" => return std::result::Result::Err("Parsing a container in this style is not supported in UeContextInSmfDataSubFilter".to_string()),
                    "snssaiList" => return std::result::Result::Err("Parsing a container in this style is not supported in UeContextInSmfDataSubFilter".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "emergencyInd" => intermediate_rep.emergency_ind.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UeContextInSmfDataSubFilter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UeContextInSmfDataSubFilter {
            dnn_list: intermediate_rep.dnn_list.into_iter().next(),
            snssai_list: intermediate_rep.snssai_list.into_iter().next(),
            emergency_ind: intermediate_rep.emergency_ind.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UeContextInSmfDataSubFilter> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UeContextInSmfDataSubFilter>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UeContextInSmfDataSubFilter>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UeContextInSmfDataSubFilter - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<UeContextInSmfDataSubFilter>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UeContextInSmfDataSubFilter as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UeContextInSmfDataSubFilter - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UeContextInSmsfData {
    #[serde(rename = "smsfInfo3GppAccess")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub smsf_info3_gpp_access: Option<models::SmsfInfo>,

    #[serde(rename = "smsfInfoNon3GppAccess")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub smsf_info_non3_gpp_access: Option<models::SmsfInfo>,
}

impl UeContextInSmsfData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UeContextInSmsfData {
        UeContextInSmsfData {
            smsf_info3_gpp_access: None,
            smsf_info_non3_gpp_access: None,
        }
    }
}

/// Converts the UeContextInSmsfData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UeContextInSmsfData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping smsfInfo3GppAccess in query parameter serialization

            // Skipping smsfInfoNon3GppAccess in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UeContextInSmsfData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UeContextInSmsfData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub smsf_info3_gpp_access: Vec<models::SmsfInfo>,
            pub smsf_info_non3_gpp_access: Vec<models::SmsfInfo>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UeContextInSmsfData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "smsfInfo3GppAccess" => intermediate_rep.smsf_info3_gpp_access.push(
                        <models::SmsfInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "smsfInfoNon3GppAccess" => intermediate_rep.smsf_info_non3_gpp_access.push(
                        <models::SmsfInfo as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UeContextInSmsfData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UeContextInSmsfData {
            smsf_info3_gpp_access: intermediate_rep.smsf_info3_gpp_access.into_iter().next(),
            smsf_info_non3_gpp_access: intermediate_rep
                .smsf_info_non3_gpp_access
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UeContextInSmsfData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UeContextInSmsfData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UeContextInSmsfData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UeContextInSmsfData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<UeContextInSmsfData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UeContextInSmsfData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UeContextInSmsfData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UeId {
    /// String identifying a Supi that shall contain either an IMSI, a network specific identifier, a Global Cable Identifier (GCI) or a Global Line Identifier (GLI) as specified in clause  2.2A of 3GPP TS 23.003. It shall be formatted as follows  - for an IMSI \"imsi-<imsi>\", where <imsi> shall be formatted according to clause 2.2    of 3GPP TS 23.003 that describes an IMSI.  - for a network specific identifier \"nai-<nai>, where <nai> shall be formatted    according to clause 28.7.2 of 3GPP TS 23.003 that describes an NAI.  - for a GCI \"gci-<gci>\", where <gci> shall be formatted according to clause 28.15.2    of 3GPP TS 23.003.  - for a GLI \"gli-<gli>\", where <gli> shall be formatted according to clause 28.16.2 of    3GPP TS 23.003.To enable that the value is used as part of an URI, the string shall    only contain characters allowed according to the \"lower-with-hyphen\" naming convention    defined in 3GPP TS 29.501.
    #[serde(rename = "supi")]
    pub supi: String,

    #[serde(rename = "gpsiList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub gpsi_list: Option<Vec<models::Gpsi>>,
}

impl UeId {
    #[allow(clippy::new_without_default)]
    pub fn new(supi: String) -> UeId {
        UeId {
            supi,
            gpsi_list: None,
        }
    }
}

/// Converts the UeId value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UeId {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("supi".to_string()),
            Some(self.supi.to_string()),
            self.gpsi_list.as_ref().map(|gpsi_list| {
                vec![
                    "gpsiList".to_string(),
                    gpsi_list
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UeId value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UeId {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub supi: Vec<String>,
            pub gpsi_list: Vec<Vec<models::Gpsi>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err("Missing value while parsing UeId".to_string())
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "supi" => intermediate_rep.supi.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    "gpsiList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in UeId"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UeId".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UeId {
            supi: intermediate_rep
                .supi
                .into_iter()
                .next()
                .ok_or_else(|| "supi missing in UeId".to_string())?,
            gpsi_list: intermediate_rep.gpsi_list.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UeId> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UeId>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UeId>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UeId - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UeId> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => match <UeId as std::str::FromStr>::from_str(value) {
                std::result::Result::Ok(value) => {
                    std::result::Result::Ok(header::IntoHeaderValue(value))
                }
                std::result::Result::Err(err) => std::result::Result::Err(format!(
                    "Unable to convert header value '{}' into UeId - {}",
                    value, err
                )),
            },
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UeUsageType(i32);

impl std::convert::From<i32> for UeUsageType {
    fn from(x: i32) -> Self {
        UeUsageType(x)
    }
}

impl std::convert::From<UeUsageType> for i32 {
    fn from(x: UeUsageType) -> Self {
        x.0
    }
}

impl std::ops::Deref for UeUsageType {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for UeUsageType {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// Integer where the allowed values correspond to the value range of an unsigned 16-bit integer.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Uint16(i32);

impl std::convert::From<i32> for Uint16 {
    fn from(x: i32) -> Self {
        Uint16(x)
    }
}

impl std::convert::From<Uint16> for i32 {
    fn from(x: Uint16) -> Self {
        x.0
    }
}

impl std::ops::Deref for Uint16 {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for Uint16 {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

/// Unsigned Integer, i.e. only value 0 and integers above 0 are permissible.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Uinteger(i32);

impl std::convert::From<i32> for Uinteger {
    fn from(x: i32) -> Self {
        Uinteger(x)
    }
}

impl std::convert::From<Uinteger> for i32 {
    fn from(x: Uinteger) -> Self {
        x.0
    }
}

impl std::ops::Deref for Uinteger {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for Uinteger {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UmtTime {
    /// String with format partial-time or full-time as defined in clause 5.6 of IETF RFC 3339. Examples, 20:15:00, 20:15:00-08:00 (for 8 hours behind UTC).
    #[serde(rename = "timeOfDay")]
    pub time_of_day: String,

    /// integer between and including 1 and 7 denoting a weekday. 1 shall indicate Monday, and the subsequent weekdays  shall be indicated with the next higher numbers. 7 shall indicate Sunday.
    #[serde(rename = "dayOfWeek")]
    pub day_of_week: u8,
}

impl UmtTime {
    #[allow(clippy::new_without_default)]
    pub fn new(time_of_day: String, day_of_week: u8) -> UmtTime {
        UmtTime {
            time_of_day,
            day_of_week,
        }
    }
}

/// Converts the UmtTime value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UmtTime {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("timeOfDay".to_string()),
            Some(self.time_of_day.to_string()),
            Some("dayOfWeek".to_string()),
            Some(self.day_of_week.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UmtTime value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UmtTime {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub time_of_day: Vec<String>,
            pub day_of_week: Vec<u8>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UmtTime".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "timeOfDay" => intermediate_rep.time_of_day.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "dayOfWeek" => intermediate_rep
                        .day_of_week
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UmtTime".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UmtTime {
            time_of_day: intermediate_rep
                .time_of_day
                .into_iter()
                .next()
                .ok_or_else(|| "timeOfDay missing in UmtTime".to_string())?,
            day_of_week: intermediate_rep
                .day_of_week
                .into_iter()
                .next()
                .ok_or_else(|| "dayOfWeek missing in UmtTime".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UmtTime> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UmtTime>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UmtTime>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UmtTime - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UmtTime> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UmtTime as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UmtTime - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Indicates value of uncertainty.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Uncertainty(f32);

impl std::convert::From<f32> for Uncertainty {
    fn from(x: f32) -> Self {
        Uncertainty(x)
    }
}

impl std::convert::From<Uncertainty> for f32 {
    fn from(x: Uncertainty) -> Self {
        x.0
    }
}

impl std::ops::Deref for Uncertainty {
    type Target = f32;
    fn deref(&self) -> &f32 {
        &self.0
    }
}

impl std::ops::DerefMut for Uncertainty {
    fn deref_mut(&mut self) -> &mut f32 {
        &mut self.0
    }
}

/// Ellipse with uncertainty.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UncertaintyEllipse {
    /// Indicates value of uncertainty.
    #[serde(rename = "semiMajor")]
    pub semi_major: f32,

    /// Indicates value of uncertainty.
    #[serde(rename = "semiMinor")]
    pub semi_minor: f32,

    /// Indicates value of orientation angle.
    #[serde(rename = "orientationMajor")]
    pub orientation_major: u8,
}

impl UncertaintyEllipse {
    #[allow(clippy::new_without_default)]
    pub fn new(semi_major: f32, semi_minor: f32, orientation_major: u8) -> UncertaintyEllipse {
        UncertaintyEllipse {
            semi_major,
            semi_minor,
            orientation_major,
        }
    }
}

/// Converts the UncertaintyEllipse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UncertaintyEllipse {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("semiMajor".to_string()),
            Some(self.semi_major.to_string()),
            Some("semiMinor".to_string()),
            Some(self.semi_minor.to_string()),
            Some("orientationMajor".to_string()),
            Some(self.orientation_major.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UncertaintyEllipse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UncertaintyEllipse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub semi_major: Vec<f32>,
            pub semi_minor: Vec<f32>,
            pub orientation_major: Vec<u8>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UncertaintyEllipse".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "semiMajor" => intermediate_rep.semi_major.push(
                        <f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "semiMinor" => intermediate_rep.semi_minor.push(
                        <f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "orientationMajor" => intermediate_rep
                        .orientation_major
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UncertaintyEllipse".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UncertaintyEllipse {
            semi_major: intermediate_rep
                .semi_major
                .into_iter()
                .next()
                .ok_or_else(|| "semiMajor missing in UncertaintyEllipse".to_string())?,
            semi_minor: intermediate_rep
                .semi_minor
                .into_iter()
                .next()
                .ok_or_else(|| "semiMinor missing in UncertaintyEllipse".to_string())?,
            orientation_major: intermediate_rep
                .orientation_major
                .into_iter()
                .next()
                .ok_or_else(|| "orientationMajor missing in UncertaintyEllipse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UncertaintyEllipse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UncertaintyEllipse>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UncertaintyEllipse>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UncertaintyEllipse - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<UncertaintyEllipse>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UncertaintyEllipse as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UncertaintyEllipse - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Ellipsoid with uncertainty
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UncertaintyEllipsoid {
    /// Indicates value of uncertainty.
    #[serde(rename = "semiMajor")]
    pub semi_major: f32,

    /// Indicates value of uncertainty.
    #[serde(rename = "semiMinor")]
    pub semi_minor: f32,

    /// Indicates value of uncertainty.
    #[serde(rename = "vertical")]
    pub vertical: f32,

    /// Indicates value of orientation angle.
    #[serde(rename = "orientationMajor")]
    pub orientation_major: u8,
}

impl UncertaintyEllipsoid {
    #[allow(clippy::new_without_default)]
    pub fn new(
        semi_major: f32,
        semi_minor: f32,
        vertical: f32,
        orientation_major: u8,
    ) -> UncertaintyEllipsoid {
        UncertaintyEllipsoid {
            semi_major,
            semi_minor,
            vertical,
            orientation_major,
        }
    }
}

/// Converts the UncertaintyEllipsoid value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UncertaintyEllipsoid {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            Some("semiMajor".to_string()),
            Some(self.semi_major.to_string()),
            Some("semiMinor".to_string()),
            Some(self.semi_minor.to_string()),
            Some("vertical".to_string()),
            Some(self.vertical.to_string()),
            Some("orientationMajor".to_string()),
            Some(self.orientation_major.to_string()),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UncertaintyEllipsoid value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UncertaintyEllipsoid {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub semi_major: Vec<f32>,
            pub semi_minor: Vec<f32>,
            pub vertical: Vec<f32>,
            pub orientation_major: Vec<u8>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UncertaintyEllipsoid".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "semiMajor" => intermediate_rep.semi_major.push(
                        <f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "semiMinor" => intermediate_rep.semi_minor.push(
                        <f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "vertical" => intermediate_rep.vertical.push(
                        <f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "orientationMajor" => intermediate_rep
                        .orientation_major
                        .push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UncertaintyEllipsoid".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UncertaintyEllipsoid {
            semi_major: intermediate_rep
                .semi_major
                .into_iter()
                .next()
                .ok_or_else(|| "semiMajor missing in UncertaintyEllipsoid".to_string())?,
            semi_minor: intermediate_rep
                .semi_minor
                .into_iter()
                .next()
                .ok_or_else(|| "semiMinor missing in UncertaintyEllipsoid".to_string())?,
            vertical: intermediate_rep
                .vertical
                .into_iter()
                .next()
                .ok_or_else(|| "vertical missing in UncertaintyEllipsoid".to_string())?,
            orientation_major: intermediate_rep
                .orientation_major
                .into_iter()
                .next()
                .ok_or_else(|| "orientationMajor missing in UncertaintyEllipsoid".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UncertaintyEllipsoid> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UncertaintyEllipsoid>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UncertaintyEllipsoid>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UncertaintyEllipsoid - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<UncertaintyEllipsoid>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UncertaintyEllipsoid as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UncertaintyEllipsoid - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UnrelatedClass {
    #[serde(rename = "defaultUnrelatedClass")]
    pub default_unrelated_class: models::DefaultUnrelatedClass,

    #[serde(rename = "externalUnrelatedClass")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub external_unrelated_class: Option<models::ExternalUnrelatedClass>,

    #[serde(rename = "serviceTypeUnrelatedClasses")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_type_unrelated_classes: Option<Vec<models::ServiceTypeUnrelatedClass>>,
}

impl UnrelatedClass {
    #[allow(clippy::new_without_default)]
    pub fn new(default_unrelated_class: models::DefaultUnrelatedClass) -> UnrelatedClass {
        UnrelatedClass {
            default_unrelated_class,
            external_unrelated_class: None,
            service_type_unrelated_classes: None,
        }
    }
}

/// Converts the UnrelatedClass value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UnrelatedClass {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping defaultUnrelatedClass in query parameter serialization

            // Skipping externalUnrelatedClass in query parameter serialization

            // Skipping serviceTypeUnrelatedClasses in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UnrelatedClass value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UnrelatedClass {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub default_unrelated_class: Vec<models::DefaultUnrelatedClass>,
            pub external_unrelated_class: Vec<models::ExternalUnrelatedClass>,
            pub service_type_unrelated_classes: Vec<Vec<models::ServiceTypeUnrelatedClass>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UnrelatedClass".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "defaultUnrelatedClass" => intermediate_rep.default_unrelated_class.push(
                        <models::DefaultUnrelatedClass as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "externalUnrelatedClass" => intermediate_rep.external_unrelated_class.push(
                        <models::ExternalUnrelatedClass as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "serviceTypeUnrelatedClasses" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in UnrelatedClass"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UnrelatedClass".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UnrelatedClass {
            default_unrelated_class: intermediate_rep
                .default_unrelated_class
                .into_iter()
                .next()
                .ok_or_else(|| "defaultUnrelatedClass missing in UnrelatedClass".to_string())?,
            external_unrelated_class: intermediate_rep.external_unrelated_class.into_iter().next(),
            service_type_unrelated_classes: intermediate_rep
                .service_type_unrelated_classes
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UnrelatedClass> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UnrelatedClass>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UnrelatedClass>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UnrelatedClass - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UnrelatedClass> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UnrelatedClass as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UnrelatedClass - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// indicates whether UP confidentiality protection is required, preferred or not needed for all the traffic on the PDU Session. It shall comply with the provisions defined in table 5.4.3.5-1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpConfidentiality {}

impl UpConfidentiality {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpConfidentiality {
        UpConfidentiality {}
    }
}

/// Converts the UpConfidentiality value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpConfidentiality {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpConfidentiality value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpConfidentiality {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UpConfidentiality".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UpConfidentiality".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpConfidentiality {})
    }
}

// Methods for converting between header::IntoHeaderValue<UpConfidentiality> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpConfidentiality>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UpConfidentiality>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UpConfidentiality - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<UpConfidentiality>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UpConfidentiality as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UpConfidentiality - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// indicates whether UP integrity protection is required, preferred or not needed for all the traffic on the PDU Session. It shall comply with the provisions defined in  table 5.4.3.4-1.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpIntegrity {}

impl UpIntegrity {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpIntegrity {
        UpIntegrity {}
    }
}

/// Converts the UpIntegrity value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpIntegrity {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpIntegrity value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpIntegrity {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UpIntegrity".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UpIntegrity".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpIntegrity {})
    }
}

// Methods for converting between header::IntoHeaderValue<UpIntegrity> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpIntegrity>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UpIntegrity>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UpIntegrity - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpIntegrity> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UpIntegrity as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UpIntegrity - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum UpIntegrityAnyOf {
    #[serde(rename = "REQUIRED")]
    Required,
    #[serde(rename = "PREFERRED")]
    Preferred,
    #[serde(rename = "NOT_NEEDED")]
    NotNeeded,
}

impl std::fmt::Display for UpIntegrityAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            UpIntegrityAnyOf::Required => write!(f, "REQUIRED"),
            UpIntegrityAnyOf::Preferred => write!(f, "PREFERRED"),
            UpIntegrityAnyOf::NotNeeded => write!(f, "NOT_NEEDED"),
        }
    }
}

impl std::str::FromStr for UpIntegrityAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "REQUIRED" => std::result::Result::Ok(UpIntegrityAnyOf::Required),
            "PREFERRED" => std::result::Result::Ok(UpIntegrityAnyOf::Preferred),
            "NOT_NEEDED" => std::result::Result::Ok(UpIntegrityAnyOf::NotNeeded),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Contains Userplain security information.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpSecurity {
    #[serde(rename = "upIntegr")]
    pub up_integr: models::UpIntegrity,

    #[serde(rename = "upConfid")]
    pub up_confid: models::UpConfidentiality,
}

impl UpSecurity {
    #[allow(clippy::new_without_default)]
    pub fn new(up_integr: models::UpIntegrity, up_confid: models::UpConfidentiality) -> UpSecurity {
        UpSecurity {
            up_integr,
            up_confid,
        }
    }
}

/// Converts the UpSecurity value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpSecurity {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping upIntegr in query parameter serialization

            // Skipping upConfid in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpSecurity value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpSecurity {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub up_integr: Vec<models::UpIntegrity>,
            pub up_confid: Vec<models::UpConfidentiality>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UpSecurity".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "upIntegr" => intermediate_rep.up_integr.push(
                        <models::UpIntegrity as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "upConfid" => intermediate_rep.up_confid.push(
                        <models::UpConfidentiality as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UpSecurity".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpSecurity {
            up_integr: intermediate_rep
                .up_integr
                .into_iter()
                .next()
                .ok_or_else(|| "upIntegr missing in UpSecurity".to_string())?,
            up_confid: intermediate_rep
                .up_confid
                .into_iter()
                .next()
                .ok_or_else(|| "upConfid missing in UpSecurity".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpSecurity> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpSecurity>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UpSecurity>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UpSecurity - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpSecurity> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UpSecurity as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UpSecurity - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Contains the indication of whether the acknowledgement from UE is needed.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpuAckInd(bool);

impl std::convert::From<bool> for UpuAckInd {
    fn from(x: bool) -> Self {
        UpuAckInd(x)
    }
}

impl std::convert::From<UpuAckInd> for bool {
    fn from(x: UpuAckInd) -> Self {
        x.0
    }
}

impl std::ops::Deref for UpuAckInd {
    type Target = bool;
    fn deref(&self) -> &bool {
        &self.0
    }
}

impl std::ops::DerefMut for UpuAckInd {
    fn deref_mut(&mut self) -> &mut bool {
        &mut self.0
    }
}

/// Contains UE parameters update data set (e.g., the updated Routing ID Data or the Default configured NSSAI).
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpuData {
    /// Contains a secure packet.
    #[serde(rename = "secPacket")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sec_packet: Option<swagger::ByteArray>,

    #[serde(rename = "defaultConfNssai")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_conf_nssai: Option<Vec<models::Snssai>>,

    /// Represents a routing indicator.
    #[serde(rename = "routingId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub routing_id: Option<String>,
}

impl UpuData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UpuData {
        UpuData {
            sec_packet: None,
            default_conf_nssai: None,
            routing_id: None,
        }
    }
}

/// Converts the UpuData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpuData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping secPacket in query parameter serialization
            // Skipping secPacket in query parameter serialization

            // Skipping defaultConfNssai in query parameter serialization
            self.routing_id
                .as_ref()
                .map(|routing_id| vec!["routingId".to_string(), routing_id.to_string()].join(",")),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpuData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpuData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub sec_packet: Vec<swagger::ByteArray>,
            pub default_conf_nssai: Vec<Vec<models::Snssai>>,
            pub routing_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UpuData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "secPacket" => {
                        return std::result::Result::Err(
                            "Parsing binary data in this style is not supported in UpuData"
                                .to_string(),
                        )
                    }
                    "defaultConfNssai" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in UpuData"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "routingId" => intermediate_rep.routing_id.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UpuData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpuData {
            sec_packet: intermediate_rep.sec_packet.into_iter().next(),
            default_conf_nssai: intermediate_rep.default_conf_nssai.into_iter().next(),
            routing_id: intermediate_rep.routing_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpuData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpuData>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UpuData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UpuData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpuData> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UpuData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UpuData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpuInfo {
    #[serde(rename = "upuDataList")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub upu_data_list: Option<Vec<models::UpuData>>,

    #[serde(rename = "upuRegInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub upu_reg_ind: Option<bool>,

    /// Contains the indication of whether the acknowledgement from UE is needed.
    #[serde(rename = "upuAckInd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub upu_ack_ind: Option<bool>,

    /// MAC value for protecting UPU procedure (UPU-MAC-IAUSF and UPU-MAC-IUE).
    #[serde(rename = "upuMacIausf")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub upu_mac_iausf: Option<String>,

    /// CounterUPU.
    #[serde(rename = "counterUpu")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub counter_upu: Option<String>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "provisioningTime")]
    pub provisioning_time: chrono::DateTime<chrono::Utc>,

    /// string with format 'bytes' as defined in OpenAPI
    #[serde(rename = "upuTransparentContainer")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub upu_transparent_container: Option<swagger::ByteArray>,
}

impl UpuInfo {
    #[allow(clippy::new_without_default)]
    pub fn new(provisioning_time: chrono::DateTime<chrono::Utc>) -> UpuInfo {
        UpuInfo {
            upu_data_list: None,
            upu_reg_ind: None,
            upu_ack_ind: None,
            upu_mac_iausf: None,
            counter_upu: None,
            provisioning_time,
            upu_transparent_container: None,
        }
    }
}

/// Converts the UpuInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UpuInfo {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping upuDataList in query parameter serialization
            self.upu_reg_ind.as_ref().map(|upu_reg_ind| {
                vec!["upuRegInd".to_string(), upu_reg_ind.to_string()].join(",")
            }),
            self.upu_ack_ind.as_ref().map(|upu_ack_ind| {
                vec!["upuAckInd".to_string(), upu_ack_ind.to_string()].join(",")
            }),
            self.upu_mac_iausf.as_ref().map(|upu_mac_iausf| {
                vec!["upuMacIausf".to_string(), upu_mac_iausf.to_string()].join(",")
            }),
            self.counter_upu.as_ref().map(|counter_upu| {
                vec!["counterUpu".to_string(), counter_upu.to_string()].join(",")
            }),
            // Skipping provisioningTime in query parameter serialization

            // Skipping upuTransparentContainer in query parameter serialization
            // Skipping upuTransparentContainer in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpuInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpuInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub upu_data_list: Vec<Vec<models::UpuData>>,
            pub upu_reg_ind: Vec<bool>,
            pub upu_ack_ind: Vec<bool>,
            pub upu_mac_iausf: Vec<String>,
            pub counter_upu: Vec<String>,
            pub provisioning_time: Vec<chrono::DateTime<chrono::Utc>>,
            pub upu_transparent_container: Vec<swagger::ByteArray>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UpuInfo".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "upuDataList" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in UpuInfo"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "upuRegInd" => intermediate_rep.upu_reg_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "upuAckInd" => intermediate_rep.upu_ack_ind.push(
                        <bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "upuMacIausf" => intermediate_rep.upu_mac_iausf.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "counterUpu" => intermediate_rep.counter_upu.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "provisioningTime" => intermediate_rep.provisioning_time.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "upuTransparentContainer" => {
                        return std::result::Result::Err(
                            "Parsing binary data in this style is not supported in UpuInfo"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UpuInfo".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpuInfo {
            upu_data_list: intermediate_rep.upu_data_list.into_iter().next(),
            upu_reg_ind: intermediate_rep.upu_reg_ind.into_iter().next(),
            upu_ack_ind: intermediate_rep.upu_ack_ind.into_iter().next(),
            upu_mac_iausf: intermediate_rep.upu_mac_iausf.into_iter().next(),
            counter_upu: intermediate_rep.counter_upu.into_iter().next(),
            provisioning_time: intermediate_rep
                .provisioning_time
                .into_iter()
                .next()
                .ok_or_else(|| "provisioningTime missing in UpuInfo".to_string())?,
            upu_transparent_container: intermediate_rep
                .upu_transparent_container
                .into_iter()
                .next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpuInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UpuInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UpuInfo>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UpuInfo - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UpuInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UpuInfo as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UpuInfo - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// MAC value for protecting UPU procedure (UPU-MAC-IAUSF and UPU-MAC-IUE).
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpuMac(String);

impl std::convert::From<String> for UpuMac {
    fn from(x: String) -> Self {
        UpuMac(x)
    }
}

impl std::string::ToString for UpuMac {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for UpuMac {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(UpuMac(x.to_string()))
    }
}

impl std::convert::From<UpuMac> for String {
    fn from(x: UpuMac) -> Self {
        x.0
    }
}

impl std::ops::Deref for UpuMac {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for UpuMac {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpuRegInd(bool);

impl std::convert::From<bool> for UpuRegInd {
    fn from(x: bool) -> Self {
        UpuRegInd(x)
    }
}

impl std::convert::From<UpuRegInd> for bool {
    fn from(x: UpuRegInd) -> Self {
        x.0
    }
}

impl std::ops::Deref for UpuRegInd {
    type Target = bool;
    fn deref(&self) -> &bool {
        &self.0
    }
}

impl std::ops::DerefMut for UpuRegInd {
    fn deref_mut(&mut self) -> &mut bool {
        &mut self.0
    }
}

/// string with format 'bytes' as defined in OpenAPI
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpuTransparentContainer(swagger::ByteArray);

impl std::convert::From<swagger::ByteArray> for UpuTransparentContainer {
    fn from(x: swagger::ByteArray) -> Self {
        UpuTransparentContainer(x)
    }
}

impl std::convert::From<UpuTransparentContainer> for swagger::ByteArray {
    fn from(x: UpuTransparentContainer) -> Self {
        x.0
    }
}

impl std::ops::Deref for UpuTransparentContainer {
    type Target = swagger::ByteArray;
    fn deref(&self) -> &swagger::ByteArray {
        &self.0
    }
}

impl std::ops::DerefMut for UpuTransparentContainer {
    fn deref_mut(&mut self) -> &mut swagger::ByteArray {
        &mut self.0
    }
}

/// String providing an URI formatted according to RFC 3986.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Uri(String);

impl std::convert::From<String> for Uri {
    fn from(x: String) -> Self {
        Uri(x)
    }
}

impl std::string::ToString for Uri {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for Uri {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Uri(x.to_string()))
    }
}

impl std::convert::From<Uri> for String {
    fn from(x: Uri) -> Self {
        x.0
    }
}

impl std::ops::Deref for Uri {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Uri {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UserConsent {}

impl UserConsent {
    #[allow(clippy::new_without_default)]
    pub fn new() -> UserConsent {
        UserConsent {}
    }
}

/// Converts the UserConsent value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for UserConsent {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UserConsent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UserConsent {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {}

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing UserConsent".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing UserConsent".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UserConsent {})
    }
}

// Methods for converting between header::IntoHeaderValue<UserConsent> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<UserConsent>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<UserConsent>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for UserConsent - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<UserConsent> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <UserConsent as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into UserConsent - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(
    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum UserConsentAnyOf {
    #[serde(rename = "CONSENT_NOT_GIVEN")]
    NotGiven,
    #[serde(rename = "CONSENT_GIVEN")]
    Given,
}

impl std::fmt::Display for UserConsentAnyOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            UserConsentAnyOf::NotGiven => write!(f, "CONSENT_NOT_GIVEN"),
            UserConsentAnyOf::Given => write!(f, "CONSENT_GIVEN"),
        }
    }
}

impl std::str::FromStr for UserConsentAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "CONSENT_NOT_GIVEN" => std::result::Result::Ok(UserConsentAnyOf::NotGiven),
            "CONSENT_GIVEN" => std::result::Result::Ok(UserConsentAnyOf::Given),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct V2xSubscriptionData {
    #[serde(rename = "nrV2xServicesAuth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nr_v2x_services_auth: Option<models::NrV2xAuth>,

    #[serde(rename = "lteV2xServicesAuth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lte_v2x_services_auth: Option<models::LteV2xAuth>,

    /// String representing a bit rate; the prefixes follow the standard symbols from The International System of Units, and represent x1000 multipliers, with the exception that prefix \"K\" is used to represent the standard symbol \"k\".
    #[serde(rename = "nrUePc5Ambr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nr_ue_pc5_ambr: Option<String>,

    /// String representing a bit rate; the prefixes follow the standard symbols from The International System of Units, and represent x1000 multipliers, with the exception that prefix \"K\" is used to represent the standard symbol \"k\".
    #[serde(rename = "ltePc5Ambr")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lte_pc5_ambr: Option<String>,
}

impl V2xSubscriptionData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> V2xSubscriptionData {
        V2xSubscriptionData {
            nr_v2x_services_auth: None,
            lte_v2x_services_auth: None,
            nr_ue_pc5_ambr: None,
            lte_pc5_ambr: None,
        }
    }
}

/// Converts the V2xSubscriptionData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for V2xSubscriptionData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping nrV2xServicesAuth in query parameter serialization

            // Skipping lteV2xServicesAuth in query parameter serialization
            self.nr_ue_pc5_ambr.as_ref().map(|nr_ue_pc5_ambr| {
                vec!["nrUePc5Ambr".to_string(), nr_ue_pc5_ambr.to_string()].join(",")
            }),
            self.lte_pc5_ambr.as_ref().map(|lte_pc5_ambr| {
                vec!["ltePc5Ambr".to_string(), lte_pc5_ambr.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a V2xSubscriptionData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for V2xSubscriptionData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub nr_v2x_services_auth: Vec<models::NrV2xAuth>,
            pub lte_v2x_services_auth: Vec<models::LteV2xAuth>,
            pub nr_ue_pc5_ambr: Vec<String>,
            pub lte_pc5_ambr: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing V2xSubscriptionData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "nrV2xServicesAuth" => intermediate_rep.nr_v2x_services_auth.push(
                        <models::NrV2xAuth as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "lteV2xServicesAuth" => intermediate_rep.lte_v2x_services_auth.push(
                        <models::LteV2xAuth as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "nrUePc5Ambr" => intermediate_rep.nr_ue_pc5_ambr.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "ltePc5Ambr" => intermediate_rep.lte_pc5_ambr.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing V2xSubscriptionData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(V2xSubscriptionData {
            nr_v2x_services_auth: intermediate_rep.nr_v2x_services_auth.into_iter().next(),
            lte_v2x_services_auth: intermediate_rep.lte_v2x_services_auth.into_iter().next(),
            nr_ue_pc5_ambr: intermediate_rep.nr_ue_pc5_ambr.into_iter().next(),
            lte_pc5_ambr: intermediate_rep.lte_pc5_ambr.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<V2xSubscriptionData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<V2xSubscriptionData>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<V2xSubscriptionData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for V2xSubscriptionData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<V2xSubscriptionData>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <V2xSubscriptionData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into V2xSubscriptionData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ValidTimePeriod {
    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "startTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start_time: Option<chrono::DateTime<chrono::Utc>>,

    /// string with format 'date-time' as defined in OpenAPI.
    #[serde(rename = "endTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end_time: Option<chrono::DateTime<chrono::Utc>>,
}

impl ValidTimePeriod {
    #[allow(clippy::new_without_default)]
    pub fn new() -> ValidTimePeriod {
        ValidTimePeriod {
            start_time: None,
            end_time: None,
        }
    }
}

/// Converts the ValidTimePeriod value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ValidTimePeriod {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping startTime in query parameter serialization

            // Skipping endTime in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ValidTimePeriod value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ValidTimePeriod {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub start_time: Vec<chrono::DateTime<chrono::Utc>>,
            pub end_time: Vec<chrono::DateTime<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing ValidTimePeriod".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "startTime" => intermediate_rep.start_time.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "endTime" => intermediate_rep.end_time.push(
                        <chrono::DateTime<chrono::Utc> as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing ValidTimePeriod".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ValidTimePeriod {
            start_time: intermediate_rep.start_time.into_iter().next(),
            end_time: intermediate_rep.end_time.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ValidTimePeriod> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ValidTimePeriod>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<ValidTimePeriod>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for ValidTimePeriod - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<ValidTimePeriod>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <ValidTimePeriod as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into ValidTimePeriod - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// String represents the SUPI or GPSI
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VarUeId(String);

impl std::convert::From<String> for VarUeId {
    fn from(x: String) -> Self {
        VarUeId(x)
    }
}

impl std::string::ToString for VarUeId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for VarUeId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(VarUeId(x.to_string()))
    }
}

impl std::convert::From<VarUeId> for String {
    fn from(x: VarUeId) -> Self {
        x.0
    }
}

impl std::ops::Deref for VarUeId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for VarUeId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VnGroupData {
    #[serde(rename = "pduSessionTypes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pdu_session_types: Option<models::PduSessionTypes>,

    /// String representing a Data Network as defined in clause 9A of 3GPP TS 23.003;  it shall contain either a DNN Network Identifier, or a full DNN with both the Network  Identifier and Operator Identifier, as specified in 3GPP TS 23.003 clause 9.1.1 and 9.1.2. It shall be coded as string in which the labels are separated by dots  (e.g. \"Label1.Label2.Label3\").
    #[serde(rename = "dnn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dnn: Option<String>,

    #[serde(rename = "singleNssai")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub single_nssai: Option<models::Snssai>,

    #[serde(rename = "appDescriptors")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub app_descriptors: Option<Vec<models::AppDescriptor>>,
}

impl VnGroupData {
    #[allow(clippy::new_without_default)]
    pub fn new() -> VnGroupData {
        VnGroupData {
            pdu_session_types: None,
            dnn: None,
            single_nssai: None,
            app_descriptors: None,
        }
    }
}

/// Converts the VnGroupData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for VnGroupData {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping pduSessionTypes in query parameter serialization
            self.dnn
                .as_ref()
                .map(|dnn| vec!["dnn".to_string(), dnn.to_string()].join(",")),
            // Skipping singleNssai in query parameter serialization

            // Skipping appDescriptors in query parameter serialization
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VnGroupData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VnGroupData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub pdu_session_types: Vec<models::PduSessionTypes>,
            pub dnn: Vec<String>,
            pub single_nssai: Vec<models::Snssai>,
            pub app_descriptors: Vec<Vec<models::AppDescriptor>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing VnGroupData".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "pduSessionTypes" => intermediate_rep.pdu_session_types.push(
                        <models::PduSessionTypes as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "dnn" => intermediate_rep.dnn.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "singleNssai" => intermediate_rep.single_nssai.push(
                        <models::Snssai as std::str::FromStr>::from_str(val)
                            .map_err(|x| x.to_string())?,
                    ),
                    "appDescriptors" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in VnGroupData"
                                .to_string(),
                        )
                    }
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing VnGroupData".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VnGroupData {
            pdu_session_types: intermediate_rep.pdu_session_types.into_iter().next(),
            dnn: intermediate_rep.dnn.into_iter().next(),
            single_nssai: intermediate_rep.single_nssai.into_iter().next(),
            app_descriptors: intermediate_rep.app_descriptors.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VnGroupData> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<VnGroupData>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<VnGroupData>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for VnGroupData - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<VnGroupData> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <VnGroupData as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into VnGroupData - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// This represents the identifier of the W-AGF ID as specified in clause 9.3.1.162 of  3GPP TS 38.413 in hexadecimal representation. Each character in the string shall take a value  of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant  character representing the 4 most significant bits of the W-AGF ID shall appear first in the  string, and the character representing the 4 least significant bit of the W-AGF ID shall  appear last in the string.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct WAgfId(String);

impl std::convert::From<String> for WAgfId {
    fn from(x: String) -> Self {
        WAgfId(x)
    }
}

impl std::string::ToString for WAgfId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for WAgfId {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(WAgfId(x.to_string()))
    }
}

impl std::convert::From<WAgfId> for String {
    fn from(x: WAgfId) -> Self {
        x.0
    }
}

impl std::ops::Deref for WAgfId {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for WAgfId {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// String representing the Wildcard DNN. It shall contain the string \"*\".
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct WildcardDnn(String);

impl std::convert::From<String> for WildcardDnn {
    fn from(x: String) -> Self {
        WildcardDnn(x)
    }
}

impl std::string::ToString for WildcardDnn {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

impl std::str::FromStr for WildcardDnn {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(WildcardDnn(x.to_string()))
    }
}

impl std::convert::From<WildcardDnn> for String {
    fn from(x: WildcardDnn) -> Self {
        x.0
    }
}

impl std::ops::Deref for WildcardDnn {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for WildcardDnn {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}

/// One and only one of the \"globLineIds\", \"hfcNIds\", \"areaCodeB\" and \"areaCodeC\" attributes shall be included in a WirelineArea data structure
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct WirelineArea {
    #[serde(rename = "globalLineIds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub global_line_ids: Option<Vec<models::Gli>>,

    #[serde(rename = "hfcNIds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hfc_n_ids: Option<Vec<models::HfcNid>>,

    /// Values are operator specific.
    #[serde(rename = "areaCodeB")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub area_code_b: Option<String>,

    /// Values are operator specific.
    #[serde(rename = "areaCodeC")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub area_code_c: Option<String>,
}

impl WirelineArea {
    #[allow(clippy::new_without_default)]
    pub fn new() -> WirelineArea {
        WirelineArea {
            global_line_ids: None,
            hfc_n_ids: None,
            area_code_b: None,
            area_code_c: None,
        }
    }
}

/// Converts the WirelineArea value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for WirelineArea {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping globalLineIds in query parameter serialization
            self.hfc_n_ids.as_ref().map(|hfc_n_ids| {
                vec![
                    "hfcNIds".to_string(),
                    hfc_n_ids
                        .iter()
                        .map(|x| x.to_string())
                        .collect::<Vec<_>>()
                        .join(","),
                ]
                .join(",")
            }),
            self.area_code_b.as_ref().map(|area_code_b| {
                vec!["areaCodeB".to_string(), area_code_b.to_string()].join(",")
            }),
            self.area_code_c.as_ref().map(|area_code_c| {
                vec!["areaCodeC".to_string(), area_code_c.to_string()].join(",")
            }),
        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a WirelineArea value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for WirelineArea {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub global_line_ids: Vec<Vec<models::Gli>>,
            pub hfc_n_ids: Vec<Vec<models::HfcNid>>,
            pub area_code_b: Vec<String>,
            pub area_code_c: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing WirelineArea".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "globalLineIds" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in WirelineArea"
                                .to_string(),
                        )
                    }
                    "hfcNIds" => {
                        return std::result::Result::Err(
                            "Parsing a container in this style is not supported in WirelineArea"
                                .to_string(),
                        )
                    }
                    #[allow(clippy::redundant_clone)]
                    "areaCodeB" => intermediate_rep.area_code_b.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    #[allow(clippy::redundant_clone)]
                    "areaCodeC" => intermediate_rep.area_code_c.push(
                        <String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?,
                    ),
                    _ => {
                        return std::result::Result::Err(
                            "Unexpected key while parsing WirelineArea".to_string(),
                        )
                    }
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(WirelineArea {
            global_line_ids: intermediate_rep.global_line_ids.into_iter().next(),
            hfc_n_ids: intermediate_rep.hfc_n_ids.into_iter().next(),
            area_code_b: intermediate_rep.area_code_b.into_iter().next(),
            area_code_c: intermediate_rep.area_code_c.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<WirelineArea> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<WirelineArea>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<WirelineArea>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for WirelineArea - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<WirelineArea> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
            std::result::Result::Ok(value) => {
                match <WirelineArea as std::str::FromStr>::from_str(value) {
                    std::result::Result::Ok(value) => {
                        std::result::Result::Ok(header::IntoHeaderValue(value))
                    }
                    std::result::Result::Err(err) => std::result::Result::Err(format!(
                        "Unable to convert header value '{}' into WirelineArea - {}",
                        value, err
                    )),
                }
            }
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Unable to convert header: {:?} to string: {}",
                hdr_value, e
            )),
        }
    }
}

/// The \"restrictionType\" attribute and the \"areas\" attribute shall be either both present or absent.  The empty array of areas is used when service is allowed/restricted nowhere.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct WirelineServiceAreaRestriction {
    #[serde(rename = "restrictionType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub restriction_type: Option<models::RestrictionType>,

    #[serde(rename = "areas")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub areas: Option<Vec<models::WirelineArea>>,
}

impl WirelineServiceAreaRestriction {
    #[allow(clippy::new_without_default)]
    pub fn new() -> WirelineServiceAreaRestriction {
        WirelineServiceAreaRestriction {
            restriction_type: None,
            areas: None,
        }
    }
}

/// Converts the WirelineServiceAreaRestriction value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for WirelineServiceAreaRestriction {
    fn to_string(&self) -> String {
        let params: Vec<Option<String>> = vec![
            // Skipping restrictionType in query parameter serialization

            // Skipping areas in query parameter serialization

        ];

        params.into_iter().flatten().collect::<Vec<_>>().join(",")
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a WirelineServiceAreaRestriction value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for WirelineServiceAreaRestriction {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub restriction_type: Vec<models::RestrictionType>,
            pub areas: Vec<Vec<models::WirelineArea>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => {
                    return std::result::Result::Err(
                        "Missing value while parsing WirelineServiceAreaRestriction".to_string(),
                    )
                }
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "restrictionType" => intermediate_rep.restriction_type.push(<models::RestrictionType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "areas" => return std::result::Result::Err("Parsing a container in this style is not supported in WirelineServiceAreaRestriction".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing WirelineServiceAreaRestriction".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(WirelineServiceAreaRestriction {
            restriction_type: intermediate_rep.restriction_type.into_iter().next(),
            areas: intermediate_rep.areas.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<WirelineServiceAreaRestriction> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<WirelineServiceAreaRestriction>>
    for hyper::header::HeaderValue
{
    type Error = String;

    fn try_from(
        hdr_value: header::IntoHeaderValue<WirelineServiceAreaRestriction>,
    ) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
            std::result::Result::Ok(value) => std::result::Result::Ok(value),
            std::result::Result::Err(e) => std::result::Result::Err(format!(
                "Invalid header value for WirelineServiceAreaRestriction - value: {} is invalid {}",
                hdr_value, e
            )),
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue>
    for header::IntoHeaderValue<WirelineServiceAreaRestriction>
{
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <WirelineServiceAreaRestriction as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into WirelineServiceAreaRestriction - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}
